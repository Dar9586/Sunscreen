(()=>{var qh=Object.create;var nl=Object.defineProperty;var jh=Object.getOwnPropertyDescriptor;var Uh=Object.getOwnPropertyNames;var Qh=Object.getPrototypeOf,Xh=Object.prototype.hasOwnProperty;var xs=(l,t)=>()=>(t||l((t={exports:{}}).exports,t),t.exports),_h=(l,t)=>{for(var e in t)nl(l,e,{get:t[e],enumerable:!0})},Jh=(l,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Uh(t))!Xh.call(l,r)&&r!==e&&nl(l,r,{get:()=>t[r],enumerable:!(i=jh(t,r))||i.enumerable});return l};var J=(l,t,e)=>(e=l!=null?qh(Qh(l)):{},Jh(t||!l||!l.__esModule?nl(e,"default",{value:l,enumerable:!0}):e,l));var ll=xs(Rs=>{"use strict";Object.defineProperty(Rs,"__esModule",{value:!0});var al=class{constructor(...t){this._head=this._tail=null,this._length=0,t.length>0&&t.forEach(e=>{this.append(e)})}*iterator(){let t=this._head;for(;t;)yield t.value,t=t.next}[Symbol.iterator](){return this.iterator()}get head(){return this._head?this._head.value:null}get tail(){return this._tail?this._tail.value:null}get length(){return this._length}insert(t,e,i=!1){if(i&&this.isDuplicate(t))return!1;let r=new $n(t),n=this._head;if(n)for(;;){if(n.value===e)return r.next=n.next,r.prev=n,n.next=r,r.next?r.next.prev=r:this._tail=r,this._length++,!0;if(n.next)n=n.next;else return!1}else return!1}append(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new $n(t);return this._tail?(this._tail.next=i,i.prev=this._tail,this._tail=i):this._head=this._tail=i,this._length++,!0}prepend(t,e=!1){if(e&&this.isDuplicate(t))return!1;let i=new $n(t);return this._head?(i.next=this._head,this._head.prev=i,this._head=i):this._head=this._tail=i,this._length++,!0}remove(t){let e=this._head;if(!!e){if(e.value===t)return this._head=e.next,this._head.prev=null,e.next=e.prev=null,this._length--,e.value;for(;;){if(e.value===t)return e.next?(e.prev.next=e.next,e.next.prev=e.prev,e.next=e.prev=null):(e.prev.next=null,this._tail=e.prev,e.next=e.prev=null),this._length--,e.value;if(e.next)e=e.next;else return}}}removeHead(){let t=this._head;if(!!t)return this._head.next?(this._head.next.prev=null,this._head=this._head.next,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}removeTail(){let t=this._tail;if(!!t)return this._tail.prev?(this._tail.prev.next=null,this._tail=this._tail.prev,t.next=t.prev=null):(this._head=null,this._tail=null),this._length--,t.value}first(t){let e=this.iterator(),i=[],r=Math.min(t,this.length);for(let n=0;n<r;n++){let o=e.next();i.push(o.value)}return i}toArray(){return[...this]}isDuplicate(t){return new Set(this.toArray()).has(t)}};Rs.LinkedList=al;var $n=class{constructor(t){this.value=t,this.next=null,this.prev=null}};Rs.LinkedListItem=$n});var ai=xs(hl=>{"use strict";Object.defineProperty(hl,"__esModule",{value:!0});var sc=ll(),ul=class extends sc.LinkedList{constructor(...t){super(...t)}get top(){return this.head}get size(){return this.length}push(t){this.prepend(t)}pop(){return this.removeHead()}};hl.Stack=ul});var Mi=xs(pl=>{"use strict";Object.defineProperty(pl,"__esModule",{value:!0});var hc=ll(),ml=class extends hc.LinkedList{constructor(...t){super(...t)}get front(){return this.head}enqueue(t){this.append(t)}dequeue(){return this.removeHead()}};pl.Queue=ml});var Qe=xs(kr=>{"use strict";var Hs=kr&&kr.__spreadArrays||function(){for(var l=0,t=0,e=arguments.length;t<e;t++)l+=arguments[t].length;for(var i=Array(l),r=0,t=0;t<e;t++)for(var n=arguments[t],o=0,s=n.length;o<s;o++,r++)i[r]=n[o];return i};Object.defineProperty(kr,"__esModule",{value:!0});kr.StringBuilder=kr.String=void 0;var no=function(){function l(){}return l.IsNullOrWhiteSpace=function(t){try{return t==null||t=="undefined"?!0:t.toString().replace(/\s/g,"").length<1}catch(e){return console.log(e),!1}},l.Join=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];try{var r=e[0];if(Array.isArray(r)||r instanceof Array){for(var n=l.Empty,o=0,s=0;s<r.length;s++){var a=r[s];s<r.length-1?n+=a+t:n+=a}return n}else if(typeof r=="object"){var u=l.Empty,h=r,d=Object.keys(r);return d.forEach(function(f){u+=h[f]+t}),u=u.slice(0,u.length-t.length),u}var g=e;return l.join.apply(l,Hs([t],g))}catch(f){return console.log(f),l.Empty}},l.Format=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];try{return t.match(l.regexNumber)?l.format(l.regexNumber,t,e):t.match(l.regexObject)?l.format(l.regexObject,t,e,!0):t}catch(r){return console.log(r),l.Empty}},l.format=function(t,e,i,r){return r===void 0&&(r=!1),e.replace(t,function(n,o){var s=n.split(":");s.length>1&&(o=s[0].replace("{",""),n=s[1].replace("}",""));var a;return r?a=i[0][o]:a=i[o],a==null||a==null||n.match(/{\d+}/)?a:(a=l.parsePattern(n,a),typeof a<"u"&&a!=null?a:l.Empty)})},l.parsePattern=function(t,e){switch(t){case"L":return e=e.toLocaleLowerCase(),e;case"U":return e=e.toLocaleUpperCase(),e;case"d":{if(typeof e=="string")return l.getDisplayDateFromString(e);if(e instanceof Date)return l.Format("{0:00}.{1:00}.{2:0000}",e.getDate(),e.getMonth(),e.getFullYear());break}case"s":{if(typeof e=="string")return l.getSortableDateFromString(e);if(e instanceof Date)return l.Format("{0:0000}-{1:00}-{2:00}",e.getFullYear(),e.getMonth(),e.getDate());break}case"n":{typeof e!="string"&&(e=e.toString());var i=e.replace(/,/g,".");if(isNaN(parseFloat(i))||i.length<=3)break;var r=i.split(/[^0-9]+/g),n=r;r.length>1&&(n=[l.join.apply(l,Hs([""],r.splice(0,r.length-1))),r[r.length-1]]);var o=n[0],s=o.length%3,a=s>0?o.substring(0,s):l.Empty,u=a,h=o.substring(s).match(/.{3}/g);return a=a+"."+l.Join(".",h),e=a+(n.length>1?","+n[1]:""),e}case"x":return this.decimalToHexString(e);case"X":return this.decimalToHexString(e,!0);default:break}return(typeof e=="number"||!isNaN(e))&&!isNaN(+t)&&!l.IsNullOrWhiteSpace(e)?l.formatNumber(e,t):e},l.decimalToHexString=function(t,e){e===void 0&&(e=!1);var i=parseFloat(t),r=i.toString(16);return e?r.toLocaleUpperCase():r},l.getDisplayDateFromString=function(t){var e;if(e=t.split("-"),e.length<=1)return t;var i=e[e.length-1],r=e[e.length-2],n=e[e.length-3];return i=i.split("T")[0],i=i.split(" ")[0],i+"."+r+"."+n},l.getSortableDateFromString=function(t){var e=t.replace(",","").split(".");if(e.length<=1)return t;var i=e[e.length-1].split(" "),r=l.Empty;i.length>1&&(r=i[i.length-1]);var n=e[e.length-1].split(" ")[0],o=e[e.length-2],s=e[e.length-3],a=n+"-"+o+"-"+s;return!l.IsNullOrWhiteSpace(r)&&r.length>1?a+="T"+r:a+="T00:00:00",a},l.formatNumber=function(t,e){var i=e.length,r=t.toString();if(i<=r.length)return r;var n=i-r.length;return n+=1,new Array(n).join("0")+r},l.join=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];for(var r=l.Empty,n=0;n<e.length;n++)if(!(typeof e[n]=="string"&&l.IsNullOrWhiteSpace(e[n])||typeof e[n]!="number"&&typeof e[n]!="string")){var o=""+e[n];r+=o;for(var s=n+1;s<e.length;s++)if(!l.IsNullOrWhiteSpace(e[s])){r+=t,n=s-1;break}}return r},l.regexNumber=/{(\d+(:\w*)?)}/g,l.regexObject=/{(\w+(:\w*)?)}/g,l.Empty="",l}();kr.String=no;var mc=function(){function l(t){this.Values=[],no.IsNullOrWhiteSpace(t)||(this.Values=new Array(t))}return l.prototype.ToString=function(){return this.Values.join("")},l.prototype.Append=function(t){this.Values.push(t)},l.prototype.AppendLine=function(t){this.Values.push(`\r
`+t)},l.prototype.AppendFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push(no.Format.apply(no,Hs([t],e)))},l.prototype.AppendLineFormat=function(t){for(var e=[],i=1;i<arguments.length;i++)e[i-1]=arguments[i];this.Values.push(`\r
`+no.Format.apply(no,Hs([t],e)))},l.prototype.Clear=function(){this.Values=[]},l}();kr.StringBuilder=mc});var ru={};_h(ru,{Arrowhead:()=>we,Assert:()=>X,Attribute:()=>Gr,AttributeRegistry:()=>Le,BezierSeg:()=>ee,BundlingSettings:()=>Kt,CancelToken:()=>rl,CornerSite:()=>_,Curve:()=>p,CurveFactory:()=>be,CurvePort:()=>tt,DebugCurve:()=>z,Edge:()=>Fi,EdgeLabelPlacement:()=>hi,EdgeRoutingMode:()=>Wn,EdgeRoutingSettings:()=>wi,Ellipse:()=>k,Entity:()=>Di,EventHandler:()=>Ts,FastIncrementalLayoutSettings:()=>Pt,FloatingPort:()=>Ue,GeomEdge:()=>Pe,GeomGraph:()=>de,GeomLabel:()=>Ni,GeomNode:()=>je,GeomObject:()=>q,Graph:()=>ce,GreedyRectanglePacking:()=>ur,IntPairMap:()=>ct,InteractiveEdgeRouter:()=>re,IntersectionInfo:()=>Yt,JSONToICurve:()=>su,Label:()=>Ja,LayerDirectionEnum:()=>Ea,LayeredLayout:()=>Pn,LineSegment:()=>S,MdsLayoutSettings:()=>Dt,Node:()=>ar,OptimalRectanglePacking:()=>Dr,PackingConstants:()=>lr,PivotMDS:()=>Er,PlaneTransformation:()=>Ce,Point:()=>c,PointLocation:()=>De,Polyline:()=>R,PolylinePoint:()=>Ne,Port:()=>Hi,RTree:()=>ki,Rectangle:()=>I,RectangleNode:()=>Br,RectilinearEdgeRouter:()=>Ki,RectilinearInteractiveEditor:()=>bt,RelativeFloatingPort:()=>$e,Size:()=>Ke,SmoothedPolyline:()=>oe,SplineRouter:()=>$,StraightLineEdges:()=>ft,SugiyamaLayoutSettings:()=>Xt,TileData:()=>hr,TileMap:()=>_a,buildRTree:()=>Su,buildRTreeWithInterpolatedEdges:()=>Cu,clipWithRectangle:()=>ou,createRectangleNodeOnData:()=>or,geometryIsCreated:()=>$l,getGeomIntersectedObjects:()=>yu,iCurveToJSON:()=>au,insertRange:()=>Vr,interpolateICurve:()=>Vo,intersectedObjects:()=>bu,layoutGeomGraph:()=>Ih,layoutGeomGraphInternal:()=>gn,layoutGraphWithMds:()=>ch,layoutGraphWithSugiayma:()=>Wh,layoutIsCalculated:()=>eu,pageRank:()=>Ns,parameterSpan:()=>Zt,routeEdges:()=>dn,routeRectilinearEdges:()=>Kl,setNewParent:()=>mu});var Gr=class{bind(t){this.entity&&this.entity.setAttr(t,this)}constructor(t,e){this.entity=t,this.bind(e)}};var Le=class{};Le.GeomObjectIndex=0,Le.DrawingObjectIndex=1,Le.AlgorithmDataIndex=2,Le.ViewerIndex=3;var Ts=class{constructor(){this.actions=new Set}forEach(t){this.actions.forEach(e=>e(t,null))}subscribe(t){this.actions.add(t)}unsubscribe(t){this.actions.delete(t)}raise(t,e){this.actions.forEach(i=>i(t,e))}},q=class extends Gr{constructor(e){super(e,Le.GeomObjectIndex)}static getGeom(e){return e.getAttr(Le.GeomObjectIndex)}get parent(){let e=this.entity.parent;return e?q.getGeom(e):null}rebind(e){this.entity=e,this.bind(Le.GeomObjectIndex)}*getAncestors(){let e=this.parent;for(;e!=null;)yield e,e=e.parent}};var ol=class{static solve(t,e,i,r,n,o){let s=t*n-r*e;if(!(Math.abs(s)<ol.eps))return{x:(i*n-o*e)/s,y:(t*o-r*i)/s}}},si=ol;si.eps=1e-8;var As=class{},m=As;m.distanceEpsilonPrecision=6,m.mult=Math.pow(10,6),m.defaultLeafBoxesOffset=.5,m.lineSegmentThreshold=.05,m.intersectionEpsilon=1e-4,m.distanceEpsilon=Math.pow(10,-As.distanceEpsilonPrecision),m.squareOfDistanceEpsilon=Math.pow(10,-As.distanceEpsilonPrecision*2),m.tolerance=1e-8;function nu(l,t){return(l?1:0)-(t?1:0)}function Q(l,t){let e=l-t;return e<0?-1:e===0?0:1}function Zn(l,t){let e=Q(l.y,t.y);return e||Q(l.x,t.x)}function N(l,t){let e=l-t;return-m.distanceEpsilon<=e&&e<=m.distanceEpsilon}function ws(l,t){return Bo(l,t)>0}function Bo(l,t){let e=l-t;return e<=-m.distanceEpsilon?-1:e>=m.distanceEpsilon?1:0}function te(l,t){return l.sub(t).length}var c=class{static RoundPoint(t){return new c(c.RoundDouble(t.x),c.RoundDouble(t.y))}static RoundDouble(t){return Math.round(t*m.mult)/m.mult}toJSON(){return{x:this.x,y:this.y}}static fromJSON(t){return new c(t.x,t.y)}static ProjectionToLine(t,e,i){let r=e.sub(t),n=r.length;if(n<m.distanceEpsilon)return t;r=r.div(n);let o=i.sub(t).dot(r);return t.add(r.mul(o))}static RayIntersectsRayInteriors(t,e,i,r){let n=c.lineLineIntersection(t,t.add(e),i,i.add(r));if(!!n&&n.sub(t).dot(e.div(e.l1))>m.distanceEpsilon&&n.sub(i).dot(r.div(r.l1))>m.distanceEpsilon)return n}static IntervalIntersectsRay(t,e,i,r){let n=c.lineLineIntersection(t,e,i,i.add(r));if(!n)return;let o=t.sub(n),s=n.sub(e);if(!(o.dot(s)<=0)&&!(n.sub(i).dot(r)<0)&&o.dot(o)>m.squareOfDistanceEpsilon&&s.dot(s)>=m.squareOfDistanceEpsilon)return n}static PointToTheLeftOfLineOrOnLine(t,e,i){return c.signedDoubledTriangleArea(t,e,i)>=0}static PointToTheLeftOfLine(t,e,i){return c.signedDoubledTriangleArea(t,e,i)>0}static PointIsInsideCone(t,e,i,r){return c.PointToTheRightOfLineOrOnLine(t,e,i)&&c.PointToTheLeftOfLineOrOnLine(t,e,r)}static PointToTheRightOfLineOrOnLine(t,e,i){return c.signedDoubledTriangleArea(e,i,t)<=0}static PointToTheRightOfLine(t,e,i){return c.signedDoubledTriangleArea(e,i,t)<0}static closeIntersections(t,e){return c.close(t,e,m.intersectionEpsilon)}get l1(){return Math.abs(this.x_)+Math.abs(this.y_)}dot(t){return this.x*t.x+this.y*t.y}get x(){return this.x_}get y(){return this.y_}compareTo(t){let e=Q(this.x,t.x);return e!==0?e:Q(this.y,t.y)}toString(){return"("+this.x+","+this.y+")"}static close(t,e,i){return t.sub(e).length<=i}static closeSquare(t,e,i){let r=e.sub(t);return r.dot(r)<=i}static closeDistEps(t,e,i=m.distanceEpsilon){return t.sub(e).length<=i}normalize(){let t=this.length;return new c(this.x/t,this.y/t)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSquared(){return this.x*this.x+this.y*this.y}constructor(t,e){this.x_=t,this.y_=e}static middle(t,e){return t.add(e).div(2)}scale(t,e){return new c(this.x*t,this.y*e)}add(t){return new c(this.x+t.x,this.y+t.y)}sub(t){return new c(this.x-t.x,this.y-t.y)}mul(t){return new c(this.x*t,this.y*t)}div(t){return new c(this.x/t,this.y/t)}equal(t){return t.x===this.x&&t.y===this.y}neg(){return new c(-this.x,-this.y)}static lineLineIntersection(t,e,i,r){let n=e.sub(t),o=i.sub(r),s=i.sub(t),a=si.solve(n.x,o.x,s.x,n.y,o.y,s.y);if(a!==void 0)return t.add(n.mul(a.x))}static segSegIntersection(t,e,i,r){let n=e.sub(t),o=i.sub(r),s=i.sub(t),a=m.tolerance,u=si.solve(n.x,o.x,s.x,n.y,o.y,s.y);if(u!==void 0&&u.x>-a&&u.x<1+a&&u.y>-a&&u.y<1+a)return t.add(n.mul(u.x))}static parallelWithinEpsilon(t,e,i){let r=t.length,n=e.length;return r<i||n<i?!0:(t=t.div(r),e=e.div(n),Math.abs(-t.x*e.y+t.y*e.x)<i)}static crossProduct(t,e){return t.x*e.y-t.y*e.x}static dot(t,e){return t.x*e.x+t.y*e.y}static add(t,e){return t.add(e)}rotate90Ccw(){return new c(-this.y,this.x)}rotate90Cw(){return new c(this.y,-this.x)}clone(){return new c(this.x,this.y)}rotate(t){let e=Math.cos(t),i=Math.sin(t);return new c(e*this.x-i*this.y,i*this.x+e*this.y)}static mkPoint(t,e,i,r){return e.mul(t).add(r.mul(i))}static convSum(t,e,i){return e.add(i.sub(e).mul(t))}static anglePCP(t,e,i){return c.angle(t.sub(e),i.sub(e))}static angle(t,e){let i=t.x,r=t.y,n=e.x,o=e.y,s=i*o-r*n,a=i*n+r*o;if(Math.abs(a)<m.tolerance)return Math.abs(s)<m.tolerance?0:s<-m.tolerance?3*Math.PI/2:Math.PI/2;if(Math.abs(s)<m.tolerance)return a<-m.tolerance?Math.PI:0;let u=Math.atan2(s,a);return s>=-m.tolerance?u:Math.PI*2+u}static signedDoubledTriangleArea(t,e,i){return(e.x-t.x)*(i.y-t.y)-(i.x-t.x)*(e.y-t.y)}static getTriangleOrientation(t,e,i){let r=c.signedDoubledTriangleArea(t,e,i);return r>m.distanceEpsilon?1:r<-m.distanceEpsilon?0:2}static getTriangleOrientationWithIntersectionEpsilon(t,e,i){let r=c.signedDoubledTriangleArea(t,e,i);return r>m.intersectionEpsilon?1:r<-m.intersectionEpsilon?0:2}static ClosestPointAtLineSegment(t,e,i){let r=i.sub(e),n=t.sub(e),o=r.dot(n),s=r.dot(r);return o<=0+m.tolerance?e:s<=o+m.tolerance?i:e.add(r.mul(o/s))}static pointToTheLeftOfLineOrOnLine(t,e,i){return c.signedDoubledTriangleArea(t,e,i)>=0}static pointToTheLeftOfLine(t,e,i){return c.signedDoubledTriangleArea(t,e,i)>0}static pointToTheRightOfLineOrOnLine(t,e,i){return c.signedDoubledTriangleArea(e,i,t)<=0}static pointToTheRightOfLine(t,e,i){return c.signedDoubledTriangleArea(e,i,t)<0}static canProject(t,e,i){let r=i.sub(e);return!(t.sub(e).dot(r)<0||t.sub(i).dot(r)>0)}static distToLineSegment(t,e,i){let r=i.sub(e),n=t.sub(e),o,s;if((o=r.dot(n))<=m.tolerance)return{par:0,dist:n.length};if((s=r.dot(r))<=o+m.tolerance)return{par:1,dist:t.sub(i).length};let a=o/s;return{par:a,dist:e.add(r.mul(a)).length}}};var Ne=class{constructor(){this._next=null;this.prev=null}get point(){return this._point}set point(t){this._point=t}get next(){return this._next}set next(t){this._next=t}get nextOnPolyline(){return this.polyline.next(this)}get prevOnPolyline(){return this.polyline.prev(this)}getNext(){return this.next}setNext(t){this.next=t,this.polyline!=null&&this.polyline.setInitIsRequired()}getPrev(){return this.prev}setPrev(t){this.prev=t,this.polyline!=null&&this.polyline.setInitIsRequired()}static mkFromPoint(t){let e=new Ne;return e.point=t,e}};var j=class{contains(t){let e=t.sub(this.corner),i=m.distanceEpsilon,r=e.dot(this.bRot);if(r>this.abRot+i||r<-i)return!1;let n=e.dot(this.aRot);return n<=this.baRot+i&&n>=-i}get area(){return Math.abs(this.a.x*this.b.y-this.a.y*this.b.x)}vertex(t){switch(t){case 0:return this.corner;case 1:return this.aPlusCorner;case 2:return this.otherCorner;case 3:return this.bPlusCorner;default:return}}static parallelogramOfTwo(t,e){let i=new j,r=t.corner,n={minx:r.x,maxx:r.x,miny:r.y,maxy:r.y};return j.pumpMinMax(n,t.aPlusCorner),j.pumpMinMax(n,t.otherCorner),j.pumpMinMax(n,t.bPlusCorner),j.pumpMinMax(n,e.corner),j.pumpMinMax(n,e.aPlusCorner),j.pumpMinMax(n,e.otherCorner),j.pumpMinMax(n,e.bPlusCorner),i.corner=new c(n.minx,n.miny),i.a=new c(0,n.maxy-n.miny),i.b=new c(n.maxx-n.minx,0),i.aPlusCorner=i.a.add(i.corner),i.otherCorner=i.b.add(i.aPlusCorner),i.bPlusCorner=i.b.add(i.corner),i.aRot=new c(-i.a.y,i.a.x),i.aRot.length>.5&&(i.aRot=i.aRot.normalize()),i.bRot=new c(-i.b.y,i.b.x),i.bRot.length>.5&&(i.bRot=i.bRot.normalize()),i.abRot=i.a.dot(i.bRot),i.baRot=i.b.dot(i.aRot),i.abRot<0&&(i.abRot=-i.abRot,i.bRot=i.bRot.neg()),i.baRot<0&&(i.baRot=-i.baRot,i.aRot=i.aRot.neg()),i.isSeg=i.a.sub(i.b).length<m.distanceEpsilon,i}static pumpMinMax(t,e){e.x<t.minx?t.minx=e.x:e.x>t.maxx&&(t.maxx=e.x),e.y<t.miny?t.miny=e.y:e.y>t.maxy&&(t.maxy=e.y)}static intersect(t,e){return!(j.separByA(t,e)||j.separByA(e,t)||j.separByB(t,e)||j.separByB(e,t))===!1?!1:!(t.isSeg&&e.isSeg)||!c.parallelWithinEpsilon(t.otherCorner.sub(t.corner),e.otherCorner.sub(e.corner),1e-5)?!0:j.ParallelSegsIntersect(e,t)}static ParallelSegsIntersect(t,e){let i=t.corner,r=t.otherCorner,n=e.corner,o=e.otherCorner,s=r.sub(i),a=0,u=s.dot(s),h=n.sub(i).dot(s),d=o.sub(i).dot(s);if(h>d){let g=h;h=d,d=g}return!(d<a-m.distanceEpsilon||h>u+m.distanceEpsilon)}static separByB(t,e){let i=m.distanceEpsilon,r=e.vertex(0).sub(t.corner).dot(t.bRot),n=[1,2,3];if(r>t.abRot+i){for(let o of n)if(e.vertex(o).sub(t.corner).dot(t.bRot)<=t.abRot+i)return!1;return!0}else if(r<-i){for(let o of n)if(e.vertex(o).sub(t.corner).dot(t.bRot)>=-i)return!1;return!0}return!1}static separByA(t,e){let i=m.distanceEpsilon,r=e.corner.sub(t.corner),n=c.dot(r,t.aRot);return n>t.baRot+i?(r=e.aPlusCorner.sub(t.corner),!(c.dot(r,t.aRot)<=t.baRot+i||(r=e.bPlusCorner.sub(t.corner),c.dot(r,t.aRot)<=t.baRot+i)||(r=e.otherCorner.sub(t.corner),c.dot(r,t.aRot)<=t.baRot+i))):n<-i?(r=e.aPlusCorner.sub(t.corner),!(c.dot(r,t.aRot)>=-i||(r=e.bPlusCorner.sub(t.corner),c.dot(r,t.aRot)>=-i)||(r=e.otherCorner.sub(t.corner),c.dot(r,t.aRot)>=-i))):!1}static parallelogramByCornerSideSide(t,e,i){let r=new j;return r.corner=t,r.a=e,r.b=i,r.aRot=new c(-e.y,e.x),r.aRot.length>.5&&(r.aRot=r.aRot.normalize()),r.bRot=new c(-i.y,i.x),r.bRot.length>.5&&(r.bRot=r.bRot.normalize()),r.abRot=r.bRot.dot(e),r.baRot=i.dot(r.aRot),r.abRot<0&&(r.abRot=-r.abRot,r.bRot=r.bRot.neg()),r.baRot<0&&(r.baRot=-r.baRot,r.aRot=r.aRot.neg()),r.isSeg=e.sub(i).length<m.distanceEpsilon,r.aPlusCorner=e.add(t),r.otherCorner=i.add(r.aPlusCorner),r.bPlusCorner=i.add(t),r}static getParallelogramOfAGroup(t){let e=0,i=0,r=0,n=0,o=!0;for(let s of t){let a=Yh(s);for(let u of a){let h=u.x,d=u.y;o?(o=!1,e=i=h,r=n=d):(h<e?e=h:h>i&&(i=h),d<r?r=d:d>n&&(n=d))}}return j.parallelogramByCornerSideSide(new c(e,r),new c(0,n-r),new c(i-e,0))}};function*Yh(l){yield l.corner,yield l.aPlusCorner,yield l.otherCorner,yield l.bPlusCorner}var S=class{constructor(t,e,i,r){this.parStart=0;this.parEnd=1;this.start=new c(t,e),this.end=new c(i,r)}static fromJSON(t){return S.mkPP(c.fromJSON(t.start),c.fromJSON(t.end))}toJSON(){return{start:this.start.toJSON(),end:this.end.toJSON()}}offsetCurve(t,e){return null}trim(t,e){if(t=Math.max(this.parStart,t),e=Math.min(this.parEnd,e),t>e)throw"wrong params in trimming";let i=this.value(t),r=this.value(e);return c.close(i,r,m.distanceEpsilon)?null:S.mkPP(i,r)}value(t){return this.start.add(this.end.sub(this.start).mul(t))}trimWithWrap(t,e){return null}pNodeOverICurve(){let t=this.end.sub(this.start).mul(.5);return{parallelogram:j.parallelogramByCornerSideSide(this.start,t,t),seg:this,leafBoxesOffset:0,node:{low:0,high:1,chord:this}}}normal(){let t=this.start.sub(this.end);return t=t.div(t.length),new c(-t.y,t.x)}static mkPP(t,e){return new S(t.x,t.y,e.x,e.y)}static mkLinePXY(t,e,i){return new S(t.x,t.y,e,i)}derivative(t){return this.end.sub(this.start)}secondDerivative(t){return new c(0,0)}thirdDerivative(t){return new c(0,0)}reverse(){return S.mkPP(this.end,this.start)}translate(t){this.start=this.start.add(t),this.end=this.end.add(t)}scaleFromOrigin(t,e){return S.mkPP(this.start.scale(t,e),this.end.scale(t,e))}getParameterAtLength(t){let e=this.end.sub(this.start).length;if(e<m.tolerance)return 0;let i=t/e;return i>1?1:i<0?0:i}transform(t){return S.mkPP(t.multiplyPoint(this.start),t.multiplyPoint(this.end))}closestParameterWithinBounds(t,e,i){let r=this.closestParameter(t);return r<e&&(r=e),r>i&&(r=i),r}lengthPartial(t,e){return this.value(e).sub(this.value(t)).length}get length(){return this.start.sub(this.end).length}get boundingBox(){return I.mkPP(this.start,this.end)}clone(){return S.mkPP(this.start.clone(),this.end.clone())}static closestParameterOnLineSegment(t,e,i){let r=i.sub(e),n=t.sub(e),o=r.dot(n);if(o<=0+m.tolerance)return 0;let s=r.dot(r);return s<=o+m.tolerance?1:o/s}closestParameter(t){return S.closestParameterOnLineSegment(t,this.start,this.end)}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}static IntersectPPPP(t,e,i,r){let n=c.lineLineIntersection(t,e,i,r);if(n!=null&&Kn(n,t,e)&&Kn(n,i,r))return n}curvature(t){return 0}curvatureDerivative(t){return 0}curvatureSecondDerivative(t){return 0}static minDistBetweenLineSegments(t,e,i,r){let n=e.sub(t),o=r.sub(i),s=t.sub(i),a=c.crossProduct(n,o),u=n.dot(n),h=n.dot(o),d=o.dot(o),g=n.dot(s),f=o.dot(s),P,y,w=Math.abs(a),x=w,G=w;w<m.tolerance?(P=0,x=1,y=f,G=d):(P=c.crossProduct(o,s),y=c.crossProduct(n,s),a<0&&(P=-P,y=-y),P<0?(P=0,y=f,G=d):P>x&&(P=x=1,y=f+h,G=d)),y<0?(y=0,-g<0?P=0:-g>u?P=x:(P=-g,x=u)):y>G&&(y=G=1,-g+h<0?P=0:-g+h>u?P=x:(P=-g+h,x=u));let A=Math.abs(P)<m.tolerance?0:P/x,M=Math.abs(y)<m.tolerance?0:y/G;return{parab:A,parcd:M,dist:s.add(n.mul(A).sub(o.mul(M))).length}}};function Kn(l,t,e){return l.x>=Math.min(t.x,e.x)-m.distanceEpsilon&&l.y>=Math.min(t.y,e.y)-m.distanceEpsilon&&l.x<=Math.max(t.x,e.x)+m.distanceEpsilon&&l.y<=Math.max(t.y,e.y)+m.distanceEpsilon}function Os(l,t,e,i){let r=c.getTriangleOrientation(l,t,e),n=c.getTriangleOrientation(l,t,i),o=c.getTriangleOrientation(e,i,l),s=c.getTriangleOrientation(e,i,t);return!!(r!=n&&o!=s||r==2&&Kn(e,l,t)||n==2&&Kn(i,l,t)||o==2&&Kn(l,e,i)||s==2&&Kn(t,e,i))}function Zh(l,t,e,i,r){return{parallelogram:e,seg:i,leafBoxesOffset:r,node:{low:l,high:t,chord:null}}}var ye=class{static distToSegm(t,e,i){let r=i.sub(e);if(r.length<m.intersectionEpsilon)return t.sub(e.add(i).div(2)).length;let n=new c(-r.y,r.x);return n=n.mul(1/n.length),Math.abs(t.sub(e).dot(n))}static createParallelogramOnSubSeg(t,e,i){let r=i.derivative(t),n=i.derivative(e),o=new c(-n.y,n.x),s=i.value(t),a=i.value(e),h=a.sub(s).dot(o),d=r.dot(o),g=Math.abs(h)<m.distanceEpsilon;if(!g&&Math.abs(d)<m.distanceEpsilon)return;let f=g?0:h/d;return r=r.mul(f),j.parallelogramByCornerSideSide(s,r,a.sub(s).sub(r))}static createParallelogramNodeForCurveSeg(t,e,i,r){if(t===i.parStart&&e===i.parEnd&&c.close(i.start,i.end,m.distanceEpsilon))return ye.createNodeWithSegmentSplit(t,e,i,r);let o=i.value(t),s=i.value(e),a=s.sub(o),u=i.value((t+e)/2);if(ye.distToSegm(u,o,s)<=m.intersectionEpsilon&&a.dot(a)<m.lineSegmentThreshold*m.lineSegmentThreshold&&e-t<m.lineSegmentThreshold){let h=S.mkPP(o,s),d=h.pNodeOverICurve();d.seg=i;let g=d.node;return g.low=t,g.high=e,g.chord=h,d}if(ye.WithinEpsilon(i,t,e,r)){let h=ye.createParallelogramOnSubSeg(t,e,i);if(h!==void 0)return Zh(t,e,h,i,r)}return ye.createNodeWithSegmentSplit(t,e,i,r)}static WithinEpsilon(t,e,i,r){let o=(i-e)/3,s=t.value(e),a=t.value(i);return ye.distToSegm(t.value(e+o),s,a)>r?!1:ye.distToSegm(t.value(e+o*(3-1)),s,a)<=r}static createParallelogramNodeForCurveSegDefaultOffset(t){return ye.createParallelogramNodeForCurveSeg(t.parStart,t.parEnd,t,m.defaultLeafBoxesOffset)}static createNodeWithSegmentSplit(t,e,i,r){let n={parallelogram:null,seg:i,leafBoxesOffset:1,node:{children:[]}},o=n.node;return o.children.push(ye.createParallelogramNodeForCurveSeg(t,.5*(t+e),i,r)),o.children.push(ye.createParallelogramNodeForCurveSeg(.5*(t+e),e,i,r)),n.parallelogram=j.parallelogramOfTwo(o.children[0].parallelogram,o.children[1].parallelogram),n}};var Yt=class{constructor(t,e,i,r,n){this.par0=t,this.par1=e,this.x=i,this.seg0=r,this.seg1=n}};var Nr=class{static closestPoint(t,e,i,r,n){let a=i,u=0,h=0,d,g=!1;do{let f=t.value(a),P=t.derivative(a),y=t.secondDerivative(a),w=P.dot(P)+f.sub(e).dot(y);if(Math.abs(w)<m.tolerance)return a;d=f.sub(e).dot(P.div(w)),a-=d,a>n+m.tolerance?(a=n,h++):a<r-m.tolerance&&(a=r,h++),u++}while(Math.abs(d)>m.tolerance&&!(g=u>=5||h>=5));return g&&t.value(i).sub(e).length<m.distanceEpsilon&&(a=i),a}};var k=class{isFullEllipse(){return this.parEnd===Math.PI*2&&this.parStart===0}static fromJSON(t){return new k(t.parStart,t.parEnd,c.fromJSON(t.axis0),c.fromJSON(t.axis1),c.fromJSON(t.center))}toJSON(){return{parStart:this.parStart,parEnd:this.parEnd,axis0:this.aAxis.toJSON(),axis1:this.bAxis.toJSON(),center:this.center.toJSON()}}offsetCurve(t,e){let i=e.sub(this.center),r=c.angle(this.aAxis,i);if(this.aAxis.mul(Math.cos(r)).add(this.bAxis.mul(Math.sin(r))).length<i.length){let o=this.aAxis.length,s=this.bAxis.length;return k.mkEllipsePPP(this.aAxis.normalize().mul(o+t),this.bAxis.normalize().mul(s+t),this.center)}{let o=this.aAxis.length,s=this.bAxis.length;return k.mkEllipsePPP(this.aAxis.normalize().mul(o-t),this.bAxis.normalize().mul(s-t),this.center)}}reverse(){return null}static mkEllipsePPP(t,e,i){return new k(0,Math.PI*2,t,e,i)}constructor(t,e,i,r,n){for(this.parStart=t,this.parEnd=e,this.aAxis=i,this.bAxis=r,this.center=n,this.pNode=null,this.setBoundingBox();this.parStart<0;)this.parStart+=Math.PI*2,this.parEnd+=Math.PI*2}get start(){return this.value(this.parStart)}get end(){return this.value(this.parEnd)}trim(t,e){return new k(Math.max(t,this.parStart),Math.min(e,this.parEnd),this.aAxis,this.bAxis,this.center)}trimWithWrap(t,e){return null}get boundingBox(){return this.box}value(t){return this.center.add(c.mkPoint(Math.cos(t),this.aAxis,Math.sin(t),this.bAxis))}derivative(t){return c.mkPoint(-Math.sin(t),this.aAxis,Math.cos(t),this.bAxis)}secondDerivative(t){return c.mkPoint(-Math.cos(t),this.aAxis,-Math.sin(t),this.bAxis)}thirdDerivative(t){return c.mkPoint(Math.sin(t),this.aAxis,-Math.cos(t),this.bAxis)}pNodeOverICurve(){return this.pNode!=null?this.pNode:this.pNode=ye.createParallelogramNodeForCurveSegDefaultOffset(this)}setBoundingBox(){if(N(this.parStart,0)&&N(this.parEnd,Math.PI*2))this.box=this.fullBox();else{this.box=I.mkPP(this.start,this.end);let t;for(let e=Math.ceil(this.parStart/(Math.PI/2));(t=e*Math.PI/2)<this.parEnd;e++)t>this.parStart&&this.box.add(this.value(t))}}static mkEllipse(t,e,i,r,n,o){return new k(t,e,i,r,new c(n,o))}static mkFullEllipsePPP(t,e,i){return new k(0,Math.PI*2,t,e,i)}static mkFullEllipseNNP(t,e,i){return new k(0,Math.PI*2,new c(t,0),new c(0,e),i)}static mkCircle(t,e){return k.mkFullEllipseNNP(t,t,e)}translate(t){this.center=this.center.add(t),this.box.center=this.box.center.add(t),this.pNode=null}scaleFromOrigin(t,e){return new k(this.parStart,this.parEnd,this.aAxis.mul(t),this.bAxis.mul(e),this.center.scale(t,e))}getParameterAtLength(t){let i=this.parStart,r=this.parEnd,n=t+.001,o=t-.001;for(;r-i>m.distanceEpsilon;){let s=.5*(r+i),a=this.lengthPartial(this.parStart,s);if(a>n)r=s;else if(a<o)i=s;else return s}return(r+i)/2}transform(t){if(t!=null){let e=t.multiplyPoint(this.aAxis).sub(t.offset()),i=t.multiplyPoint(this.bAxis).sub(t.offset());return new k(this.parStart,this.parEnd,e,i,t.multiplyPoint(this.center))}return this.clone()}closestParameterWithinBounds(t,e,i){let n=(i-e)/9,o=e,s=Number.MAX_VALUE;for(let u=0;u<=8;u++){let h=e+u*n,d=t.sub(this.value(h)),g=d.dot(d);g<s&&(s=g,o=h)}o===0&&i===Math.PI*2&&(e=-Math.PI);let a=Nr.closestPoint(this,t,o,e,i);return a<0&&(a+=2*Math.PI),a}lengthPartial(t,e){return p.lengthWithInterpolationAndThreshold(this.trim(t,e),m.lineSegmentThreshold/100)}get length(){return(this.aAxis.length+this.bAxis.length)*Math.abs(this.parEnd-this.parStart)/2}clone(){return new k(this.parStart,this.parEnd,this.aAxis.clone(),this.bAxis.clone(),this.center.clone())}closestParameter(t){let e=0,i=8,r=(this.parEnd-this.parStart)/(i+1),n=this.parStart,o=Number.MAX_VALUE;for(let u=0;u<=i;u++){let h=this.parStart+u*r,d=t.sub(this.value(h)),g=d.dot(d);g<o&&(o=g,n=h)}let s=!1;n===0&&this.parEnd===Math.PI*2&&(s=!0,e=this.parStart,this.parStart=-Math.PI);let a=Nr.closestPoint(this,t,n,this.parStart,this.parEnd);return a<0&&(a+=2*Math.PI),s&&(this.parStart=e),a}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}curvature(t){throw"NotImplementedException()"}curvatureDerivative(t){throw"NotImplementedException();"}curvatureSecondDerivative(t){throw"NotImplementedException()"}orientedCounterclockwise(){return c.crossProduct(this.aAxis,this.bAxis)>0}fullBox(){let t=this.aAxis.add(this.bAxis);return I.mkPP(this.center.add(t),this.center.sub(t))}isArc(){return Math.abs(this.aAxis.dot(this.bAxis))<m.tolerance&&Math.abs(this.aAxis.length-this.bAxis.length)<m.tolerance&&c.closeDistEps(this.aAxis.rotate90Ccw(),this.bAxis)}};var Ls=class{initValues(){this.a=this.curveA.value(this.si),this.b=this.curveB.value(this.ti),this.a_b=this.a.sub(this.b),this.ad=this.curveA.derivative(this.si),this.add=this.curveA.secondDerivative(this.si),this.bd=this.curveB.derivative(this.ti),this.bdd=this.curveB.secondDerivative(this.ti)}constructor(t,e,i,r,n,o,s,a){this.curveA=t,this.curveB=e,this.aMin=i,this.bMin=n,this.aMax=r,this.bMax=o,this.aGuess=s,this.bGuess=a,this.si=s,this.ti=a}Fs(){return this.a_b.dot(this.ad)}Fss(){return this.a_b.dot(this.add)+this.ad.dot(this.ad)}Fst(){return-this.bd.dot(this.ad)}Ftt(){return-this.a_b.dot(this.bdd)+this.bd.dot(this.bd)}Ft(){return-this.a_b.dot(this.bd)}delta(t,e,i,r){return t*r-i*e}solve(){let t=0,e=10,i=0,r=100,n=!1;if(this.initValues(),this.curveA instanceof S&&this.curveB instanceof S){let s=this.curveB.derivative(0);s=s.div(s.length);let a=this.curveA.normal(),u=Math.abs(a.dot(s));if(Math.abs(u)<m.distanceEpsilon||this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt())<m.tolerance){this.success=!0,this.parallelLineSegLineSegMinDist();return}}let o;do{let s=this.delta(this.Fss(),this.Fst(),this.Fst(),this.Ftt());if(Math.abs(s)<m.tolerance){this.success=!1,n=!0;break}o={s:this.delta(-this.Fs(),this.Fst(),-this.Ft(),this.Ftt())/s,t:this.delta(this.Fss(),-this.Fs(),this.Fst(),-this.Ft())/s};let a=this.si+o.s,u=this.ti+o.t,h;a>this.aMax+m.distanceEpsilon||a<this.aMin-m.distanceEpsilon||u>this.bMax+m.distanceEpsilon||u<this.bMin-m.distanceEpsilon?(t++,this.chopDsDt(o),this.si+=o.s,this.ti+=o.t,h=!0):(h=!1,this.si=a,this.ti=u,this.si>this.aMax?this.si=this.aMax:this.si<this.aMin&&(this.si=this.aMin),this.ti>this.bMax?this.ti=this.bMax:this.ti<this.bMin&&(this.ti=this.bMin)),this.initValues(),i++,n=t>=e||i>=r||o.s===0&&o.t===0&&h}while((Math.abs(o.s)>=m.tolerance||Math.abs(o.t)>=m.tolerance)&&!n);if(n){let s=this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));if(s.dot(s)<m.distanceEpsilon*m.distanceEpsilon){this.aSolution=this.aGuess,this.bSolution=this.bGuess,this.aPoint=this.curveA.value(this.aGuess),this.bPoint=this.curveB.value(this.bGuess),this.success=!0;return}}this.aSolution=this.si,this.bSolution=this.ti,this.aPoint=this.a,this.bPoint=this.b,this.success=!n}chopDsDt(t){if(t.s!==0&&t.t!==0){let e=1;this.si+t.s>this.aMax?e=(this.aMax-this.si)/t.s:this.si+t.s<this.aMin&&(e=(this.aMin-this.si)/t.s);let i=1;this.ti+t.t>this.bMax?i=(this.bMax-this.ti)/t.t:this.ti+t.t<this.bMin&&(i=(this.bMin-this.ti)/t.t);let r=Math.min(e,i);t.s*=r,t.t*=r}else t.s===0?this.ti+t.t>this.bMax?t.t=this.bMax-this.ti:this.ti+t.t<this.bMin&&(t.t=this.bMin-this.ti):this.si+t.s>this.aMax?t.s=this.aMax-this.si:this.si+t.s<this.aMin&&(t.s=this.aMin-this.si)}parallelLineSegLineSegMinDist(){let t=this.curveA,e=this.curveB,i=t.start,r=t.end,n=e.start,o=e.end,s=r.sub(i),a=s.length,u=0,h,d,g;if(a>m.distanceEpsilon){s=s.div(a),h=s.dot(r.sub(i)),d=s.dot(n.sub(i)),g=s.dot(o.sub(i));let f=!1;if(d>g){f=!0;let P=d;d=g,g=P}if(g<u)this.aSolution=0,this.bSolution=f?0:1;else if(d>h)this.aSolution=1,this.bSolution=f?1:0;else{let P=Math.min(h,g);this.aSolution=P/(h-u),this.bSolution=(P-d)/(g-d),f&&(this.bSolution=1-this.bSolution)}}else{let f=o.sub(n),P=f.length;if(P>m.distanceEpsilon)if(f=f.div(P),u=0,h=f.dot(o.sub(n)),d=f.dot(i.sub(n)),d<u)this.bSolution=0,this.aSolution=1;else if(d>h)this.bSolution=1,this.aSolution=0;else{let y=Math.min(h,d);this.bSolution=y/(h-u),this.aSolution=0}else this.aSolution=0,this.bSolution=0}this.aPoint=this.curveA.value(this.aSolution),this.bPoint=this.curveB.value(this.bSolution)}};var ee=class{constructor(t,e,i,r){this.b=new Array(4);this.parStart=0;this.parEnd=1;this.b[0]=t,this.b[1]=e,this.b[2]=i,this.b[3]=r,this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e)}toJSON(){return{b:this.b.map(t=>t.toJSON())}}static fromJSON(t){return ee.mkBezier(t.b.map(c.fromJSON))}leftDerivative(t){return this.derivative(t)}rightDerivative(t){return this.derivative(t)}B(t){return this.b[t]}pNodeOverICurve(){return this.pBoxNode!=null?this.pBoxNode:this.pBoxNode=ye.createParallelogramNodeForCurveSegDefaultOffset(this)}value(t){let e=t*t,i=e*t;return this.l.mul(i).add(this.e.mul(e).add(this.c.mul(t)).add(this.b[0]))}static adjustParamTo01(t){return t>1?1:t<0?0:t}trim(t,e){if(t=ee.adjustParamTo01(t),e=ee.adjustParamTo01(e),t>e)return this.trim(e,t);if(t>1-m.tolerance)return new ee(this.b[3],this.b[3],this.b[3],this.b[3]);let i=new Array(3),r=new Array(2),n=this.casteljau(t,i,r),o=new ee(n,r[1],i[2],this.b[3]),s=o.casteljau((e-t)/(1-t),i,r);return new ee(o.b[0],i[0],r[0],s)}trimWithWrap(t,e){throw"NotImplementedException()"}casteljau(t,e,i){let r=1-t;for(let n=0;n<3;n++)e[n]=c.mkPoint(r,this.b[n],t,this.b[n+1]);for(let n=0;n<2;n++)i[n]=c.mkPoint(r,e[n],t,e[n+1]);return c.mkPoint(r,i[0],t,i[1])}derivative(t){return this.l.mul(3*t*t).add(this.e.mul(2*t)).add(this.c)}secondDerivative(t){return c.mkPoint(6*t,this.l,2,this.e)}thirdDerivative(t){return this.l.mul(6)}get start(){return this.b[0]}get end(){return this.b[3]}reverse(){return new ee(this.b[3],this.b[2],this.b[1],this.b[0])}translate(t){this.b[0]=this.b[0].add(t),this.b[1]=this.b[1].add(t),this.b[2]=this.b[2].add(t),this.b[3]=this.b[3].add(t),this.c=this.b[1].sub(this.b[0]).mul(3),this.e=this.b[2].sub(this.b[1]).mul(3).sub(this.c),this.l=this.b[3].sub(this.b[0]).sub(this.c).sub(this.e),this.bbox&&(this.bbox=I.translate(this.bbox,t)),this.pBoxNode=null}scaleFromOrigin(t,e){return new ee(this.b[0].scale(t,e),this.b[1].scale(t,e),this.b[2].scale(t,e),this.b[3].scale(t,e))}offsetCurve(t,e){return null}lengthPartial(t,e){return this.trim(t,e).length}get length(){return ee.lengthOnControlPolygon(this.b[0],this.b[1],this.b[2],this.b[3])}static lengthOnControlPolygon(t,e,i,r){let n=r.sub(t).length,o=e.sub(t).length+i.sub(e).length+r.sub(i).length;if(o-n>m.lineSegmentThreshold){let s=c.middle(t,e),a=c.middle(e,i),u=c.middle(i,r),h=c.middle(s,a),d=c.middle(u,a),g=c.middle(h,d);return ee.lengthOnControlPolygon(t,s,h,g)+ee.lengthOnControlPolygon(g,d,u,r)}return(o+n)/2}get boundingBox(){return this.bbox?this.bbox:this.bbox=I.mkOnPoints(this.b)}transform(t){return new ee(t.multiplyPoint(this.b[0]),t.multiplyPoint(this.b[1]),t.multiplyPoint(this.b[2]),t.multiplyPoint(this.b[3]))}closestParameterWithinBounds(t,e,i){let r=(i-e)/8,n=0,o=Number.MAX_VALUE;for(let s=0;s<9;s++){let a=t.sub(this.value(s*r+e)),u=a.dot(a);u<o&&(o=u,n=s*r+e)}return Nr.closestPoint(this,t,n,e,i)}clone(){return new ee(this.b[0],this.b[1],this.b[2],this.b[3])}static mkBezier(t){return new ee(t[0],t[1],t[2],t[3])}curvature(t){let e=this.G(t);return this.F(t)/e}F(t){return this.Xp(t)*this.Ypp(t)-this.Yp(t)*this.Xpp(t)}G(t){let e=this.Xp(t),i=this.Yp(t),r=e*e+i*i;return Math.sqrt(r*r*r)}Xp(t){return 3*this.l.x*t*t+2*this.e.x*t+this.c.x}Ypp(t){return 6*this.l.y*t+2*this.e.y}Yp(t){return 3*this.l.y*t*t+2*this.e.y*t+this.c.y}Xpp(t){return 6*this.l.x*t+2*this.e.x}Xppp(t){return 6*this.l.x}Yppp(t){return 6*this.l.y}curvatureDerivative(t){let e=this.G(t);return(this.Fp(t)*e-this.Gp(t)*this.F(t))/(e*e)}Fp(t){return this.Xp(t)*this.Yppp(t)-this.Yp(t)*this.Xppp(t)}Fpp(t){return this.Xpp(t)*this.Yppp(t)-this.Ypp(t)*this.Xppp(t)}closestParameter(t){let i=0,r=Number.MAX_VALUE;for(let n=0;n<9;n++){let o=t.sub(this.value(n*.125)),s=o.dot(o);s<r&&(r=s,i=n*.125)}return Nr.closestPoint(this,t,i,0,1)}curvatureSecondDerivative(t){let e=this.G(t);return(this.Qp(t)*e-2*this.Q(t)*this.Gp(t))/(e*e*e)}Q(t){return this.Fp(t)*this.G(t)-this.Gp(t)*this.F(t)}Qp(t){return this.Fpp(t)*this.G(t)-this.Gpp(t)*this.F(t)}Gpp(t){let e=this.Xp(t),i=this.Yp(t),r=this.Xpp(t),n=this.Ypp(t),o=this.Xppp(t),s=this.Yppp(t),a=Math.sqrt(e*e+i*i),u=e*r+i*n;return 3*(u*u/a+a*(r*r+e*o+n*n+i*s))}Gp(t){let e=this.Xp(t),i=this.Yp(t),r=this.Xpp(t),n=this.Ypp(t);return 3*Math.sqrt(e*e+i*i)*(e*r+i*n)}getParameterAtLength(t){let e=0,i=1;for(;i-e>m.tolerance;){let r=(i+e)/2,n=this.evaluateError(t,r);if(n>0)i=r;else if(n<0)e=r;else return r}return(e+i)/2}evaluateError(t,e){let i=1-e,r=c.mkPoint(i,this.b[0],e,this.b[1]),n=c.mkPoint(i,this.b[1],e,this.b[2]),o=c.mkPoint(i,this.b[2],e,this.b[3]),s=c.mkPoint(i,r,e,n),a=c.mkPoint(i,n,e,o),u=c.mkPoint(i,s,e,a),h=ee.lengthOnControlPolygon(this.b[0],r,s,u);return h>t+m.distanceEpsilon?1:h<t-m.distanceEpsilon?-1:0}};function Kh(l){return l.seg.value(l.par)}function $h(l){return l.seg.derivative(l.par)}function ec(l){return l.seg.secondDerivative(l.par)}function tc(l){return l.seg.thirdDerivative(l.par)}var De=(i=>(i[i.Outside=0]="Outside",i[i.Boundary=1]="Boundary",i[i.Inside=2]="Inside",i))(De||{});function ic(l){if(l instanceof k)return{tag:"ellipse",segData:l.toJSON()};if(l instanceof S)return{tag:"lineSegment",segData:l.toJSON()};if(l instanceof ee)return{tag:"bezier",segData:l.toJSON()};throw new Error("not implemented")}var p=class{static fromJSON(t){let e=new p;for(let i of t.segs)switch(i.tag){case"bezier":e.addSegment(ee.fromJSON(i.segData));break;case"ellipse":e.addSegment(k.fromJSON(i.segData));break;case"lineSegment":e.addSegment(S.fromJSON(i.segData));break;default:throw new Error("not implemented")}return e}toJSON(){return{segs:this.segs.map(t=>ic(t))}}static CurvesIntersect(t,e){return t===e||p.intersectionOne(t,e,!1)!=null}static lengthWithInterpolationAndThreshold(t,e){throw new Error("not implemented")}static lengthWithInterpolation(t){throw"not implemented"}get parStart(){return 0}get parEnd(){return this.parEnd_}lengthPartial(t,e){let i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);let r=this.getSegIndexParam(t),n=this.getSegIndexParam(e);if(r.segIndex<n.segIndex){let o=this.segs[r.segIndex],s=o.lengthPartial(r.par,o.parEnd);for(let a=r.segIndex+1;a<n.segIndex;a++)s+=this.segs[a].length;return o=this.segs[n.segIndex],s+o.lengthPartial(o.parStart,n.par)}else throw new Error("not implemented.")}reverse(){let t=new p;for(let e=this.segs.length-1;e>=0;e--)t.addSegment(this.segs[e].reverse());return t}constructor(){this.segs=[],this.parEnd_=0}mkCurveWithSegs(t){this.segs=t;for(let e of t)this.parEnd_+=p.paramSpan(e)}get start(){return this.segs[0].start}get end(){return this.segs[this.segs.length-1].end}scaleFromOrigin(t,e){let i=new p;for(let r of this.segs)i.addSegment(r.scaleFromOrigin(t,e));return i}trim(t,e){let i={start:t,end:e};this.adjustStartEndEndParametersToDomain(i);let r=this.getSegIndexParam(i.start),n=this.getSegIndexParam(i.end);if(r.segIndex===n.segIndex)return this.segs[r.segIndex].trim(r.par,n.par);let o=new p;r.par<this.segs[r.segIndex].parEnd&&(o=o.addSegment(this.segs[r.segIndex].trim(r.par,this.segs[r.segIndex].parEnd)));for(let s=r.segIndex+1;s<n.segIndex;s++)o=o.addSegment(this.segs[s]);return this.segs[n.segIndex].parStart<n.par&&(o=o.addSegment(this.segs[n.segIndex].trim(this.segs[n.segIndex].parStart,n.par))),o}translate(t){for(let e of this.segs)e.translate(t);this.boundingBox_&&(this.boundingBox_=I.translate(this.boundingBox_,t)),this.pBNode=null}adjustStartEndEndParametersToDomain(t){if(t.start>t.end){let e=t.start;t.start=t.end,t.end=e}t.start<this.parStart&&(t.start=this.parStart),t.end>this.parEnd&&(t.end=this.parEnd)}trimWithWrap(t,e){if(t<e)return this.trim(t,e);let i=new p;return i.addSegment(this.trim(t,this.parEnd)),i.addSegment(this.trim(this.parStart,e)),i}addSegs(t){for(let e of t)this.addSegment(e);return this}addSegment(t){if(t==null)return this;if(this.boundingBox_=null,!(t instanceof p))this.segs.push(t),this.parEnd_+=p.paramSpan(t);else for(let e of t.segs)this.segs.push(e),this.parEnd_+=p.paramSpan(e);return this}pNodeOverICurve(){if(this.pBNode!=null)return this.pBNode;let t=[],e=[];for(let i of this.segs){let r=i.pNodeOverICurve();t.push(r.parallelogram),e.push(r)}return this.pBNode={parallelogram:j.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:m.defaultLeafBoxesOffset,node:{children:e}},this.pBNode}static intersectionOne(t,e,i){let r=p.curveCurveXWithParallelogramNodesOne(t.pNodeOverICurve(),e.pNodeOverICurve());return i&&r!=null&&(r=p.liftIntersectionToCurves(t,e,r)),r}static getAllIntersections(t,e,i){return t instanceof S?p.getAllIntersectionsOfLineAndICurve(t,e,i):p.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsInternal(t,e,i){let r=[];if(p.curveCurveXWithParallelogramNodes(t.pNodeOverICurve(),e.pNodeOverICurve(),r),i)for(let n=0;n<r.length;n++)r[n]=p.liftIntersectionToCurves(t,e,r[n]);return r}static getAllIntersectionsOfLineAndICurve(t,e,i){return e instanceof R?p.getAllIntersectionsOfLineAndPolyline(t,e):e instanceof p?p.getAllIntersectionsOfLineAndCurve(t,e,i):e instanceof k&&e.isArc()?p.getAllIntersectionsOfLineAndArc(t,e):p.getAllIntersectionsInternal(t,e,i)}static getAllIntersectionsOfLineAndCurve(t,e,i){let r=[],n=t.pNodeOverICurve(),o=e.pNodeOverICurve();if(j.intersect(n.parallelogram,o.parallelogram)===!1)return r;let s=0;for(let a of e.segs){let u=p.getAllIntersections(t,a,!1);if(i){for(let h of u)h.par1+=s-a.parStart,h.seg1=e;s+=a.parEnd-a.parStart}for(let h of u)p.alreadyInside(r,h)||r.push(h)}return r}static closeIntersections(t,e){return c.close(t.x,e.x,m.intersectionEpsilon)}static closeIntersectionPoints(t,e){return c.close(t,e,m.intersectionEpsilon)}static alreadyInside(t,e){for(let i=0;i<t.length;i++){let r=t[i];if(p.closeIntersections(r,e))return!0}return!1}static getAllIntersectionsOfLineAndArc(t,e){let i=t.end.sub(t.start),r=[],n=i.length;if(n<m.distanceEpsilon){let d=t.start.sub(e.center);if(N(d.length,e.aAxis.length)){let g=c.angle(e.aAxis,d);e.parStart-m.tolerance<=g&&(g=Math.max(g,e.parStart),g<=e.parEnd+m.tolerance&&(g=Math.min(e.parEnd,g),r.push(new Yt(0,g,t.start,t,e))))}return r}let o=i.rotate90Ccw().div(n),s=t.start.sub(e.center).dot(o),a=e.center.add(o.mul(s)),u=e.aAxis.length,h=Math.abs(s);if(u<h-m.distanceEpsilon)return r;if(i=o.rotate90Cw(),N(u,h))p.tryToAddPointToLineCircleCrossing(t,e,r,a,n,i);else{let d=Math.sqrt(u*u-s*s),g=i.mul(d);p.tryToAddPointToLineCircleCrossing(t,e,r,a.add(g),n,i),p.tryToAddPointToLineCircleCrossing(t,e,r,a.sub(g),n,i)}return r}static tryToAddPointToLineCircleCrossing(t,e,i,r,n,o){let a=r.sub(t.start).dot(o);if(a<-m.distanceEpsilon||(a=Math.max(a,0),a>n+m.distanceEpsilon))return;a=Math.min(a,n),a/=n;let u=c.angle(e.aAxis,r.sub(e.center));e.parStart-m.tolerance<=u&&(u=Math.max(u,e.parStart),u<=e.parEnd+m.tolerance&&(u=Math.min(e.parEnd,u),i.push(new Yt(a,u,r,t,e))))}static getAllIntersectionsOfLineAndPolyline(t,e){let i=[],r=0,n=e.startPoint;for(;n!=null&&n.getNext()!=null;n=n.getNext()){let o=p.crossTwoLineSegs(t.start,t.end,n.point,n.getNext().point,0,1,0,1);o&&(p.adjustSolution(t.start,t.end,n.point,n.getNext().point,o),p.oldIntersection(i,o.x)||i.push(new Yt(o.aSol,r+o.bSol,o.x,t,e))),r++}if(e.closed){let o=p.crossTwoLineSegs(t.start,t.end,n.point,e.start,0,1,0,1);o&&(p.adjustSolution(t.start,t.end,n.point,e.start,o),p.oldIntersection(i,o.x)||i.push(new Yt(o.aSol,r+o.bSol,o.x,t,e)))}return i}static adjustSolution(t,e,i,r,n){p.closeIntersectionPoints(n.x,t)?(n.x=t,n.aSol=0):p.closeIntersectionPoints(n.x,e)&&(n.x=e,n.aSol=1),p.closeIntersectionPoints(n.x,i)?(n.x=i,n.bSol=Math.floor(n.bSol)):p.closeIntersectionPoints(n.x,r)&&(n.x=r,n.bSol=Math.ceil(n.bSol))}static curveCurveXWithParallelogramNodesOne(t,e){if(!j.intersect(t.parallelogram,e.parallelogram))return null;let i=t.node,r=e.node,n=i.hasOwnProperty("children"),o=r.hasOwnProperty("children");if(n&&o)for(let s of i.children)for(let a of r.children){let u=p.curveCurveXWithParallelogramNodesOne(s,a);if(u!=null)return u}else if(o)for(let s of r.children){let a=p.curveCurveXWithParallelogramNodesOne(t,s);if(a!=null)return a}else if(n)for(let s of i.children){let a=p.curveCurveXWithParallelogramNodesOne(s,e);if(a!=null)return a}else return p.crossOverIntervalsOne(t,e);return null}static curveCurveXWithParallelogramNodes(t,e,i){if(!j.intersect(t.parallelogram,e.parallelogram))return;let r=t.node.hasOwnProperty("children"),n=e.node.hasOwnProperty("children");if(r&&n)for(let o of t.node.children)for(let s of e.node.children)p.curveCurveXWithParallelogramNodes(o,s,i);else if(n)for(let o of e.node.children)p.curveCurveXWithParallelogramNodes(t,o,i);else if(r)for(let o of t.node.children)p.curveCurveXWithParallelogramNodes(o,e,i);else i=p.crossOverLeaves(t,e,i)}static crossOverIntervalsOne(t,e){let i=t.node,r=e.node,n=(i.high-i.low)/2,o=(r.high-r.low)/2;for(let s=1;s<2;s++){let a=s*n+i.low;for(let u=1;u<2;u++){let h=u*o+r.low,d;if(i.chord==null&&r.chord==null?d=p.crossWithinIntervalsWithGuess(t.seg,e.seg,i.low,i.high,r.low,r.high,a,h):i.chord!=null&&r.chord==null?d=p.crossWithinIntervalsWithGuess(i.chord,e.seg,0,1,r.low,r.high,.5*s,h):i.chord==null?(d=p.crossWithinIntervalsWithGuess(t.seg,r.chord,i.low,i.high,0,1,a,.5*u),d&&(d.bSol=r.low+d.bSol*(r.high-r.low))):(d=p.crossWithinIntervalsWithGuess(i.chord,r.chord,0,1,0,1,.5*s,.5*u),d&&(d.aSol=i.low+d.aSol*(i.high-i.low),d.bSol=r.low+d.bSol*(r.high-r.low))),d)return p.createIntersectionOne(t,e,d.aSol,d.bSol,d.x)}}return p.goDeeperOne(t,e)}static crossOverLeaves(t,e,i){let r=t.node,n=e.node,o=!1,s=(r.high-r.low)/2+r.low,a=(n.high-n.low)/2+n.low,u;return r.chord==null&&n.chord==null?u=p.crossWithinIntervalsWithGuess(t.seg,e.seg,r.low,r.high,n.low,n.high,s,a):r.chord!=null&&n.chord==null?(u=p.crossWithinIntervalsWithGuess(r.chord,e.seg,0,1,n.low,n.high,.5,a),u&&(u.aSol=r.low+u.aSol*(r.high-r.low))):r.chord==null?(u=p.crossWithinIntervalsWithGuess(t.seg,n.chord,r.low,r.high,0,1,s,.5),u&&(u.bSol=n.low+u.bSol*(n.high-n.low))):(u=p.crossWithinIntervalsWithGuess(r.chord,n.chord,0,1,0,1,.5,.5),u&&(u.bSol=n.low+u.bSol*(n.high-n.low),u.aSol=r.low+u.aSol*(r.high-r.low))),u&&(p.addIntersection(t,e,i,u),o=!0),o||p.goDeeper(i,t,e),i}static addIntersection(t,e,i,r){let n=t.node;p.closeIntersectionPoints(r.x,t.seg.value(n.low))?(r.x=t.seg.value(n.low),r.aSol=n.low):p.closeIntersectionPoints(r.x,t.seg.value(n.high))&&(r.x=t.seg.value(n.high),r.aSol=n.high);let o=e.node;if(p.closeIntersectionPoints(r.x,e.seg.value(o.low))?(r.x=e.seg.value(o.low),r.bSol=o.low):p.closeIntersectionPoints(r.x,e.seg.value(o.high))&&(r.x=e.seg.value(o.high),r.bSol=o.high),!p.oldIntersection(i,r.x)){let a=new Yt(r.aSol,r.bSol,r.x,t.seg,e.seg);i.push(a)}}static oldIntersection(t,e){for(let i of t)if(e.sub(i.x).length<m.distanceEpsilon*100)return!0;return!1}static createIntersectionOne(t,e,i,r,n){let o=t.node,s=e.node;return p.closeIntersectionPoints(n,t.seg.value(o.low))?(n=t.seg.value(o.low),i=o.low):p.closeIntersectionPoints(n,t.seg.value(o.high))&&(n=t.seg.value(o.high),i=o.high),p.closeIntersectionPoints(n,e.seg.value(s.low))?(n=e.seg.value(s.low),r=s.low):p.closeIntersectionPoints(n,e.seg.value(s.high))&&(n=e.seg.value(s.high),r=s.high),new Yt(i,r,n,t.seg,e.seg)}static liftIntersectionToCurves_(t,e,i,r,n,o,s){let a=t instanceof p?p.liftParameterToCurve(t,i-o.parStart,o):i,u=e instanceof p?p.liftParameterToCurve(e,r-s.parStart,s):r;return new Yt(a,u,n,t,e)}static DropIntersectionToSegs(t){let e,i;if(t.seg0 instanceof p){let o=t.seg0.getSegParam(t.par0);e=o.seg,i=o.par}else i=t.par0,e=t.seg0;let r,n;if(t.seg1 instanceof p){let o=t.seg1.getSegParam(t.par1);n=o.par,r=o.seg}else n=t.par1,r=t.seg1;return new Yt(i,n,t.x,e,r)}static liftIntersectionToCurves(t,e,i){return p.liftIntersectionToCurves_(t,e,i.par0,i.par1,i.x,i.seg0,i.seg1)}static liftParameterToCurve(t,e,i){if(t===i)return e;if(!t.hasOwnProperty("segs"))return;let r=t,n=0;for(let o of r.segs){if(o===i)return e+n;n+=p.paramSpan(o)}throw"bug in liftParameterToCurve"}static paramSpan(t){return t.parEnd-t.parStart}static goDeeperOne(t,e){let i=t.node,r=e.node;if(t.leafBoxesOffset>m.distanceEpsilon&&e.leafBoxesOffset>m.distanceEpsilon){let s=ye.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2),a=ye.createParallelogramNodeForCurveSeg(r.low,r.high,e.seg,e.leafBoxesOffset/2);return p.curveCurveXWithParallelogramNodesOne(s,a)}if(t.leafBoxesOffset>m.distanceEpsilon){let s=ye.createParallelogramNodeForCurveSeg(i.low,i.high,t.seg,t.leafBoxesOffset/2);return p.curveCurveXWithParallelogramNodesOne(s,e)}if(e.leafBoxesOffset>m.distanceEpsilon){let s=ye.createParallelogramNodeForCurveSeg(r.low,r.high,e.seg,e.leafBoxesOffset/2);return p.curveCurveXWithParallelogramNodesOne(t,s)}let n=t.seg.value(i.low),o=t.seg.value(i.high);if(!c.closeDistEps(n,o)){let s=e.seg.value(r.low),a=e.seg.value(r.high);if(!c.closeDistEps(s,a)){let u=t.seg instanceof S?t.seg:S.mkPP(n,o),h=e.seg instanceof S?e.seg:S.mkPP(s,a),d=p.crossWithinIntervalsWithGuess(u,h,0,1,0,1,.5,.5);if(d)return p.adjustParameters(t,u,e,h,d),p.createIntersectionOne(t,e,d.aSol,d.bSol,d.x)}}return null}static goDeeper(t,e,i){let r=e.node,n=i.node,o=e.leafBoxesOffset>m.distanceEpsilon,s=i.leafBoxesOffset>m.distanceEpsilon;if(o&&s){let a=ye.createParallelogramNodeForCurveSeg(r.low,r.high,e.seg,e.leafBoxesOffset/2),u=ye.createParallelogramNodeForCurveSeg(n.low,n.high,i.seg,i.leafBoxesOffset/2);p.curveCurveXWithParallelogramNodes(a,u,t)}else if(o){let a=ye.createParallelogramNodeForCurveSeg(r.low,r.high,e.seg,e.leafBoxesOffset/2);p.curveCurveXWithParallelogramNodes(a,i,t)}else if(s){let a=ye.createParallelogramNodeForCurveSeg(n.low,n.high,i.seg,i.leafBoxesOffset/2);p.curveCurveXWithParallelogramNodes(e,a,t)}else{let a=e.seg.value(r.low),u=e.seg.value(r.high);if(!c.closeDistEps(a,u)){let h=i.seg.value(n.low),d=i.seg.value(n.high);if(!c.closeDistEps(h,d)){let g=e.seg instanceof S?e.seg:S.mkPP(a,u),f=i.seg instanceof S?i.seg:S.mkPP(h,d),P=p.crossWithinIntervalsWithGuess(g,f,0,1,0,1,.5,.5);P&&(p.adjustParameters(e,g,i,f,P),p.addIntersection(e,i,t,P))}}}}static adjustParameters(t,e,i,r,n){if(e!==t.seg&&!(t.seg instanceof R))n.aSol=t.seg.closestParameter(n.x);else{let o=t.node;n.aSol=o.low+n.aSol*(o.high-o.low)}if(r!==i.seg&&!(i.seg instanceof R))n.bSol=i.seg.closestParameter(n.x);else{let o=i.node;n.bSol=o.low+n.bSol*(o.high-o.low)}}getSegParam(t){let e=this.parStart;for(let r of this.segs){let n=e+r.parEnd-r.parStart;if(t>=e&&t<=n)return{par:t-e+r.parStart,seg:r};e=n}let i=this.segs[this.segs.length-1];return{seg:i,par:i.parEnd}}getSegIndexParam(t){let e=0,i=this.segs.length;for(let n=0;n<i;n++){let o=this.segs[n],s=e+o.parEnd-o.parStart;if(t>=e&&t<=s)return{segIndex:n,par:t-e+o.parStart};e=s}let r=this.segs[i-1];return{segIndex:i-1,par:r.parEnd}}value(t){return Kh(this.getSegParam(t))}derivative(t){return $h(this.getSegParam(t))}secondDerivative(t){return ec(this.getSegParam(t))}thirdDerivative(t){return tc(this.getSegParam(t))}static crossWithinIntervalsWithGuess(t,e,i,r,n,o,s,a){if(t instanceof S&&e instanceof S){let d=p.crossTwoLineSegs(t.start,t.end,e.start,e.end,i,r,n,o);if(d!==void 0)return d}let u=p.minDistWithinIntervals(t,e,i,r,n,o,s,a);if(u==null)return;let h=u.aX.sub(u.bX);return h.dot(h)>=m.distanceEpsilon?void 0:{aSol:u.aSol,bSol:u.bSol,x:c.middle(u.aX,u.bX)}}static crossTwoLineSegs(t,e,i,r,n,o,s,a){let u=e.sub(t),h=i.sub(r),d=i.sub(t),g=si.solve(u.x,h.x,d.x,u.y,h.y,d.y);if(g==null)return;let f=g.x,P=g.y,y=t.add(u.mul(f));if(!(f<n-m.tolerance)&&(f=Math.max(f,n),!(f>o+m.tolerance)&&(f=Math.min(f,o),!(P<s-m.tolerance)&&(P=Math.max(P,s),!(P>a+m.tolerance)))))return P=Math.min(P,a),{aSol:f,bSol:P,x:y}}static PointRelativeToCurveLocation(t,e){if(!e.boundingBox.contains(t))return 0;let i=2*e.boundingBox.diagonal,r=Math.PI/180,n=0;for(let o=13;o<360;o+=13){let s=new c(Math.cos(o*r),Math.sin(o*r)),a=S.mkPP(t,t.add(s.mul(i))),u=this.getAllIntersectionsOfLineAndICurve(a,e,!0);if(p.AllIntersectionsAreGood(u,e)){for(let d of u)if(c.closeDistEps(d.x,t))return 1;if(u.length%2===1?n++:n--,n>=2)return 2;if(n<=-2)return 0}}return 1}static AllIntersectionsAreGood(t,e){let i=e.hasOwnProperty("segs"),r=null;if(i||e instanceof R&&(r=e.toCurve()),r){for(let n of t)if(!p.RealCut(p.DropIntersectionToSegs(n),r,!1))return!1}return!0}static RealCut(t,e,i){let r=t.seg0,n=t.seg1,o=t.par0,s=t.par1,a=t.x,u=r.derivative(o).normalize(),h=n.derivative(s).normalize().rotate(Math.PI/2);if(c.closeDistEps(a,n.end)){let g=null;for(let y=0;y<e.segs.length-1;y++)if(e.segs[y]===n){g=e.segs[y+1];break}if(g==null)return!1;let f=u.rotate(Math.PI/2);return!(f.dot(n.derivative(n.parEnd))*f.dot(g.derivative(g.parStart))<m.tolerance)}if(c.closeDistEps(a,n.start)){let g=null;for(let y=e.segs.length-1;y>0;y--)if(e.segs[y]===n){g=e.segs[y-1];break}if(g==null)return!1;let f=u.rotate(Math.PI/2);return!(f.dot(n.derivative(n.parStart))*f.dot(g.derivative(g.parEnd))<m.tolerance)}let d=u.dot(h);return i?d>m.distanceEpsilon:Math.abs(d)>m.distanceEpsilon}static realCutWithClosedCurve(t,e,i){let r=t.seg0,n=t.seg1,o=t.par0,s=t.par1,a=t.x,u=r.derivative(o).normalize(),h=n.derivative(s).normalize().rotate(Math.PI/2);if(c.closeDistEps(a,n.end)){let g=null;for(let y=0;y<e.segs.length;y++)if(e.segs[y]===n){g=e.segs[(y+1)%e.segs.length];break}if(g==null)throw new Error;let f=u.rotate(Math.PI/2);return!(f.dot(n.derivative(n.parEnd))*f.dot(g.derivative(g.parStart))<m.tolerance)}if(c.closeDistEps(a,n.start)){let g=null;for(let y=0;y<e.segs.length;y++)if(e.segs[y]===n){g=e.segs[y>0?y-1:e.segs.length-1];break}let f=u.rotate(Math.PI/2);return!(f.dot(n.derivative(n.parStart))*f.dot(g.derivative(g.parEnd))<m.tolerance)}let d=u.dot(h);return i?d>m.distanceEpsilon:Math.abs(d)>m.distanceEpsilon}static minDistWithinIntervals(t,e,i,r,n,o,s,a){let u=new Ls(t,e,i,r,n,o,s,a);return u.solve(),u.success?{aSol:u.aSolution,bSol:u.bSolution,aX:u.aPoint,bX:u.bPoint}:void 0}offsetCurve(t,e){throw new Error("Method not implemented.")}get boundingBox(){if(this.boundingBox_)return this.boundingBox_;if(this.segs.length===0)this.boundingBox_=I.mkEmpty();else{let t=this.segs[0].boundingBox.clone();for(let e=1;e<this.segs.length;e++)t.addRecSelf(this.segs[e].boundingBox);return this.boundingBox_=t}}clone(){let t=new p;for(let e of this.segs)t.addSegment(e.clone());return this.boundingBox_!=null&&(t.boundingBox_=this.boundingBox_.clone()),t}getParameterAtLength(t){let e=0;for(let i of this.segs){let r=i.length;if(r>=t)return e+i.getParameterAtLength(t);t-=r,e+=i.parEnd-i.parStart}return this.parEnd}get length(){let t=0;for(let e of this.segs)t+=e.length;return t}transform(t){let e=new p;for(let i of this.segs)e.addSegment(i.transform(t));return this.boundingBox_&&(e.boundingBox_=this.boundingBox_.transform(t)),e}closestParameterWithinBounds(t,e,i){let r=0,n=Number.MAX_VALUE,o=0;for(let s of this.segs){if(o>i)break;let a=p.paramSpan(s);if(o+a>=e){let h=Math.max(s.parStart,s.parStart+(e-o)),d=Math.min(s.parEnd,s.parStart+(i-o)),g=s.closestParameterWithinBounds(t,h,d),f=t.sub(s.value(g)),P=f.dot(f);P<n&&(r=o+g-s.parStart,n=P)}o+=a}return r}closestParameter(t){let e=0,i=Number.MAX_VALUE,r=0;for(let n of this.segs){let o=n.closestParameter(t),s=t.sub(n.value(o)),a=s.dot(s);if(a<i){if(e=r+o-n.parStart,a===0)break;i=a}r+=p.paramSpan(n)}return e}static addLineSegment(t,e,i){return t.addSegment(S.mkPP(e,i))}static addLineSegmentCNNP(t,e,i,r){return p.addLineSegment(t,new c(e,i),r)}static addLineSegmentCNNNN(t,e,i,r,n){p.addLineSegment(t,new c(e,i),new c(r,n))}static continueWithLineSegmentNN(t,e,i){p.addLineSegment(t,t.end,new c(e,i))}static continueWithLineSegmentP(t,e){p.addLineSegment(t,t.end,e)}static closeCurve(t){return p.continueWithLineSegmentP(t,t.start),t}leftDerivative(t){let e=this.tryToGetLeftSegment(t);return e!=null?e.derivative(e.parEnd):this.derivative(t)}rightDerivative(t){let e=this.tryToGetRightSegment(t);return e!=null?e.derivative(e.parStart):this.derivative(t)}tryToGetLeftSegment(t){if(Math.abs(t-this.parStart)<m.tolerance)return this.start.equal(this.end)?this.segs[this.segs.length-1]:null;for(let e of this.segs)if(t-=p.paramSpan(e),Math.abs(t)<m.tolerance)return e;return null}tryToGetRightSegment(t){if(Math.abs(t-this.parEnd)<m.tolerance)return this.start===this.end?this.segs[0]:null;for(let e of this.segs){if(Math.abs(t)<m.tolerance)return e;t-=p.paramSpan(e)}return null}static ClosestPoint(t,e){return t.value(t.closestParameter(e))}static CurveIsInsideOther(t,e){if(!e.boundingBox.containsRect(t.boundingBox))return!1;let i=p.getAllIntersections(t,e,!0);if(i.length===0)return p.NonIntersectingCurveIsInsideOther(t,e);if(i.length===1)return t.start.equal(i[0].x)?p.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)==2:p.PointRelativeToCurveLocation(t.start,e)===2;for(let r of p.PointsBetweenIntersections(t,i))if(p.PointRelativeToCurveLocation(r,e)===0)return!1;return!0}static*PointsBetweenIntersections(t,e){e.sort((s,a)=>s.par0-a.par0);for(let s=0;s<e.length-1;s++)yield t.value((e[s].par0+e[s+1].par0)/2);let i=e[e.length-1].par0,r=e[0].par0,n=t.parEnd-i+(r-t.parStart),o=i+n/2;o>t.parEnd&&(o=t.parStart+(o-t.parEnd)),yield t.value(o)}static NonIntersectingCurveIsInsideOther(t,e){for(let i=t.parStart;i<t.parEnd;i+=.5){let r=p.PointRelativeToCurveLocation(t.value(i),e);if(r!==1)return r===2}return p.PointRelativeToCurveLocation(t.end,e)!==0}static ClosedCurveInteriorsIntersect(t,e){if(!e.boundingBox.intersects(t.boundingBox))return!1;let i=p.getAllIntersections(t,e,!0);if(i.length===0)return p.NonIntersectingCurveIsInsideOther(t,e)||p.NonIntersectingCurveIsInsideOther(e,t);if(i.length===1)return t.start.equal(i[0].x)?p.PointRelativeToCurveLocation(t.value((t.parStart+t.parEnd)/2),e)===2||!e.start.equal(i[0].x)?p.PointRelativeToCurveLocation(e.start,t)===2:p.PointRelativeToCurveLocation(e.value((e.parStart+e.parEnd)/2),t)===2:p.PointRelativeToCurveLocation(t.start,e)===2;for(let r of p.PointsBetweenIntersections(t,i))if(p.PointRelativeToCurveLocation(r,e)===2)return!0;return!0}curvature(t){let e=this.getSegParam(t);return e.seg.curvature(e.par)}curvatureDerivative(t){throw new Error("Not implemente")}curvatureSecondDerivative(t){throw new Error("Not implemented")}static createBezierSeg(t,e,i,r,n){let o=c.mkPoint(t,i.point,1-t,r.point),s=c.mkPoint(e,n.point,1-e,r.point),a=r.point.mul(2/3);return new ee(o,o.div(3).add(a),a.add(s.div(3)),s)}static createBezierSegN(t,e,i,r){let n=i.mul(r);return new ee(t,t.add(n),e.add(n),e)}static findCorner(t){let e=t.next;if(e.next==null)return;let i=e.next;if(i!=null)return{b:e,c:i}}static trimEdgeSplineWithNodeBoundaries(t,e,i,r){let n=i.parStart,o=i.parEnd;t!=null&&(n=p.findNewStart(i,n,t,r)),e!=null&&(o=p.findNewEnd(i,e,r,o));let s=Math.min(n,o),a=Math.max(n,o);return s<a?i.trim(s,a):i}static findNewEnd(t,e,i,r){let n=p.getAllIntersections(t,e,!0);if(n.length===0)return r=t.parEnd,r;if(i){r=t.parEnd;for(let o of n)o.par0<r&&(r=o.par0)}else{r=t.parStart;for(let o of n)o.par0>r&&(r=o.par0)}return r}static findNewStart(t,e,i,r){let n=p.getAllIntersections(t,i,!0);if(n.length===0){e=t.parStart;return}if(r){e=t.parStart;for(let o of n)o.par0>e&&(e=o.par0)}else{e=t.parEnd;for(let o of n)o.par0<e&&(e=o.par0)}return e}static polylineAroundClosedCurve(t){if(t instanceof k)return p.refineEllipse(t);if(t instanceof R)return t;if(t instanceof p&&p.allSegsAreLines(t)){let e=new R;for(let i of t.segs)e.addPoint(i.start);if(e.closed=!0,!e.isClockwise())return e.reverse()}return t.boundingBox.perimeter()}static allSegsAreLines(t){for(let e of t.segs)if(!(e instanceof S))return!1;return!0}static refineEllipse(t){let e=t.boundingBox.perimeter(),i=Math.PI/4,r=t.boundingBox.width,n=t.boundingBox.height,o=Math.sqrt(r*r+n*n),s=[];for(let u=0;u<4;u++){let h=i+u*Math.PI/2,d=t.value(h),g=t.derivative(h).normalize().mul(o),f=S.mkPP(d.sub(g),d.add(g));for(let P of p.getAllIntersections(e,f,!0))s.push(P)}s.sort((u,h)=>u.par0<h.par0?-1:u.par0>h.par0?1:0);let a=new R;return s.forEach(u=>a.addPoint(u.x)),a.closed=!0,a}static polyFromBox(t){let e=new R;return e.addPoint(t.leftTop),e.addPoint(t.rightTop),e.addPoint(t.rightBottom),e.addPoint(t.leftBottom),e.closed=!0,e}};function rc(l,t,e,i,r,n){if(r instanceof S)return!0;for(let o of[1/3,.5,2/3]){let s=l*o+e*(1-o);if(c.closeSquare(r.value(s),c.mkPoint(o,t,1-o,i),n*n)===!1)return!1}return!0}function sl(l,t,e,i,r,n){let o=[];if(rc(l,t,e,i,r,n))o.push(t),o.push(i);else{let s=.5*(l+e),a=r.value(s);o=sl(l,t,s,a,r,n);let u=sl(s,a,e,i,r,n).slice(1);o=o.concat(u)}return o}function Vo(l,t){return sl(l.parStart,l.start,l.parEnd,l.end,l,t)}function*ou(l,t){if(t.containsRectWithPadding(l.boundingBox,1)){yield l;return}let e=t.perimeter(),i=p.getAllIntersections(l,e,!0);if(i.length==0){t.contains(l.start)&&(yield l);return}i.sort((o,s)=>o.par0-s.par0);let r=[l.parStart],n=0;for(;n<i.length;n++){let o=i[n];o.par0>r[r.length-1]+m.distanceEpsilon&&r.push(o.par0)}for(l.parEnd>r[r.length-1]+m.distanceEpsilon&&r.push(l.parEnd),n=0;n<r.length-1;n++)nc(l,r[n],r[n+1],t)&&(yield l.trim(r[n],r[n+1]))}function nc(l,t,e,i){let r=(e-t)/5;for(let n=1;n<5;n++){let o=t+r*n;if(i.contains(l.value(o)))return!0}return!1}var R=class{constructor(){this.initIsRequired=!0;this.isClosed_=!1}toJSON(){return{points:Array.from(this).map(t=>t.toJSON())}}static fromJSON(t){return R.mkFromPoints(t.points.map(e=>c.fromJSON(e)))}RemoveStartPoint(){let t=this.startPoint.next;t.prev=null,this.startPoint=t,this.setInitIsRequired()}RemoveEndPoint(){let t=this.endPoint.prev;t.next=null,this.endPoint=t,this.setInitIsRequired()}setInitIsRequired(){this.initIsRequired=!0}addPointXY(t,e){this.addPoint(new c(t,e))}isClockwise(){return c.getTriangleOrientation(this.startPoint.point,this.startPoint.next.point,this.startPoint.next.next.point)==0}addPoint(t){let e=new Ne;e.polyline=this,e.point=t.clone(),this.endPoint!=null?(this.endPoint.next=e,e.prev=this.endPoint,this.endPoint=e):this.startPoint=this.endPoint=e,this.setInitIsRequired()}PrependPoint(t){let e=Ne.mkFromPoint(t);e.polyline=this,this.startPoint!=null?c.closeDistEps(t,this.startPoint.point)||(this.startPoint.prev=e,e.next=this.startPoint,this.startPoint=e):(this.endPoint=e,this.startPoint=e),this.setInitIsRequired()}*[Symbol.iterator](){for(let t=this.startPoint;t!=null;t=t.next)yield t.point}*polylinePoints(){for(let t=this.startPoint;t!=null;t=t.next)yield t}*skip(t){for(let e=this.startPoint;e!=null;e=e.next)t>0?t--:yield e}static parallelogramOfLineSeg(t,e){let i=e.sub(t).div(2);return j.parallelogramByCornerSideSide(t,i,i)}static mkFromPoints(t){let e=new R;for(let i of t)e.addPoint(i);return e}static mkClosedFromPoints(t){let e=R.mkFromPoints(t);return e.closed=!0,e}calculatePbNode(){let t=[],e=[],i=this.startPoint,r=0;for(;i.next!=null;){let n=R.parallelogramOfLineSeg(i.point,i.next.point);t.push(n),e.push({parallelogram:n,seg:this,leafBoxesOffset:0,node:{low:r,high:r+1,chord:S.mkPP(i.point,i.next.point)}}),i=i.next,r++}if(this.isClosed_){let n=R.parallelogramOfLineSeg(this.endPoint.point,this.startPoint.point);t.push(n),e.push({parallelogram:n,seg:this,leafBoxesOffset:0,node:{low:r,high:r+1,chord:S.mkPP(this.endPoint.point,this.startPoint.point)}})}this.pBNode={parallelogram:j.getParallelogramOfAGroup(t),seg:this,leafBoxesOffset:0,node:{children:e}}}init(){this.bBox=I.rectangleOnPoint(this.startPoint.point);for(let t of this.skip(1))this.bBox.add(t.point);this.updateCount(),this.calculatePbNode(),this.initIsRequired=!1}updateCount(){this.count_=0;for(let t=this.startPoint;t!=null;t=t.next)this.count_++}get count(){return this.initIsRequired&&this.init(),this.count_}get closed(){return this.isClosed_}set closed(t){this.isClosed_=t}value(t){this.initIsRequired&&this.init();let e=this.getAdjustedParamAndStartEndPoints(t);return c.convSum(e.t,e.a,e.b)}getAdjustedParamAndStartEndPoints(t){let e=this.startPoint;for(;e.next!=null;){if(t<=1)return{a:e.point,b:e.next.point,t};e=e.next,t-=1}if(this.closed&&t<=1)return{a:this.endPoint.point,b:this.startPoint.point,t};throw new Error("out of the parameter domain")}derivative(t){let e=this.getAdjustedParamAndStartEndPoints(t);return e.b.sub(e.a)}secondDerivative(t){return new c(0,0)}thirdDerivative(t){return new c(0,0)}pNodeOverICurve(){return this.initIsRequired&&this.init(),this.pBNode}get boundingBox(){return this.initIsRequired&&this.init(),this.bBox}get parStart(){return 0}get parEnd(){return this.initIsRequired&&this.init(),this.closed?this.count_:this.count_-1}static polylineFromCurve(t){let e=new R;e.addPoint(t.start);for(let i of t.segs)e.addPoint(i.end);return e.closed=t.start===t.end,e}trim(t,e){let i=this.toCurve();return i=i.trim(t,e),i instanceof p?R.polylineFromCurve(i):R.mkFromPoints([i.start,i.end])}trimWithWrap(t,e){throw new Error("Method not implemented.")}translate(t){let e=this.startPoint;do{if(e.point=e.point.add(t),e===this.endPoint)break;e=e.getNext()}while(!0);this.setInitIsRequired()}scaleFromOrigin(t,e){throw new Error("Method not implemented.")}get start(){return this.startPoint.point}get end(){return this.endPoint.point}reverse(){let t=new R;t.closed=this.closed;let e=this.endPoint;do{if(t.addPoint(e.point),e===this.startPoint)break;e=e.getPrev()}while(!0);return t}offsetCurve(t,e){throw new Error("Method not implemented.")}lengthPartial(t,e){throw new Error("Method not implemented.")}get length(){throw new Error("Method not implemented.")}getParameterAtLength(t){throw new Error("Method not implemented.")}transform(t){let e=new R;for(let i of this.polylinePoints())e.addPoint(t.multiplyPoint(i.point));return e.closed=this.closed,e}closestParameterWithinBounds(t,e,i){throw new Error("Method not implemented.")}closestParameter(t){let e=0,i=Number.MAX_VALUE,r=0,n=this.startPoint;for(;n.next!=null;){let o=S.mkPP(n.point,n.next.point),s=o.closestParameter(t),a=o.value(s).sub(t),u=a.dot(a);u<i&&(i=u,e=s+r),n=n.next,r++}if(this.closed){let o=S.mkPP(this.endPoint.point,this.startPoint.point),s=o.closestParameter(t),a=o.value(s).sub(t);a.dot(a)<i&&(e=s+r)}return e}clone(){let t=new R;t.closed=this.closed;let e=this.startPoint;do{if(t.addPoint(e.point),e===this.endPoint)break;e=e.getNext()}while(!0);return t}leftDerivative(t){throw new Error("Method not implemented.")}rightDerivative(t){throw new Error("Method not implemented.")}curvature(t){throw new Error("Method not implemented.")}curvatureDerivative(t){throw new Error("Method not implemented.")}curvatureSecondDerivative(t){throw new Error("Method not implemented.")}next(t){var e;return(e=t.next)!=null?e:this.closed?this.startPoint:null}prev(t){var e;return(e=t.prev)!=null?e:this.closed?this.endPoint:null}toCurve(){let t=new p;p.addLineSegment(t,this.startPoint.point,this.startPoint.next.point);let e=this.startPoint.next;for(;(e=e.next)!=null;)p.continueWithLineSegmentP(t,e.point);return this.closed&&p.continueWithLineSegmentP(t,this.startPoint.point),t}RemoveCollinearVertices(){for(let t=this.startPoint.next;t.next!=null;t=t.next)c.getTriangleOrientation(t.prev.point,t.point,t.next.point)===2&&(t.prev.next=t.next,t.next.prev=t.prev);return this.setInitIsRequired(),this}};var Ke=class{pad(t){this.width+=t*2}constructor(t,e=t){this.width=t,this.height=e}},I=class{transform(t){return I.mkPP(t.multiplyPoint(this.leftTop),t.multiplyPoint(this.rightBottom))}translate(t){return I.mkSizeCenter(this.size,this.center.add(t))}equal(t){return this.left_===t.left&&this.right_===t.right&&this.top_===t.top&&this.bottom_===t.bottom}equalEps(t){return N(this.left_,t.left)&&N(this.right_,t.right)&&N(this.top_,t.top)&&N(this.bottom_,t.bottom)}static mkSizeCenter(t,e){let i=t.width/2,r=t.height/2;return new I({left:e.x-i,right:e.x+i,bottom:e.y-r,top:e.y+r})}constructor(t){this.left_=t.left,this.right_=t.right,this.top_=t.top,this.bottom=t.bottom}add_rect(t){return this.addRec(t)}contains_point(t){return this.contains(t)}contains_rect(t){return this.containsRect(t)}intersection_rect(t){return this.intersection(t)}intersects_rect(t){return this.intersects(t)}unite(t){return I.rectangleOfTwo(this,t)}contains_point_radius(t,e){return this.containsWithPadding(t,e)}intersects(t){return this.intersectsOnX(t)&&this.intersectsOnY(t)}intersection(t){if(!this.intersects(t)){let o=I.mkEmpty();return o.setToEmpty(),o}let e=Math.max(this.left,t.left),i=Math.min(this.right,t.right),r=Math.max(this.bottom,t.bottom),n=Math.min(this.top,t.top);return new I({left:e,bottom:r,right:i,top:n})}get center(){return this.leftTop.add(this.rightBottom).mul(.5)}set center(t){let e=this.leftTop.add(this.rightBottom).mul(.5),i=t.sub(e);this.leftTop=this.leftTop.add(i),this.rightBottom=this.rightBottom.add(i)}intersectsOnY(t){return!(t.bottom_>this.top_+m.distanceEpsilon||t.top_<this.bottom_-m.distanceEpsilon)}intersectsOnX(t){return!(t.left>this.right_+m.distanceEpsilon||t.right<this.left_-m.distanceEpsilon)}static mkEmpty(){return new I({left:0,right:-1,bottom:0,top:-1})}get left(){return this.left_}set left(t){this.left_=t,this.onUpdated()}get right(){return this.right_}set right(t){this.right_=t,this.onUpdated()}get top(){return this.top_}set top(t){this.top_=t,this.onUpdated()}get bottom(){return this.bottom_}set bottom(t){this.bottom_=t,this.onUpdated()}get leftBottom(){return new c(this.left_,this.bottom_)}set leftBottom(t){this.left_=t.x,this.bottom=t.y}get rightTop(){return new c(this.right_,this.top_)}set rightTop(t){this.right_=t.x,this.top_=t.y}get leftTop(){return new c(this.left_,this.top_)}set leftTop(t){this.left_=t.x,this.top_=t.y}get rightBottom(){return new c(this.right_,this.bottom_)}set rightBottom(t){this.right_=t.x,this.bottom=t.y}onUpdated(){}static mkPP(t,e){let i=new I({left:t.x,right:t.x,top:t.y,bottom:t.y});return i.add(e),i}static rectangleOnPoint(t){return new I({left:t.x,right:t.x,top:t.y,bottom:t.y})}static mkLeftBottomSize(t,e,i){let r=t+i.width,n=e+i.height;return new I({left:t,right:r,top:n,bottom:e})}static getRectangleOnCoords(t,e,i,r){let n=new I({left:t,bottom:e,right:t,top:e});return n.add(new c(i,r)),n}static mkOnPoints(t){let e=I.mkEmpty();for(let i of t)e.add(i);return e}static mkOnRectangles(t){let e=I.mkEmpty();for(let i of t)e.addRecSelf(i);return e}get width(){return this.right_-this.left_}set width(t){let e=t/2,i=(this.left_+this.right_)/2;this.left_=i-e,this.right_=i+e}isEmpty(){return this.right<this.left}setToEmpty(){this.left=0,this.right=-1}get height(){return this.top_-this.bottom_}set height(t){let e=t/2,i=(this.top_+this.bottom_)/2;this.top_=i+e,this.bottom=i-e}static rectangleOfTwo(t,e){let i=new I({left:t.left_,right:t.right_,top:t.top_,bottom:t.bottom_});return i.addRecSelf(e),i}containsWithPadding(t,e){return this.left_-e-m.distanceEpsilon<=t.x&&t.x<=this.right_+e+m.distanceEpsilon&&this.bottom_-e-m.distanceEpsilon<=t.y&&t.y<=this.top_+e+m.distanceEpsilon}get area(){return(this.right_-this.left_)*(this.top_-this.bottom_)}add(t){this.isEmpty()?(this.left_=this.right_=t.x,this.top_=this.bottom=t.y):(this.left_>t.x&&(this.left_=t.x),this.top_<t.y&&(this.top_=t.y),this.right_<t.x&&(this.right_=t.x),this.bottom_>t.y&&(this.bottom=t.y))}addRecSelf(t){this.add(t.leftTop),this.add(t.rightBottom)}addRec(t){let e=this.clone();return e.add(t.leftTop),e.add(t.rightBottom),e}static translate(t,e){let i=t.clone();return i.center=t.center.add(e),i}static transform(t,e){return I.mkPP(e.multiplyPoint(t.leftTop),e.multiplyPoint(t.rightBottom))}contains(t){return this.containsWithPadding(t,0)}containsRect(t){return this.contains(t.leftTop)&&this.contains(t.rightBottom)}containsRectWithPadding(t,e){return this.containsWithPadding(t.leftTop,e)&&this.containsWithPadding(t.rightBottom,e)}get diagonal(){return Math.sqrt(this.width*this.width+this.height*this.height)}padWidth(t){this.left-=t,this.right+=t}padHeight(t){this.top+=t,this.bottom-=t}pad(t){t<-this.width/2&&(t=-this.width/2),t<-this.height/2&&(t=-this.height/2),this.padWidth(t),this.padHeight(t)}padEverywhere(t){this.left-=t.left,this.right+=t.right,this.bottom-=t.bottom,this.top+=t.top}static intersect(t,e){return t.intersects(e)?I.mkPP(new c(Math.max(t.left,e.left),Math.max(t.bottom,e.bottom)),new c(Math.min(t.right,e.right),Math.min(t.top,e.top))):I.mkEmpty()}perimeter(){let t=new R;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}scaleAroundCenter(t){this.width=this.width*t,this.height=this.height*t}clone(){return new I({left:this.left,right:this.right,top:this.top,bottom:this.bottom})}get size(){return new Ke(this.width,this.height)}set size(t){this.width=t.width,this.height=t.height}static creatRectangleWithSize(t,e){let i=t.width/2,r=e.x-i,n=e.x+i,o=t.height/2,s=e.y-o,a=e.y+o;return new I({left:r,right:n,top:a,bottom:s})}addPointWithSize(t,e){let i=t.width/2,r=t.height/2;this.add(new c(e.x-i,e.y-r)),this.add(new c(e.x+i,e.y-r)),this.add(new c(e.x-i,e.y+r)),this.add(new c(e.x+i,e.y+r))}};var _=class{constructor(){this.previouisBezierCoefficient=.5;this.nextBezierCoefficient=.5;this.previousTangentCoefficient=1/3;this.nextTangentCoefficient=1/3}static mkSiteP(t){let e=new _;return e.point=t,e}static mkSiteSP(t,e){let i=new _;return i.point=e,i.prev=t,t.next=i,i}static mkSiteSPS(t,e,i){let r=new _;return r.prev=t,r.point=e,r.next=i,t.next=r,i.prev=r,r}get turn(){return this.next==null||this.prev==null?0:c.getTriangleOrientation(this.prev.point,this.point,this.next.point)}clone(){let t=new _;return t.previouisBezierCoefficient=this.previouisBezierCoefficient,t.point=this.point,t}};var oe=class{static mkFromPoints(t){let e=null,i=null;for(let r of t)if(i==null)i=_.mkSiteP(r),e=new oe(i);else{let n=_.mkSiteP(r);n.prev=i,i.next=n,i=n}return e}clone(){let t=this.headSite,e=null,i,r=null;for(;t!=null;)i=t.clone(),i.prev=e,e!=null?e.next=i:r=i,t=t.next,e=i;return new oe(r)}constructor(t){this.headSite=t}get lastSite(){let t=this.headSite;for(;t.next!=null;)t=t.next;return t}*[Symbol.iterator](){let t=this.headSite;for(;t!=null;)yield t.point,t=t.next}createCurve(){let t=new p,e=this.headSite,i;do{let r=p.findCorner(e);if(r==null)break;let n=oe.createBezierSegOnSite(r.b);t.segs.length===0?c.closeDistEps(e.point,n.start)||p.addLineSegment(t,e.point,n.start):c.closeDistEps(t.end,n.start)||p.continueWithLineSegmentP(t,n.start),t.addSegment(n),e=r.b}while(!0);return t.segs.length===0?c.closeDistEps(e.point,e.next.point)?t.segs.push(new ee(e.point,e.point.add(new c(5,5)),e.point.add(new c(-5,5)),i.point)):p.addLineSegment(t,e.point,e.next.point):c.closeDistEps(t.end,e.next.point)||p.continueWithLineSegmentP(t,e.next.point),t}static createBezierSegOnSite(t){let e=t.previouisBezierCoefficient,i=t.nextBezierCoefficient,r=t.prev,n=t.next,o=r.point.mul(e).add(t.point.mul(1-e)),s=n.point.mul(i).add(t.point.mul(1-i)),a=o.mul(t.previousTangentCoefficient).add(t.point.mul(1-t.previousTangentCoefficient)),u=s.mul(t.nextTangentCoefficient).add(t.point.mul(1-t.nextTangentCoefficient));return ee.mkBezier([o,a,u,s])}};var Ce=class{get Elements(){return this.elements}getElem(t,e){return this.elements[t][e]}setElem(t,e,i){this.elements[t][e]=i}static Divide(t,e){return t.multiply(e.inverse())}isIdentity(){return N(this.elements[0][0],1)&&N(this.elements[0][1],0)&&N(this.elements[0][2],0)&&N(this.elements[1][0],0)&&N(this.elements[1][1],1)&&N(this.elements[1][2],0)}offset(){return new c(this.getElem(0,2),this.getElem(1,2))}static getIdentity(){return new Ce(1,0,0,0,1,0)}constructor(t,e,i,r,n,o){this.elements=[[t,e,i],[r,n,o]]}static rotation(t){let e=Math.cos(t),i=Math.sin(t);return new Ce(e,-i,0,i,e,0)}static scaleAroundCenterTransformation(t,e,i){let r=1-t,n=1-e;return new Ce(t,0,r*i.x,0,e,n*i.y)}multiplyPoint(t){return new c(this.getElem(0,0)*t.x+this.getElem(0,1)*t.y+this.getElem(0,2),this.getElem(1,0)*t.x+this.getElem(1,1)*t.y+this.getElem(1,2))}multiply(t){return t!=null?new Ce(this.getElem(0,0)*t.getElem(0,0)+this.getElem(0,1)*t.getElem(1,0),this.getElem(0,0)*t.getElem(0,1)+this.getElem(0,1)*t.getElem(1,1),this.getElem(0,0)*t.getElem(0,2)+this.getElem(0,1)*t.getElem(1,2)+this.getElem(0,2),this.getElem(1,0)*t.getElem(0,0)+this.getElem(1,1)*t.getElem(1,0),this.getElem(1,0)*t.getElem(0,1)+this.getElem(1,1)*t.getElem(1,1),this.getElem(1,0)*t.getElem(0,2)+this.getElem(1,1)*t.getElem(1,2)+this.getElem(1,2)):null}inverse(){let t=this.getElem(0,0)*this.getElem(1,1)-this.getElem(1,0)*this.getElem(0,1),e=this.getElem(1,1)/t,i=-this.getElem(0,1)/t,r=-this.getElem(1,0)/t,n=this.getElem(0,0)/t,o=-e*this.getElem(0,2)-i*this.getElem(1,2),s=-r*this.getElem(0,2)-n*this.getElem(1,2);return new Ce(e,i,o,r,n,s)}};var Gi=class{static mkEllipse(t,e,i){return k.mkFullEllipseNNP(t,e,i)}static createParallelogram(t,e,i){let r=e/2,n=t/2,o=i.x,s=i.y,a=80*Math.PI/180,u=r/Math.tan(a);return R.mkClosedFromPoints([new c(-n-u+o,-r+s),new c(n+o,-r+s),new c(n+o+u,r+s),new c(-n+o,r+s)])}static createHexagon(t,e,i){let r=e/2,n=t/2,o=i.x,s=i.y;return R.mkClosedFromPoints([new c(-n+o,-r+s),new c(n+o,-r+s),new c(n+(r+o),0+s),new c(n+o,r+s),new c(-n+o,r+s),new c(-(n-r)+o,0+s)])}static createOctagon(t,e,i){let r=t/2,n=e/2,o=new Array(8);o[0]=new c(r+Gi.octagonPad*r,n-n*Gi.octagonPad),o[3]=new c(o[0].x*-1,o[0].y),o[4]=new c(o[3].x,o[3].y*-1),o[7]=new c(o[0].x,o[0].y*-1),o[1]=new c(r-r*Gi.octagonPad,n+n*Gi.octagonPad),o[2]=new c(o[1].x*-1,o[1].y),o[6]=new c(o[1].x,o[1].y*-1),o[5]=new c(o[2].x,o[2].y*-1);for(let s=0;s<8;s++)o[s]=o[s].add(i);return R.mkClosedFromPoints(o)}static createInvertedHouse(t,e,i){let r=Gi.createHouse(t,e,i);return Gi.rotateCurveAroundCenterByDegree(r,i,180)}static createHouse(t,e,i){let r=t/2,n=e/2,o=i.x,s=i.y,a=new p;return p.addLineSegmentCNNNN(a,o-r,s-n,o+r,s-n),p.continueWithLineSegmentNN(a,o+r,s+n),p.continueWithLineSegmentNN(a,o,s+2*n),p.continueWithLineSegmentNN(a,o-r,s+n),p.closeCurve(a)}static mkDiamond(t,e,i){let r=t,n=e,o=i.x,s=i.y,a=new p,u=[new c(o,s-n),new c(o+r,s),new c(o,s+n),new c(o-r,s)];return a.addSegs([S.mkPP(u[0],u[1]),S.mkPP(u[1],u[2]),S.mkPP(u[2],u[3]),S.mkPP(u[3],u[0])]),a}static rotateCurveAroundCenterByDegree(t,e,i){return Gi.rotateCurveAroundCenterByRadian(t,e,i*Math.PI/180)}static rotateCurveAroundCenterByRadian(t,e,i){let r=Math.cos(i),n=Math.sin(i),o=new Ce(1,0,e.x,0,1,e.y).multiply(new Ce(r,-n,0,n,r,0)).multiply(new Ce(1,0,-e.x,0,1,-e.y));return t.transform(o)}static mkCircle(t,e){return k.mkCircle(t,e)}static createRectangle(t,e,i){let r=t/2,n=e/2,o=i.x,s=i.y,a=new p,u=[new c(o-r,s-n),new c(o+r,s-n),new c(o+r,s+n),new c(o-r,s+n)];return a.addSegs([S.mkPP(u[0],u[1]),S.mkPP(u[1],u[2]),S.mkPP(u[2],u[3]),S.mkPP(u[3],u[0])]),a}static isRoundedRect(t){if(!(t instanceof p))return;let e=t.segs;if(e.length!==8&&e.length!==4)return;let i=e.length===8,r,n;for(let o=0;o<4;o++){let s=i?2*o+1:o;if(o===0){if(!(e[s]instanceof k))return;let a=e[s];r=a.aAxis.length,n=a.bAxis.length}else{if(!(e[s]instanceof k))return;let a=e[s];if(r!==a.aAxis.length||n!==a.bAxis.length)return}}return{radX:r,radY:n}}static mkRectangleWithRoundedCorners(t,e,i,r,n=new c(0,0)){if(i===0||r===0)return Gi.createRectangle(t,e,n);let o=new p,s=t/2;i>s/2&&(i=s/2);let a=e/2;r>a/2&&(r=a/2);let u=n.x,h=n.y,d=s-i,g=a-r,f=h+a,P=h-a,y=u-s,w=u+s,x=new c(i,0),G=new c(0,r);return d>0&&o.addSegment(S.mkPP(new c(u-d,P),new c(u+d,P))),o.addSegment(k.mkEllipse(1.5*Math.PI,2*Math.PI,x,G,u+d,h-g)),g>0&&o.addSegment(S.mkPP(new c(w,h-g),new c(w,h+g))),o.addSegment(k.mkEllipse(0,.5*Math.PI,x,G,u+d,h+g)),d>0&&o.addSegment(S.mkPP(new c(u+d,f),new c(u-d,f))),o.addSegment(k.mkEllipse(.5*Math.PI,Math.PI,x,G,u-d,h+g)),g>0&&o.addSegment(S.mkPP(new c(y,h+g),new c(y,h-g))),o.addSegment(k.mkEllipse(Math.PI,1.5*Math.PI,x,G,u-d,h-g)),o}},be=Gi;be.octagonPad=1/4;function Zt(l){return l.parEnd-l.parStart}function su(l){switch(l.type){case"ellipse":return k.fromJSON(l.data);case"curve":return p.fromJSON(l.data);case"lineSegment":return S.fromJSON(l.data);case"bezier":return ee.fromJSON(l.data);case"polyline":return R.fromJSON(l.data)}}function oc(l){if(l instanceof k)return"ellipse";if(l instanceof p)return"curve";if(l instanceof S)return"lineSegment";if(l instanceof ee)return"bezier";if(l instanceof R)return"polyline";throw new Error("not implemented")}function au(l){return{type:oc(l),data:l.toJSON()}}var Rt=class{static get DifferenceEpsilon(){return Rt.differenceEpsilon}static EqualPP(t,e){return Rt.Equal(t.x,e.x)&&Rt.Equal(t.y,e.y)}static Equal(t,e){return Rt.Compare(t,e)===0}static Compare(t,e){let i=0;return t+Rt.DifferenceEpsilon<e?i=-1:e+Rt.DifferenceEpsilon<t&&(i=1),i}static ComparePP(t,e){let i=Rt.Compare(t.x,e.x);return i===0&&(i=Rt.Compare(t.y,e.y)),i}static LessOrEqual(t,e){let i=Rt.Compare(t,e);return i<0||i===0}static Less(t,e){return Rt.Compare(t,e)<0}static GetDirections(t,e){return v.DirectionFromPointToPoint(t,e)}static IsPureDirection(t,e){return v.IsPureDirection(Rt.GetDirections(t,e))}static IsPureDirectionD(t){return v.IsPureDirection(t)}static IsPureLower(t,e){let i=Rt.GetDirections(t,e);return 2===i||1===i}static GetPureDirectionVV(t,e){return Rt.GetDirections(t.point,e.point)}},C=Rt;C.differenceEpsilon=m.distanceEpsilon/2;var v=class{constructor(t){this.Dir=t}get Right(){return new v(v.RotateRight(this.Dir))}static RotateRight(t){switch(t){case 1:return 2;case 2:return 4;case 4:return 8;case 8:return 1;default:throw new Error}}static RotateLeft(t){switch(t){case 1:return 8;case 8:return 4;case 4:return 2;case 2:return 1;default:throw new Error}}static ToIndex(t){switch(t){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new Error}}static VectorDirection(t){let e=0;return t.x>C.DifferenceEpsilon?e=2:t.x<-C.DifferenceEpsilon&&(e=8),t.y>C.DifferenceEpsilon?e=e|1:t.y<-C.DifferenceEpsilon&&(e=e|4),e}static VectorDirectionPP(t,e){let i=0,r=e.x-t.x,n=e.y-t.y;return r>C.DifferenceEpsilon?i=2:-r>C.DifferenceEpsilon&&(i=8),n>C.DifferenceEpsilon?i|=1:-n>C.DifferenceEpsilon&&(i|=4),i}static DirectionFromPointToPoint(t,e){return v.VectorDirectionPP(t,e)}static OppositeDir(t){switch(t){case 1:return 4;case 8:return 2;case 4:return 1;case 2:return 8;default:return 0}}static IsPureDirection(t){switch(t){case 1:return!0;case 2:return!0;case 4:return!0;case 8:return!0;default:return!1}}static IsPureDirectionPP(t,e){return v.IsPureDirection(v.DirectionFromPointToPoint(t,e))}static DirectionsAreParallel(t,e){return t===e||t===v.OppositeDir(e)}ToPoint(){let t=0,e=0;return(this.Dir&2)===2&&t++,(this.Dir&1)===1&&e++,(this.Dir&8)===8&&t--,(this.Dir&4)===4&&e--,new c(t,e)}static toPoint(t){return new v(t).ToPoint()}static negate(t){return new v(v.OppositeDir(t.Dir))}};var Ni=class extends q{constructor(e,i){super(e);this._isPositioned=!1;i&&(this.boundingBox=I.mkPP(new c(0,0),new c(i.width,i.height)))}clone(){let e=new Ni(null,null);return e.isPositioned=this.isPositioned,e._boundingBox=this._boundingBox.clone(),e.attachmentSegmentEnd=this.attachmentSegmentEnd,e.attachmentSegmentStart=this.attachmentSegmentStart,e}get isPositioned(){return this._isPositioned}set isPositioned(e){this._isPositioned=e}get boundingBox(){return this._boundingBox}set boundingBox(e){this._boundingBox=e}setBoundingBox(e){this.isPositioned=!0,this._boundingBox=e}get width(){return this.boundingBox.width}set width(e){this.boundingBox.width=e}get height(){return this.boundingBox.height}set height(e){this.boundingBox.height=e}get center(){return this.boundingBox.center}set center(e){this.boundingBox.center=e}translate(e){this.isPositioned&&(this.center=this.center.add(e))}transform(e){this.isPositioned&&(this.center=e.multiplyPoint(this.center))}positionCenter(e){this.boundingBox.center=e,this.isPositioned=!0}};var Pe=class extends q{constructor(e){super(e);this.lineWidth=1}static getGeom(e){return q.getGeom(e)}clone(){let e=new Pe(null);return this.smoothedPolyline&&(e.smoothedPolyline=this.smoothedPolyline.clone()),e.curve=this.curve.clone(),this.sourceArrowhead!=null&&(e.sourceArrowhead=this.sourceArrowhead.clone()),this.targetArrowhead!=null&&(e.targetArrowhead=this.targetArrowhead.clone()),e}get label(){return this.edge!=null&&this.edge.label!=null?q.getGeom(this.edge.label):null}set label(e){this.edge.label.setAttr(Le.GeomObjectIndex,e)}RaiseLayoutChangeEvent(e){this.edge.raiseEvents(e)}requireRouting(){this.curve=null,this.smoothedPolyline=null}translate(e){if(!(e.x===0&&e.y===0)){if(this.curve!=null&&this.curve.translate(e),this.smoothedPolyline!=null)for(let i=this.smoothedPolyline.headSite,r=this.smoothedPolyline.headSite;i!=null;i=i.next,r=r.next)i.point=r.point.add(e);if(this.sourceArrowhead!=null&&this.sourceArrowhead.tipPosition&&(this.sourceArrowhead.tipPosition=this.sourceArrowhead.tipPosition.add(e)),this.targetArrowhead!=null&&this.targetArrowhead.tipPosition&&(this.targetArrowhead.tipPosition=this.targetArrowhead.tipPosition.add(e)),this.edge.label){let i=Ni.getGeom(this.edge.label);i&&i.translate(e)}}}GetMaxArrowheadLength(){let e=0;return this.sourceArrowhead!=null&&(e=this.sourceArrowhead.length),this.targetArrowhead!=null&&this.targetArrowhead.length>e?this.targetArrowhead.length:e}transform(e){if(this.curve!=null){if(this.curve=this.curve.transform(e),this.smoothedPolyline!=null)for(let i=this.smoothedPolyline.headSite,r=this.smoothedPolyline.headSite;i!=null;i=i.next,r=r.next)i.point=e.multiplyPoint(i.point);this.sourceArrowhead!=null&&(this.sourceArrowhead.tipPosition=e.multiplyPoint(this.sourceArrowhead.tipPosition)),this.targetArrowhead!=null&&(this.targetArrowhead.tipPosition=e.multiplyPoint(this.targetArrowhead.tipPosition))}}get edge(){return this.entity}get source(){return q.getGeom(this.edge.source)}*sourceArrowheadPoints(e){if(this.sourceArrowhead==null)return;yield this.sourceArrowhead.tipPosition;let i=this.sourceArrowhead.tipPosition.sub(this.curve.start);i=i.rotate90Cw().mul(Math.tan(e*.5*(Math.PI/180))),yield i.add(this.curve.start),yield this.curve.start.sub(i)}*targetArrowheadPoints(e){if(this.targetArrowhead==null)return;yield this.targetArrowhead.tipPosition;let i=this.targetArrowhead.tipPosition.sub(this.curve.end);i=i.rotate90Cw().mul(Math.tan(e*.5*(Math.PI/180))),yield i.add(this.curve.end),yield this.curve.end.sub(i)}get boundingBox(){let e=I.mkEmpty();if(this.smoothedPolyline!=null)for(let r of this.smoothedPolyline)e.add(r);this.curve!=null&&e.addRecSelf(this.curve.boundingBox);for(let r of this.sourceArrowheadPoints(25))e.add(r);for(let r of this.targetArrowheadPoints(25))e.add(r);this.label&&e.addRecSelf(this.label.boundingBox);let i=this.lineWidth;return e.left-=i,e.top+=i,e.right+=i,e.bottom-=i,e}isInterGraphEdge(){return this.edge.isInterGraphEdge()}get target(){return q.getGeom(this.edge.target)}toString(){return this.source.toString()+"->"+this.target}static RouteSelfEdge(e,i,r){let n=e.boundingBox.width,o=e.boundingBox.height,s=e.boundingBox.center,a=new c(s.x-n/4,s.y),u=new c(s.x-n/4,s.y-o/2-i),h=new c(s.x+n/4,s.y-o/2-i),d=new c(s.x+n/4,s.y);return r.smoothedPolyline=oe.mkFromPoints([a,u,h,d]),r.smoothedPolyline.createCurve()}underCollapsedGraph(){return this.source.underCollapsedGraph()||this.target.underCollapsedGraph()}EdgeToAncestor(){return this.edge.EdgeToAncestor()}};var Mo=J(ai(),1);function ac(l,t,e,i,r,n){for(let s=0;s<l.length;s++){if(s===t||s===e)continue;let a=n.box0.add_rect(l[s].irect),u=a.area-n.box0.area,h=n.box1.add_rect(l[s].irect),d=h.area-n.box1.area;i.length*2<r.length?(i.push(l[s]),n.box0=a):r.length*2<i.length?(r.push(l[s]),n.box1=h):u<d?(i.push(l[s]),n.box0=a):d<u?(r.push(l[s]),n.box1=h):n.box0.area<n.box1.area?(i.push(l[s]),n.box0=a):(r.push(l[s]),n.box1=h)}}function ge(l){if(l.length===0)return null;if(l.length===1)return l[0];let t={b0:l[0].irect,seed0:1},e=lc(l,t),i=[],r=[];i.push(l[t.seed0]),r.push(l[e]);let n={box0:l[t.seed0].irect,box1:l[e].irect};ac(l,t.seed0,e,i,r,n);let o=uu(l.length);return o.irect=n.box0.add_rect(n.box1),o.Left=ge(i),o.Right=ge(r),o}function lu(l,t){return l.add_rect(t).area}function lc(l,t){let e=lu(t.b0,l[t.seed0].irect);for(let r=2;r<l.length;r++){let n=lu(t.b0,l[r].irect);n>e&&(t.seed0=r,e=n)}let i;for(let r=0;r<l.length;r++)if(r!==t.seed0){i=r;break}e=l[t.seed0].irect.add_rect(l[i].irect).area;for(let r=0;r<l.length;r++){if(r===t.seed0)continue;let n=l[t.seed0].irect.add_rect(l[r].irect).area;n>e&&(i=r,e=n)}return i}function or(l,t){if(l==null||t==null)return null;let e=Array.from(l).map(i=>Se(i,t(i)));return ge(e)}function uu(l){let t=new Br;return t.Count=l,t}function Se(l,t){let e=new Br;return e.UserData=l,e.irect=t,e.Count=1,e}function cl(l,t,e){return l.irect.intersects_rect(e)?t(l.UserData)===0?l.Left!=null?cl(l.Left,t,e)===0&&cl(l.Right,t,e)===0?0:1:0:1:0}var Br=class{toString(){return this.IsLeaf?this.Count.toString()+" "+this.UserData:this.Count.toString()}get IsLeaf(){return this.left==null}get Left(){return this.left}set Left(t){this.left!=null&&this.left.Parent===this&&(this.left.Parent=null),this.left=t,this.left!=null&&(this.left.Parent=this)}get Right(){return this.right}set Right(t){this.right!=null&&this.right.Parent===this&&(this.right.Parent=null),this.right=t,this.right!=null&&(this.right.Parent=this)}get IsLeftChild(){return this===this.Parent.Left}FirstIntersectedNode(t){var e;return t.intersects_rect(this.irect)?this.IsLeaf?this:(e=this.Left.FirstIntersectedNode(t))!=null?e:this.Right.FirstIntersectedNode(t):null}FirstHitNodeWithPredicate(t,e){var i;return this.irect.contains_point(t)?this.IsLeaf?e(t,this.UserData)===1?this:null:(i=this.Left.FirstHitNodeWithPredicate(t,e))!=null?i:this.Right.FirstHitNodeWithPredicate(t,e):null}FirstHitByRectWithPredicate(t,e){var i;return this.irect.intersects_rect(t)?this.IsLeaf?e(this.UserData)===1?this:null:(i=this.Left.FirstHitByRectWithPredicate(t,e))!=null?i:this.Right.FirstHitByRectWithPredicate(t,e):null}FirstHitNode(t){var e;return this.irect.contains_point(t)?this.IsLeaf?this:(e=this.Left.FirstHitNode(t))!=null?e:this.Right.FirstHitNode(t):null}*AllHitItems(t,e=null){let i=new Mo.Stack;for(i.push(this);i.size>0;){let r=i.pop();r.irect.intersects_rect(t)&&(r.IsLeaf?(e==null||e(r.UserData))&&(yield r.UserData):(i.push(r.left),i.push(r.right)))}}*AllHitItems_(t){let e=new Mo.Stack;for(e.push(this);e.size>0;){let i=e.pop();i.irect.contains_point(t)&&(i.IsLeaf?yield i.UserData:(e.push(i.left),e.push(i.right)))}}VisitTree(t,e){cl(this,t,e)}Clone(){let t=uu(this.Count);return t.UserData=this.UserData,t.irect=this.irect,this.Left!=null&&(t.Left=this.Left.Clone()),this.Right!=null&&(t.Right=this.Right.Clone()),t}*GetNodeItemsIntersectingRectangle(t){for(let e of this.GetLeafRectangleNodesIntersectingRectangle(t))yield e.UserData}*GetLeafRectangleNodesIntersectingRectangle(t){let e=new Mo.Stack;for(e.push(this);e.size>0;){let i=e.pop();i.irect.intersects_rect(t)&&(i.IsLeaf?yield i:(e.push(i.left),e.push(i.right)))}}*GetAllLeaves(){for(let t of this.GetAllLeafNodes())yield t.UserData}*GetAllLeafNodes(){for(let t of this.EnumRectangleNodes(!0))yield t}*EnumRectangleNodes(t){let e=new Mo.Stack;for(e.push(this);e.size>0;){let i=e.pop();(i.IsLeaf||!t)&&(yield i),i.IsLeaf||(e.push(i.left),e.push(i.right))}}TraverseHierarchy(t,e){e(t),t.Left!=null&&this.TraverseHierarchy(t.Left,e),t.Right!=null&&this.TraverseHierarchy(t.Right,e)}};var he=class{constructor(t,e){Zn(t,e)<0?(this._first=t,this._second=e):(this._first=e,this._second=t)}get first(){return this._first}get second(){return this._second}get Length(){return te(this._first,this._second)}CompareTo(t){let e=Zn(this._first,t._first);return e!==0?e:Zn(this._second,t._second)}static equal(t,e){return t._first.equal(e._first)&&t._second.equal(e._second)}toString(){return this._first+(" "+this._second)}};var ie=class{constructor(){this.size_=0;this.mapOfSets=new Map}delete(t){return this.deletexy(t.x,t.y)}clear(){this.mapOfSets.clear(),this.size_=0}get size(){return this.size_}static mk(t){let e=new ie;for(let i of t)e.add(i);return e}addxy(t,e){let i=this.mapOfSets.get(t);i==null&&this.mapOfSets.set(t,i=new Set),i.has(e)||this.size_++,i.add(e)}add(t){return this.addxy(t.x,t.y),this}deletexy(t,e){let i=this.mapOfSets.get(t);return i!=null&&i.delete(e)?(this.size_--,!0):!1}hasxy(t,e){return this.mapOfSets.has(t)&&this.mapOfSets.get(t).has(e)}has(t){return this.hasxy(t.x,t.y)}forEach(t,e){for(let i of this)t(i,i,e)}*entries(){for(let t of this)yield[t,t]}keys(){return this.values()}*values(){for(let t of this.mapOfSets)for(let e of t[1])yield new c(t[0],e)}[(Symbol.toStringTag,Symbol.iterator)](){return this.values()}};function sr(l,t){let e=new Set;for(let i of l)t.has(i)||e.add(i);return e}function hu(l,t){let e=new ie;for(let i of l)t.has(i)||e.add(i);return e}function bi(l,t){let e=new Set(l);for(let i of t)e.add(i);return e}function Bi(l,t){for(let e of t)l.push(e)}function Si(l,t){let e=new Set;if(l.size<t.size)for(let i of l)t.has(i)&&e.add(i);else for(let i of t)l.has(i)&&e.add(i);return e}function cu(l){if(l.length===0)return new Set;let t=l[0];for(let e=1;e<l.length;e++)t=Si(t,l[e]);return t}function Vr(l,t){for(let e of t)l.add(e)}function vn(l,t){if(l.size!==t.size)return!1;for(let e of l)if(!t.has(e))return!1;return!0}function Vi(l,t){let e=[];for(let i of l)for(let r of t(i))e.push(r);return e}function xn(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function Tn(l,t,e){let i=l.get(t);i||(i=new Array,l.set(t,i)),i.push(e)}function dl(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function du(l,t,e){dl(l,new he(t[0],t[1]),e)}function uc(l,t,e){let i=l.get(t);i&&i.delete(e)}function gl(l,t,e){uc(l,new he(t[0],t[1]),e)}var fl=J(Mi(),1);var X=class{static assert(t,e=null){if(!t)throw e!=null?(console.log(e),new Error(e)):new Error("condition does not hold")}};var Di=class{constructor(){this.attrs=[];this._parent=null}addEvent(t){this.events.push(t)}removeEvent(t){let e=this.events.indexOf(t);e>=0&&(this.events=this.events.splice(e,1))}raiseEvents(t){this.events.forEach(e=>e(t))}clearAttr(){this.attrs=[]}setAttr(t,e){this.attrs[t]=e}getAttr(t){return this.attrs[t]}get parent(){return this._parent}set parent(t){this._parent=t}*getAncestors(){let t=this.parent;for(;t!=null;)yield t,t=t.parent}isDescendantOf(t){for(let e of this.getAncestors())if(e===t)return!0;return!1}};var Fi=class extends Di{constructor(e,i){super();this.source=e,this.target=i,e!==i?(e.outEdges.add(this),i.inEdges.add(this)):e.selfEdges.add(this)}add(){this.source!==this.target?(this.source.outEdges.add(this),this.target.inEdges.add(this)):this.source.selfEdges.add(this)}remove(){this.source!==this.target?(this.source.outEdges.delete(this),this.target.inEdges.delete(this)):this.source.selfEdges.delete(this)}toString(){return"("+this.source.toString()+"->"+this.target.toString()+")"}isInterGraphEdge(){return this.source.parent!==this.target.parent}EdgeToAncestor(){return this.source instanceof ce&&this.target.isDescendantOf(this.source)?1:this.target instanceof ce&&this.source.isDescendantOf(this.target)?2:0}};var ar=class extends Di{constructor(e){super();this.inEdges=new Set;this.outEdges=new Set;this.selfEdges=new Set;this.id=e}removeOutEdge(e){this.outEdges.delete(e)}removeInEdge(e){this.inEdges.delete(e)}get id(){return this._id}set id(e){this._id=e}toString(){return this.id}*_edges(){for(let e of this.inEdges)yield e;for(let e of this.outEdges)yield e;for(let e of this.selfEdges)yield e}get edges(){return this._edges()}get outDegree(){return this.outEdges.size}get inDegree(){return this.inEdges.size}get selfDegree(){return this.selfEdges.size}get degree(){return this.outDegree+this.inDegree+this.selfDegree}};var Gs=class{constructor(){this.nodeMap=new Map}remove(t){this.nodeMap.delete(t.id)}get size(){return this.nodeMap.size}*nodes_(){for(let t of this.nodeMap.values())yield t}*graphs_(){for(let t of this.nodes_())t instanceof ce&&(yield t)}findShallow(t){return this.nodeMap.get(t)}get nodesShallow(){return this.nodes_()}get graphs(){return this.graphs_()}*_edges(){for(let t of this.nodeMap.values()){for(let e of t.outEdges)yield e;for(let e of t.selfEdges)yield e}}interGraphEdges(){throw new Error("not implemented")}get nodeShallowCount(){return this.nodeMap.size}get edgeCount(){let t=0;for(let e of this.nodeMap.values())t+=e.outDegree+e.selfDegree;return t}get edges(){return this._edges()}addNode(t){this.nodeMap.set(t.id,t)}nodeIsConsistent(t){for(let e of t.outEdges)if(e.source!==t||e.source===e.target)return!1;for(let e of t.inEdges)if(e.target!==t||e.source===e.target)return!1;for(let e of t.selfEdges)if(e.target!==e.source||e.source!==t)return!1;return!0}isConsistent(){for(let t of this.nodeMap.values())if(!this.nodeIsConsistent(t))return!1;return!0}};var ce=class extends ar{constructor(e="__graph__"){super(e);this.nodeCollection=new Gs}remove(e){this.nodeCollection.remove(e)}removeSubgraph(){let e=this.parent;e&&e.removeNode(this);for(let i of this.outGoingEdges())i.attachedAtSource?i.node.removeOutEdge(i.edge):i.node.removeInEdge(i.edge)}*outGoingEdges(){for(let e of this.outEdges){let i=e.target;this.isAncestor(i)||(yield{edge:e,node:i,attachedAtSource:!1})}for(let e of this.inEdges){let i=e.source;this.isAncestor(i)||(yield{edge:e,node:i,attachedAtSource:!0})}for(let e of this.nodesBreadthFirst){for(let i of e.outEdges){let r=i.target;r!==this&&(this.isAncestor(r)||(yield{edge:i,node:r,attachedAtSource:!1}))}for(let i of e.inEdges){let r=i.source;r!==this&&(this.isAncestor(r)||(yield{edge:i,node:r,attachedAtSource:!0}))}}}isAncestor(e){for(let i of e.getAncestors())if(i===this)return!0;return!1}*getClusteredConnectedComponents(){let e=new Set,i=new fl.Queue;for(let r of this.nodesBreadthFirst){if(e.has(r))continue;e.add(r),i.enqueue(r);let n=new Set;do{let o=i.dequeue();o.parent===this&&n.add(o);for(let s of this.reachableFrom(o))e.has(s)||(e.add(s),i.enqueue(s))}while(i.length>0);yield Array.from(n)}}*reachableFrom(e){for(let i of e.outEdges)yield i.target;for(let i of e.inEdges)yield i.source;e instanceof ce&&(yield*e.shallowNodes),e.parent!=this&&(yield e.parent)}hasSomeAttrOnIndex(e){for(let i of this.nodesBreadthFirst)if(i.getAttr(e))return!0;for(let i of this.deepEdges)if(i.getAttr(e))return!0;return!1}*graphs(){for(let e of this.nodeCollection.graphs)yield e}noEmptySubgraphs(){for(let e of this.subgraphsBreadthFirst())if(e.shallowNodeCount===0)return!1;return!0}hasSubgraphs(){for(let e of this.shallowNodes)if(e instanceof ce)return!0;return!1}*subgraphsBreadthFirst(){for(let e of this.nodesBreadthFirst)e instanceof ce&&(yield e)}isEmpty(){return this.shallowNodeCount===0}setEdge(e,i){let r=this.nodeCollection.findShallow(e);if(r==null)return;let n=this.nodeCollection.findShallow(i);if(n!=null)return new Fi(r,n)}get shallowNodes(){return this.nodeCollection.nodesShallow}get nodesBreadthFirst(){return this.nodesBreadthFirst_()}*nodesBreadthFirst_(){for(let e of this.nodeCollection.nodesShallow)yield e,e instanceof ce&&(yield*e.nodesBreadthFirst)}findNodeRecursive(e){let i=this.nodeCollection.findShallow(e);if(i)return i;for(let r of this.shallowNodes)if(r instanceof ce){let n=r.findNodeRecursive(e);if(n)return n}return null}findNode(e){return this.nodeCollection.findShallow(e)}get shallowEdges(){return this.nodeCollection.edges}get deepEdges(){return this.deepEdgesIt()}*deepEdgesIt(){for(let e of this.nodesBreadthFirst){for(let i of e.outEdges)yield i;for(let i of e.selfEdges)yield i;for(let i of e.inEdges)this.isAncestor(i.source)||(yield i)}}isConsistent(){return this.parent?this.parent.isConsistent():this.eachNodeIdIsUnique()&&this.nodeCollection.isConsistent()}nodeIsConsistent(e){return this.nodeCollection.nodeIsConsistent(e)}removeNode(e){for(let i of e.outEdges)i.target.inEdges.delete(i);for(let i of e.inEdges)i.source.outEdges.delete(i);this.nodeCollection.remove(e);for(let i of this.subgraphsBreadthFirst())i.removeNode(e)}addNode(e){return X.assert(this.findNodeRecursive(e.id)==null),e.parent=this,this.nodeCollection.addNode(e),e}get shallowNodeCount(){return this.nodeCollection.nodeShallowCount}get nodeCountDeep(){let e=this.nodeCollection.size;for(let i of this.shallowNodes)i instanceof ce&&(e+=i.nodeCountDeep);return e}get edgeCount(){return this.nodeCollection.edgeCount}liftNode(e){for(;e!=null&&e.parent!==this;)e=e.parent;return e}get deepEdgesCount(){let e=0;for(let i of this.nodesBreadthFirst)e+=i.outDegree+i.selfDegree;return e}eachNodeIdIsUnique(){let e=new Set;for(let i of this.nodesBreadthFirst){if(e.has(i.id))return!1;e.add(i.id)}return!0}*allElements(){for(let e of this.allSuccessorsWidthFirst()){yield e;for(let i of e.selfEdges)yield i;for(let i of e.outEdges)yield i;for(let i of e.inEdges)this.isAncestor(i.source)||(yield i)}yield*this.edges}*allSuccessorsWidthFirst(){for(let e of this.shallowNodes)yield e;for(let e of this.shallowNodes)e instanceof ce&&(yield*e.allSuccessorsWidthFirst())}*allSuccessorsDepthFirst(){for(let e of this.shallowNodes)e instanceof ce&&(yield*e.allSuccessorsDepthFirst()),yield e}};function*gu(l){let t=new Set,e=new fl.Queue;for(let n of l.shallowNodes){if(t.has(n))continue;let o=new Array;for(r(n,e,t);e.length>0;){let s=e.dequeue();o.push(s);for(let a of i(s))r(a,e,t)}yield o}function*i(n){for(let o of n.outEdges)yield o.target;for(let o of n.inEdges)yield o.source}function r(n,o,s){s.has(n)||(o.enqueue(n),s.add(n))}}function mu(l,t){t.parent&&t.parent.remove(t),l.addNode(t)}function Ns(l,t){let e=new Map,i=l.nodeCountDeep,r=1/i;for(let n of l.nodesBreadthFirst)e.set(n,r);for(let n=0;n<50;n++){r=(1-t)/i;let o=new Map;for(let s of l.nodesBreadthFirst)o.set(s,r);for(let s of l.nodesBreadthFirst){let a=o.get(s);for(let u of s.inEdges){let h=u.source;a+=t*(e.get(h)/h.outDegree)}o.set(s,a)}e=o}return e}function eo(l,t){return t.has(l.source)&&t.has(l.target)}var An=class extends q{constructor(){super(...arguments);this.padding=1}clone(){let e=new An(null);return this.boundaryCurve&&(e.boundaryCurve=this.boundaryCurve.clone()),e}translate(e){e.x===0&&e.y===0||this.boundaryCurve.translate(e)}toJSON(){return{boundaryCurve:this.boundaryCurve,padding:this.padding}}get node(){return this.entity}get boundaryCurve(){return this._boundaryCurve}set boundaryCurve(e){e!=null&&e.boundingBox&&(e.boundingBox.height<An.minHeight||e.boundingBox.width<An.minWidth)&&(e=be.mkCircle(An.minWidth,e.boundingBox.center)),this._boundaryCurve=e}get id(){return this.node.id}toString(){return this.id}static mkNode(e,i){let r=new An(i);return r.boundaryCurve=e,r}get center(){return this.boundaryCurve.boundingBox.center}set center(e){let i=e.sub(this.center);this.boundaryCurve.translate(i)}fitBoundaryCurveToTarget(e){if(this.boundaryCurve!=null){let i=be.isRoundedRect(this.boundaryCurve);if(i==null){let r=e.width/this.boundaryCurve.boundingBox.width,n=e.height/this.boundaryCurve.boundingBox.height;this.boundaryCurve=this.boundaryCurve.scaleFromOrigin(r,n),this.boundaryCurve.translate(e.center.sub(this.boundaryCurve.boundingBox.center))}else this.boundaryCurve=be.mkRectangleWithRoundedCorners(e.width,e.height,i.radX,i.radY,e.center)}}static getGeom(e){return e.getAttr(Le.GeomObjectIndex)}*inEdges(){for(let e of this.node.inEdges)yield q.getGeom(e)}*outEdges(){for(let e of this.node.outEdges)yield q.getGeom(e)}*selfEdges(){for(let e of this.node.selfEdges)yield q.getGeom(e)}get boundingBoxWithPadding(){let e=this.boundingBox.clone();return e.pad(this.padding),e}get boundingBox(){return this.boundaryCurve?this.boundaryCurve.boundingBox:null}set boundingBox(e){!this.boundaryCurve||(Math.abs(e.width-this.width)<1e-4&&Math.abs(e.height-this.height)<1e-4?this.center=e.center:this.fitBoundaryCurveToTarget(e))}get width(){return this.boundaryCurve.boundingBox.width}get height(){return this.boundaryCurve.boundingBox.height}transform(e){this.boundaryCurve!=null&&(this.boundaryCurve=this.boundaryCurve.transform(e))}underCollapsedGraph(){let e=this.node.parent;if(e==null)return!1;let i=q.getGeom(e);return i==null?!1:i.isCollapsed?!0:i.underCollapsedGraph()}*getAncestors(){for(let e of this.node.getAncestors())yield q.getGeom(e)}},je=An;je.minHeight=2,je.minWidth=3;var H=class{ProgressStep(){}constructor(t){this.cancelToken=t}};var Pl=class{},lr=Pl;lr.GoldenRatio=(1+Math.sqrt(5))/2,lr.GoldenRatioRemainder=2-Pl.GoldenRatio;var Mr=class extends H{constructor(e,i){super(null);this.desiredAspectRatio=1.2;this.bestPacking=null;this.cachedCosts=new Map;this.rectangles=e,this.desiredAspectRatio=i}get PackedWidth(){return this.bestPacking!=null?this.bestPacking.PackedWidth:0}get PackedHeight(){return this.bestPacking!=null?this.bestPacking.PackedHeight:0}Pack(e,i,r){let n=Mr.GetGoldenSectionStep(e,i),o=Math.max(r/10,(i-e)/Mr.MaxSteps);i+=o,this.bestPackingCost=Number.MAX_VALUE,this.rectangles.length===1?this.PackLimit(e):this.rectangles.length===2?(this.PackLimit(e),this.PackLimit(i)):this.rectangles.length>2&&Mr.GoldenSectionSearch(a=>this.PackLimit(a),e,n,i,o);let s=this.bestPacking.getRects();for(let a=0;a<this.rectangles.length;a++)this.rectangles[a]=s[a]}PackLimit(e){let i=this.cachedCosts.get(e);if(i==null){let r=this.createPacking(this.rectangles,e);r.run(),this.cachedCosts.set(e,i=Math.abs(r.PackedAspectRatio-this.desiredAspectRatio)),i<this.bestPackingCost&&(this.bestPackingCost=i,this.bestPacking=r)}return i}static GoldenSectionSearch(e,i,r,n,o){if(Math.abs(i-n)<o)return e(i)<e(n)?i:n;let s=Mr.GetGoldenSectionStep(r,n),a=e(r),u=e(s),h=()=>Mr.GoldenSectionSearch(e,s,r,i,o),d=()=>Mr.GoldenSectionSearch(e,r,s,n,o);if(u<a)return d();if(u>a)return h();let g=d(),f=h();return e(f)<e(g)?f:g}static GetGoldenSectionStep(e,i){return e<i?e+lr.GoldenRatioRemainder*(i-e):e-lr.GoldenRatioRemainder*(e-i)}},Fo=Mr;Fo.MaxSteps=1e3;var pu=J(ai(),1);var Bs=class extends H{get PackedWidth(){return this.packedWidth}set PackedWidth(e){this.packedWidth=e}get PackedHeight(){return this.packedHeight}set PackedHeight(e){this.packedHeight=e}get PackedAspectRatio(){return this.PackedWidth/this.PackedHeight}getRects(){let e=[];for(let[i,r]of this.rectsToCenters)i.center=r,e.push(i);return e}};var ur=class extends Bs{constructor(e,i,r=!1){super(null);this.rectsToCenters=new Map,this.rectanglesByDescendingHeight=r?e:ur.SortRectangles(e),this.wrapWidth=i}static SortRectangles(e){return e.sort((i,r)=>r.height-i.height),e}run(){this.Pack()}Pack(){this.PackedWidth=0,this.PackedHeight=0;let e=new pu.Stack,i=!1,r=0,n=0,o=0,s=this.rectanglesByDescendingHeight;for(let a=0;i||a<s.length;){let u=s[a],h=e.length>0?e.top:null;if(h==null||h.right+u.width<=this.wrapWidth&&r+u.height<=h.top){let g=new c(h?h.right:0,r).add(new c(u.width/2,u.height/2));u.center=g,this.rectsToCenters.set(u,g),n=Math.max(n,u.right),o=Math.max(o,u.top),e.push(u),i=!1}else r=h.top,e.pop(),i=!0;i||a++}this.PackedWidth=n,this.PackedHeight=o}};var Dr=class extends Fo{constructor(t,e){super(ur.SortRectangles(t),e),this.createPacking=(i,r)=>new ur(i,r,!0)}run(){let t=Number.MAX_VALUE,e=0,i=0;for(let r of this.rectangles){let n=r.width;i+=n,t=Math.min(t,n),e=Math.max(e,n)}this.Pack(e,i,t)}};function yi(l){return new ki(ge(l.map(([t,e])=>Se(e,t))))}function cc(l,t){l.UserData=t.UserData,l.Left=t.Left,l.Right=t.Right,l.Count--,l.irect=t.irect}function fu(l){for(let t=l.Parent;t!=null;t=t.Parent)t.Count--,t.irect=t.Left.irect.add_rect(t.Right.irect)}function dc(l,t){let e=new Array;for(let r of l.GetAllLeafNodes())r!==t&&e.push(r);let i=ge(e);l.Count=i.Count,l.Left=i.Left,l.Right=i.Right,l.irect=i.Left.irect.add_rect(i.Right.irect)}function gc(l){for(let t=l.Parent;t!=null;t=t.Parent)if(!Pu(t))return t;return null}function Pu(l){return 2*l.Left.Count>=l.Right.Count&&2*l.Right.Count>=l.Left.Count}function bl(l,t,e,i){return l.irect.intersects_rect(t)?l.IsLeaf?i(l.UserData)?--e.bound!==0:!0:bl(l.Left,t,e,i)&&bl(l.Right,t,e,i):!0}var ki=class{clear(){this.RootNode=null}NumberOfIntersectedIsLessThanBound(t,e,i){return bl(this._rootNode,t,{bound:e},i)}get RootNode(){return this._rootNode}set RootNode(t){this._rootNode=t}constructor(t){this._rootNode=t}*GetAllLeaves(){if(this._rootNode!=null&&this.Count>0)for(let t of this._rootNode.GetAllLeaves())yield t}get Count(){return this._rootNode==null?0:this._rootNode.Count}Add(t,e){this.AddNode(Se(e,t))}AddNode(t){this._rootNode==null?this._rootNode=t:this.Count<=2?this._rootNode=ge(Array.from(this._rootNode.GetAllLeafNodes()).concat([t])):this.AddNodeToTreeRecursive(t,this._rootNode)}Rebuild(){this._rootNode=ge(Array.from(this._rootNode.GetAllLeafNodes()))}AddNodeToTreeRecursive(t,e){if(e.IsLeaf)e.Left=Se(e.UserData,e.irect),e.Right=t,e.Count=2;else{e.Count++;let i,r;if(2*e.Left.Count<e.Right.Count)this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=e.Left.irect.add_rect(t.irect);else if(2*e.Right.Count<e.Left.Count)this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=e.Right.irect.add_rect(t.irect);else{i=e.Left.irect.add_rect(t.irect);let n=i.area-e.Left.irect.area;r=e.Right.irect.add_rect(t.irect);let o=r.area-e.Right.irect.area;n<o?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):n>o?(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=r):i.area<r.area?(this.AddNodeToTreeRecursive(t,e.Left),e.Left.irect=i):(this.AddNodeToTreeRecursive(t,e.Right),e.Right.irect=r)}}e.irect=e.Left.irect.add_rect(e.Right.irect)}GetAllIntersecting(t){return this._rootNode==null||this.Count===0?[]:Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(t))}OneIntersecting(t){if(this._rootNode==null||this.Count===0)return;let e=this._rootNode.FirstIntersectedNode(t);if(e!=null)return{intersectedLeaf:e.UserData}}GetAllLeavesIntersectingRectangle(t){return this._rootNode==null||this.Count===0?[]:this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t)}IsIntersecting(t){if(this._rootNode==null||this.Count===0)return!1;for(let e of this._rootNode.GetNodeItemsIntersectingRectangle(t))return!0;return!1}Contains(t,e){if(this._rootNode==null)return!1;for(let i of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))if(i.UserData===e)return!0;return!1}Remove(t,e){if(this._rootNode==null)return;let i;for(let r of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))r.UserData===e&&(i=r);if(i!=null)return this.RootNode.Count===1?this.RootNode=null:this.RemoveLeaf(i),i.UserData}RemoveLeaf(t){let e=gc(t);if(e!=null)dc(e,t),fu(e);else{let i=t.Parent;i==null?this._rootNode=new Br:(cc(i,t.IsLeftChild?i.Right:i.Left),fu(i))}}UnbalancedNode(t){for(let e=t.Parent;e!=null;e=e.Parent)if(!Pu(e))return e;return null}};var Vs=class extends I{constructor(e){super(e);this.radX=e.radX,this.radY=e.radY,this.roundedRect_=be.mkRectangleWithRoundedCorners(this.width,this.height,e.radX,e.radY,this.center)}onUpdated(){this.isEmpty||(this.roundedRect_=be.mkRectangleWithRoundedCorners(this.width,this.height,this.radX,this.radY,this.center))}isOk(){return this.isEmpty()?!0:this.roundedRect_.boundingBox.equalEps(this)}setRect(e){this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.isEmpty()||(this.roundedRect_=be.mkRectangleWithRoundedCorners(e.width,e.height,this.radX,this.radY,this.center))}};function to(l,t){let e=t.map(n=>[n,n.boundingBox]),i=e.map(n=>n[1]),r=new Dr(i,1.5);r.run();for(let[n,o]of e){let s=o.leftBottom.sub(n.boundingBox.leftBottom);n.translate(s)}l.boundingBox=new I({left:0,bottom:0,right:r.PackedWidth,top:r.PackedHeight})}var de=class extends je{constructor(e){super(e);this.margins={left:10,top:10,bottom:10,right:10};this.radX=10;this.radY=10;this.rrect=new Vs({left:0,right:-1,top:20,bottom:0,radX:this.radX,radY:this.radY})}isAncestor(e){return this.graph.isAncestor(e.node)}deepTranslate(e){for(let i of this.nodesBreadthFirst){i instanceof de?i.boundingBox=i.boundingBox.translate(e):i.translate(e);for(let r of i.selfEdges())r.translate(e);for(let r of i.outEdges())this.graph.isAncestor(r.target.node)&&r.translate(e)}this.boundingBox=this.boundingBox.translate(e)}clone(){let e=new de(null);return e.boundingBox=this.boundingBox.clone(),e.layoutSettings=this.layoutSettings,e.margins=this.margins,e.radX=this.radX,e.radY=this.radY,e}calculateBoundsFromChildren(){let e=I.mkEmpty();for(let i of this.shallowNodes)e.addRecSelf(i.boundingBoxWithPadding);return e.padEverywhere(this.margins),e}*allSuccessorsWidthFirst(){for(let e of this.graph.allSuccessorsWidthFirst())yield je.getGeom(e)}static getGeom(e){return q.getGeom(e)}edgeCurveOrArrowheadsIntersectRect(e,i){for(let o of e.sourceArrowheadPoints(25))if(i.contains(o))return!0;for(let o of e.targetArrowheadPoints(25))if(i.contains(o))return!0;let r=e.curve,n=i.perimeter();return p.intersectionOne(r,n,!1)!=null||p.PointRelativeToCurveLocation(r.start,n)===2}isEmpty(){return this.graph.isEmpty()}setSettingsRecursively(e){this.layoutSettings=e;for(let i of this.nodesBreadthFirst){let r=i;r.layoutSettings=e}}get layoutSettings(){return this._layoutSettings}set layoutSettings(e){this._layoutSettings=e}get labelSize(){return this._labelSize}set labelSize(e){this._labelSize=e}get boundingBox(){return this.rrect?this.rrect.clone():null}set boundingBox(e){e?this.rrect.setRect(e):this.rrect.roundedRect_=null}transform(e){if(!e.isIdentity()){for(let i of this.shallowNodes)i.transform(e);for(let i of this.shallowEdges)i.transform(e),i.label&&i.label.transform(e);this.boundingBox=this.rrect==null||this.rrect.isEmpty()?this.pumpTheBoxToTheGraphWithMargins():this.boundingBox.transform(e)}}translate(e){e.x===0&&e.y===0||this.deepTranslate(e)}get nodesBreadthFirst(){return this.nodesBreadthFirstIter()}*nodesBreadthFirstIter(){for(let e of this.graph.nodesBreadthFirst)yield q.getGeom(e)}setEdge(e,i){let r=this.graph.setEdge(e,i);return new Pe(r)}getPumpedGraphWithMarginsBox(){let e={b:I.mkEmpty()};return Ms(this,e),e.b.padEverywhere(this.margins),e.b}pumpTheBoxToTheGraphWithMargins(){return this.boundingBox=this.getPumpedGraphWithMarginsBox()}get center(){return this.boundingBox||this.boundingBox.isEmpty?this.boundingBox.center:new c(0,0)}set center(e){let i=e.sub(this.center),r=new Ce(1,0,i.x,0,1,i.y);this.transform(r)}get left(){return this.boundingBox.left}get right(){return this.boundingBox.right}get top(){return this.boundingBox.top}get bottom(){return this.boundingBox.bottom}CheckClusterConsistency(){throw new Error("Method not implemented.")}get edgeCount(){return this.graph.edgeCount}get boundaryCurve(){return this.rrect.roundedRect_}set boundaryCurve(e){throw new Error}get shallowNodes(){return this.shallowNodes_()}*shallowNodes_(){for(let e of this.graph.shallowNodes)yield q.getGeom(e)}get deepEdges(){return this.deepEdgesIt()}*deepEdgesIt(){for(let e of this.graph.deepEdges)yield q.getGeom(e)}get shallowEdges(){return this.shallowEdgesIt()}*shallowEdgesIt(){for(let e of this.graph.shallowEdges)yield q.getGeom(e)}static mk(e,i=new Ke(0,0)){let r=new de(new ce(e));return r.labelSize=i,r}get Clusters(){return this.subgraphs()}*subgraphs(){for(let e of this.graph.subgraphsBreadthFirst())yield q.getGeom(e)}static mkWithGraphAndLabel(e,i){let r=new de(e);return r.labelSize=i,r}get deepNodeCount(){let e=0;for(let i of this.graph.nodesBreadthFirst)e++;return e}get subgraphsDepthFirst(){return this.getSubgraphsDepthFirst()}*getSubgraphsDepthFirst(){for(let e of this.graph.allSuccessorsDepthFirst())e instanceof ce&&(yield de.getGeom(e))}get uniformMargins(){return Math.max(this.margins.left,this.margins.right,this.margins.right,this.margins.bottom)}set uniformMargins(e){this.margins.left=this.margins.right=this.margins.right=this.margins.bottom=e}get height(){return this.boundingBox.height}get width(){return this.boundingBox.width}get shallowNodeCount(){return this.graph.shallowNodeCount}get graph(){return this.entity}liftNode(e){let i=this.graph.liftNode(e.node);return i?q.getGeom(i):null}findNode(e){let i=this.graph.findNode(e);return i?q.getGeom(i):null}addNode(e){return this.graph.addNode(e.node),e}addLabelToGraphBB(e){this.labelSize&&(e.top+=this.labelSize.height+2,e.width<this.labelSize.width&&(e.width=this.labelSize.width))}};function Ms(l,t){for(let i of l.shallowEdges){if(!e(i))continue;let r=i.curve.boundingBox;if(t.b.addRecSelf(r),i.edge.label!=null){let n=q.getGeom(i.edge.label);n&&t.b.addRecSelf(n.boundingBox)}}for(let i of l.shallowNodes)"shallowEdges"in i&&Ms(i,t),!(i.underCollapsedGraph()||!i.boundingBox)&&t.b.addRecSelf(i.boundingBox);l instanceof de&&l.addLabelToGraphBB(t.b);function e(i){if(i==null||i.curve==null||i.underCollapsedGraph())return!1;if(l instanceof de){let r=l.entity;return r.isAncestor(i.source.entity)&&r.isAncestor(i.target.entity)}else return!0}}function*bu(l,t,e=!0){let i=l.GetAllIntersecting(t);if(e)for(let r of i)r instanceof ar&&(yield r);else for(let r of i)(r instanceof ar||r instanceof Fi)&&(yield r)}function Su(l){let t=Array.from(l.nodesBreadthFirst).concat(Array.from(l.deepEdges)).map(e=>[q.getGeom(e).boundingBox,e]);return yi(t)}function*yu(l,t,e){if(!l)return;let i=I.mkSizeCenter(new Ke(t*2),e);for(let n of l.RootNode.AllHitItems(i,null))"edge"in n?r(e,n.pp._first,n.pp._second)<t&&(yield q.getGeom(n.edge)):yield q.getGeom(n);function r(n,o,s){let a=s.sub(o),u=a.length;if(u<1/10)return n.sub(c.middle(o,s)).length;let h=a.rotate90Cw();return Math.abs(n.sub(o).dot(h))/u}}function Cu(l,t){if(l==null)return null;let e=Array.from(l.nodesBreadthFirst).map(n=>[je.getGeom(n).boundingBox,n]),i=[];for(let n of l.deepEdges){let o=n.getAttr(Le.GeomObjectIndex);if(!o||(o.label&&i.push([o.label.boundingBox,n.label]),!o.curve))continue;let s=Vo(o.curve,t/2);o.sourceArrowhead&&i.push([I.mkPP(o.sourceArrowhead.tipPosition,o.curve.start),{edge:n,pp:new he(o.sourceArrowhead.tipPosition,o.curve.start)}]);for(let a=0;a<s.length-1;a++)i.push([I.mkPP(s[a],s[a+1]),{edge:n,pp:new he(s[a],s[a+1])}]);o.targetArrowhead&&i.push([I.mkPP(o.curve.end,o.targetArrowhead.tipPosition),{edge:n,pp:new he(o.curve.end,o.targetArrowhead.tipPosition)}])}let r=e.concat(i);return yi(r)}var F=class{constructor(t,e){this.x=t,this.y=e}get source(){return this.x}get target(){return this.y}isDiagonal(){return this.x===this.y}};var ct=class{isEmpty(){if(this.arrayOfMaps.length===0)return!0;for(let t of this.arrayOfMaps)if(t.size>0)return!1;return!0}set(t,e,i){this.arrayOfMaps[t].set(e,i)}setPair(t,e){this.set(t.x,t.y,e)}delete(t,e){t<0||t>=this.arrayOfMaps.length||this.arrayOfMaps[t].delete(e)}has(t,e){return t<0||t>=this.arrayOfMaps.length?!1:this.arrayOfMaps[t].has(e)}get(t,e){return t<0||t>=this.arrayOfMaps.length?null:this.arrayOfMaps[t].get(e)}getI(t){return this.get(t.x,t.y)}constructor(t){this.arrayOfMaps=new Array(t);for(let e=0;e<t;e++)this.arrayOfMaps[e]=new Map}*keys(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield new F(t,i[0])}}*keyValues(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield[new F(t,i[0]),i[1]]}}*values(){for(let t=0;t<this.arrayOfMaps.length;t++){let e=this.arrayOfMaps[t];for(let i of e)yield i[1]}}};var ve=class{constructor(){this.size_=0;this.mapOfMaps=new Map}deleteP(t){return this.delete(t.x,t.y)}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}setxy(t,e,i){let r=this.mapOfMaps.get(t);r==null&&this.mapOfMaps.set(t,r=new Map),r.has(e)||this.size_++,r.set(e,i)}set(t,e){this.setxy(t.x,t.y,e)}delete(t,e){let i=this.mapOfMaps.get(t);return i!=null?(i.delete(e)&&this.size_--,!0):!1}hasxy(t,e){let i=this.mapOfMaps.get(t);return i!=null&&i.has(e)}has(t){return this.hasxy(t.x,t.y)}getxy(t,e){let i=this.mapOfMaps.get(t);if(i!=null)return i.get(e)}get(t){return this.getxy(t.x,t.y)}*keys(){for(let t of this.mapOfMaps)for(let e of t[1])yield new c(t[0],e[0])}*[Symbol.iterator](){for(let t of this.mapOfMaps)for(let e of t[1])yield[new c(t[0],e[0]),e[1]]}*values(){for(let t of this.mapOfMaps)for(let e of t[1])yield e[1]}};var Gt=class{constructor(){this.size_=0;this.mapOfMaps=new ve}clear(){this.mapOfMaps.clear(),this.size_=0}get size(){return this.size_}set(t,e){let i=t._first,r=t._second,n=this.mapOfMaps.get(i);n==null&&this.mapOfMaps.set(i,n=new ve),n.has(r)||this.size_++,n.set(r,e)}delete(t){let e=t._first,i=t._second,r=this.mapOfMaps.get(e);r!=null&&r.deleteP(i)&&this.size_--}has(t){let e=this.mapOfMaps.get(t._first);return e!=null&&e.has(t._second)}getPP(t,e){return this.get(new he(t,e))}get(t){let e=this.mapOfMaps.get(t._first);if(e!=null)return e.get(t._second)}*keys(){for(let t of this.mapOfMaps)for(let e of t[1])yield new he(t[0],e[0])}*[Symbol.iterator](){for(let[t,e]of this.mapOfMaps)for(let[i,r]of e)yield[new he(t,i),r]}*values(){for(let t of this.mapOfMaps)for(let e of t[1])yield e[1]}};var hr=class{constructor(t){this._curveClips=[];this.arrowheads=[],this.nodes=[],this.labels=[],this.rect=t,this.bundleTable=new Gt}get curveClips(){return this._curveClips.length>0?this._curveClips:Array.from(this.getBundles()).map(t=>t.edges.map(e=>({curve:t.clip,edge:e}))).flat()}set curveClips(t){this._curveClips=t}get cachedClipsLength(){return this.bundleTable?this.bundleTable.size:0}addToBundlesOrFetchFromBundles(t,e,i){X.assert(!(i instanceof p),"CurveClip.curve is not a Curve");let r=new he(i.value(t),i.value(e)),n=this.bundleTable.get(r);if(n)return n.edges;let o=[];return this.bundleTable.set(r,{clip:i.trim(t,e),edges:o}),o}findCreateBundle(t){let e=new he(t.start,t.end),i=this.bundleTable.get(e);if(i)return i;let r={clip:t,edges:new Array};return this.bundleTable.set(e,r),r}addCurveClip(t){X.assert(!(t.curve instanceof p),"CurveClip.curve should not be a Curve!"),this.findCreateBundle(t.curve).edges.push(t.edge)}*getBundles(){yield*this.bundleTable.values()}get curveBundlesLength(){return this.bundleTable.size}isEmpty(){return this.bundleTable.size==0&&this.arrowheads.length==0&&this.nodes.length==0&&this.labels.length==0}initCurveClips(){this.bundleTable?this.bundleTable.clear():this.bundleTable=new Gt}clear(){this.arrowheads=[],this.nodes=[],this.labels=[],this.bundleTable?this.bundleTable.clear():this.bundleTable=new Gt}get entityCount(){return this.bundleTable.size+this.arrowheads.length+this.labels.length+this.nodes.length}addElement(t){if(t instanceof je)this.nodes.push(t);else if(t instanceof Ni)this.labels.push(t);else if("curve"in t)if(X.assert(this.rect.containsRect(t.curve.boundingBox),"CurveClip.curve is not in tile"),t.curve instanceof p)for(let e of t.curve.segs)this.addCurveClip({edge:t.edge,curve:e});else this.addCurveClip(t);else this.arrowheads.push(t)}};var Sl=J(Mi(),1),Ci=class{constructor(t=null){this.parents=new Set;this.children=new Set;this.ports=new Set;this.BoundaryCurve=t}get Parents(){return Array.from(this.parents.values())}get Children(){return Array.from(this.children.values())}get BoundaryCurve(){return this.boundaryCurve}set BoundaryCurve(t){this.boundaryCurve=t}get BoundingBox(){return this.BoundaryCurve.boundingBox}get Ports(){return this.ports}static mkShape(){return new Ci(null)}get IsGroup(){return this.children.size>0}*Descendants(){let t=new Sl.Queue;for(let e of this.Children)t.enqueue(e);for(;t.length>0;){let e=t.dequeue();yield e;for(let i of e.Children)t.enqueue(i)}}*Ancestors(){let t=new Sl.Queue;for(let e of this.Parents)t.enqueue(e);for(;t.length>0;){let e=t.dequeue();yield e;for(let i of e.Parents)t.enqueue(i)}}AddParent(t){this.parents.add(t),t.children.add(this)}AddChild(t){t.parents.add(this),this.children.add(t)}RemoveChild(t){this.children.delete(t),t.parents.delete(this)}RemoveParent(t){this.parents.delete(t),t.children.delete(this)}ToString(){return this.UserData?this.UserData.toString():"null"}};var Hi=class{};var Ue=class extends Hi{constructor(e,i){super();this.curve=this.curve,this.location=i.clone()}get Location(){return this.location}set Location(e){this.location=e}Translate(e){this.location=this.location.add(e)}get Curve(){return this.curve}set Curve(e){this.curve=e}};var $e=class extends Ue{constructor(e,i,r){super(null,i().add(r));this.LocationOffset=r,this.CurveDelegate=e,this.CenterDelegate=i}static mk(e,i){return new $e(e,i,new c(0,0))}get CenterDelegate(){return this.centerDelegate}set CenterDelegate(e){this.centerDelegate=e}get CurveDelegate(){return this.curveDelegate}set CurveDelegate(e){this.curveDelegate=e}get LocationOffset(){return this.locationOffset}set LocationOffset(e){this.locationOffset=e}get Location(){return this.CenterDelegate().add(this.LocationOffset)}get Curve(){return this.CurveDelegate()}};var io=class{constructor(t,e,i,r,n){this.color=t,e!==void 0&&(this.item=e),i!==void 0&&(this.parent=i),r!==void 0&&(this.left=r),n!==void 0&&(this.right=n)}toString(){return this.item.toString()}};var Ee=class{[Symbol.iterator](){return this.allNodes()}constructor(t){this.comparer=t,this.count=0,this.root=this.nil=new io(1)}clear(){this.root=this.nil=new io(1)}toNull(t){return t!==this.nil?t:null}isEmpty(){return this.root===this.nil}getComparer(){return this.comparer}getRoot(){return this.root}find(t,e=this.root){let i;for(;e!==this.nil&&(i=this.comparer(t,e.item))!==0;)e=i<0?e.left:e.right;return this.toNull(e)}findFirst(t,e=this.root){if(e===this.nil)return null;let i=null;for(;e!==this.nil;)e=t(e.item)?(i=e).left:e.right;return i}findLast(t,e=this.root){if(e===this.nil)return null;let i=null;for(;e!==this.nil;)e=t(e.item)?(i=e).right:e.left;return i}treeMinimum(t=this.root){for(;t.left!==this.nil;)t=t.left;return this.toNull(t)}treeMaximum(t=this.root){for(;t.right!==this.nil;)t=t.right;return this.toNull(t)}next(t){if(t.right!==this.nil)return this.treeMinimum(t.right);let e=t.parent;for(;e!==this.nil&&t===e.right;)t=e,e=e.parent;return this.toNull(e)}previous(t){if(t.left!==this.nil)return this.treeMaximum(t.left);let e=t.parent;for(;e!==this.nil&&t===e.left;)t=e,e=e.parent;return this.toNull(e)}leftRotate(t){let e=t.right;t.right=e.left,e.left!==this.nil&&(e.left.parent=t),e.parent=t.parent,t.parent===this.nil?this.root=e:t===t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}rightRotate(t){let e=t.left;t.left=e.right,e.right!==this.nil&&(e.right.parent=t),e.parent=t.parent,t.parent===this.nil?this.root=e:t===t.parent.right?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}deleteFixup(t){for(;t!==this.root&&t.color===1;)if(t===t.parent.left){let e=t.parent.right;e.color===0&&(e.color=1,t.parent.color=0,this.leftRotate(t.parent),e=t.parent.right),e.left.color===1&&e.right.color===1?(e.color=0,t=t.parent):(e.right.color===1&&(e.left.color=1,e.color=0,this.rightRotate(e),e=t.parent.right),e.color=t.parent.color,t.parent.color=1,e.right.color=1,this.leftRotate(t.parent),t=this.root)}else{let e=t.parent.left;e.color===0&&(e.color=1,t.parent.color=0,this.rightRotate(t.parent),e=t.parent.left),e.right.color===1&&e.left.color===1?(e.color=0,t=t.parent):(e.left.color===1&&(e.right.color=1,e.color=0,this.leftRotate(e),e=t.parent.left),e.color=t.parent.color,t.parent.color=1,e.left.color=1,this.rightRotate(t.parent),t=this.root)}t.color=1}deleteSubTree(t){let e;if(t.left===this.nil||t.right===this.nil)e=t;else for(e=t.right;e.left!==this.nil;)e=e.left;let i=e.left!==this.nil?e.left:e.right;return i.parent=e.parent,e.parent===this.nil?this.root=i:e===e.parent.left?e.parent.left=i:e.parent.right=i,e!==t&&(t.item=e.item),e.color===1&&this.deleteFixup(i),this.toNull(t)}deleteNodeInternal(t){this.count--,this.deleteSubTree(t)}remove(t){let e=this.find(t);return e!=null?(this.count--,this.deleteSubTree(e)):null}insert(t){let e=this.treeInsert(t);return this.insertPrivate(e),this.toNull(e)}treeInsert(t){let e=this.nil,i=this.root,r=0;for(;i!==this.nil;)e=i,r=this.comparer(t,i.item),i=r<0?i.left:i.right;let n=new io(1,t,e,this.nil,this.nil);return e===this.nil?this.root=n:r<0?e.left=n:e.right=n,this.toNull(n)}insertPrivate(t){for(this.count++,t.color=0;t!==this.root&&t.parent.color===0;)if(t.parent===t.parent.parent.left){let e=t.parent.parent.right;e.color===0?(t.parent.color=1,e.color=1,t.parent.parent.color=0,t=t.parent.parent):(t===t.parent.right&&(t=t.parent,this.leftRotate(t)),t.parent.color=1,t.parent.parent.color=0,this.rightRotate(t.parent.parent))}else{let e=t.parent.parent.left;e.color===0?(t.parent.color=1,e.color=1,t.parent.parent.color=0,t=t.parent.parent):(t===t.parent.left&&(t=t.parent,this.rightRotate(t)),t.parent.color=1,t.parent.parent.color=0,this.leftRotate(t.parent.parent))}this.root.color=1}*allNodes(){if(this.isEmpty())return;let t=this.treeMinimum();for(;t!=null;)yield t.item,t=this.next(t)}toString(){let t="{",e=0;for(let i of this.allNodes())t+=i.toString(),e!==this.count-1&&(t+=`
`),e++;return t+"}"}};var Fr=class{constructor(t){this.heapSize=0;this.A=[],this.compare=t}*[Symbol.iterator](){for(let t=1;t<=this.heapSize;t++)yield this.A[t]}Enqueue(t){let e=this.heapSize+1;this.A[e]=t,this.heapSize++;let i=e>>1,r,n;for(;e>1&&this.Less(r=this.A[e],n=this.A[i]);)this.A[i]=r,this.A[e]=n,e=i,i=e>>1}Dequeue(){if(this.heapSize<1)throw new Error;let t=this.A[1],e=this.A[this.heapSize];return this.heapSize--,this.ChangeMinimum(e),t}ChangeMinimum(t){this.A[1]=t;let e=1,i=2,r=!1;for(;i<this.heapSize&&!r;){r=!0;let n=this.A[i],o=this.A[i+1];this.compare(n,o)<0?this.compare(n,t)<0&&(this.A[e]=n,this.A[i]=t,r=!1,e=i,i=e<<1):this.compare(o,t)<0&&(this.A[e]=o,this.A[i+1]=t,r=!1,e=i+1,i=e<<1)}if(i===this.heapSize){let n=this.A[i];this.compare(n,t)<0&&(this.A[e]=n,this.A[i]=t)}}get Count(){return this.heapSize}Less(t,e){return this.compare(t,e)<0}GetMinimum(){return this.A[1]}};var Fe=class{};var Wt=class extends Fe{constructor(e){super();this.Vertex=e}get Site(){return this.Vertex.point}get Polyline(){return this.Vertex.polyline}};var Ds=class extends Wt{constructor(t){super(t)}};var Fs=class{constructor(t){this.lineSweeper=t}Compare(t,e){switch(c.getTriangleOrientation(e.Start,e.End,this.x)){case 2:return 0;case 0:return 1;default:return-1}}SetOperand(t){this.x=this.IntersectionOfSideAndSweepLine(t)}IntersectionOfSideAndSweepLine(t){let e=t.Direction.dot(this.lineSweeper.SweepDirection),i=(this.lineSweeper.Z-t.Start.dot(this.lineSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}};var ks=class extends Fe{constructor(e){super();this.site=e}get Site(){return this.site}};var ro=class{constructor(t,e){this.PreviousZ=Number.NEGATIVE_INFINITY;this.z=Number.NEGATIVE_INFINITY;this.Obstacles=t!=null?t:[],this.SweepDirection=e,this.DirectionPerp=e.rotate(-Math.PI/2),this.EventQueue=new Fr((i,r)=>this.Compare(i,r)),this.ObstacleSideComparer=new Fs(this),this.LeftObstacleSideTree=new Ee((i,r)=>this.ObstacleSideComparer.Compare(i,r)),this.RightObstacleSideTree=new Ee((i,r)=>this.ObstacleSideComparer.Compare(i,r))}get EventQueue(){return this.eventQueue}set EventQueue(t){this.eventQueue=t}get DirectionPerp(){return this.directionPerp}set DirectionPerp(t){this.directionPerp=t}get Z(){return this.z}set Z(t){t>this.z+m.tolerance&&(this.PreviousZ=this.z),this.z=t}GetZS(t){return this.SweepDirection.dot(t.Site)}GetZP(t){return this.SweepDirection.dot(t)}SegmentIsNotHorizontal(t,e){return Math.abs(t.sub(e).dot(this.SweepDirection))>m.distanceEpsilon}RemoveLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.remove(t)}RemoveRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.remove(t)}InsertLeftSide(t){this.ObstacleSideComparer.SetOperand(t),this.LeftObstacleSideTree.insert(t)}InsertRightSide(t){this.ObstacleSideComparer.SetOperand(t),this.RightObstacleSideTree.insert(t)}FindFirstObstacleSideToTheLeftOfPoint(t){let e=this.RightObstacleSideTree.findLast(i=>c.pointToTheRightOfLineOrOnLine(t,i.Start,i.End));return e==null?null:e.item}FindFirstObstacleSideToToTheRightOfPoint(t){let e=this.LeftObstacleSideTree.findFirst(i=>!c.pointToTheRightOfLineOrOnLine(t,i.Start,i.End));return e==null?null:e.item}EnqueueEvent(t){this.eventQueue.Enqueue(t)}InitQueueOfEvents(){for(let t of this.Obstacles)this.EnqueueLowestPointsOnObstacles(t);if(this.Ports!=null)for(let t of this.Ports.values())this.EnqueueEvent(new ks(t))}EnqueueLowestPointsOnObstacles(t){let e=this.GetLowestPoint(t);this.EnqueueEvent(new Ds(e))}GetLowestPoint(t){let e=t.startPoint,i=t.startPoint.next;for(;i!=null;i=i.next)this.Less(i.point,e.point)&&(e=i);return e}Compare(t,e){let i=t.Site,r=e.Site;return this.ComparePoints(i,r)}Less(t,e){return this.ComparePoints(t,e)<0}ComparePoints(t,e){let i=this.SweepDirection.dot(t),r=this.SweepDirection.dot(e);return i<r?-1:i>r?1:(i=this.directionPerp.dot(t),r=this.directionPerp.dot(e),i<r?-1:i>r?1:0)}};var Eu=J(Qe(),1),oo=class{constructor(t,e,i=1){this.LengthMultiplier=1;this.Source=t,this.Target=e,this.Weight=i}static closeuv(t,e){return c.closeDistEps(t.point,oo.u,.1)&&c.closeDistEps(e.point,oo.v,.1)}get SourcePoint(){return this.Source.point}get TargetPoint(){return this.Target.point}get Length(){return this.SourcePoint.sub(this.TargetPoint).length*this.LengthMultiplier}toString(){return Eu.String.Format("{0}->{1} ({2})",this.Source,this.Target,this.Weight)}ReversedClone(){return new oo(this.Target,this.Source)}Clone(){return new oo(this.Source,this.Target)}},Nt=oo;Nt.u=new c(545.833,840.458),Nt.v=new c(606.1667261889578,786.2917261889578),Nt.DefaultWeight=1;var Xe=class extends Nt{static constructorVV(t,e){return new Xe(t,e,0)}constructor(t,e,i=0){super(t,e,i)}};var Wi=class{constructor(t){this._inEdges=new Array;this._outEdges=new Ee((e,i)=>this.Compare(e,i)),this.point=t}get InEdges(){return this._inEdges}get OutEdges(){return this._outEdges}get Degree(){return this._inEdges.length+this.OutEdges.count}InEdgesLength(){return this._inEdges.length}addInEdge(t){this._inEdges.push(t)}get IsTerminal(){return this._isTerminal}set IsTerminal(t){this._isTerminal=t}get IsShortestPathTerminal(){return this._isShortestPathTerminal}set IsShortestPathTerminal(t){this._isShortestPathTerminal=t}toString(){return this.point.toString()}RemoveOutEdge(t){this.OutEdges.remove(t)}RemoveInEdge(t){let e=this._inEdges.indexOf(t);if(e===-1)return;let i=this._inEdges.length-1;e!==i&&(this._inEdges[e]=this._inEdges[i]),this._inEdges.pop()}static FindFirst(t,e){return Wi.FindFirst_t(t.root,t,e)}static FindFirst_t(t,e,i){if(t===e.nil)return null;let r=null;for(;t!==e.nil;)t=t.item.TargetPoint.compareTo(i)>=0?(r=t).left:t.right;return r}get(t){let e=Wi.FindFirst(this.OutEdges,t.point);return e!=null&&e.item.Target===t||(e=Wi.FindFirst(t.OutEdges,this.point),e!=null&&e.item.Target===this)?e.item:null}Compare(t,e){return t.TargetPoint.compareTo(e.TargetPoint)}ClearEdges(){this._outEdges.clear(),this._inEdges=[]}};var se=class{constructor(){this.activeVertices=new Set;this.VertexFactory=t=>new Wi(t);this.pointToVertexMap=new ve}*edges_(){for(let t of this.pointToVertexMap.values())for(let e of t.OutEdges)yield e}get Edges(){return this.edges_()}ClearPrevEdgesTable(){for(let t of this.activeVertices)t.prevEdge=null;this.activeVertices.clear()}ShrinkLengthOfPrevEdge(t,e){t.prevEdge.LengthMultiplier=e}PreviosVertex(t){let e=t.prevEdge;return e?e.Source===t?e.Target:e.Source:null}SetPreviousEdge(t,e){this.activeVertices.add(t),t.prevEdge=e}AddHole(t){let e=t.startPoint;for(;e!==t.endPoint;)this.AddEdgePlPl(e,e.next),e=e.next;this.AddEdgePlPl(t.endPoint,t.startPoint)}static*OrientHolesClockwise(t){for(let e of t)for(let i=e.startPoint;;i=i.next){let r=c.getTriangleOrientation(i.point,i.next.point,i.next.next.point);if(r!==2){yield r===0?e:e.reverse();break}}}AddVertexP(t){let e=this.pointToVertexMap.get(t);if(e)return e;let i=this.VertexFactory(t);return this.pointToVertexMap.set(t,i),i}AddVertexV(t){this.pointToVertexMap.set(t.point,t)}ContainsVertex(t){return this.pointToVertexMap.has(t)}static AddEdgeVV(t,e){let i;if(i=t.get(e))return i;if(t===e)throw new Error("Self-edges are not allowed");let r=new Nt(t,e);return t.OutEdges.insert(r),e.InEdges.push(r),r}AddEdgePlPl(t,e){this.AddEdgePP(t.point,e.point)}static AddEdge(t){t.Source.OutEdges.insert(t),t.Target.addInEdge(t)}AddEdgeF(t,e,i){let r=this.FindVertex(t),n=null;if(r!=null&&(n=this.FindVertex(e),n!=null)){let s=r.get(n);if(s)return s}r==null?(r=this.AddVertexP(t),n=this.AddVertexP(e)):n==null&&(n=this.AddVertexP(e));let o=i(r,n);return r.OutEdges.insert(o),n.addInEdge(o),o}AddEdgePP(t,e){return this.AddEdgeF(t,e,(i,r)=>new Nt(i,r))}FindVertex(t){return this.pointToVertexMap.get(t)}Vertices(){return this.pointToVertexMap.values()}RemoveVertex(t){for(let e of t.OutEdges)e.Target.RemoveInEdge(e);for(let e of t.InEdges)e.Source.RemoveOutEdge(e);this.pointToVertexMap.deleteP(t.point)}FindEdgePP(t,e){let i=this.FindVertex(t);if(i==null)return null;let r=this.FindVertex(e);return r==null?null:i.get(r)}static RemoveEdge(t){t.Source.RemoveOutEdge(t),t.Target.RemoveInEdge(t)}ClearEdges(){for(let t of this.Vertices())t.ClearEdges()}};var Hr=class{constructor(){this.Removed=!1}};var zi=class extends Hr{constructor(e,i,r){super();this.start=e,this.EndVertex=i,this.ConeSide=r}get Start(){return this.start}get End(){return this.EndVertex.point}get Direction(){return this.End.sub(this.Start)}toString(){return"BrokenConeSide: "+(this.Start+(","+this.End))}};var so=class{get Removed(){return this.removed}set Removed(t){this.removed=t}constructor(t,e){this.apex=t,this.coneSweeper=e}get Apex(){return this.apex}set Apex(t){this.apex=t}get RightSideDirection(){return this.coneSweeper.ConeRightSideDirection}get LeftSideDirection(){return this.coneSweeper.ConeLeftSideDirection}get RightSide(){return this.rightSide}set RightSide(t){this.rightSide=t,this.rightSide.Cone=this}get LeftSide(){return this.leftSide}set LeftSide(t){this.leftSide=t,this.leftSide.Cone=this}};var ko=class extends Fe{constructor(e,i){super();this.site=e,this.coneToClose=i}get ConeToClose(){return this.coneToClose}get Site(){return this.site}toString(){return"ConeClosureEvent "+this.site}};var zt=class extends Hr{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.LeftSideDirection}toString(){return"ConeLeftSide "+this.Start+(" "+this.Direction)}};var Ei=class extends Hr{constructor(t){super(),this.Cone=t}get Start(){return this.Cone.Apex}get Direction(){return this.Cone.RightSideDirection}toString(){return"ConeRightSide "+this.Start+" "+this.Direction}};var wn=class{SetOperand(t){this.x=this.IntersectionOfSegmentAndSweepLine(t)}constructor(t){this.coneSweeper=t}Compare(t,e){let i=t instanceof zi,r=e instanceof zi;return i?r?this.CompareBrokenSides(t,e):this.CompareObstacleSideAndConeSide(e):r?this.CompareConeSideAndObstacleSide(t,e):wn.CompareNotIntersectingSegs(t,e)}static CompareNotIntersectingSegs(t,e){switch(c.getTriangleOrientation(t.Start,e.Start,e.Start.add(e.Direction))){case 1:return-1;case 0:return 1;default:return 0}}CompareObstacleSideAndConeSide(t){let e=c.getTriangleOrientation(this.x,t.Start,t.Start.add(t.Direction));return e===1?-1:e===0?1:t instanceof zt?-1:1}CompareConeSideAndObstacleSide(t,e){let i=c.getTriangleOrientation(this.x,e.start,e.End);return i===1?-1:i===0||t instanceof zt?1:-1}IntersectionOfSegmentAndSweepLine(t){let e=t.Direction.dot(this.coneSweeper.SweepDirection),i=(this.coneSweeper.Z-t.Start.dot(this.coneSweeper.SweepDirection))/e;return t.Start.add(t.Direction.mul(i))}CompareBrokenSides(t,e){return t.EndVertex===e.EndVertex?wn.CompareNotIntersectingSegs(t.ConeSide,e.ConeSide):c.getTriangleOrientation(this.x,e.start,e.EndVertex.point)===1?-1:1}};var Wr=class extends Fe{constructor(e,i,r){super();this.coneLeftSide=e,this.intersectionPoint=i,this.endVertex=r}get EndVertex(){return this.endVertex}get Site(){return this.intersectionPoint}toString(){return"LeftIntersectionEvent "+this.intersectionPoint}};var zr=class{get Direction(){return this.End.sub(this.Start)}toString(){return this.Start+" "+this.End}};var qr=class extends zr{constructor(e){super();this.Init(e)}Init(e){this.StartVertex=e}get Polyline(){return this.StartVertex.polyline}get Start(){return this.StartVertex.point}get End(){return this.EndVertex.point}};var qi=class extends qr{constructor(e){super(e);this.end=e.nextOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.nextOnPolyline}};var Ii=class extends Wt{constructor(t){super(t)}};var Ho=class extends Fe{constructor(e,i,r){super();this.coneRightSide=e,this.intersectionPoint=i,this.endVertex=r}get EndVertex(){return this.endVertex}set EndVertex(e){this.endVertex=e}get Site(){return this.intersectionPoint}toString(){return"RightIntersectionEvent "+this.intersectionPoint}};var ji=class extends qr{constructor(e){super(e);this.end=e.prevOnPolyline.point}get End(){return this.end}get EndVertex(){return this.StartVertex.prevOnPolyline}};var vi=class extends Wt{constructor(t){super(t)}};var ke=class extends ro{constructor(e,i,r,n,o,s,a){super(e,i);this.visibilityGraph=o,this.ConeRightSideDirection=r,this.ConeLeftSideDirection=n,this.coneSideComparer=new wn(this),this.leftConeSides=new Ee((u,h)=>this.coneSideComparer.Compare(u,h)),this.rightConeSides=new Ee((u,h)=>this.coneSideComparer.Compare(u,h)),this.Ports=s,this.BorderPolyline=a,this.PortEdgesCreator=(u,h)=>new Xe(u,h,0)}static Sweep(e,i,r,n,o,s){new ke(e,i,i.rotate(-r/2),i.rotate(r/2),n,o,s).Calculate()}Calculate(){for(this.InitQueueOfEvents();this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue());this.BorderPolyline!=null&&this.CloseRemainingCones(),this.CreatePortEdges()}CreatePortEdges(){if(this.portEdgesGraph!=null)for(let e of this.portEdgesGraph.Edges)this.visibilityGraph.AddEdgeF(e.SourcePoint,e.TargetPoint,this.PortEdgesCreator)}CloseRemainingCones(){if(this.leftConeSides.count===0)return;let e=this.BorderPolyline.startPoint,i=this.leftConeSides.count;do{let r=this.leftConeSides.treeMinimum().item.Cone;e=this.FindPolylineSideIntersectingConeRightSide(e,r),e=this.GetPolylinePointInsideOfConeAndRemoveCones(e,r),i--}while(this.leftConeSides.count>0&&i>0)}GetPolylinePointInsideOfConeAndRemoveCones(e,i){let r=e.nextOnPolyline,n=ke.FindInsidePoint(e.point,r.point,i);return c.closeDistEps(n,e.point)?(this.AddEdgeAndRemoveCone(i,e.point),this.AddEdgesAndRemoveRemainingConesByPoint(e.point)):c.closeDistEps(n,r.point)?(this.AddEdgeAndRemoveCone(i,r.point),this.AddEdgesAndRemoveRemainingConesByPoint(r.point),e=r):(e=ke.InsertPointIntoPolylineAfter(this.BorderPolyline,e,n),this.AddEdgeAndRemoveCone(i,e.point),this.AddEdgesAndRemoveRemainingConesByPoint(e.point)),e}static FindInsidePoint(e,i,r){return ke.FindInsidePointBool(e,i,r.Apex,r.Apex.add(r.LeftSideDirection),r.Apex.add(r.RightSideDirection))}static FindInsidePointBool(e,i,r,n,o){if(c.closeDistEps(e,i)||c.PointIsInsideCone(e,r,n,o))return e;if(c.PointIsInsideCone(i,r,n,o))return i;let s=c.middle(e,i);return c.pointToTheLeftOfLine(s,r,n)?ke.FindInsidePointBool(s,i,r,n,o):ke.FindInsidePointBool(e,s,r,n,o)}AddEdgesAndRemoveRemainingConesByPoint(e){let i=new Array;for(let r of this.leftConeSides)if(c.PointToTheRightOfLineOrOnLine(e,r.Start,r.Start.add(r.Direction)))i.push(r.Cone);else break;for(let r of i)this.AddEdgeAndRemoveCone(r,e)}FindPolylineSideIntersectingConeRightSide(e,i){let r=e,n=i.Apex,o=i.Apex.add(this.ConeRightSideDirection),s=ke.GetSign(e,n,o);for(;;){let a=e.nextOnPolyline,u=ke.GetSign(a,n,o);if(u-s>0)return e;if(e=a,s=u,e===r)throw new Error("cannod decide if the polyline intersects the cone!")}}static GetSign(e,i,r){let n=c.signedDoubledTriangleArea(i,r,e.point);return n<0?1:n>0?-1:0}AddEdgeAndRemoveCone(e,i){this.Ports!=null&&this.Ports.has(e.Apex)?this.CreatePortEdge(e,i):this.visibilityGraph.AddEdgePP(e.Apex,i),this.RemoveCone(e)}CreatePortEdge(e,i){this.portEdgesGraph==null&&(this.portEdgesGraph=new se);let r=this.portEdgesGraph.FindVertex(e.Apex),n=r!=null?Array.from(r.InEdges).concat(Array.from(r.OutEdges.allNodes())):null;if(n)for(let o of n){let s=(o.Target===r?o.Source:o.Target).point;se.RemoveEdge(o),this.portEdgesGraph.AddEdgePP(s,i)}this.portEdgesGraph.AddEdgePP(e.Apex,i)}static InsertPointIntoPolylineAfter(e,i,r){let n;return i.next!=null?(n=Ne.mkFromPoint(r),n.prev=i,n.next=i.next,i.next.prev=n,i.next=n):(n=Ne.mkFromPoint(r),n.prev=i,i.next=n,e.endPoint=n),n.polyline=e,e.setInitIsRequired(),n}ProcessEvent(e){e instanceof Wt?this.ProcessVertexEvent(e):e instanceof Ho?this.ProcessRightIntersectionEvent(e):e instanceof Wr?this.ProcessLeftIntersectionEvent(e):(e instanceof ko?e.ConeToClose.Removed||this.RemoveCone(e.ConeToClose):this.ProcessPortObstacleEvent(e),this.Z=this.GetZS(e))}ProcessPortObstacleEvent(e){this.Z=this.GetZS(e),this.GoOverConesSeeingVertexEvent(e),this.CreateConeOnVertex(e)}ProcessLeftIntersectionEvent(e){if(e.coneLeftSide.Removed===!1)if(Math.abs(e.EndVertex.point.sub(e.Site).dot(this.SweepDirection))<m.distanceEpsilon)this.RemoveCone(e.coneLeftSide.Cone);else{this.RemoveSegFromLeftTree(e.coneLeftSide),this.Z=this.GetZP(e.Site);let i=new zi(e.Site,e.EndVertex,e.coneLeftSide);this.InsertToTree(this.leftConeSides,i),e.coneLeftSide.Cone.LeftSide=i,this.LookForIntersectionOfObstacleSideAndLeftConeSide(e.Site,e.EndVertex),this.TryCreateConeClosureForLeftSide(i)}else this.Z=this.GetZP(e.Site)}TryCreateConeClosureForLeftSide(e){if(e.Cone.RightSide instanceof Ei){let i=e.Cone.RightSide;c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.EndVertex.point)==0&&this.CreateConeClosureEvent(e,i)}}CreateConeClosureEvent(e,i){let r=c.RayIntersectsRayInteriors(e.start,e.Direction,i.Start,i.Direction);if(r){let n=new ko(r,e.Cone);this.EnqueueEvent(n)}}ProcessRightIntersectionEvent(e){if(e.coneRightSide.Removed)this.Z=this.GetZP(e.Site);else{this.RemoveSegFromRightTree(e.coneRightSide),this.Z=this.GetZP(e.Site);let i=new zi(e.Site,e.EndVertex,e.coneRightSide);this.InsertToTree(this.rightConeSides,i),e.coneRightSide.Cone.RightSide=i,this.LookForIntersectionOfObstacleSideAndRightConeSide(e.Site,e.EndVertex),this.TryCreateConeClosureForRightSide(i)}}TryCreateConeClosureForRightSide(e){if(e.Cone.LeftSide instanceof zt){let i=e.Cone.LeftSide;c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.EndVertex.point)==1&&this.CreateConeClosureEvent(e,i)}}RemoveConesClosedBySegment(e,i){this.CloseConesCoveredBySegment(e,i,this.GetZP(e)>this.GetZP(i)?this.leftConeSides:this.rightConeSides)}CloseConesCoveredBySegment(e,i,r){let n=r.findFirst(a=>c.getTriangleOrientation(a.Start,a.Start.add(a.Direction),e)===1);if(n==null||!c.IntervalIntersectsRay(e,i,n.item.Start,n.item.Direction))return;let s=new Array;do s.push(n.item.Cone),n=r.next(n);while(n!=null&&c.IntervalIntersectsRay(e,i,n.item.Start,n.item.Direction)!==void 0);for(let a of s)this.RemoveCone(a)}ProcessVertexEvent(e){this.Z=this.GetZS(e),this.GoOverConesSeeingVertexEvent(e),this.AddConeAndEnqueueEvents(e)}static Diamond(e){return be.mkDiamond(2,2,e)}AddConeAndEnqueueEvents(e){if(e instanceof Ii){let i=e.Vertex.nextOnPolyline;this.CloseConesAddConeAtLeftVertex(e,i)}else if(e instanceof vi){let i=e.Vertex.prevOnPolyline;this.CloseConesAddConeAtRightVertex(e,i)}else this.CloseConesAddConeAtLeftVertex(e,e.Vertex.nextOnPolyline),this.CloseConesAddConeAtRightVertex(e,e.Vertex.prevOnPolyline)}CloseConesAddConeAtRightVertex(e,i){let r=e.Vertex.nextOnPolyline.point;this.directionPerp.dot(e.Site.sub(r))>m.distanceEpsilon&&this.RemoveConesClosedBySegment(r,e.Vertex.point),this.directionPerp.dot(i.point.sub(e.Site))>m.distanceEpsilon&&this.RemoveConesClosedBySegment(e.Site,i.point);let n=e.Site,o=n.add(this.ConeLeftSideDirection),s=n.add(this.ConeRightSideDirection),a=i.point;this.GetZP(n.sub(r))>m.distanceEpsilon&&this.RemoveRightSide(new ji(e.Vertex.nextOnPolyline)),this.GetZP(n.sub(i.point))>m.distanceEpsilon&&this.RemoveLeftSide(new qi(i)),this.GetZP(a)+m.distanceEpsilon<this.GetZS(e)&&this.CreateConeOnVertex(e),c.PointToTheRightOfLineOrOnLine(a,n,o)?c.PointToTheLeftOfLineOrOnLine(a,n,s)?this.CaseToTheLeftOfLineOrOnLineConeRp(e,i):(this.GetZP(a.sub(n))>m.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndLeftConeSide(e.Site,i),this.InsertRightSide(new ji(e.Vertex))),this.EnqueueRightVertexEvent(new vi(i))):(this.CreateConeOnVertex(e),c.PointToTheLeftOfLineOrOnLine(a.add(this.DirectionPerp),a,n)&&this.EnqueueRightVertexEvent(new vi(i)))}CaseToTheLeftOfLineOrOnLineConeRp(e,i){this.EnqueueRightVertexEvent(new vi(i));let r=new so(e.Vertex.point,this),n=new zi(r.Apex,i,new zt(r));r.LeftSide=n,r.RightSide=new Ei(r);let o=this.InsertToTree(this.rightConeSides,r.RightSide);this.LookForIntersectionWithConeRightSide(o);let s=this.InsertToTree(this.leftConeSides,r.LeftSide);this.FixConeLeftSideIntersections(n,s),this.GetZP(i.point.sub(e.Site))>m.distanceEpsilon&&this.InsertRightSide(new ji(e.Vertex))}LookForIntersectionOfObstacleSideAndRightConeSide(e,i){let r=this.GetLastNodeToTheLeftOfPointInRightSegmentTree(e);if(r!=null&&r.item instanceof Ei){let n=c.IntervalIntersectsRay(e,i.point,r.item.Start,this.ConeRightSideDirection);n&&this.SegmentIsNotHorizontal(n,i.point)&&this.EnqueueEvent(this.CreateRightIntersectionEvent(r.item,n,i))}}CreateRightIntersectionEvent(e,i,r){return new Ho(e,i,r)}GetLastNodeToTheLeftOfPointInRightSegmentTree(e){return this.rightConeSides.findLast(i=>ke.PointIsToTheRightOfSegment(e,i))}LookForIntersectionOfObstacleSideAndLeftConeSide(e,i){let r=this.GetFirstNodeToTheRightOfPoint(e);if(r==null||!(r.item instanceof zt))return;let n=r.item,o=c.IntervalIntersectsRay(e,i.point,n.Start,this.ConeLeftSideDirection);o&&this.EnqueueEvent(new Wr(n,o,i))}GetFirstNodeToTheRightOfPoint(e){return this.leftConeSides.findFirst(i=>ke.PointIsToTheLeftOfSegment(e,i))}static PointIsToTheLeftOfSegment(e,i){return c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e)===1}static PointIsToTheRightOfSegment(e,i){return c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e)===0}FixConeLeftSideIntersections(e,i){do i=this.leftConeSides.next(i);while(i!=null&&c.PointToTheRightOfLineOrOnLine(e.Start,i.item.Start,i.item.Start.add(i.item.Direction)));if(i!=null&&i.item instanceof zt){let r=i.item,n=c.IntervalIntersectsRay(e.start,e.End,r.Start,r.Direction);n&&this.EnqueueEvent(new Wr(r,n,e.EndVertex))}}InsertToTree(e,i){return this.coneSideComparer.SetOperand(i),e.insert(i)}CloseConesAddConeAtLeftVertex(e,i){let r=e.Vertex.prevOnPolyline.point;e.Site.sub(r).dot(this.directionPerp)<-m.distanceEpsilon&&this.RemoveConesClosedBySegment(e.Site,r),i.point.sub(e.Site).dot(this.directionPerp)<-m.distanceEpsilon&&this.RemoveConesClosedBySegment(i.point,e.Site);let n=e.Site,o=n.add(this.ConeLeftSideDirection),s=n.add(this.ConeRightSideDirection),a=i.point;this.GetZP(n.sub(r))>m.distanceEpsilon&&this.RemoveLeftSide(new qi(e.Vertex.prevOnPolyline));let u=this.GetZP(a)-this.Z;u<-m.distanceEpsilon&&this.RemoveRightSide(new ji(i));let h=a.sub(e.Site);if(u<-m.distanceEpsilon||N(u,0)&&this.GetZP(h)>0&&h.dot(this.directionPerp)>-m.distanceEpsilon)this.CreateConeOnVertex(e);else if(!c.PointToTheLeftOfLineOrOnLine(a,n,s))this.CreateConeOnVertex(e),this.EnqueueEvent(new Ii(i));else if(c.PointToTheLeftOfLineOrOnLine(a,n,o))this.EnqueueEvent(new Ii(i)),this.GetZP(h)>m.distanceEpsilon&&(this.LookForIntersectionOfObstacleSideAndRightConeSide(e.Site,i),this.InsertLeftSide(new qi(e.Vertex)));else{this.EnqueueEvent(new Ii(i));let d=new so(e.Vertex.point,this),g=new zi(e.Vertex.point,i,new Ei(d));d.RightSide=g,d.LeftSide=new zt(d),this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides,d.LeftSide));let f=this.InsertToTree(this.rightConeSides,g);this.FixConeRightSideIntersections(g,f),this.GetZP(h)>m.distanceEpsilon&&this.InsertLeftSide(new qi(e.Vertex))}}RemoveCone(e){e.Removed=!0,this.RemoveSegFromLeftTree(e.LeftSide),this.RemoveSegFromRightTree(e.RightSide)}RemoveSegFromRightTree(e){this.coneSideComparer.SetOperand(e);let i=this.rightConeSides.remove(e);if(e.Removed=!0,i==null){let r=this.Z;this.Z=Math.max(this.GetZP(e.Start),this.Z-.01),this.coneSideComparer.SetOperand(e),i=this.rightConeSides.remove(e),this.Z=r}}RemoveSegFromLeftTree(e){if(e.Removed=!0,this.coneSideComparer.SetOperand(e),this.leftConeSides.remove(e)==null){let r=this.Z;this.Z=Math.max(this.GetZP(e.Start),this.Z-.01),this.coneSideComparer.SetOperand(e),this.leftConeSides.remove(e),this.Z=r}}FixConeRightSideIntersections(e,i){do i=this.rightConeSides.previous(i);while(i!=null&&c.PointToTheLeftOfLineOrOnLine(e.start,i.item.Start,i.item.Start.add(i.item.Direction)));if(i!=null){let r;if(i.item instanceof Ei){let n=i.item;(r=c.IntervalIntersectsRay(e.start,e.End,n.Start,n.Direction))&&this.EnqueueEvent(this.CreateRightIntersectionEvent(n,r,e.EndVertex))}}}CreateConeOnVertex(e){let i=new so(e.Site,this);i.LeftSide=new zt(i),i.RightSide=new Ei(i);let r=this.InsertToTree(this.leftConeSides,i.LeftSide),n=this.InsertToTree(this.rightConeSides,i.RightSide);this.LookForIntersectionWithConeRightSide(n),this.LookForIntersectionWithConeLeftSide(r)}LookForIntersectionWithConeLeftSide(e){if(e.item instanceof zt){let i=e.item,r=this.FindFirstObstacleSideToTheLeftOfPoint(i.Start);r!=null&&this.TryIntersectionOfConeLeftSideAndObstacleSide(i,r)}else{let i=e.item;e=this.leftConeSides.next(e),e!=null&&e.item instanceof zt&&this.TryIntersectionOfConeLeftSideAndObstacleConeSide(e.item,i)}}LookForIntersectionWithConeRightSide(e){if(e.item instanceof Ei){let i=e.item,r=this.FindFirstObstacleSideToToTheRightOfPoint(i.Start);r!=null&&this.TryIntersectionOfConeRightSideAndObstacleSide(i,r)}else{let i=e.item;e=this.rightConeSides.previous(e),e!=null&&e.item instanceof Ei&&this.TryIntersectionOfConeRightSideAndObstacleConeSide(e.item,i)}}TryIntersectionOfConeRightSideAndObstacleConeSide(e,i){let r=c.IntervalIntersectsRay(i.start,i.End,e.Start,e.Direction);r&&this.EnqueueEvent(this.CreateRightIntersectionEvent(e,r,i.EndVertex))}TryIntersectionOfConeRightSideAndObstacleSide(e,i){let r=c.IntervalIntersectsRay(i.Start,i.End,e.Start,e.Direction);r&&this.EnqueueEvent(this.CreateRightIntersectionEvent(e,r,i.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleConeSide(e,i){let r=c.IntervalIntersectsRay(i.start,i.End,e.Start,e.Direction);r&&this.EnqueueEvent(new Wr(e,r,i.EndVertex))}TryIntersectionOfConeLeftSideAndObstacleSide(e,i){let r=c.IntervalIntersectsRay(i.Start,i.End,e.Start,e.Direction);r&&this.EnqueueEvent(new Wr(e,r,i.EndVertex))}ExtendSegmentToZ(e){let i=e.Direction.dot(this.SweepDirection),r=(this.Z+40-e.Start.dot(this.SweepDirection))/i;return S.mkPP(e.Start,e.Start.add(e.Direction.mul(r)))}GoOverConesSeeingVertexEvent(e){let i=this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(e);if(i==null)return;let n=i.item.Cone,o=n.LeftSide;if(ke.VertexIsToTheLeftOfSegment(e,o))return;let s=[n];if(this.coneSideComparer.SetOperand(o),i=this.leftConeSides.find(o),i==null){let a=this.Z;this.Z=Math.max(this.GetZP(o.Start),this.PreviousZ),this.coneSideComparer.SetOperand(o),i=this.leftConeSides.find(o),this.Z=a}if(!(i==null&&(i=this.GetRbNodeEmergency(o),i==null))){for(i=this.leftConeSides.next(i);i!=null&&!ke.VertexIsToTheLeftOfSegment(e,i.item);)s.push(i.item.Cone),i=this.leftConeSides.next(i);for(let a of s)this.AddEdgeAndRemoveCone(a,e.Site)}}GetRbNodeEmergency(e){if(this.leftConeSides.count===0)return null;for(let i=this.leftConeSides.treeMinimum();i!=null;i=this.leftConeSides.next(i))if(i.item===e)return i;return null}static VertexIsToTheLeftOfSegment(e,i){return c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.Site)===1}static VertexIsToTheRightOfSegment(e,i){return c.getTriangleOrientation(i.Start,i.Start.add(i.Direction),e.Site)===0}FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(e){return this.rightConeSides.findFirst(i=>!ke.VertexIsToTheRightOfSegment(e,i))}EnqueueRightVertexEvent(e){this.GetZP(e.Site.sub(e.Vertex.prevOnPolyline.point))>m.tolerance||this.EnqueueEvent(e)}invariant(){for(let e of this.leftConeSides)if(e.Removed)return!1;for(let e of this.rightConeSides)if(e.Removed)return!1;return!0}};var Ui=class extends H{constructor(e,i){super(null);this.coneAngle=Math.PI/6;this.ports=new ie;this._obstacles=Array.from(se.OrientHolesClockwise(e)),this._visibilityGraph=i}static mk(e,i,r,n,o){let s=new Ui(e,i);return s.Ports=n,s.BorderPolyline=o,s.ConeAngle=r,s}get ConeAngle(){return this.coneAngle}set ConeAngle(e){this.coneAngle=e}get Ports(){return this.ports}set Ports(e){this.ports=e}get BorderPolyline(){return this.borderPolyline}set BorderPolyline(e){this.borderPolyline=e}get Bidirectional(){return this._bidirectional}set Bidirectional(e){this._bidirectional=e}static GetTotalSteps(e){return Math.floor((2*Math.PI-e/2)/e)+1}run(){let e=2*Math.PI-this.coneAngle/2;if(this.Bidirectional)this.HandleBideractionalCase();else{let i;for(let r=0;(i=this.coneAngle*r)<=e;r++)super.ProgressStep(),this.AddDirection(new c(Math.cos(i),Math.sin(i)),this.BorderPolyline,this._visibilityGraph)}}HandleBideractionalCase(){let e=Math.PI/this.coneAngle;for(let i=0;i<e;i++){let r=i*this.coneAngle,n=new se;this.AddDirection(new c(Math.cos(r),Math.sin(r)),this.BorderPolyline,n);let o=new se;this.AddDirection(new c(Math.cos(r)*-1,Math.sin(r)*-1),this.BorderPolyline,o),this.AddIntersectionOfBothDirectionSweepsToTheResult(n,o)}}AddIntersectionOfBothDirectionSweepsToTheResult(e,i){for(let r of e.Edges)i.FindEdgePP(r.SourcePoint,r.TargetPoint)!=null&&this._visibilityGraph.AddEdgePP(r.SourcePoint,r.TargetPoint)}AddDirection(e,i,r){ke.Sweep(this._obstacles,e,this.coneAngle,r,this.Ports,i)}};var Re=class extends Hi{constructor(e){super();this.adjustmentAngle=Math.PI/10;this.hookSize=9;this.curve=e,this.location=this.curve().start}mk(e,i){let r=new Re(e);return r.HookSize=i,r}get Location(){return this.location}get Curve(){return this.curve()}SetLocation(e){this.location=e}get AdjustmentAngle(){return this.adjustmentAngle}set AdjustmentAngle(e){this.adjustmentAngle=e}get HookSize(){return this.hookSize}set HookSize(e){this.hookSize=e}};var et=class extends $e{constructor(e,i,r=new c(0,0)){super(e,i,r)}get LoosePolyline(){return this.loosePolyline}set LoosePolyline(e){this.loosePolyline=e}static mk(e,i){return new et(e,i)}};var tt=class extends Hi{get Location(){return this.curve.value(this.parameter)}set Location(e){throw new Error("Method should not be called.")}static mk(e,i){let r=new tt;return r.curve=e,r.parameter=i,r}get Parameter(){return this.parameter}set Parameter(e){this.parameter=e}get Curve(){return this.curve}set Curve(e){this.curve=e}};var xi=class{constructor(){this.capacityOverflowCoefficient=xi.DefaultCapacityOverflowCoefficientMultiplier;this.RotateBundles=!1;this.MaxHubRadius=50;this.MinHubRadius=.1;this.CreateUnderlyingPolyline=!1;this.pathLengthImportance=xi.DefaultPathLengthImportance;this.inkImportance=xi.DefaultInkImportance;this.edgeSeparation=xi.DefaultEdgeSeparation;this._edgeWidthShrinkCoeff=1;this.useCubicBezierSegmentsInsideOfHubs=!1;this.angleThreshold=Math.PI/180*45;this.hubRepulsionImportance=100;this.bundleRepulsionImportance=100;this.minimalRatioOfGoodCdtEdges=.9;this.highestQuality=!0;this.KeepOverlaps=!1;this.StopAfterShortestPaths=!1}toJSON(){let t={};return this.capacityOverflowCoefficient!=xi.DefaultCapacityOverflowCoefficientMultiplier&&(t.capacityOverflowCoefficient=this.capacityOverflowCoefficient),this.RotateBundles&&(t.RotateBundles=this.RotateBundles),this.MaxHubRadius!=50&&(t.MaxHubRadius=this.MaxHubRadius),this.MinHubRadius!=.1&&(t.MinHubRadius=this.MinHubRadius),this.CreateUnderlyingPolyline&&(t.CreateUnderlyingPolyline=this.CreateUnderlyingPolyline),this.pathLengthImportance!=xi.DefaultPathLengthImportance&&(t.pathLengthImportance=this.pathLengthImportance),this.inkImportance!=xi.DefaultInkImportance&&(t.inkImportance=this.inkImportance),this.edgeSeparation!=xi.DefaultEdgeSeparation&&(t.edgeSeparation=this.edgeSeparation),this._edgeWidthShrinkCoeff!=1&&(t._edgeWidthShrinkCoeff=this._edgeWidthShrinkCoeff),this.useCubicBezierSegmentsInsideOfHubs&&(t.useCubicBezierSegmentsInsideOfHubs=this.useCubicBezierSegmentsInsideOfHubs),this.angleThreshold!=Math.PI/180*45&&(t.angleThreshold=this.angleThreshold),this.hubRepulsionImportance!=100&&(t.hubRepulsionImportance=this.hubRepulsionImportance),this.bundleRepulsionImportance!=100&&(t.bundleRepulsionImportance=this.bundleRepulsionImportance),this.minimalRatioOfGoodCdtEdges!=.9&&(t.minimalRatioOfGoodCdtEdges=this.minimalRatioOfGoodCdtEdges),this.highestQuality||(t.highestQuality=this.highestQuality),this.KeepOverlaps&&(t.KeepOverlaps=this.KeepOverlaps),this.StopAfterShortestPaths&&(t.StopAfterShortestPaths=this.StopAfterShortestPaths),t}static createFromJSON(t){let e=new xi;return t.capacityOverflowCoefficient&&(e.capacityOverflowCoefficient=t.capacityOverflowCoefficient),t.RotateBundles&&(e.RotateBundles=t.RotateBundles),t.MaxHubRadius&&(e.MaxHubRadius=t.MaxHubRadius),t.MinHubRadius&&(e.MinHubRadius=t.MinHubRadius),t.CreateUnderlyingPolyline&&(e.CreateUnderlyingPolyline=t.CreateUnderlyingPolyline),t.pathLengthImportance&&(e.pathLengthImportance=t.pathLengthImportance),t.inkImportance&&(e.inkImportance=t.inkImportance),t.edgeSeparation&&(e.edgeSeparation=t.edgeSeparation),t._edgeWidthShrinkCoeff&&(e._edgeWidthShrinkCoeff=t._edgeWidthShrinkCoeff),t.useCubicBezierSegmentsInsideOfHubs&&(e.useCubicBezierSegmentsInsideOfHubs=t.useCubicBezierSegmentsInsideOfHubs),t.angleThreshold&&(e.angleThreshold=t.angleThreshold),t.hubRepulsionImportance&&(e.hubRepulsionImportance=t.hubRepulsionImportance),t.bundleRepulsionImportance&&(e.bundleRepulsionImportance=t.bundleRepulsionImportance),t.minimalRatioOfGoodCdtEdges&&(e.minimalRatioOfGoodCdtEdges=t.minimalRatioOfGoodCdtEdges),t.highestQuality&&(e.HighestQuality=t.highestQuality),t.KeepOverlaps&&(e.KeepOverlaps=t.KeepOverlaps),t.StopAfterShortestPaths&&(e.StopAfterShortestPaths=t.StopAfterShortestPaths),e}get CapacityOverflowCoefficient(){return this.capacityOverflowCoefficient}set CapacityOverflowCoefficient(t){this.capacityOverflowCoefficient=t}get PathLengthImportance(){return this.pathLengthImportance}set PathLengthImportance(t){this.pathLengthImportance=t}get InkImportance(){return this.inkImportance}set InkImportance(t){this.inkImportance=t}get EdgeSeparation(){return this.edgeSeparation}set EdgeSeparation(t){this.edgeSeparation=t}get edgeWidthShrinkCoeff(){return this._edgeWidthShrinkCoeff}set edgeWidthShrinkCoeff(t){this._edgeWidthShrinkCoeff=t}ActualEdgeWidth(t,e=this.edgeWidthShrinkCoeff){return e*(this.edgeSeparation+t.lineWidth)}get UseCubicBezierSegmentsInsideOfHubs(){return this.useCubicBezierSegmentsInsideOfHubs}set UseCubicBezierSegmentsInsideOfHubs(t){this.useCubicBezierSegmentsInsideOfHubs=t}get AngleThreshold(){return this.angleThreshold}set AngleThreshold(t){this.angleThreshold=t}get HubRepulsionImportance(){return this.hubRepulsionImportance}set HubRepulsionImportance(t){this.hubRepulsionImportance=t}get BundleRepulsionImportance(){return this.bundleRepulsionImportance}set BundleRepulsionImportance(t){this.bundleRepulsionImportance=t}get MinimalRatioOfGoodCdtEdges(){return this.minimalRatioOfGoodCdtEdges}set MinimalRatioOfGoodCdtEdges(t){this.minimalRatioOfGoodCdtEdges=t}get HighestQuality(){return this.highestQuality}set HighestQuality(t){this.highestQuality=t}},Kt=xi;Kt.DefaultCapacityOverflowCoefficientMultiplier=1e3,Kt.DefaultPathLengthImportance=500,Kt.DefaultInkImportance=.01,Kt.DefaultEdgeSeparation=.5;var cr=class extends Ci{constructor(e){super(null);this.node=e}get BoundaryCurve(){return this.node.boundaryCurve}set BoundaryCurve(e){if(e)throw new Error("Cannot set BoundaryCurve directly for RelativeShape")}};var qt=class{static GetShapes(t,e){let i=new Map;for(let r of t)qt.ProcessAncestorDescendantCouple(r.target,r.source,i),qt.InsertEdgePortsToShapes(i,r);for(let r of e)qt.ProcessAncestorDescendantCouple(r.source,r.target,i),qt.InsertEdgePortsToShapes(i,r);return qt.BindShapes(i),Array.from(i.values())}static InsertEdgePortsToShapes(t,e){t.get(e.target).Ports.add(e.targetPort),t.get(e.source).Ports.add(e.sourcePort)}static BindShapes(t){for(let[e,i]of t){if(!(e instanceof de))continue;let r=e;for(let n of yl(r)){let o=t.get(n);o&&i.AddChild(o)}}}static ProcessAncestorDescendantCouple(t,e,i){let r=Ws(e);do{for(let n of yl(r))qt.CreateShapeIfNeeeded(n,i);if(r===t)break;r=Ws(r)}while(!0);qt.CreateShapeIfNeeeded(r,i)}static CreateShapeIfNeeeded(t,e){e.has(t)||e.set(t,new cr(t))}static NumberOfActiveNodesIsUnderThreshold(t,e,i){let r=new Set;for(let n of t)if(qt.SetOfActiveNodesIsLargerThanThreshold(n.target,n.source,r,i))return!1;for(let n of e)if(qt.SetOfActiveNodesIsLargerThanThreshold(n.source,n.target,r,i))return!1;return!0}static SetOfActiveNodesIsLargerThanThreshold(t,e,i,r){let n=Ws(e);for(;;){for(let o of yl(n))if(i.add(o),i.size>r)return!0;if(n===t)break;n=Ws(n)}return i.add(n),i.size>r}};function Ws(l){let t=l.node.parent;return q.getGeom(t)}function*yl(l){for(let t of l.graph.shallowNodes)yield q.getGeom(t)}var yt=class{constructor(t){this.stamp=0;this.SetPivotAndAllocateHullPointsArray(t)}SetPivotAndAllocateHullPointsArray(t){this.pivot=new c(0,Number.MAX_SAFE_INTEGER);let e=-1,i=0;for(let r of t)r.y<this.pivot.y?(this.pivot=r,e=i):r.y===this.pivot.y&&r.x>this.pivot.x&&(this.pivot=r,e=i),i++;if(i>=1){this.hullPoints=new Array(i-1),i=0;for(let r of t)i!==e?this.hullPoints[i++]={point:r,deleted:!1,stamp:this.stamp++}:e=-1}}get StackTopPoint(){return this.stack.point}get StackSecondPoint(){return this.stack.next.point}static*CalculateConvexHull(t){let e=new yt(t);for(let i of e.Calculate())yield i}*Calculate(){if(this.pivot.y!==Number.MAX_SAFE_INTEGER){if(this.hullPoints.length===0){yield this.pivot;return}this.SortAllPointsWithoutPivot(),this.Scan();for(let t of this.EnumerateStack())yield t}}*EnumerateStack(){let t=this.stack;for(;t!=null;)yield t.point,t=t.next}Scan(){let t=0;for(;this.hullPoints[t].deleted;)t++;for(this.stack={point:this.pivot,next:null},this.Push(t++),t<this.hullPoints.length&&(this.hullPoints[t].deleted?t++:this.Push(t++));t<this.hullPoints.length;)this.hullPoints[t].deleted?t++:this.LeftTurn(t)?this.Push(t++):this.Pop();for(;this.StackHasMoreThanTwoPoints()&&!this.LeftTurnToPivot();)this.Pop()}LeftTurnToPivot(){return c.getTriangleOrientation(this.StackSecondPoint,this.StackTopPoint,this.pivot)===1}StackHasMoreThanTwoPoints(){return this.stack.next!=null&&this.stack.next.next!=null}Pop(){this.stack=this.stack.next}LeftTurn(t){if(this.stack.next==null)return!0;let e=c.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint,this.StackTopPoint,this.hullPoints[t].point);return e===1?!0:e===0?!1:this.BackSwitchOverPivot(this.hullPoints[t].point)}BackSwitchOverPivot(t){return this.stack.next.next!=null?!1:this.StackTopPoint.x>this.pivot.x+m.distanceEpsilon&&t.x<this.pivot.x-m.distanceEpsilon}Push(t){this.stack={point:this.hullPoints[t].point,next:this.stack}}SortAllPointsWithoutPivot(){this.hullPoints.sort(pc(this.pivot))}static createConvexHullAsClosedPolyline(t){return R.mkClosedFromPoints(Array.from(yt.CalculateConvexHull(t)))}};function pc(l){return(t,e)=>{if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;switch(c.getTriangleOrientationWithIntersectionEpsilon(l,t.point,e.point)){case 1:return-1;case 0:return 1;case 2:let i=t.point.x-l.x,r=e.point.x-l.x;if(i>m.distanceEpsilon&&r<-m.distanceEpsilon)return-1;if(i<-m.distanceEpsilon&&r>m.distanceEpsilon)return 1;let n=t.point.sub(l),o=e.point.sub(l),s=n.l1-o.l1;return s<0?(t.deleted=!0,-1):s>0?(e.deleted=!0,1):(t.stamp>e.stamp?t.deleted=!0:e.deleted=!0,0)}throw new Error}}function it(l,t,e){!l.irect.intersects_rect(t.irect)||(l.Left==null?t.Left==null?e(l.UserData,t.UserData):(it(l,t.Left,e),it(l,t.Right,e)):t.Left!=null?(it(l.Left,t.Left,e),it(l.Left,t.Right,e),it(l.Right,t.Left,e),it(l.Right,t.Right,e)):(it(l.Left,t,e),it(l.Right,t,e)))}function Be(l,t,e){!l.irect.intersects_rect(t.irect)||(l===t?Pc(l,e):l.Left==null?t.Left==null?e(l.UserData,t.UserData):(Be(l,t.Left,e),Be(l,t.Right,e)):t.Left!=null?(Be(l.Left,t.Left,e),Be(l.Left,t.Right,e),Be(l.Right,t.Left,e),Be(l.Right,t.Right,e)):(Be(l.Left,t,e),Be(l.Right,t,e)))}function $t(l,t,e){if(!l.irect.intersects_rect(t.irect))return!1;if(l===t)return fc(l,e);if(l.Left==null){if(t.Left==null)return e(l.UserData,t.UserData);if($t(l,t.Left,e)||$t(l,t.Right,e))return!0}else if(t.Left!=null){if($t(l.Left,t.Left,e)||$t(l.Left,t.Right,e)||$t(l.Right,t.Left,e)||$t(l.Right,t.Right,e))return!0}else if($t(l.Left,t,e)||$t(l.Right,t,e))return!0;return!1}function fc(l,t){return l.Left==null?!1:$t(l.Left,l.Left,t)||$t(l.Left,l.Right,t)||$t(l.Right,l.Right,t)}function Pc(l,t){l.Left!=null&&(Be(l.Left,l.Left,t),Be(l.Left,l.Right,t),Be(l.Right,l.Right,t))}var Iu=BigInt("6364136223846793005"),Cl=(BigInt(1)<<BigInt(32))-BigInt(1),dr=(BigInt(1)<<BigInt(64))-BigInt(1),jr=class{constructor(t,e){this._state=BigInt(0),this._inc=(BigInt(e)<<BigInt(1)|BigInt(1))&dr,this._random_b(),this._state=this._state+BigInt(t)&dr,this._random_b()}_random_b(){let t=this._state;this._state=t*Iu+this._inc&dr;let e=(t>>BigInt(18)^t)>>BigInt(27),i=t>>BigInt(59),r=i^BigInt(31);return(e>>i|e<<r)&Cl}_advance(t){t&=dr;let e=BigInt(1),i=Iu,r=BigInt(0),n=this._inc;for(;t>0;)t&BigInt(1)&&(e=e*i&dr,r=r*i+n&dr),n=(i+BigInt(1))*n&dr,i=i*i&dr,t>>=BigInt(1);this._state=e*this._state+r&dr}randint(t){if(t>Cl)throw new TypeError(`Bound too large: ${t}`);if(t<=0)throw new TypeError(`Empty sample space for r: 0 \u2264 r < ${t}`);let e=BigInt(t),i=(Cl^e)%e;for(;;){let r=this._random_b();if(r>=i)return Number(r%e)}}random(){return Number(this._random_b())/Math.pow(2,32)}};var On;function Ur(l){return On==null&&(On=new jr(0,0)),On.randint(l)}function Qr(l){On=new jr(l,0)}function Qi(){return On==null&&(On=new jr(0,0)),On.random()}var xu=J(Mi(),1);function*Ti(l){let t=new Array(l.nodeCount).fill(!1),e=new xu.Queue;for(let i=0;i<l.nodeCount;i++)if(!t[i]){let r=new Array;for(vu(i,e,t);e.length>0;){let n=e.dequeue();r.push(n);for(let o of bc(l,n))vu(o,e,t)}yield r}}function*bc(l,t){for(let e of l.outEdges[t])yield e.target;for(let e of l.inEdges[t])yield e.source}function vu(l,t,e){e[l]===!1&&(t.enqueue(l),e[l]=!0)}var Tu=J(Mi(),1);function ao(l){let t=new _e;return t.SetEdges(l,_e.vertexCount(l)),t}function zs(l){let t=new _e;return t.SetEdges(l,_e.vertexCount(l)),t}function rt(l,t){let e=new _e;return e.SetEdges(l,t),e}var _e=class{constructor(){this.nodeCount=0}*incidentEdges(t){for(let e of this.outEdges[t])yield e;for(let e of this.inEdges[t])yield e}static deleteFromArray(t,e){let i=t.indexOf(e,0);i>-1&&t.splice(i,1)}removeEdge(t){_e.deleteFromArray(this.edges,t),t.source!==t.target?(_e.deleteFromArray(this.outEdges[t.source],t),_e.deleteFromArray(this.inEdges[t.target],t)):_e.deleteFromArray(this.selfEdges[t.source],t)}static vertexCount(t){let e=0;for(let i of t)i.source>=e&&(e=i.source),i.target>=e&&(e=i.target);return++e}SetEdges(t,e){this.edges=t,this.nodeCount=e;let i=new Array(this.nodeCount).fill(0),r=new Array(this.nodeCount).fill(0),n=new Array(this.nodeCount).fill(0);this.outEdges=new Array(this.nodeCount),this.inEdges=new Array(this.nodeCount),this.selfEdges=new Array(this.nodeCount);for(let o of this.edges)o.source!==o.target?(i[o.source]++,r[o.target]++):n[o.source]++;for(let o=0;o<this.nodeCount;o++)this.outEdges[o]=new Array(i[o]),i[o]=0,this.inEdges[o]=new Array(r[o]),r[o]=0,this.selfEdges[o]=new Array(n[o]),n[o]=0;for(let o of this.edges){let s=o.source,a=o.target;s!==a?(this.outEdges[s][i[s]++]=o,this.inEdges[a][r[a]++]=o):this.selfEdges[s][n[s]++]=o}}inEdgesCount(t){return this.inEdges[t].length}outEdgesCount(t){return this.outEdges[t].length}selfEdgesCount(t){return this.selfEdges[t].length}addEdge(t){this.edges.push(t),t.source!==t.target?(this.outEdges[t.source].push(t),this.inEdges[t.target].push(t)):this.selfEdges[t.source].push(t)}*nodesOfConnectedGraph(){if(this.edges.length===0)return;let t=new Set,e=new Tu.Queue,i=this.edges[0].source;for(_e.enqueue(t,e,i),yield i;e.length>0;){i=e.dequeue();for(let r of this.outEdges[i]){let n=r.target;t.has(n)||(_e.enqueue(t,e,n),yield n)}for(let r of this.inEdges[i]){let n=r.source;t.has(n)||(_e.enqueue(t,e,n),yield n)}}}*pred(t){for(let e of this.inEdges[t])yield e.source}*succ(t){for(let e of this.outEdges[t])yield e.target}static enqueue(t,e,i){e.enqueue(i),t.add(i)}};var Ln=class{get Sequence(){return this.f}set Sequence(t){this.f=t}get Length(){return this.length}set Length(t){this.length=t}constructor(t,e){this.f=t,this.length=e}FindMinimum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2),r=this.f(i);if(r>=this.f(0)&&r>=this.f(this.length-1))return this.f(0)<this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case 1:t=i;break;case 0:e=i;break;case 2:return i}return t===e||this.f(t)<=this.f(e)?t:e}BehaviourAtIndex(t){let e=this.f(t);if(t===0){let n=this.f(1);return n===e?2:n>e?0:1}if(t===this.length-1){let n=this.f(this.length-2);return n===e?2:n>e?1:0}let i=e-this.f(t-1),r=this.f(t+1)-e;return i*r<=0?2:i>0?0:1}FindMaximum(){let t=0,e=this.length-1,i=t+Math.floor((e-t)/2),r=this.f(i);if(r<=this.f(0)&&r<=this.f(this.length-1))return this.f(0)>this.f(this.length-1)?0:this.length-1;for(;e-t>1;)switch(i=t+Math.floor((e-t)/2),this.BehaviourAtIndex(i)){case 1:e=i;break;case 0:t=i;break;case 2:return i}return t===e||this.f(t)>=this.f(e)?t:e}};var qs=class{toArray(){let t=[];for(let e=0;e<this.length;e++)t.push(this.f(e));return t}constructor(t,e){this.f=t,this.length=e}GetAdjustedSequenceForMinimum(){let t=this.f(0),i=(this.f(this.length-1)-t)/(this.length-1);return r=>Math.min(this.f(r),t+i*r)}GetAdjustedSequenceForMaximum(){let t=this.f(0),i=(this.f(this.length-1)-t)/(this.length-1);return r=>Math.max(this.f(r),t+i*r)}FindMinimum(){return this.f(0)===this.f(this.length-1)?new Ln(this.f,this.length).FindMinimum():new Ln(this.GetAdjustedSequenceForMinimum(),this.length).FindMinimum()}FindMaximum(){return this.f(0)===this.f(this.length-1)?new Ln(this.f,this.length).FindMaximum():new Ln(this.GetAdjustedSequenceForMaximum(),this.length).FindMaximum()}};var Xr=class{constructor(t,e){this.P=t,this.Q=e}LeftFromLineOnP(t,e,i){let r=this.P.pnt(t);return this.upperBranchOnP?c.pointToTheLeftOfLineOrOnLine(i,r,e):c.pointToTheRightOfLineOrOnLine(i,r,e)}LeftFromLineOnQ(t,e,i){let r=this.Q.pnt(t);return this.lowerBranchOnQ?c.pointToTheLeftOfLineOrOnLine(i,r,e):c.pointToTheRightOfLineOrOnLine(i,r,e)}PrevOnP(t){return this.upperBranchOnP?this.P.Prev(t):this.P.Next(t)}PrevOnQ(t){return this.lowerBranchOnQ?this.Q.Prev(t):this.Q.Next(t)}NextOnP(t){return this.upperBranchOnP?this.P.Next(t):this.P.Prev(t)}NextOnQ(t){return this.lowerBranchOnQ?this.Q.Next(t):this.Q.Prev(t)}MedianOnP(t,e){return this.upperBranchOnP?this.P.Median(t,e):this.P.Median(e,t)}MedianOnQ(t,e){return this.lowerBranchOnQ?this.Q.Median(t,e):this.Q.Median(e,t)}ModuleP(t,e){return this.upperBranchOnP?this.P.Module(e-t):this.P.Module(t-e)}ModuleQ(t,e){return this.lowerBranchOnQ?this.Q.Module(e-t):this.Q.Module(t-e)}TangentBetweenBranches(t,e,i,r){for(;e!==t||r!==i;){let n=e!==t?this.MedianOnP(t,e):t,o=r!==i?this.MedianOnQ(i,r):i,s=this.P.pnt(n),a=this.Q.pnt(o),u=!0;this.ModuleP(t,e)>1?this.LeftFromLineOnP(this.NextOnP(n),s,a)?t=n:this.LeftFromLineOnP(this.PrevOnP(n),s,a)?e=n:u=!1:e!==t?this.LeftFromLineOnP(e,this.P.pnt(t),a)?t=e:this.LeftFromLineOnP(t,this.P.pnt(e),a)?e=t:u=!1:u=!1;let h=!0;this.ModuleQ(i,r)>1?this.LeftFromLineOnQ(this.NextOnQ(o),a,s)?i=o:this.LeftFromLineOnQ(this.PrevOnQ(o),a,s)?r=o:h=!1:r!==i?this.LeftFromLineOnQ(r,this.Q.pnt(i),s)?i=r:this.LeftFromLineOnQ(i,this.Q.pnt(r),s)?r=i:h=!1:h=!1,!u&&!h&&(t=n,e=n,i=o,r=o)}return[t,r]}FindDividingBisector(t){let e={pClosest:void 0,qClosest:void 0,p1:void 0,p2:void 0,q1:void 0,q2:void 0};this.FindClosestFeatures(e),t.bisectorPivot=c.middle(e.pClosest,e.qClosest),t.bisectorRay=e.pClosest.sub(e.qClosest).rotate(Math.PI/2),t.p1=e.p1,t.p2=e.p2,t.q1=e.q1,t.q2=e.q2}FindClosestPoints(){let t={q2:void 0,p1:void 0,p2:void 0,q1:void 0,pClosest:void 0,qClosest:void 0};return this.FindClosestFeatures(t),{pClosest:t.pClosest,qClosest:t.qClosest}}FindClosestFeatures(t){let e={leftTangentPoint:void 0,rightTangentPoint:void 0};this.P.GetTangentPoints(e,this.Q.pp(0).point),t.p2=e.leftTangentPoint,t.p1=e.rightTangentPoint,t.p2===t.p1&&(t.p2+=this.P.count),this.Q.GetTangentPoints(e,this.P.pp(0).point),t.q1=e.leftTangentPoint,t.q2=e.rightTangentPoint,t.q2===t.q1&&(t.q2+=this.Q.count),this.FindClosestPoints_(t)}FindClosestPoints_(t){for(;this.ChunksAreLong(t.p2,t.p1,t.q2,t.q1);)this.ShrinkChunks(t);t.p1===t.p2?(t.pClosest=this.P.pp(t.p2).point,t.q1===t.q2?t.qClosest=this.Q.pp(t.q1).point:(t.qClosest=c.ClosestPointAtLineSegment(t.pClosest,this.Q.pp(t.q1).point,this.Q.pp(t.q2).point),c.closeDistEps(t.qClosest,this.Q.pnt(t.q1))?t.q2=t.q1:c.closeDistEps(t.qClosest,this.Q.pnt(t.q2))&&(t.q1=t.q2))):(t.qClosest=this.Q.pp(t.q1).point,t.pClosest=c.ClosestPointAtLineSegment(t.qClosest,this.P.pp(t.p1).point,this.P.pp(t.p2).point),c.closeDistEps(t.pClosest,this.P.pnt(t.p1))?t.p2=t.p1:c.closeDistEps(t.qClosest,this.P.pnt(t.p2))&&(t.p1=t.p2))}ChunksAreLong(t,e,i,r){let n=this.P.Module(t-e)+1;if(n>2)return!0;let o=this.Q.Module(r-i)+1;return o>2||n===2&&o===2}ShrinkChunks(t){let e=t.p1===t.p2?t.p1:this.P.Median(t.p1,t.p2),i=t.q1===t.q2?t.q1:this.Q.Median(t.q2,t.q1),r=this.P.pp(e).point,n=this.Q.pp(i).point,o={a1:void 0,a2:void 0,b1:void 0,b2:void 0};if(this.GetAnglesAtTheMedian(e,i,r,n,o),!this.InternalCut(t,e,i,o.a1,o.a2,o.b1,o.b2)&&!Xr.OneOfChunksContainsOnlyOneVertex(t,e,i,o.a1,o.b1)&&!this.OnlyOneChunkContainsExactlyTwoVertices(t,{mp:e,mq:i},o)){if(t.p2===this.P.Next(t.p1)&&t.q1===this.Q.Next(t.q2)){let s=S.minDistBetweenLineSegments(this.P.pnt(t.p1),this.P.pnt(t.p2),this.Q.pnt(t.q1),this.Q.pnt(t.q2));s.parab===0?t.p2=t.p1:s.parab===1?t.p1=t.p2:s.parcd===0?t.q2=t.q1:s.parcd===1&&(t.q1=t.q2);return}o.a1<=Math.PI&&o.a2<=Math.PI&&o.b1<=Math.PI&&o.b2<=Math.PI?o.a1+o.b1>Math.PI?o.a1>=Math.PI/2?t.p1=e:t.q1=i:o.a2>=Math.PI/2?t.p2=e:t.q2=i:o.a1>Math.PI?t.p1=e:o.a2>Math.PI?t.p2=e:o.b1>Math.PI?t.q1=i:t.q2=i}}InternalCut(t,e,i,r,n,o,s){let a=!1;if(r>=Math.PI&&n>=Math.PI){let u=this.P.pp(e).point,h=this.Q.pp(i).point,d=this.P.pp(this.P.Next(e)).point,g=c.getTriangleOrientation(u,h,this.Q.pp(0).point),f=c.getTriangleOrientation(u,h,d);g===f?t.p1=this.P.Next(e):t.p2=this.P.Prev(e),a=!0}if(o>=Math.PI&&s>=Math.PI){let u=this.P.pp(e).point,h=this.Q.pp(i).point,d=this.Q.pp(this.Q.Next(i)).point,g=c.getTriangleOrientation(u,h,this.P.pp(0).point),f=c.getTriangleOrientation(u,h,d);g===f?t.q2=this.Q.Next(i):t.q1=this.Q.Prev(i),a=!0}return a}GetAnglesAtTheMedian(t,e,i,r,n){n.a1=c.anglePCP(r,i,this.P.pnt(this.P.Prev(t))),n.a2=c.anglePCP(this.P.pnt(this.P.Next(t)),i,r),n.b1=c.anglePCP(this.Q.pnt(this.Q.Next(e)),r,i),n.b2=c.anglePCP(i,r,this.Q.pnt(this.Q.Prev(e)))}OnlyOneChunkContainsExactlyTwoVertices(t,e,i){let r=t.p2===this.P.Next(t.p1),n=t.q1===this.Q.Next(t.q2);return r&&!n?(this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),!0):n&&!r?(this.SwapEverything(t,e,i),this.ProcessShortSide(t,e.mp,e.mq,i.a1,i.b1,i.a2,i.b2),this.SwapEverything(t,e,i),!0):!1}SwapEverything(t,e,i){this.SwapPq();let r=t.p2;t.p2=t.q1,t.q1=r,r=t.q2,t.q2=t.p1,t.p1=r,r=e.mq,e.mq=e.mp,e.mp=r,r=i.a2,i.a2=i.b1,i.b1=r,r=i.b2,i.b2=i.a1,i.a1=r}ProcessShortSide(t,e,i,r,n,o,s){e===t.p2?this.ProcessSide(t,i,r,n,s):o<=Math.PI?o+s>=Math.PI?o>=Math.PI/2?t.p2=t.p1:t.q2=i:n>=Math.PI/2?t.q1=i:o<s&&(c.canProject(this.Q.pnt(i),this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q1=i:t.p1=t.p2):r+n<=Math.PI?t.p1=t.p2:t.p2=t.p1}SwapPq(){let t=this.P;this.P=this.Q,this.Q=t}ProcessSide(t,e,i,r,n){let o=this.Q.pnt(e);i<=Math.PI?i+r>=Math.PI?i>=Math.PI/2?t.p1=t.p2:t.q1=e:n>=Math.PI/2?t.q2=e:i<n&&(c.canProject(o,this.P.pp(t.p1).point,this.P.pp(t.p2).point)?t.q2=e:t.p2=t.p1):(t.p2=t.p1,r>=Math.PI?t.q1=e:n>=Math.PI&&(t.q2=e))}static OneOfChunksContainsOnlyOneVertex(t,e,i,r,n){return t.p1===t.p2?(n>=Math.PI/2?t.q1=i:t.q2=i,!0):t.q1===t.q2?(r>=Math.PI/2?t.p1=e:t.p2=e,!0):!1}CalculateLeftTangents(){let t={bisectorPivot:null,bisectorRay:null,p1:0,p2:0,q1:0,q2:0};this.FindDividingBisector(t);let e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!1,this.lowerBranchOnQ=!0,this.leftPLeftQ=this.TangentBetweenBranches(e,t.p1,i,t.q1),this.lowerBranchOnQ=!1,this.leftPRightQ=this.TangentBetweenBranches(e,t.p1,i,t.q2)}CalculateRightTangents(){let t={bisectorPivot:null,bisectorRay:null,p1:0,p2:0,q1:0,q2:0};this.FindDividingBisector(t);let e=this.P.FindTheFurthestVertexFromBisector(t.p1,t.p2,t.bisectorPivot,t.bisectorRay),i=this.Q.FindTheFurthestVertexFromBisector(t.q2,t.q1,t.bisectorPivot,t.bisectorRay);this.upperBranchOnP=!0,this.lowerBranchOnQ=!0,this.rightPLeftQ=this.TangentBetweenBranches(e,t.p2,i,t.q1),this.lowerBranchOnQ=!1,this.rightPRightQ=this.TangentBetweenBranches(e,t.p2,i,t.q2)}};var He=class{static mkFromPoints(t){return new He(R.mkClosedFromPoints(t))}get Polyline(){return this.polyline}constructor(t){this.polyline=t,this.points=new Array;for(let e=this.polyline.startPoint;e;e=e.next)this.points.push(e)}Next(t){return this.Module(t+1)}Prev(t){return this.Module(t-1)}get count(){return this.Polyline.count}Module(t){return t<0?t+this.count:t<this.count?t:t-this.count}pp(t){return this.points[this.Module(t)]}pnt(t){return this.pp(t).point}toString(){return this.polyline.toString()}Median(t,e){return e>t?Math.floor((e+t)/2):this.Module(e+Math.floor((this.count+t)/2))}FindTheFurthestVertexFromBisector(t,e,i,r){let n=r.rotate(Math.PI/2);this.polyline.startPoint.point.sub(i).dot(n)<0&&(n=n.mul(-1)),t===e&&(e=this.Next(t));do{let o=this.Median(e,t),s=this.pnt(o);this.pnt(this.Next(o)).sub(s).dot(n)>=0?e=this.Next(o):this.pnt(this.Prev(o)).sub(s).dot(n)>=0?t=this.Prev(o):e=o,t=o}while(t!==e);return t}static TestPolygonDist(t,e){let i=Number.MAX_SAFE_INTEGER;for(let r=0;r<t.count;r++)for(let n=0;n<e.count;n++){let o=S.minDistBetweenLineSegments(t.pnt(r),t.pnt(r+1),e.pnt(n),e.pnt(n+1));i=Math.min(i,o.dist)}return i}static Distance(t,e){let r=new Xr(t,e).FindClosestPoints();return{p:r.pClosest,q:r.qClosest,dist:r.pClosest.sub(r.qClosest).length}}static DistanceOnly(t,e){return He.Distance(t,e).dist}static PolygonIsLegalDebug(t){let e=t.Polyline;for(let i=e.startPoint;i.next!=null&&i.next.next!=null;i=i.next)if(c.getTriangleOrientation(i.point,i.next.point,i.next.next.point)===2)return!1;return!0}static DistancePoint(t,e){let i=Number.MAX_VALUE;for(let r=0;r<t.count;r++){let n=c.distToLineSegment(e,t.points[r].point,t.points[(r+1)%t.count].point).dist;i=Math.min(i,n)}return i}GetTangentPoints(t,e){let i=new qs(this.GetSequenceDelegate(e),this.count);t.leftTangentPoint=i.FindMaximum(),t.rightTangentPoint=i.FindMinimum()}GetSequenceDelegate(t){let e=this.pnt(0);return i=>{let r=c.anglePCP(e,t,this.pnt(i));return r<Math.PI?r:r-2*Math.PI}}};var U=class{constructor(t,e,i,r){this.randomizationShift=.01;this.TightObstacles=new Set;this.Obstacles=t,this.TightPadding=e,this.LoosePadding=i,this.IgnoreTightPadding=r}ObstaclesIntersectLine(t,e){return this.ObstaclesIntersectICurve(S.mkPP(t,e))}static PadCorner(t,e,i,r,n){let o=U.GetPaddedCorner(e,i,r,n);return o.numberOfPoints===-1?!1:(t.addPoint(o.a),o.numberOfPoints===2&&t.addPoint(o.b),!0)}static CurveIsClockwise(t,e){return c.getTriangleOrientation(e,t.start,t.start.add(t.derivative(t.parStart)))==0}static PaddedPolylineBoundaryOfNode(t,e,i=!1){return U.CreatePaddedPolyline(p.polylineAroundClosedCurve(t),e,i)}static LoosePolylineWithFewCorners(t,e,i){return e<m.distanceEpsilon?t:U.CreateLoosePolylineOnBisectors(t,e,i)}static CreateLoosePolylineOnBisectors(t,e,i){let r=Array.from(U.BisectorPoints(t,e));i&&o();let n=yt.CalculateConvexHull(r);return R.mkClosedFromPoints(n);function o(){for(let s=0;s<r.length;s++){let a=r[s];r[s]=new c(a.x+(2*Qi()-1)*i,a.y+(2*Qi()-1)*i)}}}static CreateRectNodeOfPolyline(t){return Se(t,t.boundingBox)}CreateLooseObstacles(){this.tightPolylinesToLooseDistances=new Map,this.LooseObstacles=new Array;for(let t of this.TightObstacles){let e=U.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy,t,this.LoosePadding);this.tightPolylinesToLooseDistances.set(t,e),this.LooseObstacles.push(U.LoosePolylineWithFewCorners(t,e,this.randomizationShift))}this.RootOfLooseHierarchy=U.CalculateHierarchy(this.LooseObstacles)}CreateTightObstacles(){this.RootOfTightHierarchy=this.CreateTightObstacles_(),this.OverlapsDetected=this.TightObstacles.size<this.Obstacles.length}Calculate(){this.IgnoreTightPadding?this.CreateTightObstaclesIgnoringTightPadding():this.CreateTightObstacles(),this.IsEmpty()||this.CreateLooseObstacles()}IsEmpty(){return this.TightObstacles==null||this.TightObstacles.size===0}ObstaclesIntersectICurve(t){let e=t.boundingBox;return U.CurveIntersectsRectangleNode(t,e,this.RootOfTightHierarchy)}static CurveIntersectsRectangleNode(t,e,i){if(!i.irect.intersects(e))return!1;if(i.UserData!=null){let r=i.UserData;return p.intersectionOne(r,t,!1)!=null||U.PointIsInside(r.start,t)}return U.CurveIntersectsRectangleNode(t,e,i.Left)||U.CurveIntersectsRectangleNode(t,e,i.Right)}static PointIsInside(t,e){return p.PointRelativeToCurveLocation(t,e)===2}CreateTightObstaclesIgnoringTightPadding(){let t=this.Obstacles.map(r=>p.polylineAroundClosedCurve(r)),e=U.CalculateHierarchy(t),i=U.GetOverlappedPairSet(e);if(this.TightObstacles=new Set,i.size===0){for(let r of t){let n=U.FindMaxPaddingForTightPolyline(e,r,this.TightPadding);this.TightObstacles.add(U.LoosePolylineWithFewCorners(r,n,this.randomizationShift))}this.RootOfTightHierarchy=U.CalculateHierarchy(Array.from(this.TightObstacles))}else{for(let r of t)this.TightObstacles.add(U.CreatePaddedPolyline(r,this.TightPadding));if(!this.IsEmpty())for(this.RootOfTightHierarchy=U.CalculateHierarchy(Array.from(this.TightObstacles)),this.OverlapsDetected=!1;U.GetOverlappedPairSet(this.RootOfTightHierarchy).size>0;)this.RootOfTightHierarchy=U.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles,Array.from(i)),this.OverlapsDetected=!0}}CreateTightObstacles_(){if(this.Obstacles.length===0)return null;for(let t of this.Obstacles)U.CalculateTightPolyline(this.TightObstacles,this.TightPadding,t);return U.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles)}static CalculateTightPolyline(t,e,i){let r=U.PaddedPolylineBoundaryOfNode(i,e);t.add(r)}static CalculateHierarchy(t){let e=t.map(i=>U.CreateRectNodeOfPolyline(i));return ge(e)}static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t){let e=U.CalculateHierarchy(Array.from(t)),i;for(;(i=U.GetOverlappedPairSet(e)).size>0;)e=U.ReplaceTightObstaclesWithConvexHulls(t,Array.from(i));return e}static MapToInt(t){let e=new Map;for(let i=0;i<t.length;i++)e.set(t[i],i);return e}static ReplaceTightObstaclesWithConvexHulls(t,e){let i=new Set;for(let a of e)i.add(a[0]),i.add(a[1]);let r=Array.from(i),n=U.MapToInt(r),o=zs(Array.from(e).map(a=>new F(n.get(a[0]),n.get(a[1])))),s=Ti(o);for(let a of s){let u=a.map(g=>r[g]),h=Vi(u,g=>g),d=yt.createConvexHullAsClosedPolyline(h);for(let g of u)t.delete(g);t.add(d)}return U.CalculateHierarchy(Array.from(t))}static OneCurveLiesInsideOfOther(t,e){return p.PointRelativeToCurveLocation(t.start,e)!==0||p.PointRelativeToCurveLocation(e.start,t)!==0}static PolylinesIntersect(t,e){return p.CurvesIntersect(t,e)||U.OneCurveLiesInsideOfOther(t,e)}static GetOverlappedPairSet(t){let e=new Set;return Be(t,t,(i,r)=>{U.PolylinesIntersect(i,r)&&e.add([i,r])}),e}static*BisectorPoints(t,e){for(let i=t.startPoint;i!=null;i=i.next){let r={skip:!1},n=U.GetStickingVertexOnBisector(i,e,r);r.skip||(yield n)}}static GetStickingVertexOnBisector(t,e,i){let r=t.polyline.prev(t).point,n=t.point,o=t.polyline.next(t).point,s=n.sub(r).normalize().add(n.sub(o).normalize()),a=s.length;return a<m.tolerance?i.skip=!0:(i.skip=!1,s=s.div(a)),s.mul(e).add(n)}static FindMaxPaddingForTightPolyline(t,e,i){let r=i,n=new He(e),o=e.boundingBox.clone();o.pad(2*i);for(let s of Array.from(t.GetNodeItemsIntersectingRectangle(o)).filter(a=>a!==e)){let a=He.Distance(n,new He(s)).dist;r=Math.min(r,a/U.LooseDistCoefficient)}return r}static GetPaddedCorner(t,e,i,r){let n=t.point,o=e.point,s=i.point;if(c.getTriangleOrientation(n,o,s)===1)return{a:void 0,b:void 0,numberOfPoints:-1};let a=o.sub(n).rotate(Math.PI/2).normalize();if(U.CornerIsNotTooSharp(n,o,s)){a=a.mul(r);let P=s.sub(o).normalize().mul(r).rotate(Math.PI/2),y=c.lineLineIntersection(n.add(a),o.add(a),o.add(P),s.add(P));return{a:y,b:y,numberOfPoints:1}}let u=o.sub(n).normalize().add(o.sub(s).normalize());if(u.length<m.intersectionEpsilon){let P=o.add(a.mul(r));return{a:P,b:P,numberOfPoints:1}}let h=u.normalize().mul(r),d=h.rotate(Math.PI/2),g=(r-h.dot(a))/d.dot(a),f=d.mul(g);return{a:h.add(f).add(o),b:h.sub(f).add(o),numberOfPoints:2}}static CornerIsNotTooSharp(t,e,i){let r=t.sub(e).rotate(Math.PI/4).add(e);return c.getTriangleOrientation(e,r,i)===1}static CreatePaddedPolyline(t,e,i=!1){let r=new R,n=i?Sc(t):t;if(!U.PadCorner(r,n.endPoint.prev,n.endPoint,n.startPoint,e))return U.CreatePaddedPolyline(R.mkClosedFromPoints(Array.from(yt.CalculateConvexHull(n))),e);if(!U.PadCorner(r,n.endPoint,n.startPoint,n.startPoint.next,e))return U.CreatePaddedPolyline(R.mkClosedFromPoints(Array.from(yt.CalculateConvexHull(n))),e);for(let o=n.startPoint;o.next.next!=null;o=o.next)if(!U.PadCorner(r,o,o.next,o.next.next,e))return U.CreatePaddedPolyline(R.mkClosedFromPoints(Array.from(yt.CalculateConvexHull(n))),e);return r.closed=!0,r}},We=U;We.LooseDistCoefficient=2.1;function Sc(l){let t=new R,e=.01;for(let i=l.startPoint;i;i=i.next){let r=i.point.x+e*Qi(),n=i.point.y+e*Qi();t.addPointXY(r,n)}return t.closed=l.closed,t}var lo=class{get TightPolyline(){return this.tightPoly}set TightPolyline(t){this.tightPoly=t}static mk(t,e,i){let r=new lo;return r.TightPolyline=t,r.LooseShape=e,r.Distance=i,r}toString(){return(this.TightPolyline==null?"null":this.TightPolyline.toString().substring(0,5))+","+(this.LooseShape==null?"null":this.LooseShape.toString().substring(0,5))}};var uo=class{constructor(t,e,i,r){this.loosePolylinesToNodes=new Map;this.MainShape=t,this.TightPadding=e,this.LoosePadding=i,this.ShapesToTightLooseCouples=r}Calculate(t){Qr(3),this.MainShape.Children.length!==0&&(this.CreateTightObstacles(),this.CreateTigthLooseCouples(t),this.OverlapsDetected&&this.FillTheMapOfShapeToTightLooseCouples())}FillTheMapOfShapeToTightLooseCouples(){let t=ge(this.MainShape.Children.map(e=>Se(e,e.BoundingBox)));it(t,this.coupleHierarchy,this.TryMapShapeToTightLooseCouple.bind(this))}TryMapShapeToTightLooseCouple(t,e){uo.ShapeIsInsideOfPoly(t,e.TightPolyline)&&this.ShapesToTightLooseCouples.set(t,e)}static ShapeIsInsideOfPoly(t,e){return p.PointRelativeToCurveLocation(t.BoundaryCurve.start,e)===2}CreateTigthLooseCouples(t){let e=new Array;for(let i of this.tightHierarchy.GetAllLeaves()){let r=We.FindMaxPaddingForTightPolyline(this.tightHierarchy,i,this.LoosePadding),n=We.LoosePolylineWithFewCorners(i,r,t),o=new Ci(n),s=lo.mk(i,o,r);this.ShapesToTightLooseCouples.set(this.tightToShape.get(i),s),e.push(s)}this.coupleHierarchy=ge(e.map(i=>Se(i,i.TightPolyline.boundingBox)))}CreateTightObstacles(){this.tightToShape=new Map;let t=new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))),e=t.size;this.tightHierarchy=We.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t),this.OverlapsDetected=e>t.size}InitialTightPolyline(t){let e=We.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,this.TightPadding),i=Vi(this.LoosePolylinesUnderShape(t),n=>n).filter(n=>p.PointRelativeToCurveLocation(n,e)===0);if(i.length==0)return this.tightToShape&&this.tightToShape.set(e,t),e;let r=Array.from(e).concat(i);return e=R.mkClosedFromPoints(yt.CalculateConvexHull(r)),this.tightToShape&&this.tightToShape.set(e,t),e}LoosePolylinesUnderShape(t){return t.Children.map(e=>this.ShapesToTightLooseCouples.get(e).LooseShape.BoundaryCurve)}};var Au=J(Qe(),1);var js=class{constructor(t,e,i){this.indexToA=t,this.priority=e,this.v=i}};var nt=class{constructor(t=Q){this.heapSize=0;this.compare=t,this.cache=new Map,this.A=[]}get count(){return this.heapSize}ContainsElement(t){return this.cache.has(t)}SwapWithParent(t){let e=this.A[t>>1];this.PutAtI(t>>1,this.A[t]),this.PutAtI(t,e)}Enqueue(t,e){let i=++this.heapSize,r=new js(i,e,t);for(this.cache.set(t,r),this.A[i]=r;i>1&&this.compare(this.A[i>>1].priority,e)>0;)this.SwapWithParent(i),i>>=1}IsEmpty(){return this.heapSize===0}PutAtI(t,e){this.A[t]=e,e.indexToA=t}Dequeue(){if(this.heapSize===0)throw new Error("dequeue on an empty queue");let t=this.A[1].v;return this.MoveQueueOneStepForward(t),t}DequeueAndGetPriority(t){if(this.heapSize===0)throw new Error("dequeue on an empty queue");let e=this.A[1].v;return t.priority=this.A[1].priority,this.MoveQueueOneStepForward(e),e}MoveQueueOneStepForward(t){this.cache.delete(t),this.PutAtI(1,this.A[this.heapSize]);let e=1;for(;;){let i=e,r=e<<1;r<=this.heapSize&&this.compare(this.A[r].priority,this.A[e].priority)<0&&(i=r);let n=r+1;if(n<=this.heapSize&&this.compare(this.A[n].priority,this.A[i].priority)<0&&(i=n),i!==e)this.SwapWithParent(i);else break;e=i}this.heapSize--}DecreasePriority(t,e){let i=this.cache.get(t);if(!i)return;i.priority=e;let r=i.indexToA;for(;r>1&&this.compare(this.A[r].priority,this.A[r>>1].priority)<0;){this.SwapWithParent(r);r>>=1}}*GetEnumerator(){for(let t=1;t<=this.heapSize;t++)yield this.A[t].v}Peek(t){if(this.count===0){t.priority=0;return}return t.priority=this.A[1].priority,this.A[1].v}toString(){let t=new Au.StringBuilder;for(let e of this.A)t.Append(e+",");return t.ToString()}};var gr=class{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY;this._visGraph=i,this._visGraph.ClearPrevEdgesTable();for(let r of i.Vertices())r.Distance=Number.POSITIVE_INFINITY;this.source=t,this.targets=new Set(e),this.source.Distance=0}GetPath(){let t=new nt(Q);for(this.source.Distance=0,t.Enqueue(this.source,0);!t.IsEmpty()&&(this.current=t.Dequeue(),!this.targets.has(this.current));){for(let e of this.current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(let e of this.current.InEdges)this.PassableInEdge(e)&&this.ProcessNeighbor(t,e,e.Source)}return this._visGraph.PreviosVertex(this.current)==null?null:this.CalculatePath()}PassableOutEdge(t){return t.Source===this.source||this.targets.has(t.Target)||!gr.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||t.Target===this.source||!gr.IsForbidden(t)}static IsForbidden(t){return t.IsPassable!=null&&!t.IsPassable()||t instanceof Xe}ProcessNeighbor(t,e,i){let r=e.Length,n=this.current.Distance+r;n>=this.upperBound||(this.targets.has(i)&&(this.upperBound=n,this.closestTarget=i),i!==this.source&&this._visGraph.PreviosVertex(i)==null?(i.Distance=n,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,n)):n<i.Distance&&(i.Distance=n,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,n)))}CalculatePath(){if(this.closestTarget==null)return null;let t=new Array,e=this.closestTarget;do t.push(e),e=this._visGraph.PreviosVertex(e);while(e!==this.source);return t.push(this.source),t.reverse()}};var Rn=class{constructor(t,e,i){this._lengthMultiplier=1;this._lengthMultiplierForAStar=1;this._visGraph=t,this._source=e,this._target=i,this._source.Distance=0}get LengthMultiplier(){return this._lengthMultiplier}set LengthMultiplier(t){this._lengthMultiplier=t}get LengthMultiplierForAStar(){return this._lengthMultiplierForAStar}set LengthMultiplierForAStar(t){this._lengthMultiplierForAStar=t}GetPath(t){let e=new nt(Q);for(this._source.Distance=0,this._target.Distance=Number.POSITIVE_INFINITY,e.Enqueue(this._source,this.H(this._source));!e.IsEmpty();){let i={priority:0},r=e.DequeueAndGetPriority(i);if(i.priority>=this._target.Distance)break;for(let n of r.OutEdges)if(this.PassableOutEdge(n)){let o=n.Target;this.ProcessNeighbor(e,r,n,o)}for(let n of r.InEdges)if(this.PassableInEdge(n)){let o=n.Source;this.ProcessNeighbor(e,r,n,o)}}return this._visGraph.PreviosVertex(this._target)==null?null:this.CalculatePath(t)}PassableOutEdge(t){return t.Source===this._source||t.Target===this._target||!Rn.IsForbidden(t)}PassableInEdge(t){return t.Source===this._target||t.Target===this._source||!Rn.IsForbidden(t)}static IsForbidden(t){return t.IsPassable!=null&&!t.IsPassable()||t instanceof Xe}ProcessNeighborN(t,e,i,r,n){let o=i.Length+n,s=e.Distance+o;r!==this._source&&this._visGraph.PreviosVertex(r)==null?(r.Distance=s,this._visGraph.SetPreviousEdge(r,i),r!==this._target&&t.Enqueue(r,this.H(r))):r!==this._source&&s<r.Distance&&(r.Distance=s,this._visGraph.SetPreviousEdge(r,i),r!==this._target&&t.DecreasePriority(r,this.H(r)))}ProcessNeighbor(t,e,i,r){let n=i.Length,o=e.Distance+n;r!==this._source&&this._visGraph.PreviosVertex(r)==null?(r.Distance=o,this._visGraph.SetPreviousEdge(r,i),r!==this._target&&t.Enqueue(r,this.H(r))):r!==this._source&&o<r.Distance&&(r.Distance=o,this._visGraph.SetPreviousEdge(r,i),r!==this._target&&t.DecreasePriority(r,this.H(r)))}H(t){return t.Distance+t.point.sub(this._target.point).length*this.LengthMultiplierForAStar}CalculatePath(t){let e=new Array,i=this._target;do e.push(i),t&&this._visGraph.ShrinkLengthOfPrevEdge(i,this.LengthMultiplier),i=this._visGraph.PreviosVertex(i);while(i!==this._source);return e.push(this._source),e.reverse()}};var wu=J(Qe(),1),Wo=class{toString(){return wu.String.Format("{0},{1}",this.Start,this.End)}get Start(){return this.leftTangent.End.point}get End(){return this.rightTangent.End.point}constructor(t,e){this.LeftTangent=t,this.RightTangent=e}get LeftTangent(){return this.leftTangent}set LeftTangent(t){this.leftTangent=t}get RightTangent(){return this.rightTangent}set RightTangent(t){this.rightTangent=t}get RbNode(){return this.rbNode}set RbNode(t){this.rbNode=t}};var Ou=J(Qe(),1),zo=class{get Comp(){return this.comp}set Comp(t){this.comp=t}get IsHigh(){return!this.IsLow}get IsLow(){return this.lowTangent}set IsLow(t){this.lowTangent=t}get SeparatingPolygons(){return this.separatingPolygons}set SeparatingPolygons(t){this.separatingPolygons=t}get Diagonal(){return this.diagonal}set Diagonal(t){this.diagonal=t}get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}constructor(t,e){this.start=t,this.End=e}toString(){return Ou.String.Format("{0},{1}",this.Start,this.End)}};var qo=class{get PointOnTangentAndInsertedDiagonal(){return this.pointOnTheRay}set PointOnTangentAndInsertedDiagonal(t){this.pointOnTheRay=t}Compare(t,e){if(t.Start.equal(e.Start))return 0;switch(c.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal,e.Start,e.End)){case 1:return-1;default:return 1}}static BelongsToTheDiagonal(t,e,i){return c.closeDistEps(t,c.ClosestPointAtLineSegment(t,e,i))}static IntersectDiagonalWithRay(t,e,i){let r=e.sub(t),n=i.Start,o=i.End,s=si.solve(o.x-n.x,r.x*-1,t.x-n.x,o.y-n.y,r.y*-1,t.y-n.y);return t.add(r.mul(s.y))}};var Xi=class{constructor(t){this.pivot=t}IComparer(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=t.Start.point.sub(this.pivot),r=e.Start.point.sub(this.pivot);return Xi.CompareVectorsByAngleToXAxis(i,r)}static CompareVectorsByAngleToXAxis(t,e){return t.y>=0?e.y<0?-1:Xi.CompareVectorsPointingToTheSameYHalfPlane(t,e):e.y>=0?1:Xi.CompareVectorsPointingToTheSameYHalfPlane(t,e)}static CompareVectorsPointingToTheSameYHalfPlane(t,e){let i=t.x*e.y-t.y*e.x;if(i>m.tolerance)return-1;if(i<-m.tolerance)return 1;if(t.x>=0){if(e.x<0)return-1}else if(e.x>=0)return 1;let r=Math.abs(t.x)-Math.abs(e.x);return r<0?-1:r>0?1:(r=Math.abs(t.y)-Math.abs(e.y),r<0?-1:r>0?1:0)}};var Ai=class extends H{constructor(e,i,r){super(null);this.polygons=[];this.activeDiagonalComparer=new qo;this.polygons=e,this.visibilityGraph=r,this.addedPolygons=i}run(){this.useLeftPTangents=!0,this.CalculateAndAddEdges(),this.useLeftPTangents=!1,this.CalculateAndAddEdges()}CalculateAndAddEdges(){for(let e of this.addedPolygons)this.CalculateVisibleTangentsFromPolygon(e);this.ProgressStep()}CalculateVisibleTangentsFromPolygon(e){this.currentPolygon=e,this.AllocateDataStructures(),this.OrganizeTangents(),this.InitActiveDiagonals(),this.Sweep()}AllocateDataStructures(){this.tangents=new Array,this.diagonals=new Array,this.activeDiagonalTree=new Ee(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer))}Sweep(){if(!(this.tangents.length<2))for(let e=1;e<this.tangents.length;e++){let i=this.tangents[e];i.Diagonal!=null?(i.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(i),i.IsHigh&&this.RemoveDiagonalFromActiveNodes(i.Diagonal)):i.IsLow&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=i.End.point,this.InsertActiveDiagonal(new Wo(i,i.Comp)),i.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(i))}}AddVisibleEdge(e){se.AddEdgeVV(Lu(this.visibilityGraph,e.start),Lu(this.visibilityGraph,e.End))}InitActiveDiagonals(){if(this.tangents.length===0)return;let e=this.tangents[0],i=e.start.point,r=e.End.point;for(let n of this.diagonals)Ai.RayIntersectDiagonal(i,r,n)&&(this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal=qo.IntersectDiagonalWithRay(i,r,n),this.InsertActiveDiagonal(n));if(e.Diagonal.RbNode===this.activeDiagonalTree.treeMinimum()&&this.AddVisibleEdge(e),e.IsLow===!1){let n=e.Diagonal;this.RemoveDiagonalFromActiveNodes(n)}}RemoveDiagonalFromActiveNodes(e){let i=this.activeDiagonalTree.deleteSubTree(e.RbNode);i!=null&&i.item!=null&&(i.item.RbNode=i),e.LeftTangent.Diagonal=null,e.RightTangent.Diagonal=null}InsertActiveDiagonal(e){e.RbNode=this.activeDiagonalTree.insert(e),Ai.MarkDiagonalAsActiveInTangents(e)}static MarkDiagonalAsActiveInTangents(e){e.LeftTangent.Diagonal=e,e.RightTangent.Diagonal=e}static RayIntersectDiagonal(e,i,r){let n=r.Start,o=r.End;return c.getTriangleOrientation(e,n,o)===1&&c.getTriangleOrientation(e,i,n)!==1&&c.getTriangleOrientation(e,i,o)!==0}static TangentComparison(e,i){return Xi.CompareVectorsByAngleToXAxis(e.End.point.sub(e.start.point),i.End.point.sub(i.start.point))}*AllObstacles(){for(let e of this.addedPolygons)yield e;if(this.polygons)for(let e of this.polygons)yield e}OrganizeTangents(){for(let e of this.AllObstacles())e!==this.currentPolygon&&this.ProcessPolygonQ(e);this.tangents.sort(Ai.TangentComparison)}ProcessPolygonQ(e){let i=new Xr(this.currentPolygon,e);this.useLeftPTangents?i.CalculateLeftTangents():i.CalculateRightTangents();let r=this.useLeftPTangents?i.leftPLeftQ:i.rightPLeftQ,n=new zo(this.currentPolygon.pp(r[0]),e.pp(r[1]));n.IsLow=!0,n.SeparatingPolygons=!this.useLeftPTangents,r=this.useLeftPTangents?i.leftPRightQ:i.rightPRightQ;let o=new zo(this.currentPolygon.pp(r[0]),e.pp(r[1]));o.IsLow=!1,o.SeparatingPolygons=this.useLeftPTangents,n.Comp=o,o.Comp=n,this.tangents.push(n),this.tangents.push(o),this.diagonals.push(new Wo(n,o))}};function Lu(l,t){return l.FindVertex(t.point)}var ho=class{get Pivot(){return this.pivot}set Pivot(t){this.pivot=t}get IntersectionOfTheRayAndInsertedEdge(){return this.pointOnTheRay}set IntersectionOfTheRayAndInsertedEdge(t){this.pointOnTheRay=t}Compare(t,e){switch(c.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge,e.point,e.nextOnPolyline.point)){case 1:return-1;default:return 1}}IntersectionPointBelongsToTheInsertedEdge(t){let e=t.point.sub(this.IntersectionOfTheRayAndInsertedEdge),i=t.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);return Math.abs(e.x*i.y-i.x*e.y)<m.distanceEpsilon}IntersectEdgeWithRayPPP(t,e,i){let r=si.solve(e.x-t.x,-i.x,this.Pivot.x-t.x,e.y-t.y,-i.y,this.Pivot.y-t.y);if(!(-m.tolerance<=r.x&&r.x<=1+m.tolerance))throw new Error;if(!r)throw new Error;return this.Pivot.add(i.mul(r.y))}IntersectEdgeWithRay(t,e){return this.IntersectEdgeWithRayPPP(t.point,t.nextOnPolyline.point,e)}static constructorPP(t,e){let i=new ho;return i.pivot=t,i.pointOnTheRay=e,i}};var Ru=J(Qe(),1),_r=class{get Start(){return this.start}set Start(t){this.start=t}get End(){return this.end}set End(t){this.end=t}constructor(t,e){this.start=t,this.end=e}*Sides(){let t=this.start;for(;t!==this.end;){let e=t;yield e,t=e.nextOnPolyline}}MoveStartClockwise(){return this.Start!==this.End?(this.Start=this.Start.nextOnPolyline,!0):!1}toString(){return Ru.String.Format("Stem({0},{1})",this.Start,this.End)}};var li=class{constructor(t,e,i,r){this.sideNodes=new Map;this.visibleBoundaries=new Map;this.sortedListOfPolypoints=new Array;this.holes=Array.from(t),this.visibilityGraph=e,this.q=i,this.qPolylinePoint=Ne.mkFromPoint(this.q),this.QVertex=this.visibilityGraph.AddVertexP(this.qPolylinePoint.point),this.visibilityKind=r;let n=new Xi(this.q);this.heapForSorting=new Fr(n.IComparer.bind(n))}get QVertex(){return this.qV}set QVertex(t){this.qV=t}static CalculatePointVisibilityGraph(t,e,i,r){let n=e.FindVertex(i);if(n!=null)return n;let o=new li(t,e,i,r);return o.FillGraph(),o.QVertex}FillGraph(){this.ComputeHoleBoundariesPossiblyVisibleFromQ(),this.visibleBoundaries.size>0&&(this.SortSAndInitActiveSides(),this.Sweep())}SortSAndInitActiveSides(){this.InitHeapAndInsertActiveSides();for(let t=this.heapForSorting.GetMinimum();this.sortedListOfPolypoints.push(t.Start),t.MoveStartClockwise()?this.heapForSorting.ChangeMinimum(t):this.heapForSorting.Dequeue(),this.heapForSorting.Count!==0;t=this.heapForSorting.GetMinimum());}InitHeapAndInsertActiveSides(){for(let t of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())this.heapForSorting.Enqueue(t)}*GetInitialVisibleBoundaryStemsAndInsertActiveSides(){for(let[t,e]of this.visibleBoundaries){let i=!1;for(let r of e.Sides()){let n=r;if(n.point.y<this.q.y){if(r.nextOnPolyline.point.y>=this.q.y){let o=c.getTriangleOrientation(this.q,n.point,r.nextOnPolyline.point);if(o===1||o===2){i=!0,yield new _r(e.Start,r),yield new _r(r.nextOnPolyline,e.End),this.RegisterActiveSide(r);break}}}else{if(n.point.y>this.q.y)break;if(r.point.x>=this.q.x){i=!0,yield new _r(r,e.End),r!==e.Start&&(yield new _r(e.Start,t.prev(n))),this.RegisterActiveSide(r);break}}}i||(yield e)}}RegisterActiveSide(t){this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=this.activeEdgeComparer.IntersectEdgeWithRay(t,new c(1,0)),this.sideNodes.set(t,this.activeSidesTree.insert(t))}Sweep(){for(let t of this.sortedListOfPolypoints)this.SweepPolylinePoint(t)}SweepPolylinePoint(t){let e=li.GetIncomingSide(t),i=this.GetOutgoingSide(t);this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge=t.point;let r;if(r=this.sideNodes.get(e)){if(r===this.activeSidesTree.treeMinimum()&&this.AddEdge(t),i!=null)r.item=i,this.sideNodes.set(i,r);else{let n=this.activeSidesTree.deleteSubTree(r);n!=null&&n.item!=null&&this.sideNodes.set(n.item,n)}this.sideNodes.delete(e)}else if(i!=null){let n;(n=this.sideNodes.get(i))||(n=this.activeSidesTree.insert(i),this.sideNodes.set(i,n),n===this.activeSidesTree.treeMinimum()&&this.AddEdge(t))}else throw new Error}AddEdge(t){(this.visibilityKind===0||this.visibilityKind===1&&li.LineTouchesPolygon(this.QVertex.point,t))&&this.visibilityGraph.AddEdgeF(this.QVertex.point,t.point,(e,i)=>new Xe(e,i))}static LineTouchesPolygon(t,e){let i=e.polyline.prev(e).point,r=e.polyline.next(e).point,n=e.point;return c.signedDoubledTriangleArea(t,n,i)*c.signedDoubledTriangleArea(t,n,r)>=0}GetOutgoingSide(t){let e=this.visibleBoundaries.get(t.polyline);return t===e.End?null:t}static GetIncomingSide(t){return t.prevOnPolyline}ComputeHoleBoundariesPossiblyVisibleFromQ(){this.InitActiveEdgesAndActiveEdgesComparer();for(let t of this.holes)this.ComputeVisiblePartOfTheHole(t)}InitActiveEdgesAndActiveEdgesComparer(){this.activeEdgeComparer=new ho,this.activeEdgeComparer.pivot=this.q,this.activeSidesTree=new Ee(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer))}ComputeVisiblePartOfTheHole(t){let e,i=!0;for(e=t.startPoint;!this.HoleSideIsVisibleFromQ(t,e);e=t.next(e))i=!1;let r=t.next(e);if(i)for(;this.HoleSideIsVisibleFromQ(t,t.prev(e));)e=t.prev(e);for(;this.HoleSideIsVisibleFromQ(t,r);r=t.next(r));this.visibleBoundaries.set(t,new _r(e,r))}HoleSideIsVisibleFromQ(t,e){return c.signedDoubledTriangleArea(this.q,e.point,t.next(e).point)>=-m.squareOfDistanceEpsilon}};var re=class extends H{constructor(){super(...arguments);this.IgnoreTightPadding=!0;this.activeRectangle=I.mkEmpty();this.activePolygons=new Array;this.alreadyAddedOrExcludedPolylines=new Set;this.UseEdgeLengthMultiplier=!1;this.UseInnerPolylingShortcutting=!0;this.UsePolylineEndShortcutting=!0;this.AllowedShootingStraightLines=!0;this.LookForRoundedVertices=!1}rerouteEdge(e){if(e.smoothedPolyline==null)return;let i=R.mkFromPoints(e.smoothedPolyline);this.pathOptimizer.run(i),e.curve=this.pathOptimizer.poly.toCurve()}static constructorANNN(e,i,r,n){return re.constructorANNNB(e,i,r,n,!1)}get Obstacles(){return this.obstacles_}set Obstacles(e){this.obstacles_=e}get EnteringAngleBound(){return this.enteringAngleBound_}set EnteringAngleBound(e){this.enteringAngleBound_=e}get SourceTightPolyline(){return this._sourceTightPolyline}set SourceTightPolyline(e){this._sourceTightPolyline=e}get TargetTightPolyline(){return this.targetTightPolyline}set TargetTightPolyline(e){this.targetTightPolyline=e}get TargetLoosePolyline(){return this.targetLoosePolyline}set TargetLoosePolyline(e){this.targetLoosePolyline=e}get VisibilityGraph(){return this.visibilityGraph}set VisibilityGraph(e){this.visibilityGraph=e}get SourcePort(){return this.sourcePort}set SourcePort(e){if(this.sourcePort=e,this.sourcePort!=null)if(this.SourceTightPolyline=re.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof Ue)this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location;else{let i=this.sourcePort;this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(i.Curve,i.Parameter,this.SourceLoosePolyline)}}get TargetPort(){return this.targetPort}set TargetPort(e){this.targetPort=e}get LoosePadding(){return this.loosePadding}set LoosePadding(e){this.loosePadding=e,this.ObstacleCalculator!=null&&(this.ObstacleCalculator.LoosePadding=e)}get OffsetForPolylineRelaxing(){return this.TightPadding*.75}get StartPointOfEdgeRouting(){return this.startPointOfRouting_}set StartPointOfEdgeRouting(e){this.startPointOfRouting_=e}ExtendVisibilityGraphToLocation(e){this.VisibilityGraph==null&&(this.VisibilityGraph=new se);let i=null;if(!this.activeRectangle.contains(e)){this.activeRectangle.isEmpty?this.activeRectangle=I.mkPP(this.SourcePort.Location,e):this.activeRectangle.add(e),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let r of i)this.VisibilityGraph.AddHole(r.Polyline)}i==null||i.length===0?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(e)):(this.RemovePointVisibilityGraphs(),new Ai(i,this.activePolygons,this.VisibilityGraph).run(),Bi(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraph(e),this.CalculateSourcePortVisibilityGraph())}RemovePointVisibilityGraphs(){this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.sourceVV!=null&&this.VisibilityGraph.RemoveVertex(this.sourceVV)}CalculateEdgeTargetVisibilityGraph(e){this.targetVV=li.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,e,1)}CalculateSourcePortVisibilityGraph(){this.sourceVV=li.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()),this.VisibilityGraph,this.StartPointOfEdgeRouting,1)}TakeBoundaryPortOutsideOfItsLoosePolyline(e,i,r){let n=e.value(i),o=e.leftDerivative(i).normalize().add(e.rightDerivative(i).normalize()).normalize();c.getTriangleOrientation(re.PointInsideOfConvexCurve(e),n,n.add(o))==1&&(o=o.mul(-1)),o=o.rotate(Math.PI/2);let s=r.boundingBox.diagonal,a=S.mkPP(n,n.add(o.mul(s))),u=p.intersectionOne(a,r,!1).x,h=o.mul(u.sub(n).length/2);for(;;){a=S.mkPP(n,u.add(h));let d=!1;for(let g of re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(a,this.ObstacleCalculator.RootOfLooseHierarchy))if(g.seg1!==r){h=h.div(1.5),d=!0;break}if(!d)break}return a.end}static PointInsideOfConvexCurve(e){return e.value(0).add(e.value(1.5)).div(2)}*GetActivePolylines(){for(let e of this.activePolygons)yield e.Polyline}GetAddedPolygonesAndMaybeExtendActiveRectangle(){let e=this.activeRectangle,i=new Array,r;do{r=!1;for(let n of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))this.alreadyAddedOrExcludedPolylines.has(n)||(e.addRec(n.boundingBox),i.push(new He(n)),this.alreadyAddedOrExcludedPolylines.add(n),r=!0);r&&(this.activeRectangle=e)}while(r);return i}PolylineSegmentIntersectsTightHierarchy(e,i){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(e,i,this.ObstacleCalculator.RootOfTightHierarchy)}PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(e,i,r){return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(S.mkPP(e,i),r)}PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i){if(!e.boundingBox.intersects(i.irect))return!1;if(i.UserData!=null){for(let r of p.getAllIntersections(e,i.UserData,!1))if(r.seg1!==this.SourceTightPolyline&&r.seg1!==this.TargetTightPolyline||(r.seg1===this.SourceTightPolyline&&this.SourcePort)instanceof tt||(r.seg1===this.TargetTightPolyline&&this.TargetPort)instanceof tt)return!0;return!1}return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i.Left)||this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(e,i.Right)}static IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,i){let r=new Array;return re.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i,r),r}static IntersectionsOfLineAndRectangleNodeOverPolyline(e,i,r){if(i!=null&&!!e.boundingBox.intersects(i.irect)){if(i.UserData!=null){Bi(r,p.getAllIntersections(e,i.UserData,!0));return}re.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i.Left,r),re.IntersectionsOfLineAndRectangleNodeOverPolyline(e,i.Right,r)}}LineCanBeAcceptedForRouting(e){let i=this.SourcePort instanceof Ue,r=this.TargetPort instanceof Ue;if(!i&&!this.targetIsInsideOfSourceTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(e.end,this.SourcePort)||!r&&this.TargetPort!=null&&!this.sourceIsInsideOfTargetTightPolyline&&!this.InsideOfTheAllowedConeOfBoundaryPort(e.start,this.TargetPort))return!1;let n=re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy);for(let o of n)if(o.seg1!==this.SourceTightPolyline&&o.seg1!==this.targetTightPolyline)return!1;return!0}InsideOfTheAllowedConeOfBoundaryPort(e,i){let r=i.Curve,n=We.CurveIsClockwise(r,re.PointInsideOfConvexCurve(r)),o=i.Location,s=this.GetPointOnTheRightBoundaryPortConeSide(o,r,n,i.Parameter),a=this.GetPointOnTheLeftBoundaryPortConeSide(o,r,n,i.Parameter);return c.getTriangleOrientation(o,s,e)!==0&&c.getTriangleOrientation(o,e,a)!==0}GetPointOnTheRightBoundaryPortConeSide(e,i,r,n){let o=r?i.rightDerivative(n):i.leftDerivative(n).neg();return e.add(o.rotate(this.EnteringAngleBound))}GetPointOnTheLeftBoundaryPortConeSide(e,i,r,n){let o=r?i.leftDerivative(n).neg():i.rightDerivative(n);return e.add(o.rotate(-this.EnteringAngleBound))}SmoothenCorners(e){let i=e.headSite,r={b:null,c:null};for(;r=p.findCorner(i);)i=this.SmoothOneCorner(i,r.c,r.b)}SmoothOneCorner(e,i,r){let s=.5,a,u,h;e.prev==null?(h=2,u=1):i.next==null?(h=1,u=2):h=u=1;do a=p.createBezierSeg(s*h,s*u,e,r,i),r.previouisBezierCoefficient=s*h,r.nextBezierCoefficient=s*u,s/=1.5;while(d()>this.loosePadding&&s>.01);return s*=1.5,s<.5&&s>.01&&(s=.5*(s+s*1.5),a=p.createBezierSeg(s*h,s*u,e,r,i),d()>this.loosePadding&&(r.previouisBezierCoefficient=s*h,r.nextBezierCoefficient=s*u)),r;function d(){let g=a.closestParameter(r.point);return r.point.sub(a.value(g)).length}}TryToRemoveInflectionsAndCollinearSegments(e){let i=!0,r={s:null};for(;i;)for(i=!1,r.s=e.headSite;r.s!=null&&r.s.next!=null;r.s=r.s.next)r.s.turn*r.s.next.turn<0&&(i=this.TryToRemoveInflectionEdge(r)||i)}TryToRemoveInflectionEdge(e){if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.prev.point,e.s.next.point)){let i=e.s.prev,r=e.s.next;return i.next=r,r.prev=i,e.s=i,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.prev.point,e.s.next.next.point)){let i=e.s.prev,r=e.s.next.next;return i.next=r,r.prev=i,e.s=i,!0}if(!this.ObstacleCalculator.ObstaclesIntersectLine(e.s.point,e.s.next.next.point)){let i=e.s.next.next;return e.s.next=i,i.prev=e.s,!0}return!1}GetShortestPolyline(e,i){this.CleanTheGraphForShortestPath();let n=new Rn(this.visibilityGraph,e,i).GetPath(this.UseEdgeLengthMultiplier);if(n==null)return null;let o=R.mkFromPoints(Array.from(n).map(s=>s.point)).RemoveCollinearVertices();return this.pathOptimizer&&(this.pathOptimizer.run(o),o=this.pathOptimizer.poly),o}CleanTheGraphForShortestPath(){this.visibilityGraph.ClearPrevEdgesTable()}get OverlapsDetected(){return this.ObstacleCalculator.OverlapsDetected}get TightHierarchy(){return this.ObstacleCalculator.RootOfTightHierarchy}set TightHierarchy(e){this.ObstacleCalculator.RootOfTightHierarchy=e}get LooseHierarchy(){return this.ObstacleCalculator.RootOfLooseHierarchy}set LooseHierarchy(e){this.ObstacleCalculator.RootOfLooseHierarchy=e}CalculateObstacles(){this.ObstacleCalculator=new We(this.Obstacles,this.TightPadding,this.LoosePadding,this.IgnoreTightPadding),this.ObstacleCalculator.Calculate()}static constructorANNNB(e,i,r,n,o){let s=new re(null);return s.IgnoreTightPadding=o,s.EnteringAngleBound=80*(Math.PI/180),s.TightPadding=i,s.LoosePadding=r,n>0?(X.assert(n>Math.PI/180),X.assert(n<=90*(Math.PI/180)),s.UseSpanner=!0,s.ExpectedProgressSteps=Ui.GetTotalSteps(n)):s.ExpectedProgressSteps=e.length,s.ConeSpannerAngle=n,s.Obstacles=e,s.CalculateObstacles(),s}RouteEdgeToLocation(e){this.TargetPort=new Ue(null,e),this.TargetTightPolyline=null,this.TargetLoosePolyline=null;let i=new Pe(null),r=S.mkPP(this.SourcePort.Location,e);return this.LineCanBeAcceptedForRouting(r)?(this._polyline=new R,this._polyline.addPoint(r.start),this._polyline.addPoint(r.end),i.smoothedPolyline=oe.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i):this.SourcePort instanceof tt&&(r=S.mkPP(this.StartPointOfEdgeRouting,e),re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(r,this.ObstacleCalculator.RootOfTightHierarchy).length==0)?(this._polyline=new R,this._polyline.addPoint(this.SourcePort.Location),this._polyline.addPoint(r.start),this._polyline.addPoint(r.end),i.smoothedPolyline=oe.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i):(this.ExtendVisibilityGraphToLocation(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this.SourcePort instanceof tt&&this._polyline.PrependPoint(this.SourcePort.Location),i.smoothedPolyline=oe.mkFromPoints(this._polyline),i.curve=i.smoothedPolyline.createCurve(),i)}RouteEdgeToPort(e,i,r,n){return this.ObstacleCalculator.IsEmpty()?this.sourcePort!=null&&this.targetPort!=null?(n.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location,this.targetPort.Location),S.mkPP(this.sourcePort.Location,this.targetPort.Location)):null:(this.TargetPort=e,this.TargetTightPolyline=re.GetFirstHitPolyline(e.Location,this.ObstacleCalculator.RootOfTightHierarchy),e instanceof tt?this.RouteEdgeToBoundaryPort(i,r,n):this.RouteEdgeToFloatingPortOfNode(i,r,n))}SmoothedPolylineFromTwoPoints(e,i){return this._polyline=new R,this._polyline.addPoint(e),this._polyline.addPoint(i),oe.mkFromPoints(this._polyline)}RouteEdgeToFloatingPortOfNode(e,i,r){return this.sourcePort instanceof Ue?this.RouteFromFloatingPortToFloatingPort(e,i,r):this.RouteFromBoundaryPortToFloatingPort(e,i,r)}RouteFromBoundaryPortToFloatingPort(e,i,r){let n=this.SourcePort.Location,o=this.targetPort.Location,s=S.mkPP(n,o);if(this.LineCanBeAcceptedForRouting(s))return r.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),s;if(!this.targetIsInsideOfSourceTightPolyline){let u=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.SourcePort.Parameter,this.SourceLoosePolyline);if(s=S.mkPP(u,o),this.LineAvoidsTightHierarchyLP(s,e))return r.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),s}this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);let a=this.SourceTightPolyline;return this.targetIsInsideOfSourceTightPolyline||(this.SourceTightPolyline=null),this.SourceTightPolyline=a,this._polyline.PrependPoint(n),this.SmoothCornersAndReturnCurve(i,r)}SmoothCornersAndReturnCurve(e,i){return i.smoothedPolyline=oe.mkFromPoints(this._polyline),e&&this.SmoothenCorners(i.smoothedPolyline),i.smoothedPolyline.createCurve()}RouteFromFloatingPortToFloatingPort(e,i,r){return this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(e),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this._polyline==null?null:(r.smoothedPolyline=oe.mkFromPoints(this._polyline),this.SmoothCornersAndReturnCurve(i,r))}TryShortcutPolyPoint(e){return this.LineAvoidsTightHierarchyLPP(S.mkPP(e.point,e.next.next.point),this.SourceTightPolyline,this.targetTightPolyline)?(e.next=e.next.next,e.next.prev=e,!0):!1}ExtendVisibilityGraphToLocationOfTargetFloatingPort(e){this.VisibilityGraph==null&&(this.VisibilityGraph=new se);let i=null,r=this.targetPort.Location;if(!this.activeRectangle.contains(r)){this.activeRectangle.isEmpty?this.activeRectangle=I.mkPP(this.SourcePort.Location,r):this.activeRectangle.add(r),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let n of i)this.VisibilityGraph.AddHole(n.Polyline)}i==null?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(r,e),this.sourceVV==null&&this.CalculateSourcePortVisibilityGraph()):(this.RemovePointVisibilityGraphs(),new Ai(i,this.activePolygons,this.VisibilityGraph).run(),Bi(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraphForFloatingPort(r,e),this.CalculateSourcePortVisibilityGraph())}CalculateEdgeTargetVisibilityGraphForFloatingPort(e,i){this.UseSpanner?this.targetVV=this.AddTransientVisibilityEdgesForPort(e,i):this.targetVV=li.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(i),this.VisibilityGraph,e,1)}AddTransientVisibilityEdgesForPort(e,i){let r=this.GetVertex(e);if(r!=null)return r;if(r=this.visibilityGraph.AddVertexP(e),i!=null)for(let n of i)this.visibilityGraph.AddEdgeF(e,n,(o,s)=>new Xe(o,s));else r=li.CalculatePointVisibilityGraph(this.GetActivePolylines(),this.VisibilityGraph,e,1);return r}GetVertex(e){let i=this.visibilityGraph.FindVertex(e);return i==null&&this.LookForRoundedVertices&&(i=this.visibilityGraph.FindVertex(c.RoundPoint(e))),i}*GetActivePolylinesWithException(e){for(let i of this.activePolygons)i.Polyline!==e&&(yield i.Polyline)}RouteEdgeToBoundaryPort(e,i,r){return this.TargetLoosePolyline=e,this.sourcePort instanceof Ue?this.RouteFromFloatingPortToBoundaryPort(i,r):this.RouteFromBoundaryPortToBoundaryPort(i,r)}RouteFromBoundaryPortToBoundaryPort(e,i){let r=this.SourcePort.Location,n,o=this.targetPort.Location,s=S.mkPP(r,o);if(this.LineCanBeAcceptedForRouting(s))this._polyline=new R,this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(s.start,s.end),n=oe.mkFromPoints(this._polyline).createCurve();else{let a=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve,this.targetPort.Parameter,this.TargetLoosePolyline);if(s=S.mkPP(r,a),this.InsideOfTheAllowedConeOfBoundaryPort(a,this.SourcePort)&&this.LineAvoidsTightHierarchyLP(s,this._sourceTightPolyline))this._polyline=new R,this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),this._polyline.addPoint(o),n=this.SmoothCornersAndReturnCurve(e,i);else if(s=S.mkPP(this.StartPointOfEdgeRouting,o),this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting,this.TargetPort)&&this.LineAvoidsTightHierarchy(s))this._polyline=new R,this._polyline.addPoint(r),this._polyline.addPoint(s.start),this._polyline.addPoint(s.end),n=this.SmoothCornersAndReturnCurve(e,i);else{let u;if(u=S.IntersectPPPP(r,this.StartPointOfEdgeRouting,o,a))this._polyline=new R,this._polyline.addPoint(r),this._polyline.addPoint(u),this._polyline.addPoint(o),n=this.SmoothCornersAndReturnCurve(e,i);else if(c.closeDistEps(this.StartPointOfEdgeRouting,a))this._polyline=new R,this._polyline.addPoint(r),this._polyline.addPoint(a),this._polyline.addPoint(o),n=this.SmoothCornersAndReturnCurve(e,i);else if(this.LineAvoidsTightHierarchy(S.mkPP(this.StartPointOfEdgeRouting,a)))this._polyline=new R,this._polyline.addPoint(r),this._polyline.addPoint(this.StartPointOfEdgeRouting),this._polyline.addPoint(a),this._polyline.addPoint(o),n=this.SmoothCornersAndReturnCurve(e,i);else{this.ExtendVisibilityGraphToTargetBoundaryPort(a),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV);let h={tmpTargetTight:null},d=this.HideSourceTargetTightsIfNeeded(h);this.RecoverSourceTargetTights(d,h.tmpTargetTight),this._polyline.PrependPoint(r),this._polyline.addPoint(o),n=this.SmoothCornersAndReturnCurve(e,i)}}}return n}RecoverSourceTargetTights(e,i){this.SourceTightPolyline=e,this.TargetTightPolyline=i}HideSourceTargetTightsIfNeeded(e){let i=this.SourceTightPolyline;return e.tmpTargetTight=this.TargetTightPolyline,this.TargetTightPolyline=null,this.SourceTightPolyline=null,i}LineAvoidsTightHierarchy(e){return re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy).length===0}RouteFromFloatingPortToBoundaryPort(e,i){let r=this.targetPort.Location,n;if(this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location,this.targetPort)&&(n=S.mkPP(this.SourcePort.Location,r),this.LineCanBeAcceptedForRouting(n)))return i.smoothedPolyline=this.SmoothedPolylineFromTwoPoints(n.start,n.end),n;let o=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve,this.TargetPort.Parameter,this.TargetLoosePolyline);if(n=S.mkPP(this.SourcePort.Location,o),this.LineAvoidsTightHierarchyLP(n,this._sourceTightPolyline))return this._polyline=R.mkFromPoints([n.start,n.end,r]),i.smoothedPolyline=oe.mkFromPoints(this._polyline),i.smoothedPolyline.createCurve();this.ExtendVisibilityGraphToTargetBoundaryPort(o),this._polyline=this.GetShortestPolyline(this.sourceVV,this.targetVV),this._polyline.addPoint(r);let s={smoothedPolyline:null};return this.SmoothCornersAndReturnCurve(e,s)}LineAvoidsTightHierarchyLP(e,i){let r=!0;for(let n of re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy))if(n.seg1!==i){r=!1;break}return r}LineAvoidsTightHierarchyLPP(e,i,r){let n=!0;for(let o of re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(e,this.ObstacleCalculator.RootOfTightHierarchy))if(!(o.seg1===i||o.seg1===r)){n=!1;break}return n}LineAvoidsTightHierarchyPPPP(e,i,r,n){return this.LineAvoidsTightHierarchyLPP(S.mkPP(e,i),r,n)}ExtendVisibilityGraphToTargetBoundaryPort(e){let i=null;if(this.VisibilityGraph==null&&(this.VisibilityGraph=new se),!this.activeRectangle.contains(e)||!this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)){this.activeRectangle.isEmpty?(this.activeRectangle=this.TargetLoosePolyline.boundingBox.clone(),this.activeRectangle.add(this.SourcePort.Location),this.activeRectangle.add(this.StartPointOfEdgeRouting),this.activeRectangle.add(e)):(this.activeRectangle.add(e),this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)),i=this.GetAddedPolygonesAndMaybeExtendActiveRectangle();for(let r of i)this.VisibilityGraph.AddHole(r.Polyline)}i==null?(this.targetVV!=null&&this.VisibilityGraph.RemoveVertex(this.targetVV),this.CalculateEdgeTargetVisibilityGraph(e)):(this.RemovePointVisibilityGraphs(),new Ai(i,this.activePolygons,this.VisibilityGraph).run(),Bi(this.activePolygons,i),this.CalculateEdgeTargetVisibilityGraph(e),this.CalculateSourcePortVisibilityGraph())}GetHitLoosePolyline(e){return this.ObstacleCalculator.IsEmpty()||this.ObstacleCalculator.RootOfLooseHierarchy==null?null:re.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy)}static GetFirstHitPolyline(e,i){let r=re.GetFirstHitRectangleNode(e,i);return r?r.UserData:null}static GetFirstHitRectangleNode(e,i){return i==null?null:i.FirstHitNodeWithPredicate(e,(r,n)=>p.PointRelativeToCurveLocation(r,n)!==0?1:0)}Clean(){this.TargetPort=null,this.SourcePort=null,this.SourceTightPolyline=null,this.SourceLoosePolyline=null,this.TargetLoosePolyline=null,this.targetTightPolyline=null,this.VisibilityGraph=null,this.targetVV=null,this.sourceVV=null,this.activePolygons=[],this.alreadyAddedOrExcludedPolylines.clear(),this.activeRectangle.setToEmpty()}SetSourcePortAndSourceLoosePolyline(e,i){this.SourceLoosePolyline=i,this.sourcePort=e,this.sourcePort!=null&&(this.SourceTightPolyline=re.GetFirstHitPolyline(this.sourcePort.Location,this.ObstacleCalculator.RootOfTightHierarchy),this.sourcePort instanceof Ue?(this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline),this.StartPointOfEdgeRouting=this.SourcePort.Location):this.StartPointOfEdgeRouting=this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve,this.sourcePort.Parameter,this.SourceLoosePolyline))}run(){this.CalculateWholeTangentVisibilityGraph()}CalculateWholeTangentVisibilityGraph(){this.VisibilityGraph=new se,this.CalculateWholeVisibilityGraphOnExistingGraph()}CalculateWholeVisibilityGraphOnExistingGraph(){this.activePolygons=Array.from(this.AllPolygons());for(let i of this.ObstacleCalculator.LooseObstacles)this.VisibilityGraph.AddHole(i);let e;this.UseSpanner?e=new Ui(this.ObstacleCalculator.LooseObstacles,this.VisibilityGraph):e=new Ai(new Array,this.activePolygons,this.visibilityGraph),e.run()}RouteSplineFromPortToPortWhenTheWholeGraphIsReady(e,i,r,n){let o=e instanceof Ue&&i instanceof tt||e instanceof Re;if(o){let a=e;e=i,i=a}this.sourcePort=e,this.targetPort=i,this.FigureOutSourceTargetPolylinesAndActiveRectangle();let s=this.GetEdgeGeomByRouting(r,n);return s==null?null:(this.targetVV=null,this.sourceVV=null,o&&(s=s.reverse()),s)}GetEdgeGeomByRouting(e,i){this.sourceIsInsideOfTargetTightPolyline=this.TargetTightPolyline==null||p.PointRelativeToCurveLocation(this.sourcePort.Location,this.TargetTightPolyline)===2;let r;if(this.sourcePort instanceof tt){let n=this.sourcePort;this.StartPointOfEdgeRouting=this.targetIsInsideOfSourceTightPolyline?n.Location:this.TakeBoundaryPortOutsideOfItsLoosePolyline(n.Curve,n.Parameter,this.SourceLoosePolyline),this.CalculateSourcePortVisibilityGraph();let o={smoothedPolyline:null};this.targetPort instanceof tt?r=this.RouteFromBoundaryPortToBoundaryPort(e,o):r=this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline,e,o)}else this.targetPort instanceof Ue?(this.ExtendVisibilityGraphFromFloatingSourcePort(),r=this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline,e,i)):r=this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline,e,i,this.targetPort);return r}RouteFromFloatingPortToAnywherePort(e,i,r,n){return n.Curve.boundingBox.contains(this.sourcePort.Location)?(this.sourceVV=this.GetVertex(this.sourcePort.Location),this._polyline=this.GetShortestPolylineToMulitpleTargets(this.sourceVV,Array.from(this.Targets(e))),this._polyline==null?null:(this.FixLastPolylinePointForAnywherePort(n),n.HookSize>0&&this.BuildHook(n),this.SmoothCornersAndReturnCurve(i,r))):(r.smoothedPolyline=null,null)}BuildHook(e){let i=e.Curve,r=k.mkFullEllipseNNP(e.HookSize,e.HookSize,this._polyline.end),n=p.getAllIntersections(i,r,!0);c.getTriangleOrientation(n[0].x,this._polyline.end,this._polyline.endPoint.prev.point)==1&&n.reverse();let o=this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(),s=i.derivative(n[0].par0).normalize(),a=s.dot(o);if(Math.abs(a)<.2)this.ExtendPolyline(s,n[0],o,e);else{let u=i.derivative(n[1].par0).normalize();u.dot(o)<a?this.ExtendPolyline(u,n[1],o,e):this.ExtendPolyline(s,n[0],o,e)}}ExtendPolyline(e,i,r,n){let o=e.rotate(Math.PI/2);o.dot(r)<0&&(o=o.neg());let s=i.x.add(o.mul(n.HookSize)),a;!(a=c.lineLineIntersection(s,s.add(e),this._polyline.end,this._polyline.end.add(r)))||(this._polyline.addPoint(a),this._polyline.addPoint(s),this._polyline.addPoint(i.x))}FixLastPolylinePointForAnywherePort(e){for(;;){let i=this.GetLastPointInsideOfCurveOnPolyline(e.Curve);i.next.next=null,this._polyline.endPoint=i.next;let r=i.next.point.sub(i.point);r=r.normalize().mul(e.Curve.boundingBox.diagonal);let n=r.rotate(e.AdjustmentAngle*-1),o=r.rotate(e.AdjustmentAngle),s=p.intersectionOne(e.Curve,S.mkPP(i.point,i.point.add(n)),!0),a=p.intersectionOne(e.Curve,S.mkPP(i.point,i.point.add(o)),!0);if(s==null||a==null)return;let u=re.GetTrimmedCurveForHookingUpAnywhere(e.Curve,i,s,a),h=u.value(u.closestParameter(i.point));if(!this.LineAvoidsTightHierarchyLPP(S.mkPP(i.point,h),this.SourceTightPolyline,null)){let d=p.intersectionOne(e.Curve,S.mkPP(i.point,i.next.point),!1);if(d==null)return;this._polyline.endPoint.point=d.x;break}if(this._polyline.endPoint.point=h,i.prev==null||!this.TryShortcutPolyPoint(i.prev))break}}static GetTrimmedCurveForHookingUpAnywhere(e,i,r,n){let o=c.getTriangleOrientation(n.x,r.x,i.point)===0,s=r.par0,a=n.par0,u,h,d;return o?s<a?e.trim(s,a):(h=e.trim(s,e.parEnd),u=e.trim(e.parStart,a),d=new p,d.addSegs([h,u])):a<s?e.trim(a,s):(h=e.trim(a,e.parEnd),u=e.trim(e.parStart,s),d=new p,d.addSegs([h,u]))}GetLastPointInsideOfCurveOnPolyline(e){for(let i=this._polyline.endPoint.prev;i!=null;i=i.prev)if(i.prev==null||p.PointRelativeToCurveLocation(i.point,e)===2)return i;throw new Error}GetShortestPolylineToMulitpleTargets(e,i){this.CleanTheGraphForShortestPath();let n=new gr(e,i,this.VisibilityGraph).GetPath();if(n==null)return null;let o=new R;for(let s of n)o.addPoint(s.point);return o.RemoveCollinearVertices()}Targets(e){return Array.from(e).map(i=>this.visibilityGraph.FindVertex(i))}ExtendVisibilityGraphFromFloatingSourcePort(){let e=this.sourcePort;this.StartPointOfEdgeRouting=e.Location,this.UseSpanner?this.sourceVV=this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location,this.SourceLoosePolyline):this.sourceVV=li.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter(i=>i!==this.SourceLoosePolyline),this.VisibilityGraph,this.StartPointOfEdgeRouting,1)}FigureOutSourceTargetPolylinesAndActiveRectangle(){let e=this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);this._sourceTightPolyline=re.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfTightHierarchy),this.SourceLoosePolyline=re.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy),e=this.targetPort.Curve.value(this.targetPort.Curve.parStart),this.targetTightPolyline=re.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfTightHierarchy),this.targetLoosePolyline=re.GetFirstHitPolyline(e,this.ObstacleCalculator.RootOfLooseHierarchy),this.activeRectangle=I.mkPP(new c(Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY),new c(Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY))}*AllPolygons(){for(let e of this.ObstacleCalculator.LooseObstacles)yield new He(e)}GetVisibilityGraph(){return this.VisibilityGraph}AddActivePolygons(e){Bi(this.activePolygons,e)}ClearActivePolygons(){this.activePolygons=[]}};var Oh=J(Mi(),1);var ei=class{constructor(){this.length=ei.defaultArrowheadLength;this.width=0;this.length=ei.defaultArrowheadLength}clone(){let t=new ei;return t.length=this.length,t.width=this.width,t.tipPosition=this.tipPosition,t}static calculateArrowheads(t){if(t.sourceArrowhead==null&&t.targetArrowhead==null)return!0;let e=ei.findTrimStartForArrowheadAtSource(t);if(e==null)return!1;let i=ei.findTrimEndForArrowheadAtTarget(t);if(i==null||e>i-m.intersectionEpsilon||p.closeIntersectionPoints(t.curve.value(e),t.curve.value(i)))return!1;let r=t.curve.trim(e,i);return r==null?!1:(t.sourceArrowhead!=null&&(t.sourceArrowhead.tipPosition=t.curve.start),t.targetArrowhead!=null&&(t.targetArrowhead.tipPosition=t.curve.end),t.curve=r,!0)}static getIntersectionsWithArrowheadCircle(t,e,i){let r=k.mkFullEllipseNNP(e,e,i);return p.getAllIntersections(r,t,!0)}static findTrimEndForArrowheadAtTarget(t){let e=m.distanceEpsilon*m.distanceEpsilon,i=t.curve.parEnd;if(t.targetArrowhead==null||t.targetArrowhead.length<=m.distanceEpsilon)return i;let r=t.curve,n=t.targetArrowhead.length,o,s,a=10;do{if(a--,a===0)return;s=ei.getIntersectionsWithArrowheadCircle(r,n,r.end),i=s.length!==0?Math.max(...s.map(u=>u.par1)):r.parEnd,o=t.curve.value(i),n/=2}while(o.sub(r.start).lengthSquared<e||s.length===0);return i}static findTrimStartForArrowheadAtSource(t){if(t.sourceArrowhead==null||t.sourceArrowhead.length<=m.distanceEpsilon)return t.curve.parStart;let e=m.distanceEpsilon*m.distanceEpsilon,i=t.sourceArrowhead.length,r,n=t.curve,o,s=10,a;for(;--s>0;){if(o=ei.getIntersectionsWithArrowheadCircle(n,i,n.start),o.length===0)return n.parStart;if(a=Math.min(...o.map(u=>u.par1)),r=o.filter(u=>u.par1===a)[0].x,r.sub(n.end).lengthSquared>=e)return a;i/=2}}static trimSplineAndCalculateArrowheads(t,e,i){return ei.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,e,i)}static trimSplineAndCalculateArrowheadsII(t,e,i,r,n){if(t.curve=p.trimEdgeSplineWithNodeBoundaries(e,i,r,n),t.curve==null)return!1;if((t.sourceArrowhead==null||t.sourceArrowhead.length<m.distanceEpsilon)&&(t.targetArrowhead==null||t.targetArrowhead.length<m.distanceEpsilon))return!0;let o=!1,s=t.sourceArrowhead!=null?t.sourceArrowhead.length:0,a=t.targetArrowhead!=null?t.targetArrowhead.length:0,u=t.curve.end.sub(t.curve.start).length;t.sourceArrowhead!=null&&(t.sourceArrowhead.length=Math.min(u,s)),t.targetArrowhead!=null&&(t.targetArrowhead.length=Math.min(u,a));let h=10;for(;(t.sourceArrowhead!=null&&t.sourceArrowhead.length>m.intersectionEpsilon||t.targetArrowhead!=null&&t.targetArrowhead.length>m.intersectionEpsilon)&&!o&&(o=ei.calculateArrowheads(t),o||(t.sourceArrowhead!=null&&(t.sourceArrowhead.length*=.5),t.targetArrowhead!=null&&(t.targetArrowhead.length*=.5)),h--,h!==0););return o||(t.sourceArrowhead!=null&&(t.sourceArrowhead.tipPosition=r.start),t.targetArrowhead!=null&&(t.targetArrowhead.tipPosition=r.end)),t.sourceArrowhead!=null&&(t.sourceArrowhead.length=s),t.targetArrowhead!=null&&(t.targetArrowhead.length=a),o}static createBigEnoughSpline(t){let e=t.source.center,i=t.target.center,r=i.sub(e),n=r.length,o;n<.001?(o=new c(1,0),i=e.add(o.rotate(Math.PI/2))):o=r.rotate(Math.PI/2);let s=1;t.sourceArrowhead!=null&&(s+=t.sourceArrowhead.length),t.targetArrowhead!=null&&(s+=t.targetArrowhead.length),o=o.normalize().mul(1.5*s);for(let a=1;a<1e4;a=a*2){let u=p.createBezierSegN(e,i,o,a);if(ei.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,u,!1))return}ei.createEdgeCurveWithNoTrimming(t,e,i)}static createEdgeCurveWithNoTrimming(t,e,i){let r=i.sub(e).normalize(),n=e,o=i,s=t.targetArrowhead;s!=null&&(s.tipPosition=i,o=i.sub(r.mul(s.length)));let a=t.sourceArrowhead;a!=null&&(a.tipPosition=e,n=e.add(r.mul(a.length))),t.curve=S.mkPP(n,o)}},we=ei;we.defaultArrowheadLength=5;var ot=class{static GetShapes(t,e=Array.from(t.shallowEdges)){let i=new Map;Gu(t,i);for(let r of e){let n=i.get(r.source);n&&r.sourcePort!=null&&n.Ports.add(r.sourcePort),n=i.get(r.target),n&&r.targetPort!=null&&n.Ports.add(r.targetPort)}return Array.from(i.values())}static CreateShapeWithCenterPort(t){let e=new cr(t),i=$e.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);for(let r of t.inEdges())ot.FixPortAtTarget(i,r);for(let r of t.outEdges())ot.FixPortAtSource(i,r);for(let r of t.selfEdges())ot.FixPortAtSource(i,r),ot.FixPortAtTarget(i,r);return e}static CreateShapeWithClusterBoundaryPort(t){let e=new cr(t),i=et.mk(()=>t.boundaryCurve,()=>t.center);e.Ports.add(i);let r;for(let n of t.inEdges())n.EdgeToAncestor()===2?(r==null&&(r=new Re(()=>t.boundaryCurve)),n.targetPort=r):ot.FixPortAtTarget(i,n);for(let n of t.outEdges())n.EdgeToAncestor()===1?(r==null&&(r=new Re(()=>t.boundaryCurve)),n.sourcePort=r):ot.FixPortAtSource(i,n);for(let n of t.selfEdges())ot.FixPortAtSource(i,n),ot.FixPortAtTarget(i,n);return e}static FixPortAtSource(t,e){e!=null&&e.sourcePort==null&&(e.sourcePort=t)}static FixPortAtTarget(t,e){e!=null&&e.targetPort==null&&(e.targetPort=t)}};function Gu(l,t){for(let e of l.shallowNodes)if(e instanceof de){let i=ot.CreateShapeWithClusterBoundaryPort(e);t.set(e,i);let r=e;if(!r.isCollapsed){Gu(r,t);for(let n of r.shallowNodes)i.AddChild(t.get(n))}}else t.set(e,ot.CreateShapeWithCenterPort(e))}var Nu=J(ai(),1);var El=class{constructor(t,e){this.v=t,this.i=e}},jt=class{static getFeedbackSetWithConstraints(t,e){throw new Error("Method not implemented.")}static push(t,e,i,r){e[i]=1,t.push(new El(i,r))}static getFeedbackSet(t){let e=new ct(t.nodeCount);if(t==null||t.nodeCount===0)return[];let i=new Array(t.nodeCount).fill(0);for(let r=0;r<t.nodeCount;r++){if(i[r]===2)continue;let n=new Nu.Stack,o=0;for(jt.push(n,i,r,o);n.size>0;){let s=n.pop();r=s.v,i[r]=2,o=s.i;let a=t.outEdges[r];for(;o<a.length;o++){let u=a[o];if(u.source===u.target)continue;let h=i[u.target];h===1?e.set(u.source,u.target,u):h===0&&(jt.push(n,i,r,o+1),r=u.target,i[u.target]=2,a=t.outEdges[r],o=-1)}}}return Array.from(e.values())}};var ti=class{constructor(){this.isEmpty=!0}AddValue(t){this.isEmpty?(this.max=t,this.min=t,this.isEmpty=!1):t<this.min?this.min=t:t>this.max&&(this.max=t)}get length(){return this.max-this.min}static sign(t){return t>m.distanceEpsilon?1:t<-m.distanceEpsilon?-1:0}};var Il=J(ai(),1),Mu=J(Qe(),1);var Bu=J(Qe(),1);var mr=class{SetActiveState(t,e){this.IsActive=t,this.VectorIndex=e,this.IsActive?(this.Left.ActiveConstraintCount++,this.Right.ActiveConstraintCount++):(this.Left.ActiveConstraintCount--,this.Right.ActiveConstraintCount--)}SetVectorIndex(t){this.VectorIndex=t}Reinitialize(){this.IsActive=!1,this.IsUnsatisfiable=!1,this.ClearDfDv()}UpdateGap(t){this.Gap=t}static constructorVVNB(t,e,i,r){let n=new mr(t);return n.Left=t,n.Right=e,n.Gap=i,n.IsEquality=r,n.Lagrangian=0,n.IsActive=!1,n}constructor(t){this.Right=t,this.Left=t}ToString(){return Bu.String.Format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv",this.Left,this.Right,this.IsEquality?"==":">=",this.Gap,this.Violation,this.Lagrangian,this.Lagrangian*2,this.IsActive?"+":this.IsUnsatisfiable?"!":"-")}get Violation(){return this.Left.ActualPos*this.Left.Scale+(this.Gap-this.Right.ActualPos*this.Right.Scale)}ClearDfDv(){this.Lagrangian=0}CompareTo(t){let e=this.Left.CompareTo(t.Left);return e===0&&(e=this.Right.CompareTo(t.Right)),e===0&&(e=Q(this.Gap,t.Gap)),e}};var Vu=J(Qe(),1),Jr=class{static constructorDCVV(t,e,i,r){let n=new Jr(e);return n.Set(t,e,i,r),n}constructor(t){this.ConstraintToEval=t,this.Depth=-1}Set(t,e,i,r){return this.Parent=t,this.ConstraintToEval=e,this.VariableToEval=i,this.VariableDoneEval=r,this.Depth=0,this.ChildrenHaveBeenPushed=!1,e.Lagrangian=0,this}get IsLeftToRight(){return this.VariableToEval===this.ConstraintToEval.Right}toString(){return Vu.String.Format("{0} {1}{2} - {3}{4} ({5})","",this.IsLeftToRight?"":"*",this.ConstraintToEval.Left.Name,this.IsLeftToRight?"*":"",this.ConstraintToEval.Right.Name,this.Depth)}};var vl=class{constructor(t,e){this.Constraint=t,this.IsForward=e}},Gn=class{constructor(t,e){this.Variables=new Array,t!=null&&this.AddVariable(t),this.allConstraints=e}toString(){return Mu.String.Format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]",this.Variables.length,this.ReferencePos,this.Scale)}ComputeDfDv(t){this.allConstraints.DfDvStack=new Il.Stack;let e=new mr(t);this.dfDvDummyParentNode=new Jr(e);let i=this.GetDfDvNode(this.dfDvDummyParentNode,e,t,null);for(this.allConstraints.DfDvStack.push(i);;){let r=this.allConstraints.DfDvStack.top,n=this.allConstraints.DfDvStack.length;if(!r.ChildrenHaveBeenPushed){r.ChildrenHaveBeenPushed=!0;for(let o of r.VariableToEval.LeftConstraints)if(o.IsActive&&o.Right!==r.VariableDoneEval){let s=this.GetDfDvNode(r,o,o.Right,r.VariableToEval);o.Right.ActiveConstraintCount===1?this.ProcessDfDvLeafNodeDirectly(s):this.PushDfDvNode(s)}for(let o of r.VariableToEval.RightConstraints)if(o.IsActive&&o.Left!==r.VariableDoneEval){let s=this.GetDfDvNode(r,o,o.Left,r.VariableToEval);o.Left.ActiveConstraintCount===1?this.ProcessDfDvLeafNodeDirectly(s):this.PushDfDvNode(s)}if(this.allConstraints.DfDvStack.length>n)continue}if(this.allConstraints.DfDvStack.pop(),this.ProcessDfDvLeafNode(r),r===i)break}}ProcessDfDvLeafNode(t){let e=t.VariableToEval.DfDv;t.IsLeftToRight?(t.ConstraintToEval.Lagrangian=t.ConstraintToEval.Lagrangian+e,t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian+t.ConstraintToEval.Lagrangian):(t.ConstraintToEval.Lagrangian=(t.ConstraintToEval.Lagrangian+e)*-1,t.Parent.ConstraintToEval.Lagrangian=t.Parent.ConstraintToEval.Lagrangian-t.ConstraintToEval.Lagrangian),this.CheckForConstraintPathTarget(t),this.Debug_CheckForViolatedActiveConstraint(t.ConstraintToEval),this.allConstraints.RecycleDfDvNode(t)}Debug_CheckForViolatedActiveConstraint(t){t.Violation>this.allConstraints.SolverParameters.GapTolerance}ProcessDfDvLeafNodeDirectly(t){this.ProcessDfDvLeafNode(t)}GetDfDvNode(t,e,i,r){let n=this.allConstraints.DfDvRecycleStack.size>0?this.allConstraints.DfDvRecycleStack.pop().Set(t,e,i,r):Jr.constructorDCVV(t,e,i,r);return n.Depth=n.Parent.Depth+1,this.allConstraints.MaxConstraintTreeDepth<n.Depth&&(this.allConstraints.MaxConstraintTreeDepth=n.Depth),n}PushDfDvNode(t){this.PushOnDfDvStack(t)}AddVariableAndPushDfDvNode(t,e){t.push(e.VariableToEval),this.PushOnDfDvStack(e)}PushOnDfDvStack(t){this.allConstraints.DfDvStack.push(t)}CheckForConstraintPathTarget(t){if(this.pathTargetVariable===t.VariableToEval){for(;t.Parent!==this.dfDvDummyParentNode;)this.constraintPath.push(new vl(t.ConstraintToEval,t.IsLeftToRight)),t=t.Parent;this.pathTargetVariable=null}}Expand(t){this.constraintPath==null&&(this.constraintPath=new Array),this.constraintPath=[],this.pathTargetVariable=t.Right,this.ComputeDfDv(t.Left);let e=null;if(this.constraintPath.length>0){for(let o of this.constraintPath)o.IsForward&&(e==null||o.Constraint.Lagrangian<e.Lagrangian)&&(o.Constraint.IsEquality||(e=o.Constraint));e!=null&&this.allConstraints.DeactivateConstraint(e)}if(this.constraintPath=[],this.pathTargetVariable=null,e==null){t.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++;return}let i=new Array;this.GetConnectedVariables(i,t.Right,t.Left);let r=t.Violation,n=i.length;for(let o=0;o<n;o++)i[o].OffsetInBlock=i[o].OffsetInBlock+r;this.allConstraints.ActivateConstraint(t),t.ClearDfDv(),this.UpdateReferencePos()}Split(t){if(t&&this.UpdateReferencePos(),this.Variables.length<2)return null;let e=null;this.ComputeDfDv(this.Variables[0]);let i=this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold,r=this.Variables.length;for(let n=0;n<r;n++)for(let o of this.Variables[n].LeftConstraints)o.IsActive&&!o.IsEquality&&o.Lagrangian<i&&(e=o,i=o.Lagrangian);return e==null?null:this.SplitOnConstraint(e)}SplitOnConstraint(t){this.allConstraints.DeactivateConstraint(t);let e=new Gn(null,this.allConstraints);return this.TransferConnectedVariables(e,t.Right,t.Left),e.Variables.length>0?(this.UpdateReferencePos(),e.UpdateReferencePos()):e=null,e}AddVariable(t){this.Variables.push(t),t.Block=this,this.Variables.length===1?(this.Scale=t.Scale,this.ReferencePos=t.ActualPos,this.sumAd=t.ActualPos*t.Weight,this.sumAb=0,this.sumA2=t.Weight,t.OffsetInBlock=0):this.AddVariableToBlockSums(t)}UpdateReferencePos(){this.Scale=this.Variables[0].Scale,this.sumAd=0,this.sumAb=0,this.sumA2=0;let t=this.Variables.length;for(let e=0;e<t;e++)this.AddVariableToBlockSums(this.Variables[e]);this.UpdateReferencePosFromSums()}AddVariableToBlockSums(t){let e=this.Scale/t.Scale,i=t.OffsetInBlock/t.Scale,r=e*t.Weight;this.sumAd+=r*t.DesiredPos,this.sumAb+=r*i,this.sumA2+=r*e}UpdateReferencePosFromSums(){if(!(Number.isFinite(this.sumAd)&&Number.isFinite(this.sumAb)&&Number.isFinite(this.sumA2)))throw new Error("infinite numbers");this.ReferencePos=(this.sumAd-this.sumAb)/this.sumA2,this.UpdateVariablePositions()}UpdateVariablePositions(){let t=this.Scale*this.ReferencePos,e=this.Variables.length;for(let i=0;i<e;i++){let r=this.Variables[i];r.ActualPos=(t+r.OffsetInBlock)/r.Scale}}GetConnectedVariables(t,e,i){this.RecurseGetConnectedVariables(t,e,i)}RecurseGetConnectedVariables(t,e,i){this.allConstraints.DfDvStack=new Il.Stack;let r=new mr(e);for(this.dfDvDummyParentNode=new Jr(r),this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode,r,e,i)),t.push(e);this.allConstraints.DfDvStack.length>0;){let n=this.allConstraints.DfDvStack.top,o=this.allConstraints.DfDvStack.length;if(!n.ChildrenHaveBeenPushed){n.ChildrenHaveBeenPushed=!0;for(let s of n.VariableToEval.LeftConstraints)s.IsActive&&s.Right!==n.VariableDoneEval&&(s.Right.ActiveConstraintCount===1?t.push(s.Right):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(n,s,s.Right,n.VariableToEval)));for(let s of n.VariableToEval.RightConstraints)s.IsActive&&s.Left!==n.VariableDoneEval&&(s.Left.ActiveConstraintCount===1?t.push(s.Left):this.AddVariableAndPushDfDvNode(t,this.GetDfDvNode(n,s,s.Left,n.VariableToEval)))}this.allConstraints.DfDvStack.length>o||this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop())}}TransferConnectedVariables(t,e,i){this.GetConnectedVariables(t.Variables,e,i);let r=t.Variables.length;for(let o=0;o<r;o++)t.Variables[o].Block=t;let n=this.Variables.length-1;for(let o=this.Variables.length-1;o>=0;o--)this.Variables[o].Block===t&&(o<n&&(this.Variables[o]=this.Variables[n]),n--);if(this.Variables=this.Variables.slice(0,n+1),this.Variables.length===0){for(let o=0;o<r;o++){let s=t.Variables[o];this.Variables.push(s),s.Block=this}t.Variables=[]}}};var Us=class{get Count(){return this.Vector.length}item(t){return this.Vector[t]}constructor(){this.Vector=new Array}Add(t){t.VectorIndex=this.Vector.length,this.Vector.push(t)}Remove(t){let e=this.Vector[this.Vector.length-1];this.Vector[t.VectorIndex]=e,e.VectorIndex=t.VectorIndex,this.Vector.pop()}toString(){return this.Vector.toString()}};var xl=J(ai(),1),Qs=class{constructor(){this.nextConstraintIndex=0;this.DfDvStack=new xl.Stack;this.DfDvRecycleStack=new xl.Stack}get IsEmpty(){return this.Vector==null}Create(t){this.Vector=new Array(t),this.firstActiveConstraintIndex=t}Add(t){t.SetVectorIndex(this.nextConstraintIndex),this.Vector[this.nextConstraintIndex++]=t}ActivateConstraint(t){this.firstActiveConstraintIndex--,this.SwapConstraint(t)}DeactivateConstraint(t){this.SwapConstraint(t),this.firstActiveConstraintIndex++}SwapConstraint(t){let e=this.Vector[this.firstActiveConstraintIndex];e.SetVectorIndex(t.VectorIndex),this.Vector[t.VectorIndex]=e,this.Vector[this.firstActiveConstraintIndex]=t,t.SetActiveState(!t.IsActive,this.firstActiveConstraintIndex)}Reinitialize(){if(this.Vector!=null){for(let t of this.Vector)t.Reinitialize();this.firstActiveConstraintIndex=this.Vector.length}}RecycleDfDvNode(t){this.DfDvRecycleStack.length<1024&&this.DfDvRecycleStack.push(t)}toString(){return this.Vector.toString()}};var co=class{constructor(){this.GapTolerance=1e-4,this.QpscConvergenceEpsilon=1e-5,this.QpscConvergenceQuotient=1e-6,this.OuterProjectIterationsLimit=-1,this.InnerProjectIterationsLimit=-1,this.TimeLimit=-1,this.Advanced=new jo}Clone(){let t=this.MemberwiseClone();return t.Advanced=this.Advanced.Clone(),t}MemberwiseClone(){let t=new co;return t.GapTolerance=this.GapTolerance,t.QpscConvergenceEpsilon=this.QpscConvergenceEpsilon,t.QpscConvergenceQuotient=this.QpscConvergenceQuotient,t.OuterProjectIterationsLimit=this.OuterProjectIterationsLimit,t.InnerProjectIterationsLimit=this.InnerProjectIterationsLimit,t.TimeLimit=this.TimeLimit,t}},jo=class{constructor(){this.ForceQpsc=!1,this.ScaleInQpsc=!0,this.MinSplitLagrangianThreshold=-1e-7,this.UseViolationCache=!0,this.ViolationCacheMinBlocksDivisor=10,this.ViolationCacheMinBlocksCount=100}Clone(){let t=new jo;return t.ForceQpsc=this.ForceQpsc,t.ScaleInQpsc=this.ScaleInQpsc,t.MinSplitLagrangianThreshold=this.MinSplitLagrangianThreshold,t.UseViolationCache=this.UseViolationCache,t.ViolationCacheMinBlocksDivisor=this.ViolationCacheMinBlocksDivisor,t.ViolationCacheMinBlocksCount=this.ViolationCacheMinBlocksCount,t}};var Tl=class{constructor(t){this.Variable=t,this.OrigWeight=t.Weight,this.OrigScale=t.Scale,this.OrigDesiredPos=this.Variable.DesiredPos}},Al=class{constructor(t,e){this.Value=t,this.Column=e}},Ct=class{constructor(t,e){this.newMatrixRow=new Array;this.previousFunctionValue=Number.MAX_VALUE;this.solverParameters=t,this.matrixQ=new Array(e).fill(0),this.vectorWiDi=new Array(e).fill(0),this.vectorQpscVars=new Array(e).fill(0),this.gradientVector=new Array(e).fill(0),this.vectorQg=new Array(e).fill(0),this.vectorPrevY=new Array(e).fill(0),this.vectorCurY=new Array(e).fill(0)}AddVariable(t){if(this.isFirstProjectCall=!0,this.vectorWiDi[t.Ordinal]=2*(t.Weight*t.DesiredPos)*-1,this.vectorPrevY[t.Ordinal]=t.Weight,t.Neighbors!=null)for(let e of t.Neighbors)this.vectorPrevY[t.Ordinal]=this.vectorPrevY[t.Ordinal]+e.Weight,this.vectorPrevY[e.Neighbor.Ordinal]=this.vectorPrevY[e.Neighbor.Ordinal]-e.Weight;for(let e=0;e<this.vectorPrevY.length;e++)this.vectorPrevY[e]!==0&&(this.newMatrixRow.push(new Al(this.vectorPrevY[e]*2,e)),this.vectorPrevY[e]=0);this.matrixQ[t.Ordinal]=Array.from(this.newMatrixRow),this.newMatrixRow=[],this.vectorQpscVars[t.Ordinal]=new Tl(t),t.Weight=1}VariablesComplete(){for(let t of this.vectorQpscVars){let e=t.Variable;for(let i of this.matrixQ[e.Ordinal])i.Column===e.Ordinal&&(this.solverParameters.Advanced.ScaleInQpsc&&(e.Scale=1/Math.sqrt(Math.abs(i.Value)),Number.isFinite(e.Scale)||(e.Scale=1),e.Scale,this.vectorWiDi[e.Ordinal]=this.vectorWiDi[e.Ordinal]*e.Scale),this.vectorCurY[e.Ordinal]=e.ActualPos,e.DesiredPos=e.ActualPos)}if(!!this.solverParameters.Advanced.ScaleInQpsc)for(let t=0;t<this.matrixQ.length;t++){let e=this.matrixQ[t];for(let i=0;i<e.length;i++)e[i].Column===t?e[i].Value=1:e[i].Value=e[i].Value*(this.vectorQpscVars[t].Variable.Scale*this.vectorQpscVars[e[i].Column].Variable.Scale)}}PreProject(){if(this.isFirstProjectCall)for(let r of this.vectorQpscVars)this.vectorCurY[r.Variable.Ordinal]=r.Variable.ActualPos;if(this.MatrixVectorMultiply(this.vectorCurY,this.gradientVector),this.HasConverged())return!1;Ct.VectorVectorAdd(this.gradientVector,this.vectorWiDi,this.gradientVector);let t=Ct.VectorVectorMultiply(this.gradientVector,this.gradientVector),e=0;if(t!==0&&(this.MatrixVectorMultiply(this.gradientVector,this.vectorQg),e=Ct.VectorVectorMultiply(this.vectorQg,this.gradientVector)),e===0)return!1;let i=t/e;Ct.VectorCopy(this.vectorPrevY,this.vectorCurY),Ct.VectorScaledVectorSubtract(this.vectorPrevY,i,this.gradientVector,this.vectorCurY);for(let r=0;r<this.vectorCurY.length;r++)this.vectorQpscVars[r].Variable.DesiredPos=this.vectorCurY[r];return!0}PostProject(){for(let i of this.vectorQpscVars)this.vectorCurY[i.Variable.Ordinal]=i.Variable.ActualPos;Ct.VectorVectorSubtract(this.vectorPrevY,this.vectorCurY,this.vectorCurY);let t=Ct.VectorVectorMultiply(this.gradientVector,this.vectorCurY),e=0;if(t!==0){this.MatrixVectorMultiply(this.vectorCurY,this.vectorQg);let i=Ct.VectorVectorMultiply(this.vectorQg,this.vectorCurY);e=i===0?1:t/i,e>1?e=1:e<0&&(e=0)}return Ct.VectorScaledVectorSubtract(this.vectorPrevY,e,this.vectorCurY,this.vectorCurY),this.isFirstProjectCall=!1,e>0}QpscComplete(){for(let t of this.vectorQpscVars)t.Variable.Weight=t.OrigWeight,t.Variable.DesiredPos=t.OrigDesiredPos,this.solverParameters.Advanced.ScaleInQpsc&&(t.Variable.ActualPos=t.Variable.ActualPos*t.Variable.Scale,t.Variable.Scale=t.OrigScale);return this.previousFunctionValue}HasConverged(){let t=this.GetFunctionValue(this.vectorCurY),e=!1;if(!this.isFirstProjectCall){let i=this.previousFunctionValue-t,r=0;if(i!==0){let n=this.previousFunctionValue!==0?this.previousFunctionValue:t;r=Math.abs(i/n)}(Math.abs(i)<this.solverParameters.QpscConvergenceEpsilon||Math.abs(r)<this.solverParameters.QpscConvergenceQuotient)&&(e=!0)}return this.previousFunctionValue=t,e}GetFunctionValue(t){return Ct.VectorVectorMultiply(this.gradientVector,t)/2+Ct.VectorVectorMultiply(this.vectorWiDi,t)}static VectorVectorMultiply(t,e){let i=0;for(let r=0;r<t.length;r++)i=i+t[r]*e[r];return i}MatrixVectorMultiply(t,e){let i=0;for(let r of this.matrixQ){let n=0;for(let o of r)n=n+o.Value*t[o.Column];e[i++]=n}}static VectorVectorAdd(t,e,i){for(let r=0;r<t.length;r++)i[r]=t[r]+e[r]}static VectorVectorSubtract(t,e,i){for(let r=0;r<t.length;r++)i[r]=t[r]-e[r]}static VectorScaledVectorSubtract(t,e,i,r){for(let n=0;n<t.length;n++)r[n]=t[n]-e*i[n]}static VectorCopy(t,e){for(let i=0;i<e.length;i++)t[i]=e[i]}};var Nn=class{constructor(){this.NumberOfUnsatisfiableConstraints=0;this.OuterProjectIterations=0;this.InnerProjectIterationsTotal=0;this.MinInnerProjectIterations=0;this.MaxInnerProjectIterations=0;this.MaxConstraintTreeDepth=0;this.GoalFunctionValue=0;this.TimeLimitExceeded=!1;this.OuterProjectIterationsLimitExceeded=!1;this.InnerProjectIterationsLimitExceeded=!1}get ExecutionLimitExceeded(){return this.TimeLimitExceeded||this.OuterProjectIterationsLimitExceeded||this.InnerProjectIterationsLimitExceeded}Clone(){let t=new Nn;return t.GoalFunctionValue=this.GoalFunctionValue,t.InnerProjectIterationsLimitExceeded=this.InnerProjectIterationsLimitExceeded,t.InnerProjectIterationsTotal=this.InnerProjectIterationsTotal,t.MaxConstraintTreeDepth=this.MaxConstraintTreeDepth,t.OuterProjectIterations=this.OuterProjectIterations,t.OuterProjectIterationsLimitExceeded=this.OuterProjectIterationsLimitExceeded,t.AlgorithmUsed=this.AlgorithmUsed,t.NumberOfUnsatisfiableConstraints=this.NumberOfUnsatisfiableConstraints,t.MaxInnerProjectIterations=this.MaxInnerProjectIterations,t}};var Du=J(Qe(),1);var wl=class{constructor(t,e){this.Neighbor=t,this.Weight=e}},Xs=class{constructor(t,e,i,r,n){this.ActiveConstraintCount=0;if(r<=0)throw new Error("weight");if(n<=0)throw new Error("scale");let o=i*r;if(!Number.isFinite(o)||Number.isNaN(o))throw new Error("desiredPos");if(o=i*n,!Number.isFinite(o)||Number.isNaN(o))throw new Error("desiredPos");this.Ordinal=t,this.UserData=e,this.DesiredPos=i,this.Weight=r,this.Scale=n,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}get DfDv(){return 2*(this.Weight*(this.ActualPos-this.DesiredPos))/this.Scale}Reinitialize(){this.ActiveConstraintCount=0,this.OffsetInBlock=0,this.ActualPos=this.DesiredPos}AddNeighbor(t,e){this.Neighbors==null&&(this.Neighbors=new Array),this.Neighbors.push(new wl(t,e))}toString(){return Du.String.Format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}",this.Name,this.ActualPos,this.DesiredPos,this.Weight,this.Scale)}get Name(){return this.UserData==null?"-0-":this.UserData.toString()}SetConstraints(t,e){this.LeftConstraints=t,this.RightConstraints=e}CompareTo(t){return Q(this.Ordinal,t.Ordinal)}};var _s=class{get IsFull(){return this.numConstraints===_s.MaxConstraints}Clear(){this.LowViolation=0,this.numConstraints=0,this.constraints||(this.constraints=new Array(_s.MaxConstraints))}FilterBlock(t){this.LowViolation=Number.MAX_VALUE;let e=this.numConstraints>0;for(let i=this.numConstraints-1;i>=0;i--){let r=this.constraints[i];if(r.Left.Block===t||r.Right.Block===t||r.IsActive||r.IsUnsatisfiable)i<this.numConstraints-1&&(this.constraints[i]=this.constraints[this.numConstraints-1]),this.numConstraints--;else{let n=r.Left.ActualPos*r.Left.Scale+(r.Gap-r.Right.ActualPos*r.Right.Scale);n<this.LowViolation&&(this.LowViolation=n)}}return this.numConstraints===0&&(this.LowViolation=0),e}FindIfGreater(t){let e=null;for(let i=0;i<this.numConstraints;i++){let r=this.constraints[i],n=r.Left.ActualPos*r.Left.Scale+(r.Gap-r.Right.ActualPos*r.Right.Scale);n>t&&(t=n,e=r)}return e}Insert(t,e){let i=0,r=e,n=e;for(let o=0;o<this.numConstraints;o++){let s=this.constraints[o],a=s.Left.ActualPos*s.Left.Scale+(s.Gap-s.Right.ActualPos*s.Right.Scale);a<r?(n=r,i=o,r=a):a<n&&(n=a)}this.IsFull?(this.constraints[i]=t,this.LowViolation=n):(this.constraints[this.numConstraints++]=t,this.IsFull&&(this.LowViolation=r))}},Uo=_s;Uo.MaxConstraints=20;var Js=class{constructor(t,e){this.NumberOfLeftConstraints=0;this.Constraints=t,this.NumberOfLeftConstraints=e}},Ys=class{constructor(){this.allBlocks=new Us;this.allConstraints=new Qs;this.numberOfConstraints=0;this.numberOfVariables=0;this.equalityConstraints=new Array;this.loadedVariablesAndConstraintLists=new Map;this.emptyConstraintList=new Array(0);this.updatedConstraints=new Array;this.violationCache=new Uo;this.violationCacheMinBlockCutoff=0;this.nextVariableOrdinal=0;this.solverParams=new co;this.solverSolution=new Nn}get IsQpsc(){return this.hasNeighbourPairs||this.solverParams.Advanced.ForceQpsc}AddVariableAN(t,e){return this.AddVariableANNN(t,e,1,1)}AddVariableANN(t,e,i){return this.AddVariableANNN(t,e,i,1)}AddVariableANNN(t,e,i,r){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");let n=new Xs(this.nextVariableOrdinal++,t,e,i,r),o=new Gn(n,this.allConstraints);return n.Block=o,this.allBlocks.Add(o),this.numberOfVariables++,this.loadedVariablesAndConstraintLists.set(n,new Js(new Array,0)),n}UpdateVariables(){for(let t of this.allBlocks.Vector)t.UpdateReferencePos()}get Variables(){return Vi(this.allBlocks.Vector,t=>t.Variables)}get VariableCount(){return this.numberOfVariables}*Constraints(){if(this.allConstraints.IsEmpty)for(let t of this.loadedVariablesAndConstraintLists.keys()){let e=this.loadedVariablesAndConstraintLists.get(t);if(e.Constraints!=null){let i=e.Constraints.length;for(let r=0;r<i;r++){let n=e.Constraints[r];if(t===n.Left)return yield,n}}}else for(let t of this.allConstraints.Vector)yield t}get ConstraintCount(){return this.numberOfConstraints}AddEqualityConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!0)}AddConstraintVVNB(t,e,i,r){if(!this.allConstraints.IsEmpty)throw new Error("Cannot add Variables or Constraints once Solve() has been called");if(t===e)throw new Error("Cannot add a constraint between a variable and itself");let n=this.loadedVariablesAndConstraintLists.get(t),o=this.loadedVariablesAndConstraintLists.get(e),s=mr.constructorVVNB(t,e,i,r);return this.loadedVariablesAndConstraintLists.set(t,new Js(n.Constraints,n.NumberOfLeftConstraints+1)),n.Constraints.push(s),o.Constraints.push(s),this.numberOfConstraints++,r&&this.equalityConstraints.push(s),s}AddConstraint(t,e,i){return this.AddConstraintVVNB(t,e,i,!1)}SetConstraintUpdate(t,e){e!==t.Gap&&this.updatedConstraints.push([t,e])}AddNeighborPair(t,e,i){if(i<=0||Number.isNaN(i)||!Number.isFinite(i))throw new Error("relationshipWeight");if(t===e)throw new Error;t.AddNeighbor(e,i),e.AddNeighbor(t,i),this.hasNeighbourPairs=!0}Solve(){return this.SolvePar(null)}SolvePar(t){t&&(this.solverParams=t.Clone()),this.solverParams.OuterProjectIterationsLimit<0&&(this.solverParams.OuterProjectIterationsLimit=100*(Math.floor(Math.log2(this.numberOfVariables))+1)),this.solverParams.InnerProjectIterationsLimit<0&&(this.solverParams.InnerProjectIterationsLimit=this.numberOfConstraints*2+100*(Math.max(0,Math.floor(Math.log2(this.numberOfConstraints)))+1));let e=!this.allConstraints.IsEmpty;if(this.CheckForUpdatedConstraints(),this.solverSolution=new Nn,this.solverSolution.MinInnerProjectIterations=Number.MAX_VALUE,this.allConstraints.MaxConstraintTreeDepth=0,this.allConstraints.SolverParameters=this.solverParams,this.numberOfConstraints===0){if(!this.IsQpsc)return this.solverSolution.Clone()}else e||this.SetupConstraints();return this.allConstraints.NumberOfUnsatisfiableConstraints=0,this.MergeEqualityConstraints(),this.IsQpsc?this.SolveQpsc():(this.SolveByStandaloneProject(),this.CalculateStandaloneProjectGoalFunctionValue()),this.solverSolution.MinInnerProjectIterations>this.solverSolution.MaxInnerProjectIterations&&(this.solverSolution.MinInnerProjectIterations=this.solverSolution.MaxInnerProjectIterations),this.solverSolution.NumberOfUnsatisfiableConstraints=this.allConstraints.NumberOfUnsatisfiableConstraints,this.solverSolution.MaxConstraintTreeDepth=this.allConstraints.MaxConstraintTreeDepth,this.solverSolution.Clone()}CheckForUpdatedConstraints(){if(this.updatedConstraints.length===0)return;let t=this.IsQpsc;for(let[e,i]of this.updatedConstraints){let r=e;if(r.UpdateGap(i),!t&&!r.IsEquality){this.SplitOnConstraintIfActive(r);continue}t=!0}this.updatedConstraints=[],t&&this.ReinitializeBlocks()}SplitOnConstraintIfActive(t){if(t.IsActive){let e=t.Left.Block.SplitOnConstraint(t);e!=null&&this.allBlocks.Add(e)}}SetupConstraints(){this.allConstraints.Create(this.numberOfConstraints);for(let t of this.loadedVariablesAndConstraintLists.keys()){let e=this.loadedVariablesAndConstraintLists.get(t),i=e.Constraints,r=0,n=0,o=0;i!=null&&(r=i.length,n=e.NumberOfLeftConstraints,o=r-n);let s=this.emptyConstraintList;n!==0&&(s=new Array(n));let a=this.emptyConstraintList;o!==0&&(a=new Array(o)),t.SetConstraints(s,a);let u=0,h=0;for(let d=0;d<r;d++){let g=i[d];t===g.Left?s[u++]=g:a[h++]=g}for(let d of t.LeftConstraints)this.allConstraints.Add(d)}this.loadedVariablesAndConstraintLists.clear(),this.violationCacheMinBlockCutoff=Number.MAX_VALUE,this.solverParams.Advanced.UseViolationCache&&this.solverParams.Advanced.ViolationCacheMinBlocksDivisor>0&&(this.violationCacheMinBlockCutoff=Math.min(this.allBlocks.Count/this.solverParams.Advanced.ViolationCacheMinBlocksDivisor,this.solverParams.Advanced.ViolationCacheMinBlocksCount))}SolveByStandaloneProject(){for(;;){if(!this.RunProject())return;if(!this.SplitBlocks())break}}RunProject(){return this.solverSolution.OuterProjectIterations++,this.Project(),!this.CheckForLimitsExceeded()}CheckForLimitsExceeded(){return this.solverParams.OuterProjectIterationsLimit>0&&this.solverSolution.OuterProjectIterations>=this.solverParams.OuterProjectIterationsLimit?(this.solverSolution.OuterProjectIterationsLimitExceeded=!0,!0):!!this.solverSolution.InnerProjectIterationsLimitExceeded}CalculateStandaloneProjectGoalFunctionValue(){this.solverSolution.GoalFunctionValue=0;let t=this.allBlocks.Count;for(let e=0;e<t;e++){let i=this.allBlocks.item(e),r=i.Variables.length;for(let n=0;n<r;n++){let o=i.Variables[n];this.solverSolution.GoalFunctionValue+=o.Weight*(o.ActualPos*o.ActualPos),this.solverSolution.GoalFunctionValue-=2*(o.Weight*(o.DesiredPos*o.ActualPos))}}}SolveQpsc(){if(this.solverSolution.AlgorithmUsed=this.solverParams.Advanced.ScaleInQpsc?1:2,!this.QpscMakeFeasible())return;let t=new Ct(this.solverParams,this.numberOfVariables);for(let i of this.allBlocks.Vector)for(let r of i.Variables)t.AddVariable(r);t.VariablesComplete(),this.ReinitializeBlocks(),this.MergeEqualityConstraints();let e=!1;for(;!(!t.PreProject()&&!e||(e=this.SplitBlocks(),!this.RunProject())||!t.PostProject()&&!e););this.solverSolution.GoalFunctionValue=t.QpscComplete()}QpscMakeFeasible(){return this.RunProject()}ReinitializeBlocks(){let t=Array.from(this.allBlocks.Vector);this.allBlocks.Vector=[];for(let e of t)for(let i of e.Variables){i.Reinitialize();let r=new Gn(i,this.allConstraints);this.allBlocks.Add(r)}this.allConstraints.Reinitialize(),this.violationCache.Clear()}MergeEqualityConstraints(){for(let t of this.equalityConstraints){if(t.Left.Block===t.Right.Block){Math.abs(t.Violation)>this.solverParams.GapTolerance&&(t.IsUnsatisfiable=!0,this.allConstraints.NumberOfUnsatisfiableConstraints++);continue}this.MergeBlocks(t)}}Project(){if(this.numberOfConstraints===0)return!1;this.violationCache.Clear(),this.lastModifiedBlock=null;let t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,e=1,i={maxViolation:0},r=this.GetMaxViolatedConstraint(i,t);if(!r)return!1;for(;r;){if(r.Left.Block===r.Right.Block?(r.Left.Block.Expand(r),r.IsUnsatisfiable&&this.violationCache.Clear(),this.lastModifiedBlock=r.Left.Block):this.lastModifiedBlock=this.MergeBlocks(r),this.solverParams.InnerProjectIterationsLimit>0&&e>=this.solverParams.InnerProjectIterationsLimit){this.solverSolution.InnerProjectIterationsLimitExceeded=!0;break}t=this.allBlocks.Count>this.violationCacheMinBlockCutoff,t||this.violationCache.Clear(),e++;let n={maxViolation:0};r=this.GetMaxViolatedConstraint(n,t)}return this.solverSolution.InnerProjectIterationsTotal=this.solverSolution.InnerProjectIterationsTotal+e,this.solverSolution.MaxInnerProjectIterations<e&&(this.solverSolution.MaxInnerProjectIterations=e),this.solverSolution.MinInnerProjectIterations>e&&(this.solverSolution.MinInnerProjectIterations=e),!0}MergeBlocks(t){let e=t.Left.Block,i=t.Right.Block,r=t.Left.OffsetInBlock+(t.Gap-t.Right.OffsetInBlock);i.Variables.length>e.Variables.length&&(e=t.Right.Block,i=t.Left.Block,r=-r);let n=i.Variables.length;for(let o=0;o<n;o++){let s=i.Variables[o];s.OffsetInBlock+=r,e.AddVariable(s)}return e.UpdateReferencePosFromSums(),this.allConstraints.ActivateConstraint(t),this.allBlocks.Remove(i),e}SplitBlocks(){let t=new Array,e=this.allBlocks.Count;for(let r=0;r<e;r++){let o=this.allBlocks.item(r).Split(this.IsQpsc);o!=null&&t.push(o)}let i=t.length;for(let r=0;r<i;r++){let n=t[r];this.allBlocks.Add(n)}return t.length!==0}GetMaxViolatedConstraint(t,e){t.maxViolation=this.solverParams.GapTolerance;let i=this.SearchViolationCache(t.maxViolation);return i!=null?i:this.SearchAllConstraints(t.maxViolation,e)}SearchViolationCache(t){let e=null;if(this.lastModifiedBlock==null)return;this.lastModifiedBlock.Variables.length<this.numberOfVariables+1&&this.violationCache.FilterBlock(this.lastModifiedBlock);let i=this.lastModifiedBlock.Variables.length;for(let n=0;n<i;n++){let o=this.lastModifiedBlock.Variables[n];for(let s of o.LeftConstraints)if(!s.IsActive&&!s.IsUnsatisfiable){let a=s.Left.ActualPos*s.Left.Scale+(s.Gap-s.Right.ActualPos*s.Right.Scale);ws(a,t)&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=s.Violation,e=s)}for(let s of o.RightConstraints)if(!s.IsActive&&!s.IsUnsatisfiable&&s.Left.Block!==this.lastModifiedBlock){let a=s.Left.ActualPos*s.Left.Scale+(s.Gap-s.Right.ActualPos*s.Right.Scale);ws(a,t)&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),t=a,e=s)}}let r=this.violationCache.FindIfGreater(t);return r!=null&&(e!=null&&t>this.violationCache.LowViolation&&this.violationCache.Insert(e,t),e=r),e}SearchAllConstraints(t,e){let i=null;this.violationCache.Clear();for(let r of this.allConstraints.Vector){if(r.IsActive)break;if(r.IsUnsatisfiable)continue;let n=r.Left.ActualPos*r.Left.Scale+(r.Gap-r.Right.ActualPos*r.Right.Scale),o=null,s=0;ws(n,t)&&(t>this.violationCache.LowViolation&&(o=i,s=t),t=n,i=r),e&&(o==null&&r!==i&&(!this.violationCache.IsFull||n>this.violationCache.LowViolation)&&(o=r,s=n),o!=null&&s>this.violationCache.LowViolation&&this.violationCache.Insert(o,s))}return i}};var Zs=class{constructor(){this.variables=new Map;this.fixedVars=new Map;this.FailToAdjustEpsilon=.001;this.InitSolver()}AddVariableWithIdealPositionNNN(t,e,i){this.variables.set(t,this.solver.AddVariableANN(t,e,i))}AddVariableWithIdealPositionNN(t,e){this.AddVariableWithIdealPositionNNN(t,e,1)}AddLeftRightSeparationConstraintNNNB(t,e,i,r){let n=this.GetVariable(t);if(n==null)return;let o=this.GetVariable(e);o!=null&&this.solver.AddConstraintVVNB(n,o,i,r)}AddLeftRightSeparationConstraintNNN(t,e,i){this.AddLeftRightSeparationConstraintNNNB(t,e,i,!1)}AddGoalTwoVariablesAreCloseNNN(t,e,i){let r=this.GetVariable(t);if(r==null)return;let n=this.GetVariable(e);n!=null&&this.solver.AddNeighborPair(r,n,i)}AddGoalTwoVariablesAreClose(t,e){this.AddGoalTwoVariablesAreCloseNNN(t,e,1)}GetVariable(t){return this.variables.get(t)}Solve(){this.SolveP(null)}SolveP(t){let e={executionLimitExceeded:!1};this.SolvePNS(t,e)}SolvePNS(t,e){let i;do{this.solution=null;let r=null;if(t!=null&&(r=t,r==null))throw new Error("parameters");this.solution=this.solver.SolvePar(r),e.executionLimitExceeded=this.solution.ExecutionLimitExceeded,i=this.AdjustConstraintsForMovedFixedVars()}while(i&&this.solution.ExecutionLimitExceeded===!1);return this.solution.ExecutionLimitExceeded===!1}AdjustConstraintsForMovedFixedVars(){let t=new Set;for(let[e,i]of this.fixedVars.entries())Zs.Close(i,this.GetVariableResolvedPosition(e))||t.add(e);return t.size===0?!1:this.AdjustConstraintsForMovedFixedVarSet(t)}static Close(t,e){return Math.abs(t-e)<5e-4}AdjustConstraintsForMovedFixedVarSet(t){for(;t.size>0;){let e;for(let i of t){e=i;break}if(!this.AdjustSubtreeOfFixedVar(e,t))return!1}return!0}AdjustSubtreeOfFixedVar(t,e){let i={successInAdjusting:!1},r=this.AdjustConstraintsOfNeighborsOfFixedVariable(t,i);if(!i.successInAdjusting||r.length===0)return!1;for(let n of r)e.delete(n);return!0}AdjustConstraintsOfNeighborsOfFixedVariable(t,e){let i=this.variables.get(t).Block.Variables,r=new ti,n=new ti,o=1;for(let s of i)!this.fixedVars.has(s.UserData)||(r.AddValue(s.ActualPos),n.AddValue(s.DesiredPos),n.length>0&&(o=Math.max(o,r.length/n.length)));return o===1&&(o=2),e.successInAdjusting=this.FixActiveConstraints(i,o),i.map(s=>s.UserData)}FixActiveConstraints(t,e){let i=!1;for(let r of t)for(let n of r.LeftConstraints)n.IsActive&&(n.Gap>this.FailToAdjustEpsilon&&(i=!0),this.solver.SetConstraintUpdate(n,n.Gap/e));return i}GetVariableResolvedPosition(t){let e=this.GetVariable(t);return e==null?0:e.ActualPos}InitSolver(){this.solver=new Ys,this.variables.clear()}AddFixedVariable(t,e){this.AddVariableWithIdealPositionNNN(t,e,Zs.FixedVarWeight),this.fixedVars.set(t,e)}ContainsVariable(t){return this.variables.has(t)}GetVariableIdealPosition(t){return this.variables.get(t).DesiredPos}get Solution(){return this.solution}},Qo=Zs;Qo.FixedVarWeight=1e9;var Ks=class{constructor(){this.lowBound=Number.NEGATIVE_INFINITY;this.upperBound=Number.POSITIVE_INFINITY}get Position(){return this.position}set Position(t){t<this.lowBound?this.position=this.lowBound:t>this.upperBound?this.position=this.upperBound:this.position=t}get LowBound(){return this.lowBound}set LowBound(t){this.lowBound=t}get UpperBound(){return this.upperBound}set UpperBound(t){this.upperBound=t}toString(){return this.lowBound+(" "+(this.Position+(" "+this.upperBound)))}};var $s=class{constructor(t){this.idealPositions=new Map;this.varList=new Array;this.constraints=new Set;this.solverShell=new Qo;this.boundsToInt=new Map;this.varSepartion=t}SetLowBound(t,e){let i=this.Var(e);i.LowBound=Math.max(t,i.LowBound)}Var(t){return this.varList[t]}SetUpperBound(t,e){let i=this.Var(t);i.UpperBound=Math.min(e,i.UpperBound)}Solve(){this.SolveByRegularSolver()}SolveByRegularSolver(){this.CreateVariablesForBounds();for(let t=0;t<this.varList.length;t++){let e=this.varList[t];e.IsFixed?this.solverShell.AddFixedVariable(t,e.Position):(this.solverShell.AddVariableWithIdealPositionNN(t,this.idealPositions.get(t)),e.LowBound!==Number.NEGATIVE_INFINITY&&this.constraints.add(new F(this.GetBoundId(e.LowBound),t)),e.UpperBound!==Number.POSITIVE_INFINITY&&this.constraints.add(new F(t,this.GetBoundId(e.UpperBound))))}this.CreateGraphAndRemoveCycles();for(let t of this.graph.edges){let e=0;t.x<this.varList.length&&(e+=this.varList[t.x].Width),t.y<this.varList.length&&(e+=this.varList[t.y].Width),e/=2,this.solverShell.AddLeftRightSeparationConstraintNNN(t.x,t.y,this.varSepartion+e)}this.solverShell.Solve();for(let t=0;t<this.varList.length;t++)this.varList[t].Position=this.solverShell.GetVariableResolvedPosition(t)}GetBoundId(t){return this.boundsToInt.get(t)}CreateVariablesForBounds(){for(let t of this.varList)t.IsFixed||(t.LowBound!==Number.NEGATIVE_INFINITY&&this.RegisterBoundVar(t.LowBound),t.UpperBound!==Number.POSITIVE_INFINITY&&this.RegisterBoundVar(t.UpperBound))}RegisterBoundVar(t){if(!this.boundsToInt.has(t)){let e=this.varList.length+this.boundsToInt.size;this.boundsToInt.set(t,e),this.solverShell.AddFixedVariable(e,t)}}CreateGraphAndRemoveCycles(){this.graph=rt(Array.from(this.constraints),this.varList.length+this.boundsToInt.size);let t=jt.getFeedbackSet(this.graph);if(t!=null)for(let e of t)this.graph.removeEdge(e)}GetVariablePosition(t){return this.varList[t].Position}AddConstraint(t,e){this.constraints.add(new F(t,e))}AddVariableNNNN(t,e,i,r){this.idealPositions.set(t,i),this.AddVariableNNBN(t,e,!1,r)}AddFixedVariable(t,e){this.AddVariableNNBN(t,e,!0,0)}AddVariableNNBN(t,e,i,r){let n=new Ks;n.Position=e,n.IsFixed=i,n.Width=r,this.varList.push(n)}};var Yr=class{clone(){let t=new Yr;return t.transparency=this.transparency,t.width=this.width,t.color=this.color,t.icurve=this.icurve.clone(),t.label=this.label,t.dashArray=this.dashArray,t.drawPN=this.drawPN,t}static mkDebugCurveTWCILD(t,e,i,r,n,o,s=!1){let a=new Yr;return a.transparency=t,a.width=e,a.color=i,a.icurve=r,a.label=n,a.dashArray=o,a.drawPN=s,a}static mkDebugCurveTWCI(t,e,i,r){return Yr.mkDebugCurveTWCILD(t,e,i,r,null,null)}static mkDebugCurveWCI(t,e,i){return Yr.mkDebugCurveTWCI(255,t,e,i)}static mkDebugCurveCI(t,e){return Yr.mkDebugCurveWCI(1,t,e)}static mkDebugCurveI(t){return Yr.mkDebugCurveCI("Black",t)}},z=Yr;z.colors=["DeepSkyBlue","IndianRed","Orange","Gold","DarkRed","Plum","Red","Violet","Indigo","Yellow","OrangeRed","Tomato","Purple","SaddleBrown","Green","Navy","Aqua","Pink","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","Lime","BurlyWood","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","CadetBlue","Chartreuse","DarkBlue","DarkCyan","DarkGoldenrod","DarkGray","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkTurquoise","DarkViolet","DeepPink","DimGray","DodgerBlue","Firebrick","FloralWhite","ForestGreen","Fuchsia","CodeAnalysis","Gainsboro","GhostWhite","Goldenrod","Gray","GreenYellow","Honeydew","HotPink","Ivory","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenrodYellow","LightGray","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSteelBlue","LightYellow","LimeGreen","Linen","Magenta","Maroon","MediumAquamarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","OldLace","Olive","OliveDrab","Orchid","PaleGoldenrod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","PowderBlue","RosyBrown","RoyalBlue","Salmon","SandyBrown","SeaGreen","CodeAnalysis","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Transparent","Turquoise","Aquamarine","Azure","Beige","Wheat","White","WhiteSmoke","YellowGreen","Khaki","AntiqueWhite"];var Fu=J(Mi(),1);var ea=class extends Nt{constructor(e,i){super(e,i);this.RightNeighbors=new Set;this.setOfLongestSegs=new Set;this.RightBound=Number.POSITIVE_INFINITY,this.LeftBound=Number.NEGATIVE_INFINITY,this.Direction=v.DirectionFromPointToPoint(e.point,i.point)}AddRightNeighbor(e){this.RightNeighbors.add(e)}get LongestNudgedSegments(){return this.setOfLongestSegs}AddLongestNudgedSegment(e){this.setOfLongestSegs.add(e)}BoundFromRight(e){e=Math.max(e,this.LeftBound),this.RightBound=Math.min(e,this.RightBound)}BoundFromLeft(e){e=Math.min(e,this.RightBound),this.LeftBound=Math.max(e,this.LeftBound)}};var Bt=class{constructor(t){this.Point=t}*GetEnumerator(){let t;for(t=this;t!=null;t=t.Next)yield t.Point}get X(){return this.Point.x}get Y(){return this.Point.y}InsertVerts(t,e,i){for(e--;t<e;e--)this.SetNewNext(i[e])}InsertVertsInReverse(t,e,i){for(t++;t<e;t++)this.SetNewNext(i[t])}SetNewNext(t){let e=new Bt(t),i=this.Next;this.Next=e,e.Next=i}};var Bn=class{constructor(t,e){this.IsFixed=!1;this.Reversed=!1;this.index=-1;this.AxisEdge=t,this.Width=e}toString(){return this.Source+(" "+this.Target)}get LongestNudgedSegment(){return this.longestNudgedSegment}set LongestNudgedSegment(t){this.longestNudgedSegment=t,this.longestNudgedSegment!=null&&(this.longestNudgedSegment.AddEdge(this),this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment))}get Source(){return this.Reversed?this.AxisEdge.TargetPoint:this.AxisEdge.SourcePoint}get Target(){return this.Reversed?this.AxisEdge.SourcePoint:this.AxisEdge.TargetPoint}static VectorsAreParallel(t,e){return N(t.x*e.y-t.y*e.x,0)}static EdgesAreParallel(t,e){return Bn.VectorsAreParallel(t.AxisEdge.TargetPoint.sub(t.AxisEdge.SourcePoint),e.AxisEdge.TargetPoint.sub(e.AxisEdge.SourcePoint))}get Direction(){return this.Reversed?v.OppositeDir(this.AxisEdge.Direction):this.AxisEdge.Direction}get Index(){return this.index}set Index(t){this.index=t}};var Et=class{constructor(t){this.pathVisibilityGraph=new se;this.axisEdgesToPathOrders=new Map;this.OriginalPaths=t}get PathVisibilityGraph(){return this.pathVisibilityGraph}GetOrder(){return this.FillTheVisibilityGraphByWalkingThePaths(),this.InitPathOrder(),this.OrderPaths(),this.axisEdgesToPathOrders}FillTheVisibilityGraphByWalkingThePaths(){for(let t of this.OriginalPaths)this.FillTheVisibilityGraphByWalkingPath(t)}FillTheVisibilityGraphByWalkingPath(t){let e=this.CreatePathEdgesFromPoints(r(),t.Width),i=e.next();for(i.done||t.SetFirstEdge(i.value);(i=e.next()).done===!1;)t.AddEdge(i.value);function*r(){if(t.PathPoints instanceof Bt)for(let n=t.PathPoints;n!=null;n=n.Next)yield n.Point;else for(let n of t.PathPoints)yield n}}*CreatePathEdgesFromPoints(t,e){let i=t.next(),r=i.value;for(;!(i=t.next()).done;)yield this.CreatePathEdge(r,i.value,e),r=i.value}CreatePathEdge(t,e,i){switch(v.DirectionFromPointToPoint(t,e)){case 2:case 1:return new Bn(this.GetAxisEdge(t,e),i);case 4:case 8:{let n=new Bn(this.GetAxisEdge(e,t),i);return n.Reversed=!0,n}default:throw new Error("Not a rectilinear path")}}GetAxisEdge(t,e){return this.PathVisibilityGraph.AddEdgeF(t,e,(i,r)=>new ea(i,r))}InitPathOrder(){for(let t of this.PathVisibilityGraph.Edges)this.axisEdgesToPathOrders.set(t,new Array);for(let t of this.OriginalPaths)for(let e of t.PathEdges())this.axisEdgesToPathOrders.get(e.AxisEdge).push(e)}OrderPaths(){for(let t of Et.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))this.OrderPathEdgesSharingEdge(t)}OrderPathEdgesSharingEdge(t){let e=this.PathOrderOfVisEdge(t);e.sort(Et.CompareTwoPathEdges);let i=0;for(let r of e)r.Index=i++}static CompareTwoPathEdges(t,e){if(t===e)return 0;let i=Et.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,t.AxisEdge.Direction);return i!==0?i:-Et.CompareInDirectionStartingFromAxisEdge(t,e,t.AxisEdge,v.OppositeDir(t.AxisEdge.Direction))}static CompareInDirectionStartingFromAxisEdge(t,e,i,r){for(;;){if(t=Et.GetNextPathEdgeInDirection(t,i,r),t==null||(e=Et.GetNextPathEdgeInDirection(e,i,r),e==null))return 0;if(t.AxisEdge===e.AxisEdge){r=Et.FindContinuedDirection(i,r,t.AxisEdge),i=t.AxisEdge;let u=Et.GetExistingOrder(t,e);if(u===Et.NotOrdered)continue;return r===i.Direction?u:-u}let n=r===i.Direction?i.Target:i.Source,o=Et.OtherVertex(t.AxisEdge,n),s=Et.OtherVertex(e.AxisEdge,n),a=Et.ProjectionForCompare(i,r!==i.Direction);return Q(a(o.point),a(s.point))}}static FindContinuedDirection(t,e,i){return t.Direction===e?i.Source===t.Target?i.Direction:v.OppositeDir(i.Direction):i.Source===t.Source?i.Direction:v.OppositeDir(i.Direction)}static OtherVertex(t,e){return t.Source===e?t.Target:t.Source}static ProjectionForCompare(t,e){return t.Direction===1?e?i=>-i.x:i=>i.x:e?i=>i.y:i=>-i.y}static GetNextPathEdgeInDirection(t,e,i){return e.Direction===i?t.Reversed?t.Prev:t.Next:t.Reversed?t.Next:t.Prev}static GetExistingOrder(t,e){let i=t.Index;if(i===-1)return Et.NotOrdered;let r=e.Index;return Q(i,r)}PathOrderOfVisEdge(t){return this.axisEdgesToPathOrders.get(t)}static InitQueueOfSources(t,e,i){for(let r of i.Vertices()){let n=r.InEdgesLength();e.set(r,n),n===0&&t.enqueue(r)}}static*WalkGraphEdgesInTopologicalOrderIfPossible(t){let e=new Fu.Queue,i=new Map;for(Et.InitQueueOfSources(e,i,t);e.length>0;){let r=e.dequeue();for(let n of r.OutEdges){let o=i.get(n.Target);i.set(n.Target,o-1),o===1&&e.enqueue(n.Target),yield n}}}},Xo=Et;Xo.NotOrdered=Number.MAX_VALUE;var ta=class extends Fe{constructor(e,i){super();this.site=i,this.AxisEdge=e}get Site(){return this.site}};var _o=class extends Fe{constructor(e,i){super();this.site=i,this.AxisEdge=e}get Site(){return this.site}};var ia=class{constructor(t){this.edges=new Set;this.Source=t}get Edges(){return this.edges}AddEdge(t){this.UpPoint=t.TargetPoint,this.edges.add(t)}RemoveAxis(t){this.edges.delete(t)}IsEmpty(){return this.edges.size===0}};var Zr=class extends ro{constructor(e,i,r,n,o){super(i,new v(e).ToPoint());this.DirectionPerp=new v(e).Right.ToPoint(),this.PathOrders=n,this.xProjection=e===1?s=>s.x:s=>-s.y,this.edgeContainersTree=new Ee((s,a)=>this.CompareAA(s,a)),this.SweepPole=v.VectorDirection(this.SweepDirection),this.AxisEdges=o,this.AxisEdgesToObstaclesTheyOriginatedFrom=r}FindFreeSpace(){this.InitTheQueueOfEvents(),this.ProcessEvents()}ProcessEvents(){for(;this.EventQueue.Count>0;)this.ProcessEvent(this.EventQueue.Dequeue())}ProcessEvent(e){e instanceof Wt?this.ProcessVertexEvent(e):(this.Z=this.GetZP(e.Site),e instanceof _o?this.ProcessLowEdgeEvent(e):this.ProcessHighEdgeEvent(e))}ProcessHighEdgeEvent(e){let i=e.AxisEdge;this.RemoveEdge(i),this.ConstraintEdgeWithObstaclesAtZ(i,i.Target.point)}ProcessLowEdgeEvent(e){let i=e.AxisEdge,r=this.GetOrCreateAxisEdgesContainer(i);r.item.AddEdge(i);let n=this.edgeContainersTree.previous(r);if(n!=null)for(let s of n.item.edges)for(let a of r.item.edges)this.TryToAddRightNeighbor(s,a);let o=this.edgeContainersTree.next(r);if(o!=null)for(let s of r.item.Edges)for(let a of o.item.edges)this.TryToAddRightNeighbor(s,a);this.ConstraintEdgeWithObstaclesAtZ(i,i.Source.point)}TryToAddRightNeighbor(e,i){this.ProjectionsOfEdgesOverlap(e,i)&&e.AddRightNeighbor(i)}ProjectionsOfEdgesOverlap(e,i){return this.SweepPole===1?!(e.TargetPoint.y<i.SourcePoint.y-m.distanceEpsilon||i.TargetPoint.y<e.SourcePoint.y-m.distanceEpsilon):!(e.TargetPoint.x<i.SourcePoint.x-m.distanceEpsilon||i.TargetPoint.x<e.SourcePoint.x-m.distanceEpsilon)}GetObstacleBoundaries(e){return this.Obstacles.map(i=>z.mkDebugCurveWCI(1,e,i))}ConstraintEdgeWithObstaclesAtZ(e,i){this.ConstraintEdgeWithObstaclesAtZFromLeft(e,i),this.ConstraintEdgeWithObstaclesAtZFromRight(e,i)}ConstraintEdgeWithObstaclesAtZFromRight(e,i){let r=this.GetActiveSideFromRight(i);if(r==null||this.NotRestricting(e,r.item.Polyline))return;let n=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(r.item);e.BoundFromRight(n.dot(this.DirectionPerp))}GetActiveSideFromRight(e){return this.LeftObstacleSideTree.findFirst(i=>Zr.PointToTheLeftOfLineOrOnLineLocal(e,i.Start,i.End))}ConstraintEdgeWithObstaclesAtZFromLeft(e,i){let r=this.GetActiveSideFromLeft(i);if(r==null||this.NotRestricting(e,r.item.Polyline))return;let n=this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(r.item);e.BoundFromLeft(n.dot(this.DirectionPerp))}static PointToTheLeftOfLineOrOnLineLocal(e,i,r){return c.signedDoubledTriangleArea(e,i,r)>-Zr.AreaComparisonEpsilon}static PointToTheRightOfLineOrOnLineLocal(e,i,r){return c.signedDoubledTriangleArea(i,r,e)<Zr.AreaComparisonEpsilon}GetActiveSideFromLeft(e){return this.RightObstacleSideTree.findLast(i=>Zr.PointToTheRightOfLineOrOnLineLocal(e,i.Start,i.End))}static EdgeMidPoint(e){return c.middle(e.SourcePoint,e.TargetPoint)}GetOrCreateAxisEdgesContainer(e){let i=e.Source.point,r=this.GetAxisEdgesContainerNode(i);return r!=null?r:this.edgeContainersTree.insert(new ia(i))}GetAxisEdgesContainerNode(e){let i=this.xProjection(e),r=this.edgeContainersTree.findFirst(n=>this.xProjection(n.Source)>=i-m.distanceEpsilon/2);return r!=null&&this.xProjection(r.item.Source)<=i+m.distanceEpsilon/2?r:null}ProcessVertexEvent(e){this.Z=this.GetZS(e),e instanceof Ii?this.ProcessLeftVertex(e,e.Vertex.nextOnPolyline):e instanceof vi?this.ProcessRightVertex(e,e.Vertex.prevOnPolyline):(this.ProcessLeftVertex(e,e.Vertex.nextOnPolyline),this.ProcessRightVertex(e,e.Vertex.prevOnPolyline))}ProcessRightVertex(e,i){let r=e.Site;this.ProcessPrevSegmentForRightVertex(e,r);let n=i.point.sub(e.Site),o=n.dot(this.DirectionPerp),s=n.dot(this.SweepDirection);s<=m.distanceEpsilon?o>0&&s>=0?this.EnqueueEvent(new vi(i)):this.RestrictEdgeContainerToTheRightOfEvent(e.Vertex):(this.InsertRightSide(new ji(e.Vertex)),this.EnqueueEvent(new vi(i)),this.RestrictEdgeContainerToTheRightOfEvent(e.Vertex))}RestrictEdgeContainerToTheRightOfEvent(e){let i=e.point,r=this.xProjection(i),n=this.edgeContainersTree.findFirst(o=>r<=this.xProjection(o.Source));if(n!=null)for(let o of n.item.Edges)this.NotRestricting(o,e.polyline)||o.BoundFromLeft(this.DirectionPerp.dot(i))}NotRestricting(e,i){return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(e)===i}ProcessPrevSegmentForRightVertex(e,i){let r=e.Vertex.nextOnPolyline.point;i.sub(r).dot(this.SweepDirection)>m.distanceEpsilon&&this.RemoveRightSide(new ji(e.Vertex.nextOnPolyline))}RemoveEdge(e){let i=this.GetAxisEdgesContainerNode(e.Source.point);i.item.RemoveAxis(e),i.item.IsEmpty()&&this.edgeContainersTree.deleteNodeInternal(i)}ProcessLeftVertex(e,i){let r=e.Site;this.ProcessPrevSegmentForLeftVertex(e,r);let n=i.point.sub(e.Site),o=n.dot(this.DirectionPerp),s=n.dot(this.SweepDirection);s<=m.distanceEpsilon?o<0&&s>=0&&this.EnqueueEvent(new Ii(i)):(this.InsertLeftSide(new qi(e.Vertex)),this.EnqueueEvent(new Ii(i))),this.RestrictEdgeFromTheLeftOfEvent(e.Vertex)}RestrictEdgeFromTheLeftOfEvent(e){let i=e.point,r=this.GetContainerNodeToTheLeftOfEvent(i);if(r!=null)for(let n of r.item.Edges)this.NotRestricting(n,e.polyline)||n.BoundFromRight(i.dot(this.DirectionPerp))}GetContainerNodeToTheLeftOfEvent(e){let i=this.xProjection(e);return this.edgeContainersTree.findLast(r=>this.xProjection(r.Source)<=i)}ProcessPrevSegmentForLeftVertex(e,i){let r=e.Vertex.prevOnPolyline.point;i.sub(r).dot(this.SweepDirection)>m.distanceEpsilon&&this.RemoveLeftSide(new qi(e.Vertex.prevOnPolyline))}InitTheQueueOfEvents(){this.InitQueueOfEvents();for(let e of this.AxisEdges)this.EnqueueEventsForEdge(e)}EnqueueEventsForEdge(e){this.EdgeIsParallelToSweepDir(e)&&(this.EnqueueEvent(Zr.EdgeLowPointEvent(e,e.Source.point)),this.EnqueueEvent(Zr.EdgeHighPointEvent(e,e.Target.point)))}EdgeIsParallelToSweepDir(e){return e.Direction===this.SweepPole||e.Direction===v.OppositeDir(this.SweepPole)}static EdgeHighPointEvent(e,i){return new ta(e,i)}static EdgeLowPointEvent(e,i){return new _o(e,i)}CompareAA(e,i){return Q(e.Source.dot(this.DirectionPerp),i.Source.dot(this.DirectionPerp))}},Jo=Zr;Jo.AreaComparisonEpsilon=m.intersectionEpsilon;var ra=class extends zr{constructor(e){super();this.CompassDirection=0;this.edges=new Array;this._isFixed=!1;this.Id=-1;this.IdealPosition=0;this.Id=e}get Start(){return this.start}get End(){return this.end}get Edges(){return this.edges}AddEdge(e){if(this.Edges.length===0){let i=v.VectorDirectionPP(e.Source,e.Target);switch(i){case 4:i=1;break;case 8:i=2;break}this.CompassDirection=i,this.start=e.Source,this.end=e.Source}switch(this.CompassDirection){case 1:this.TryPointForStartAndEndNorth(e.Source),this.TryPointForStartAndEndNorth(e.Target);break;case 2:this.TryPointForStartAndEndEast(e.Source),this.TryPointForStartAndEndEast(e.Target);break}this.Edges.push(e)}TryPointForStartAndEndNorth(e){e.y<this.start.y?this.start=e:e.y>this.end.y&&(this.end=e)}TryPointForStartAndEndEast(e){e.x<this.start.x?this.start=e:e.x>this.end.x&&(this.end=e)}get IsFixed(){return this._isFixed}set IsFixed(e){this._isFixed=e}get Width(){let e=0;for(let i of this.edges)e=Math.max(e,i.Width);return e}GetLeftBound(){if(!this.IsFixed){let e=Number.NEGATIVE_INFINITY;for(let i of this.edges)e=Math.max(e,i.AxisEdge.LeftBound);return e}return this.CompassDirection===1?this.Edges[0].Source.x:-this.Edges[0].Source.y}GetRightBound(){if(!this.IsFixed){let e=Number.POSITIVE_INFINITY;for(let i of this.edges)e=Math.min(e,i.AxisEdge.RightBound);return e}return this.Position()}Position(){return this.CompassDirection===1?this.Edges[0].Source.x:-this.Edges[0].Source.y}};var ii=class{constructor(t,e){this.tree=new Ee((t,e)=>Q(t.Point.x,e.Point.x));this.VerticalPoints=e,this.HorizontalPoints=t}SplitPoints(){this.VerticalPoints.length===0||this.HorizontalPoints.length===0||(this.InitEventQueue(),this.ProcessEvents())}ProcessEvents(){for(;!this.Queue.IsEmpty();){let t={priority:0},e=this.Queue.DequeueAndGetPriority(t);this.ProcessEvent(e,t.priority)}}ProcessEvent(t,e){N(t.Next.Point.x,t.Point.x)?e===ii.Low(t)?this.ProcessLowLinkedPointEvent(t):this.ProcessHighLinkedPointEvent(t):this.IntersectWithTree(t)}IntersectWithTree(t){let e,i,r,n=t.Y;if(t.Point.x<t.Next.Point.x?(i=t.Point.x,e=t.Next.Point.x,r=!0):(e=t.Point.x,i=t.Next.Point.x,r=!1),r)for(let o=this.tree.findFirst(s=>i<=s.Point.x);o!=null&&o.item.Point.x<=e;o=this.tree.next(o)){let s=new c(o.item.Point.x,n);t=ii.TrySplitHorizontalPoint(t,s,!0),ii.TrySplitVerticalPoint(o.item,s)}else for(let o=this.tree.findLast(s=>s.Point.x<=e);o!=null&&o.item.Point.x>=i;o=this.tree.previous(o)){let s=new c(o.item.Point.x,n);t=ii.TrySplitHorizontalPoint(t,s,!1),ii.TrySplitVerticalPoint(o.item,s)}}static TrySplitVerticalPoint(t,e){ii.Low(t)+m.distanceEpsilon<e.y&&e.y+m.distanceEpsilon<ii.High(t)&&t.SetNewNext(e)}static TrySplitHorizontalPoint(t,e,i){return i&&t.X+m.distanceEpsilon<e.x&&e.x+m.distanceEpsilon<t.Next.X||!i&&t.Next.X+m.distanceEpsilon<e.x&&e.x+m.distanceEpsilon<t.X?(t.SetNewNext(e),t.Next):t}ProcessHighLinkedPointEvent(t){this.tree.remove(t)}ProcessLowLinkedPointEvent(t){this.tree.insert(t)}InitEventQueue(){this.Queue=new nt(Q);for(let t of this.VerticalPoints)this.Queue.Enqueue(t,ii.Low(t));for(let t of this.HorizontalPoints)this.Queue.Enqueue(t,t.Point.y)}static Low(t){return Math.min(t.Point.y,t.Next.Point.y)}static High(t){return Math.max(t.Point.y,t.Next.Point.y)}};var pr=class{constructor(t){this.verticesToPathOffsets=new ve;this.Paths=t}MergePaths(){this.InitVerticesToPathOffsetsAndRemoveSelfCycles();for(let t of this.Paths)this.ProcessPath(t)}ProcessPath(t){let e=new Map,i=null;for(let r=t.PathPoints;r!=null;r=r.Next){let n=this.verticesToPathOffsets.get(r.Point);if(i!=null){if(e.size>0)for(let[o,s]of n){let a=e.get(o);a&&(this.CollapseLoopingPath(o,a,s,t,r),e.delete(o))}for(let[o,s]of i)n.has(o)||e.set(o,s)}i=n}}CollapseLoopingPath(t,e,i,r,n){let o=pr.FindLinkedPointInPath(r,e.Point),s=Array.from(pr.GetPointsInBetween(o,n));pr.Before(e,i)?(this.CleanDisappearedPiece(e,i,t),this.ReplacePiece(e,i,s,t)):(this.CleanDisappearedPiece(i,e,t),this.ReplacePiece(i,e,s.reverse(),t))}static*GetPointsInBetween(t,e){for(let i=t.Next;i!==e;i=i.Next)yield i.Point}ReplacePiece(t,e,i,r){let n=t;for(let o of i){let s=new Bt(o);n.Next=s,n=s,this.verticesToPathOffsets.get(o).set(r,n)}n.Next=e}CleanDisappearedPiece(t,e,i){for(let r of pr.GetPointsInBetween(t,e))this.verticesToPathOffsets.get(r).delete(i)}static Before(t,e){for(t=t.Next;t!=null;t=t.Next)if(t===e)return!0;return!1}static FindLinkedPointInPath(t,e){for(let i=t.PathPoints;;i=i.Next)if(i.Point.equal(e))return i}InitVerticesToPathOffsetsAndRemoveSelfCycles(){for(let t of this.Paths)for(let e=t.PathPoints;e!=null;e=e.Next){let i=this.verticesToPathOffsets.get(e.Point);i||this.verticesToPathOffsets.set(e.Point,i=new Map);let r=i.get(t);r?(this.CleanDisappearedPiece(r,e,t),r.Next=e.Next):i.set(t,e)}}};var na=class{constructor(t){this.projection=t}compare(t,e){return Q(this.projection(t),this.projection(e))}};var go;(function(l){l.has=Symbol.for("@esfx/collection-core!ReadonlyCollection.has"),l.name="ReadonlyContainer";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&l.has in e}l.hasInstance=t})(go||(go={}));var Yo;(function(l){l.has=go.has,l.add=Symbol.for("@esfx/collection-core!Collection.add"),l.delete=Symbol.for("@esfx/collection-core!Collection.delete"),l.name="Container";function t(e){return go.hasInstance(e)&&l.add in e&&l.delete in e}l.hasInstance=t})(Yo||(Yo={}));var Vt;(function(l){l.has=go.has,l.size=Symbol.for("@esfx/collection-core!ReadonlyCollection.size"),l.name="ReadonlyCollection";function t(e){return go.hasInstance(e)&&(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&l.size in e}l.hasInstance=t})(Vt||(Vt={}));var Ve;(function(l){l.size=Vt.size,l.has=Vt.has,l.add=Yo.add,l.delete=Yo.delete,l.clear=Symbol.for("@esfx/collection-core!Collection.clear"),l.name="Collection";function t(e){return Vt.hasInstance(e)&&Yo.hasInstance(e)&&l.clear in e}l.hasInstance=t})(Ve||(Ve={}));var Vn;(function(l){l.size=Vt.size,l.has=Vt.has,l.indexOf=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.indexOf"),l.getAt=Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.getAt"),l.name="ReadonlyIndexedCollection";function t(e){return Vt.hasInstance(e)&&l.indexOf in e&&l.getAt in e}l.hasInstance=t})(Vn||(Vn={}));var oa;(function(l){l.size=Vt.size,l.has=Vt.has,l.indexOf=Vn.indexOf,l.getAt=Vn.getAt,l.setAt=Symbol.for("@esfx/collection-core!FixedSizeIndexedCollection.setAt"),l.name="FixedSizeIndexedCollection";function t(e){return Vn.hasInstance(e)&&l.setAt in e}l.hasInstance=t})(oa||(oa={}));var ku;(function(l){l.size=Vt.size,l.has=Vt.has,l.indexOf=Vn.indexOf,l.getAt=Vn.getAt,l.setAt=oa.setAt,l.add=Ve.add,l.delete=Ve.delete,l.clear=Ve.clear,l.insertAt=Symbol.for("@esfx/collection-core!IndexedCollection.insertAt"),l.removeAt=Symbol.for("@esfx/collection-core!IndexedCollection.removeAt"),l.name="IndexedCollection";function t(e){return oa.hasInstance(e)&&l.insertAt in e&&l.removeAt in e}l.hasInstance=t})(ku||(ku={}));var Kr;(function(l){l.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.has"),l.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.get"),l.name="ReadonlyKeyedContainer";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&l.has in e&&l.get in e}l.hasInstance=t})(Kr||(Kr={}));var Zo;(function(l){l.has=Kr.has,l.get=Kr.get,l.set=Symbol.for("@esfx/collection-core!KeyedCollection.set"),l.delete=Symbol.for("@esfx/collection-core!KeyedCollection.delete"),l.name="KeyedContainer";function t(e){return Kr.hasInstance(e)&&l.set in e&&l.delete in e}l.hasInstance=t})(Zo||(Zo={}));var Ut;(function(l){l.has=Kr.has,l.get=Kr.get,l.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.size"),l.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.keys"),l.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.values"),l.name="ReadonlyKeyedCollection";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&Kr.hasInstance(e)&&l.size in e&&l.keys in e&&l.values in e}l.hasInstance=t})(Ut||(Ut={}));var Mt;(function(l){l.size=Ut.size,l.has=Ut.has,l.get=Ut.get,l.keys=Ut.keys,l.values=Ut.values,l.set=Zo.set,l.delete=Zo.delete,l.clear=Symbol.for("@esfx/collection-core!KeyedCollection.clear"),l.name="KeyedCollection";function t(e){return Ut.hasInstance(e)&&Zo.hasInstance(e)&&l.clear in e}l.hasInstance=t})(Mt||(Mt={}));var It;(function(l){l.size=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.size"),l.has=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.has"),l.hasValue=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue"),l.get=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.get"),l.keys=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.keys"),l.values=Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.values"),l.name="ReadonlyKeyedMultiCollection";function t(e){return(typeof e=="object"&&e!==null||typeof e=="function")&&Symbol.iterator in e&&l.size in e&&l.has in e&&l.hasValue in e&&l.get in e&&l.keys in e&&l.values in e}l.hasInstance=t})(It||(It={}));var Mn;(function(l){l.size=It.size,l.has=It.has,l.hasValue=It.hasValue,l.get=It.get,l.keys=It.keys,l.values=It.values,l.add=Symbol.for("@esfx/collection-core!KeyedMultiCollection.add"),l.delete=Symbol.for("@esfx/collection-core!KeyedMultiCollection.delete"),l.deleteValue=Symbol.for("@esfx/collection-core!KeyedMultiCollection.deleteValue"),l.clear=Symbol.for("@esfx/collection-core!KeyedMultiCollection.clear"),l.name="KeyedMultiCollection";function t(e){return It.hasInstance(e)&&l.add in e&&l.delete in e&&l.deleteValue in e&&l.clear in e}l.hasInstance=t})(Mn||(Mn={}));function Hu(l,t,e,i){if(t%4)throw new TypeError("Pointer not aligned");let r=new Uint32Array(l),n,o,s,a,u,h,d;if(o=t+e,t>>=2,e>=16){s=o-16>>2,a=(i+2654435761|0)+2246822519|0,u=i+2246822519|0,h=i+0|0,d=i+2654435761|0;do a=a+r[t++]*2246822519|0|0,a=(a<<13|a>>>19)*2654435761|0,u=u+r[t++]*2246822519|0|0,u=(u<<13|u>>>19)*2654435761|0,h=h+r[t++]*2246822519|0|0,h=(h<<13|h>>>19)*2654435761|0,d=d+r[t++]*2246822519|0|0,d=(d<<13|d>>>19)*2654435761|0;while(t<=s);n=(a<<1|a>>>31)+(u<<7|u>>>25)|(h<<12|h>>>20)|(d<<18|d>>>14)}else n=i+374761393|0;for(n=n+e|0,s=o-4>>2;t<=s;)n=n+r[t++]*3266489917|0|0,n=(n<<17|n>>>15)*668265263|0;if(t=t<<2,t<o){let g=new Uint8Array(r.buffer);do n=n+g[t++]*374761393|0|0,n=(n<<11|n>>>21)*2654435761|0;while(t<o)}return n=(n^n>>>15)*2246822519|0,n=(n^n>>>13)*3266489917|0,n=n^n>>>16,n>>>0}var Ec=typeof WebAssembly<"u"&&typeof WebAssembly.Module=="function"&&typeof WebAssembly.Instance=="function",Ic=new Uint8Array([0,97,115,109,1,0,0,0,1,8,1,96,3,127,127,126,1,126,3,2,1,0,5,3,1,0,1,7,15,2,3,109,101,109,2,0,5,120,120,104,54,52,0,0,10,130,6,1,255,5,2,3,126,1,127,32,0,32,1,106,33,6,32,1,65,32,79,4,126,32,6,65,32,107,33,6,32,2,66,214,235,130,238,234,253,137,245,224,0,124,33,3,32,2,66,177,169,172,193,173,184,212,166,61,125,33,4,32,2,66,249,234,208,208,231,201,161,228,225,0,124,33,5,3,64,32,3,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,3,32,4,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,4,32,2,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,5,32,0,65,8,106,34,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,124,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,33,5,32,6,32,0,65,8,106,34,0,79,13,0,11,32,2,66,12,137,32,5,66,18,137,124,32,4,66,7,137,124,32,3,66,1,137,124,32,3,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,4,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,2,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,32,5,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,133,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,5,32,2,66,197,207,217,178,241,229,186,234,39,124,11,32,1,173,124,33,2,32,0,32,1,65,31,113,106,33,1,3,64,32,1,32,0,65,8,106,79,4,64,32,0,41,3,0,66,207,214,211,190,210,199,171,217,66,126,66,31,137,66,135,149,175,175,152,182,222,155,158,127,126,32,2,133,66,27,137,66,135,149,175,175,152,182,222,155,158,127,126,66,157,163,181,234,131,177,141,138,250,0,125,33,2,32,0,65,8,106,33,0,12,1,11,11,32,0,65,4,106,32,1,77,4,64,32,2,32,0,53,2,0,66,135,149,175,175,152,182,222,155,158,127,126,133,66,23,137,66,207,214,211,190,210,199,171,217,66,126,66,249,243,221,241,153,246,153,171,22,124,33,2,32,0,65,4,106,33,0,11,3,64,32,0,32,1,73,4,64,32,2,32,0,49,0,0,66,197,207,217,178,241,229,186,234,39,126,133,66,11,137,66,135,149,175,175,152,182,222,155,158,127,126,33,2,32,0,65,1,106,33,0,12,1,11,11,32,2,32,2,66,33,136,133,66,207,214,211,190,210,199,171,217,66,126,34,2,66,29,136,32,2,133,66,249,243,221,241,153,246,153,171,22,126,34,2,66,32,136,32,2,133,11]),Dn=Ec?new WebAssembly.Instance(new WebAssembly.Module(Ic)).exports:void 0;var Fn=Dn===null||Dn===void 0?void 0:Dn.mem,Ol=Dn===null||Dn===void 0?void 0:Dn.xxh64;var Tc=typeof TextEncoder=="function",Wu=(l,t)=>(Wu=Ac())(l,t),Ll=(l,t)=>Wu(l,t);function Ac(){function l(){let e=new TextEncoder;function i(r,n){let{written:o=0}=e.encodeInto(r,n);return o}return i}function t(){function e(i,r){let n=i.length,o=0;for(let s=0;s<n;s++){let a=i.charCodeAt(s);if((a&55296)!==0&&(a&4294910976)===0&&s<n-1){let u=i.charCodeAt(s+1);(u&64512)===56320&&(a=((a&1023)<<10)+(u&1023)+65536,s++)}if((a&4294967168)===0)r[o++]=a;else if((a&4294965248)===0)r[o++]=a>>6|192,r[o++]=a&63|128;else if((a&268431360)===0)r[o++]=a>>12|224,r[o++]=a>>6&63|128,r[o++]=a&63|128;else if((a&4292870144)===0)r[o++]=a>>18|240,r[o++]=a>>12&63|128,r[o++]=a>>6&63|128,r[o++]=a&63|128;else throw new RangeError("Unsupported charCode.")}return o}return e}return Tc?l():t()}var Rl=typeof BigInt=="function"&&typeof BigInt(0)=="bigint",zu=typeof BigUint64Array=="function",Oc=typeof Fn=="object"&&typeof Ol=="function",Gl=new ArrayBuffer(8),Lc=new Float64Array(Gl),fr=new Uint32Array(Gl),po=()=>(po=Rc())(),qu=l=>(qu=Gc())(l),ju=l=>(ju=Nc())(l),Uu=l=>(Uu=po())(l),Qu=l=>(Qu=Bc())(l),Xu=l=>(Xu=Vc())(l),_u=l=>qu(l),Ju=l=>ju(l),Yu=l=>Uu(l),Zu=l=>Qu(l),Nl=l=>Xu(l);function Rc(){function l(){let e=new BigUint64Array(fr.buffer),i=new Uint8Array(Fn.buffer);function r(u){Fn.buffer.byteLength<u&&(Fn.grow(Math.ceil((u-Fn.buffer.byteLength)/65536)),i=new Uint8Array(Fn.buffer))}function n(u){e[0]=u;let h=fr[0],d=fr[1];return(h<<7|h>>>25)^d}function o(){return fr[0]=sa(),fr[1]=sa(),e[0]}function s(u,h){r(u.length*3);let d=Ll(u,i);return n(Ol(0,d,h))}function a(){let u=o();function h(d){return s(d,u)}return h}return a}function t(){let e=new Uint8Array(65536);function i(o){e.byteLength<o&&(e=new Uint8Array(o+(65536-o%65536)))}function r(o,s){i(o.length*3);let a=Ll(o,e);return Hu(e.buffer,0,a,s)>>0}function n(){let o=sa();function s(a){return r(a,o)}return s}return n}return Rl&&zu&&Oc?l():t()}function Gc(){function l(e){Lc[0]=e;let i=fr[0],r=fr[1];return(i<<7|i>>>25)^r|0}function t(e){return e>>0===e?e|0:l(e)}return t}function Nc(){function l(){let i=new BigUint64Array(Gl),r=BigInt(0),n=BigInt(1),o=BigInt(2),s=BigInt(2)**BigInt(31)-BigInt(1),a=~s,u=BigInt(64);function h(d){if(d===r)return 0;if(d>=a&&d<=s)return Number(d);d=d<r?~d*o+n:d*o;let g=0;for(;d;)i[0]=d,g=(g<<7|g>>>25)^fr[0],g=(g<<7|g>>>25)^fr[1],d=d>>u;return g|0}return h}function t(){let i=BigInt(0),r=BigInt(1),n=BigInt(2),o=BigInt(2)**BigInt(31)-BigInt(1),s=~o,a=BigInt(32),u=BigInt("0xFFFFFFFF");function h(d){if(d===i)return 0;if(d>=s&&d<=o)return Number(d);d=d<i?~d*n+r:d*n;let g=0;for(;d!==i;)g=(g<<7|g>>>25)^Number(d&u),d>>=a,g=(g<<7|g>>>25)^Number(d&u),d>>=a;return g|0}return h}function e(){let i=po();function r(n){return i(n.toString())}return r}return Rl&&zu?l():Rl?t():e()}function Bc(){let l="description"in Symbol.prototype?f=>f.description:f=>{let P=f.toString();return P.length>=8&&P.slice(0,7)==="Symbol("&&P.slice(-1)===")"?P.slice(7,-1):P},t=po(),e,i;try{new WeakMap().set(Symbol.iterator,null),e=new WeakMap,i=new WeakMap}catch{e=new Map,i=new Map}for(let f of Object.getOwnPropertyNames(Symbol))if(typeof f=="string"){let P=Symbol[f];typeof P=="symbol"&&i.set(P,`Symbol.${f}`)}let r=po(),n;try{new WeakMap().set(Symbol.for("@esfx/equatable!~globalSymbolTest"),null),n=new WeakMap}catch{n=new Map}let o=po(),s,a=1;try{new WeakMap().set(Symbol(),null),s=new WeakMap}catch{s=new Map}function u(f,P){let y=n.get(f);return y===void 0&&(y=r(P),n.set(f,y)),y}function h(f,P){let y=e.get(f);return y===void 0&&(y=t(P),e.set(f,y)),y}function d(f){let P=s.get(f);return P===void 0&&(P=o(`${a++}#${l(f)}`),s.set(f,P)),P}function g(f){let P=i.get(f);if(P!==void 0)return h(f,P);let y=Symbol.keyFor(f);return y!==void 0?u(f,y):d(f)}return g}function Vc(){let l=new WeakMap,t=sa(),e=1;function i(n){return n=~n+(n<<15),n=n^n>>12,n=n+(n<<2),n=n^n>>4,n=n*2057,n=n^n>>16,n>>>0}function r(n){let o=l.get(n);return o===void 0&&(o=i(e++^t)^t,l.set(n,o)),o}return r}function sa(){return Math.floor(Math.random()*4294967295)>>>0}var aa=typeof globalThis=="object"?globalThis:typeof global=="object"?global:typeof self=="object"?self:void 0,Bl=Symbol.for("@esfx/equatable!~hashUnknown"),la;aa&&typeof aa[Bl]=="function"?la=aa[Bl]:(la=function(t){switch(typeof t){case"boolean":return t?1:0;case"number":return _u(t);case"bigint":return Ju(t);case"string":return Yu(t);case"symbol":return Zu(t);case"function":return Nl(t);case"object":return t===null?0:Nl(t);case"undefined":return 0;default:throw new TypeError(`Unsupported type: ${typeof t}`)}},Object.defineProperty(aa,Bl,{value:la}));function Ku(l){return la(l)}var $r;(function(l){l.equals=Symbol.for("@esfx/equatable:Equatable.equals"),l.hash=Symbol.for("@esfx/equatable:Equatable.hash"),l.name="Equatable";function t(e){let i;return e!=null&&l.equals in(i=Object(e))&&l.hash in i}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})($r||($r={}));var fo;(function(l){l.compareTo=Symbol.for("@esfx/equatable:Comparable.compareTo"),l.name="Comparable";function t(e){return e!=null&&l.compareTo in Object(e)}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(fo||(fo={}));var en;(function(l){l.structuralEquals=Symbol.for("@esfx/equatable:StructualEquatable.structuralEquals"),l.structuralHash=Symbol.for("@esfx/equatable:StructuralEquatable.structuralHash"),l.name="StructuralEquatable";function t(e){let i;return e!=null&&l.structuralEquals in(i=Object(e))&&l.structuralHash in i}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(en||(en={}));var Po;(function(l){l.structuralCompareTo=Symbol.for("@esfx/equatable:StructuralComparable.structuralCompareTo"),l.name="StructuralComparable";function t(e){return e!=null&&l.structuralCompareTo in Object(e)}l.hasInstance=t,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:t})})(Po||(Po={}));var dt;(function(l){let t=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Equaler"});l.defaultEqualer=e((n,o)=>$r.hasInstance(n)?n[$r.equals](o):$r.hasInstance(o)?o[$r.equals](n):Object.is(n,o),n=>$r.hasInstance(n)?n[$r.hash]():Dc(n)),l.structuralEqualer=e((n,o)=>en.hasInstance(n)?n[en.structuralEquals](o,l.structuralEqualer):en.hasInstance(o)?o[en.structuralEquals](n,l.structuralEqualer):l.defaultEqualer.equals(n,o),n=>en.hasInstance(n)?n[en.structuralHash](l.structuralEqualer):l.defaultEqualer.hash(n)),l.tupleEqualer=e((n,o)=>{if(n!=null&&!Array.isArray(n)||o!=null&&!Array.isArray(o))throw new TypeError("Array expected");if(n===o)return!0;if(!n||!o||n.length!==o.length)return!1;for(let s=0;s<n.length;s++)if(!l.defaultEqualer.equals(n[s],o[s]))return!1;return!0},n=>{if(n==null)return 0;if(!Array.isArray(n))throw new TypeError("Array expected");let o=0;for(let s of n)o=i(o,l.defaultEqualer.hash(s));return o}),l.tupleStructuralEqualer=e((n,o)=>{if(n!=null&&!Array.isArray(n)||o!=null&&!Array.isArray(o))throw new TypeError("Array expected");if(n===o)return!0;if(!n||!o||n.length!==o.length)return!1;for(let s=0;s<n.length;s++)if(!l.structuralEqualer.equals(n[s],o[s]))return!1;return!0},n=>{if(n==null)return 0;if(!Array.isArray(n))throw new TypeError("Array expected");let o=0;for(let s of n)o=i(o,l.structuralEqualer.hash(s));return o});function e(n,o=l.defaultEqualer.hash){return Object.setPrototypeOf({equals:n,hash:o},t)}l.create=e;function i(n,o,s=7){if(typeof n!="number")throw new TypeError("Integer expected: x");if(typeof o!="number")throw new TypeError("Integer expected: y");if(typeof s!="number")throw new TypeError("Integer expected: rotate");if(isNaN(n)||!isFinite(n))throw new RangeError("Argument must be a finite number value: x");if(isNaN(o)||!isFinite(o))throw new RangeError("Argument must be a finite number value: y");if(isNaN(s)||!isFinite(s))throw new RangeError("Argument must be a finite number value: rotate");for(;s<0;)s+=32;for(;s>=32;)s-=32;return(n<<s|n>>>32-s)^o}l.combineHashes=i;function r(n){return typeof n=="object"&&n!==null&&typeof n.equals=="function"&&typeof n.hash=="function"}l.hasInstance=r,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:r})})(dt||(dt={}));var RI=dt.defaultEqualer,GI=dt.structuralEqualer,NI=dt.tupleEqualer,BI=dt.tupleEqualer,VI=dt.combineHashes,ui;(function(l){let t=Object.defineProperty({},Symbol.toStringTag,{configurable:!0,value:"Comparer"});l.defaultComparer=e((r,n)=>fo.hasInstance(r)?r[fo.compareTo](n):fo.hasInstance(n)?-n[fo.compareTo](r):r<n?-1:r>n?1:0),l.structuralComparer=e((r,n)=>Po.hasInstance(r)?r[Po.structuralCompareTo](n,l.structuralComparer):Po.hasInstance(n)?-n[Po.structuralCompareTo](r,l.structuralComparer):l.defaultComparer.compare(r,n)),l.tupleComparer=e((r,n)=>{if(r!=null&&!Array.isArray(r)||n!=null&&!Array.isArray(n))throw new TypeError("Array expected");let o;if(o=l.defaultComparer.compare(r.length,n.length))return o;for(let s=0;s<r.length;s++)if(o=l.defaultComparer.compare(r[s],n[s]))return o;return 0}),l.tupleStructuralComparer=e((r,n)=>{if(r!=null&&!Array.isArray(r)||n!=null&&!Array.isArray(n))throw new TypeError("Array expected");let o;if(o=l.defaultComparer.compare(r.length,n.length))return o;for(let s=0;s<r.length;s++)if(o=l.structuralComparer.compare(r[s],n[s]))return o;return 0});function e(r){return Object.setPrototypeOf({compare:r},t)}l.create=e;function i(r){return typeof r=="object"&&r!==null&&typeof r.compare=="function"}l.hasInstance=i,Object.defineProperty(l,Symbol.hasInstance,{configurable:!0,writable:!0,value:i})})(ui||(ui={}));var MI=ui.defaultComparer,DI=ui.structuralComparer,FI=ui.tupleComparer,kI=ui.tupleStructuralComparer;function Dc(l){return Ku(l)}var $u,ua=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});function r(n,o,s){if(n.length===0)return-1;let a=0,u=n.length-1;for(;a<=u;){let h=a+(u-a>>1),d=n[h];switch(Math.sign(s.compare(d,o))){case-1:a=h+1;break;case 0:return h;case 1:u=h-1;break}}return~a}e.binarySearch=r}(l,l.exports,null),l.exports}(),Pr=class{constructor(...t){this._keys=[],this._values=[];let e,i;if(t.length>0){let r=t[0];r===void 0||r!=null&&Symbol.iterator in Object(r)?(e=r,t.length>1&&(i=t[1])):i=r}if(i??(i=ui.defaultComparer),this._comparer=typeof i=="function"?ui.create(i):i,e)for(let[r,n]of e)this.set(r,n)}get comparer(){return this._comparer}get size(){return this._keys.length}has(t){return(0,ua.binarySearch)(this._keys,t,this._comparer)>=0}get(t){let e=(0,ua.binarySearch)(this._keys,t,this._comparer);return e>=0?this._values[e]:void 0}set(t,e){let i=(0,ua.binarySearch)(this._keys,t,this._comparer);return i>=0?this._values[i]=e:(this._keys.splice(~i,0,t),this._values.splice(~i,0,e)),this}delete(t){let e=(0,ua.binarySearch)(this._keys,t,this._comparer);return e>=0?(this._keys.splice(e,1),this._values.splice(e,1),!0):!1}clear(){this._keys.length=0,this._values.length=0}keys(){return this._keys.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._keys.length;t++)yield[this._keys[t],this._values[t]]}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let[i,r]of this)t.call(e,r,i,this)}get[Mt.size](){return this.size}[Mt.has](t){return this.has(t)}[Mt.get](t){return this.get(t)}[Mt.set](t,e){this.set(t,e)}[Mt.delete](t){return this.delete(t)}[Mt.clear](){this.clear()}[Mt.keys](){return this.keys()}[Mt.values](){return this.values()}};$u=Pr;Object.defineProperty($u.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedMap"});var Je=class{static RefinePaths(t,e){Je.AdjustPaths(t);let i=Je.CreatePathsToFirstLinkedVerticesMap(t);Je.Refine(Array.from(i.values())),Je.CrossVerticalAndHorizontalSegs(i.values()),Je.ReconstructPathsFromLinkedVertices(i),e&&new pr(t).MergePaths()}static AdjustPaths(t){for(let e of t)e.PathPoints=Je.AdjustPathPoints(e.PathPoints)}static AdjustPathPoints(t){if(!t||t.length===0)return;let e=[],i=c.RoundPoint(t[0]);e.push(i);for(let r=1;r<t.length;r++){let n=c.RoundPoint(t[r]);i.equal(n)||(i=n,e.push(i))}return e}static CrossVerticalAndHorizontalSegs(t){let e=new Array,i=new Array;for(let r of t)for(let n=r;n.Next!=null;n=n.Next)N(n.Point.x,n.Next.Point.x)?i.push(n):e.push(n);new ii(e,i).SplitPoints()}static ReconstructPathsFromLinkedVertices(t){for(let[e,i]of t)e.PathPoints=i}static Refine(t){Je.RefineInDirection(1,t),Je.RefineInDirection(2,t)}static*groupByProj(t,e){let i=new Map;for(let r of e){let n=t(r.Point),o=i.get(n);o||(o=new Array,i.set(n,o)),o.push(r)}for(let r of i.values())yield r}static RefineInDirection(t,e){let i={projectionToPerp:void 0,projectionToDirection:void 0};Je.GetProjectionsDelegates(t,i);let r=Array.from(Je.GetAllLinkedVertsInDirection(i.projectionToPerp,e)),n=Je.groupByProj(i.projectionToPerp,r);for(let o of n)Je.RefineCollinearBucket(o,i.projectionToDirection)}static GetProjectionsDelegates(t,e){t===2?(e.projectionToDirection=i=>i.x,e.projectionToPerp=i=>i.y):(e.projectionToPerp=i=>i.x,e.projectionToDirection=i=>i.y)}static*GetAllLinkedVertsInDirection(t,e){for(let i of e)for(let r=i;r.Next!=null;r=r.Next)N(t(r.Point),t(r.Next.Point))&&(yield r)}static RefineCollinearBucket(t,e){let i=new Pr(new na(e));for(let o of t)i.has(o.Point)||i.set(o.Point,0),i.has(o.Next.Point)||i.set(o.Next.Point,0);let r=new Array(i.size),n=0;for(let o of i.keys())r[n++]=o;for(n=0;n<r.length;n++)i.set(r[n],n);for(let o of t){n=i.get(o.Point);let s=i.get(o.Next.Point);Math.abs(s-n)>1&&Je.InsertPoints(o,r,n,s)}}static InsertPoints(t,e,i,r){i<r?t.InsertVerts(i,r,e):t.InsertVertsInReverse(r,i,e)}static CreatePathsToFirstLinkedVerticesMap(t){let e=new Map;for(let i of t)e.set(i,Je.CreateLinkedVertexOfEdgePath(i));return e}static CreateLinkedVertexOfEdgePath(t){let e=t.PathPoints,i=new Bt(e[0]),r=i;for(let n=1;n<e.length;n++)i.Next=new Bt(e[n]),i=i.Next;return r}};var _i=class{constructor(t,e){this.Points=t,this.I=e}static equal(t,e){return t.I===e.I&&t.Points===e.Points}get Start(){return this.Points[this.I]}get End(){return this.Points[this.I+1]}};var Ji=class{constructor(t,e){this.segTree=new ki(null);this.crossedOutPaths=new Set;this.HierarchyOfObstacles=new ki(e),this.Paths=t}static RemoveStaircases(t,e){new Ji(t,e).Calculate()}Calculate(){this.InitHierarchies();let t;do{t=!1;for(let e of this.Paths.filter(i=>!this.crossedOutPaths.has(i)))this.ProcessPath(e)&&(t=!0)}while(t)}ProcessPath(t){let e={pts:t.PathPoints,canHaveStaircase:!1};return this.ProcessPoints(e)?(t.PathPoints=e.pts,!0):(e.canHaveStaircase||this.crossedOutPaths.add(t),!1)}ProcessPoints(t){let e=this.FindStaircaseStart(t);return e<0?!1:(t.pts=this.RemoveStaircasePN(t.pts,e),!0)}FindStaircaseStart(t){if(t.canHaveStaircase=!1,t.pts.length<5)return-1;let e=[new _i(t.pts,0),new _i(t.pts,1),new _i(t.pts,2),new _i(t.pts,3)],i=0;for(let r=0;;){let n={canHaveStaircaseAtI:!1};if(this.IsStaircase(t.pts,r,e,n))return t.canHaveStaircase=!0,r;if(t.canHaveStaircase=t.canHaveStaircase||n.canHaveStaircaseAtI,r++,t.pts.length<r+5)return-1;e[i]=new _i(t.pts,r+3),i++,i%=4}}static GetFlippedPoint(t,e){return N(t[e].y,t[e+1].y)?new c(t[e+4].x,t[e].y):new c(t[e].x,t[e+4].y)}Crossing(t,e,i){return Ji.IsCrossing(S.mkPP(t,e),this.segTree,i)}static IsCrossing(t,e,i){for(let r of e.GetAllIntersecting(t.boundingBox))if(i.findIndex(n=>n===r)===-1)return!0;return!1}IntersectObstacleHierarchyPPP(t,e,i){return this.IntersectObstacleHierarchyL(S.mkPP(t,e))||this.IntersectObstacleHierarchyL(S.mkPP(e,i))}IntersectObstacleHierarchyL(t){return this.HierarchyOfObstacles.GetAllIntersecting(t.boundingBox).some(e=>p.intersectionOne(t,e,!1)!=null)}IsStaircase(t,e,i,r){let n=t[e],o=t[e+1],s=t[e+2],a=t[e+3],u=t[e+4];return r.canHaveStaircaseAtI=!1,v.DirectionFromPointToPoint(n,o)!==v.DirectionFromPointToPoint(s,a)||v.DirectionFromPointToPoint(o,s)!==v.DirectionFromPointToPoint(a,u)||(s=Ji.GetFlippedPoint(t,e),this.IntersectObstacleHierarchyPPP(o,s,a))?!1:(r.canHaveStaircaseAtI=!0,!this.Crossing(o,s,i))}RemoveStaircasePN(t,e){let i=t[e],r=t[e+1],n=Math.abs(i.y-r.y)<m.distanceEpsilon/2;return this.RemoveStaircasePNB(t,e,n)}RemoveStaircasePNB(t,e,i){this.RemoveSegs(t);let r=new Array(t.length-2);kc(t,r,e+1);let n=t[e+1],o=t[e+3];return r[e+1]=i?new c(o.x,n.y):new c(n.x,o.y),Fc(t,e+4,r,e+2,r.length-e-2),this.InsertNewSegs(r,e),r}RemoveSegs(t){for(let e=0;e<t.length-1;e++)this.RemoveSeg(new _i(t,e))}RemoveSeg(t){this.segTree.Remove(Ji.Rect(t),t)}InsertNewSegs(t,e){this.InsSeg(t,e),this.InsSeg(t,e+1)}InitHierarchies(){for(let t of this.Paths)this.InsertPathSegs(t)}InsertPathSegs(t){this.InsertSegs(t.PathPoints)}InsertSegs(t){for(let e=0;e<t.length-1;e++)this.InsSeg(t,e)}InsSeg(t,e){let i=new _i(t,e);this.segTree.Add(Ji.Rect(i),i)}static Rect(t){return I.mkPP(t.Start,t.End)}};function Fc(l,t,e,i,r){for(;r-- >0;)e[i++]=l[t++]}function kc(l,t,e){let i=0;for(;e-- >0;)t[i++]=l[i++]}var fe=class{get HasGroups(){return this.HierarchyOfGroups!=null&&this.HierarchyOfGroups.Count>0}constructor(t,e,i,r){this.AncestorsSets=r,this.HierarchyOfGroups=ge(Array.from(r.keys()).filter(n=>n.IsGroup).map(n=>Se(n,n.BoundingBox))),this.Obstacles=i,this.EdgeSeparation=2*e,this.Paths=t,this.HierarchyOfObstacles=ge(i.map(n=>Se(n,n.boundingBox))),this.MapPathsToTheirObstacles()}MapPathsToTheirObstacles(){this.PathToObstacles=new Map;for(let t of this.Paths)this.MapPathToItsObstacles(t)}MapPathToItsObstacles(t){if(!t.PathPoints||t.PathPoints.length===0)return;let e=t.PathPoints,i=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[0],fe.ObstacleTest),r=this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[e.length-1],fe.ObstacleTest);i!=null&&r!=null&&this.PathToObstacles.set(t,[i.UserData,r.UserData])}static ObstacleTest(t,e){return p.PointRelativeToCurveLocation(t,e)!==0?1:0}Calculate(t,e){this.NudgingDirection=t,Je.RefinePaths(this.Paths,e),this.GetPathOrdersAndPathGraph(),this.MapAxisEdgesToTheirObstacles(),this.DrawPaths()}MapAxisEdgesToTheirObstacles(){this.axisEdgesToObstaclesTheyOriginatedFrom=new Map;for(let t of this.Paths)this.MapPathEndAxisEdgesToTheirObstacles(t);for(let t of this.Paths)this.UmmapPathInteriourFromStrangerObstacles(t)}UmmapPathInteriourFromStrangerObstacles(t){let e=this.FindFirstUnmappedEdge(t);if(e==null)return;let i=this.FindLastUnmappedEdge(t);for(let r=e;r!=null&&r!==i;r=r.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.delete(r.AxisEdge)}FindLastUnmappedEdge(t){for(let e=t.LastEdge;e!=null;e=e.Prev)if(e.AxisEdge.Direction!==this.NudgingDirection)return e;return null}FindFirstUnmappedEdge(t){for(let e=t.FirstEdge;e!=null;e=e.Next)if(e.AxisEdge.Direction!==this.NudgingDirection)return e;return null}MapPathEndAxisEdgesToTheirObstacles(t){let e=this.PathToObstacles.get(t);e&&(this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e[0]),this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e[1]))}ProcessThePathEndToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.LastEdge;i!=null&&v.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Prev)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}ProcessThePathStartToMapAxisEdgesToTheirObstacles(t,e){for(let i=t.FirstEdge;i!=null&&v.DirectionsAreParallel(i.Direction,this.NudgingDirection);i=i.Next)this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge,e)}GetPathOrdersAndPathGraph(){let t=new Xo(this.Paths);this.PathOrders=t.GetOrder(),this.PathVisibilityGraph=t.PathVisibilityGraph}static GetCurvesForShow(t,e){let i=new Array;for(let r of t){let n=new R;for(let o of r.PathPoints)n.addPoint(o);i.push(n)}return i.concat(Array.from(e))}DrawPaths(){this.SetWidthsOfArrowheads(),this.CreateLongestNudgedSegments(),this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)),this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(),this.PositionShiftedEdqges()}SetWidthsOfArrowheads(){for(let t of this.Paths)fe.SetWidthsOfArrowheadsForEdge(t)}static SetWidthsOfArrowheadsForEdge(t){let e=t.GeomEdge;if(e.targetArrowhead!=null){let i=t.LastEdge;i.Width=Math.max(e.targetArrowhead.width,i.Width)}if(e.sourceArrowhead!=null){let i=t.FirstEdge;i.Width=Math.max(e.sourceArrowhead.width,i.Width)}}PositionShiftedEdqges(){this.Solver=new $s(this.EdgeSeparation);for(let t=0;t<this.LongestNudgedSegs.length;t++)this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[t]);this.CreateConstraintsOfTheOrder(),this.CreateConstraintsBetweenLongestSegments(),this.Solver.SolveByRegularSolver(),this.ShiftPathEdges()}MoveLongestSegsIdealPositionsInsideFeasibleIntervals(){for(let t=0;t<this.LongestNudgedSegs.length;t++){let e=this.LongestNudgedSegs[t];fe.MoveLongestSegIdealPositionsInsideFeasibleInterval(e)}}static MoveLongestSegIdealPositionsInsideFeasibleInterval(t){if(t.IsFixed)return;let e=t.GetLeftBound(),i=t.GetRightBound();t.IdealPosition<e?t.IdealPosition=e:t.IdealPosition>i&&(t.IdealPosition=i)}ShiftPathEdges(){for(let t of this.Paths)t.PathPoints=this.GetShiftedPoints(t)}GetShiftedPoints(t){return fe.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(t))}static Rectilinearise(t,e){if(t.x===e.x||t.y===e.y)return e;let i=Math.abs(t.x-e.x),r=Math.abs(t.y-e.y);return i<r?new c(t.x,e.y):new c(e.x,t.y)}GetShiftedPointsSimple(t){let e=[],i=t.FirstEdge;e.push(this.ShiftedPoint(i.Source,i.LongestNudgedSegment));for(let r of t.PathEdges())e.push(this.ShiftedEdgePositionOfTarget(r));return e}ShiftedEdgePositionOfTarget(t){return t.LongestNudgedSegment!=null||t.Next==null?this.ShiftedPoint(t.Target,t.LongestNudgedSegment):this.ShiftedPoint(t.Next.Source,t.Next.LongestNudgedSegment)}ShiftedPoint(t,e){if(e==null)return t;let i=this.Solver.GetVariablePosition(e.Id);return this.NudgingDirection===1?new c(i,t.y):new c(t.x,-i)}static LineSegOfLongestSeg(t,e){let i=e===2?n=>n.x:n=>n.y,r={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};for(let n of t.Edges)fe.UpdateMinMaxWithPoint(r,i,n.Source),fe.UpdateMinMaxWithPoint(r,i,n.Target);return e===2?new S(r.min,-t.IdealPosition,r.max,-t.IdealPosition):new S(t.IdealPosition,r.min,t.IdealPosition,r.max)}static UpdateMinMaxWithPoint(t,e,i){let r=e(i);t.min>r&&(t.min=r),t.max<r&&(t.max=r)}CreateConstraintsBetweenLongestSegments(){for(let t of this.LongestNudgedSegs)this.CreateConstraintsBetweenLongestSegmentsForSegment(t)}CreateConstraintsBetweenLongestSegmentsForSegment(t){let e=new Set;for(let i of t.Edges){let r=i.AxisEdge;if(r!=null)for(let n of r.RightNeighbors)for(let o of n.LongestNudgedSegments)e.add(o)}for(let i of e)this.ConstraintTwoLongestSegs(t,i)}CreateConstraintsOfTheOrder(){for(let t of this.PathOrders)fe.ParallelToDirection(t[0],this.NudgingDirection)&&this.CreateConstraintsOfThePathOrder(t[1])}static ParallelToDirection(t,e){switch(e){case 1:case 4:return N(t.SourcePoint.x,t.TargetPoint.x);default:return N(t.SourcePoint.y,t.TargetPoint.y)}}CreateConstraintsOfThePathOrder(t){let e=null;for(let i of t.filter(r=>r.LongestNudgedSegment!=null))e!=null&&this.ConstraintTwoLongestSegs(e.LongestNudgedSegment,i.LongestNudgedSegment),e=i}ConstraintTwoLongestSegs(t,e){(!t.IsFixed||!e.IsFixed)&&this.Solver.AddConstraint(t.Id,e.Id)}CreateVariablesOfLongestSegment(t){if(t.IsFixed)this.Solver.AddFixedVariable(t.Id,fe.SegmentPosition(t,this.NudgingDirection));else{let e=t.GetLeftBound(),i=t.GetRightBound();e>=i?(this.Solver.AddFixedVariable(t.Id,fe.SegmentPosition(t,this.NudgingDirection)),t.IsFixed=!0):(this.Solver.AddVariableNNNN(t.Id,fe.SegmentPosition(t,this.NudgingDirection),t.IdealPosition,t.Width),e!==Number.NEGATIVE_INFINITY&&this.Solver.SetLowBound(e,t.Id),i!==Number.POSITIVE_INFINITY&&this.Solver.SetUpperBound(t.Id,i))}}static SegmentPosition(t,e){return e===1?t.Start.x:-t.Start.y}FindFreeSpaceInDirection(t){this.BoundAxisEdgesByRectsKnownInAdvance(),new Jo(this.NudgingDirection,this.Obstacles,this.axisEdgesToObstaclesTheyOriginatedFrom,this.PathOrders,t).FindFreeSpace()}BoundAxisEdgesByRectsKnownInAdvance(){for(let t of this.Paths)this.HasGroups&&this.BoundPathByMinCommonAncestors(t),this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t)}BoundPathByMinCommonAncestors(t){for(let e of this.GetMinCommonAncestors(t.GeomEdge)){let i=e.BoundingBox;for(let r of t.PathEdges()){let n=r.AxisEdge;n.Direction===this.NudgingDirection&&this.BoundAxisEdgeByRect(i,n)}}}GetMinCommonAncestors(t){this.PortToShapes==null&&(this.PortToShapes=fe.MapPortsToShapes(this.AncestorsSets.keys()));let e=Hc(this.AncestorsForPort(t.sourcePort),this.AncestorsForPort(t.targetPort));return Array.from(e).filter(i=>!i.Children.some(r=>e.has(r)))}AncestorsForPort(t){let e=this.PortToShapes.get(t);return e?this.AncestorsSets.get(e):new Set(this.HierarchyOfGroups.AllHitItems(I.mkPP(t.Location,t.Location),null))}BoundAxisEdgeAdjacentToObstaclePort(t,e){t.Curve==null?this.BoundAxisByPoint(t.Location,e):t.Curve.boundingBox.contains(t.Location)&&this.BoundAxisEdgeByRect(t.Curve.boundingBox,e)}BoundAxisByPoint(t,e){e!=null&&e.Direction===this.NudgingDirection&&(this.NudgingDirection===1?(e.BoundFromLeft(t.x),e.BoundFromRight(t.x)):(e.BoundFromLeft(-t.y),e.BoundFromRight(-t.y)))}BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t){this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.sourcePort,t.FirstEdge.AxisEdge),this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.targetPort,t.LastEdge.AxisEdge)}BoundAxisEdgeByRect(t,e){e!=null&&e.Direction===this.NudgingDirection&&(this.NudgingDirection===1?(e.BoundFromLeft(t.left),e.BoundFromRight(t.right)):(e.BoundFromLeft(t.top*-1),e.BoundFromRight(t.bottom*-1)))}CreateLongestNudgedSegments(){let t=this.NudgingDirection===2?e=>-e.y:e=>e.x;this.LongestNudgedSegs=new Array;for(let e=0;e<this.Paths.length;e++)this.CreateLongestNudgedSegmentsForPath(this.Paths[e],t)}CreateLongestNudgedSegmentsForPath(t,e){this.GoOverPathAndCreateLongSegs(t),fe.CalculateIdealPositionsForLongestSegs(t,e)}static CalculateIdealPositionsForLongestSegs(t,e){let i=null,r=null,n=e(t.Start);for(let o of t.PathEdges())if(o.LongestNudgedSegment!=null){if(i=o.LongestNudgedSegment,r!=null){let s;fe.SetIdealPositionForSeg(r,s=e(r.start),n,e(i.Start)),n=s,r=null}}else i!=null&&(r=i,i=null);r!=null?fe.SetIdealPositionForSeg(r,e(r.Start),n,e(t.End)):i!=null&&(i.IdealPosition=e(i.Start))}static SetIdealPositionForSeg(t,e,i,r){let n=Math.max(i,r),o=Math.min(i,r);o+m.distanceEpsilon<e?e<n?t.IdealPosition=.5*(n+o):t.IdealPosition=n:t.IdealPosition=o}GoOverPathAndCreateLongSegs(t){let e=null,i=v.OppositeDir(this.NudgingDirection);for(let r of t.PathEdges()){let n=r.Direction;n===this.NudgingDirection||n===i?(e==null?(r.LongestNudgedSegment=e=new ra(this.LongestNudgedSegs.length),this.LongestNudgedSegs.push(e)):r.LongestNudgedSegment=e,r.IsFixed&&(e.IsFixed=!0)):(r.LongestNudgedSegment=null,e=null)}}static BuildPolylineForPath(t){let e={points:t.PathPoints.map(i=>i.clone())};return fe.ExtendPolylineToPorts(e,t),e.points}static ExtendPolylineToPorts(t,e){fe.ExtendPolylineToSourcePort(t,e.GeomEdge.sourcePort.Location),fe.ExtendPolylineToTargetPort(t,e.GeomEdge.targetPort.Location),t.points.length<2&&(t.points=new Array(2),t.points[0]=e.GeomEdge.sourcePort.Location,t.points[1]=e.GeomEdge.targetPort.Location)}static ExtendPolylineToTargetPort(t,e){let i=t.points.length-1,r=v.VectorDirectionPP(t.points[i-1],t.points[i]);if(fe.ProjectionsAreClose(t.points[i-1],r,e)){t.points=t.points.slice(0,i);return}let n=t.points[i];r===2||r===8?t.points[i]=new c(e.x,n.y):t.points[i]=new c(n.x,e.y)}static ProjectionsAreClose(t,e,i){return e===2||e===8?N(t.x,i.x):N(t.y,i.y)}static ExtendPolylineToSourcePort(t,e){let i=v.VectorDirectionPP(t.points[0],t.points[1]);if(fe.ProjectionsAreClose(t.points[1],i,e)){t.points=t.points.slice(1);return}let r=t.points[0];i===2||i===8?t.points[0]=new c(e.x,r.y):t.points[0]=new c(r.x,e.y)}static RemoveSwitchbacksAndMiddlePoints(t){let e=[],i=t[0];e.push(i);let r=t[1],n=v.VectorDirectionPP(i,r),o=1;for(;++o<t.length;){let s=v.VectorDirectionPP(r,t[o]);s===n||v.OppositeDir(s)===n||s===0||(c.closeDistEps(i,r)||e.push(i=fe.Rectilinearise(i,r)),n=s),r=t[o]}return c.closeDistEps(i,r)||e.push(fe.Rectilinearise(i,r)),e}static NudgePaths(t,e,i,r,n){if(t.length===0)return;let o=new fe(t,e,i,r);o.Calculate(1,!0),o.Calculate(2,!1),o.Calculate(1,!1),n&&o.RemoveStaircases();for(let s of t)s.GeomEdge.curve=R.mkFromPoints(fe.BuildPolylineForPath(s))}RemoveStaircases(){Ji.RemoveStaircases(this.Paths,this.HierarchyOfObstacles)}static MapPortsToShapes(t){let e=new Map;for(let i of t)for(let r of i.Ports)e.set(r,i);return e}static*GetEdgePathFromPathEdgesAsDebugCurves(t,e,i,r){let n=r.ArrayOfPathPoints(),o=n.length,s=o>1?(e-t)/(o-1):1;for(let a=0;a<n.length-1;a++)yield z.mkDebugCurveTWCI(200,t+s*a,i,S.mkPP(n[a],n[a+1]))}};function Hc(l,t){let e=new Set;if(l.size<t.size)for(let i of l)t.has(i)&&e.add(i);else for(let i of t)l.has(i)&&e.add(i);return e}var eh=J(Qe(),1);var ha=class{constructor(t,e){this.Crossings=[];this.Location=t,this.Crossings=e}};var Yi=class{constructor(){this.ListOfPointsAndCrossings=[];this.index=0;this.ListOfPointsAndCrossings=new Array}Count(){return this.ListOfPointsAndCrossings.length}Add(t,e){this.ListOfPointsAndCrossings.push(new ha(t,e))}Pop(){return this.ListOfPointsAndCrossings[this.index++]}CurrentIsBeforeOrAt(t){return this.index>=this.ListOfPointsAndCrossings.length?!1:C.ComparePP(this.ListOfPointsAndCrossings[this.index].Location,t)<=0}get First(){return this.ListOfPointsAndCrossings[0]}get Last(){return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length-1]}Reset(){this.index=0}MergeFrom(t){if(this.Reset(),t==null)return;let e=this.ListOfPointsAndCrossings.length,i=0,r=t.ListOfPointsAndCrossings.length,n=0,o=new Array(this.ListOfPointsAndCrossings.length);for(;i<e||n<r;){if(i>=e){o.push(t.ListOfPointsAndCrossings[n++]);continue}if(n>=r){o.push(this.ListOfPointsAndCrossings[i++]);continue}let s=this.ListOfPointsAndCrossings[i],a=t.ListOfPointsAndCrossings[n],u=C.ComparePP(s.Location,a.Location);u===0?(o.push(s),++i,++n):u===-1?(o.push(s),++i):(o.push(a),++n)}this.ListOfPointsAndCrossings=o}Trim(t,e){this.Reset(),!(this.ListOfPointsAndCrossings==null||this.ListOfPointsAndCrossings.length===0)&&(this.ListOfPointsAndCrossings=this.ListOfPointsAndCrossings.filter(i=>C.ComparePP(i.Location,t)>=0&&C.ComparePP(i.Location,e)<=0))}static ToCrossingArray(t,e){let i=0,r=t.length;for(let s=0;s<r;s++)t[s].DirectionToInside===e&&i++;if(i===0)return null;let n=new Array(i),o=0;for(let s=0;s<r;s++)t[s].DirectionToInside===e&&(n[o++]=t[s]);return n}ToString(){return eh.String.Format("{0} [{1}]",this.ListOfPointsAndCrossings.length,this.index)}};var O=class{static EdgeDirectionVE(t){return O.EdgeDirectionVV(t.Source,t.Target)}static EdgeDirectionVV(t,e){return C.GetDirections(t.point,e.point)}static GetEdgeEnd(t,e){let i=O.EdgeDirectionVE(t);return e===i?t.Target:t.Source}static FindAdjacentVertex(t,e){for(let i of t.InEdges)if(C.GetDirections(t.point,i.SourcePoint)===e)return i.Source;for(let i of t.OutEdges)if(C.GetDirections(t.point,i.TargetPoint)===e)return i.Target;return null}static FindAdjacentEdge(t,e){for(let i of t.InEdges)if(C.GetDirections(i.SourcePoint,t.point)===e)return i;for(let i of t.OutEdges)if(C.GetDirections(t.point,i.TargetPoint)===e)return i;return null}static FindBendPointBetween(t,e,i){return O.IsVerticalD(i)?new c(e.x,t.y):new c(t.x,e.y)}static SegmentIntersectionPPP(t,e,i){let r=C.GetDirections(t,e);return O.IsVerticalD(r)?new c(t.x,i.y):new c(i.x,t.y)}static SegmentIntersectionSP(t,e){return O.SegmentIntersectionPPP(t.Start,t.End,e)}static SegmentsIntersection(t,e){return O.IntervalsIntersect(t.Start,t.End,e.Start,e.End)}static SegmentsIntersectLL(t,e){return O.IntervalsIntersect(t.start,t.end,e.start,e.end)}static IntervalsOverlapSS(t,e){return O.IntervalsOverlapPPPP(t.Start,t.End,e.Start,e.End)}static IntervalsOverlapPPPP(t,e,i,r){return O.IntervalsAreCollinear(t,e,i,r)&&C.ComparePP(t,r)!==C.ComparePP(e,i)}static IntervalsAreCollinear(t,e,i,r){let n=O.IsVerticalPP(t,e);return O.IsVerticalPP(i,r)===n?n?C.Equal(t.x,i.x):C.Equal(t.y,i.y):!1}static IntervalsAreSame(t,e,i,r){return C.EqualPP(t,i)&&C.EqualPP(e,r)}static IntervalsIntersect(t,e,i,r){let n=O.SegmentIntersectionPPP(t,e,i);return O.PointIsOnSegmentPPP(t,e,n)&&O.PointIsOnSegmentPPP(i,r,n)?n:void 0}static SegmentIntersectionEP(t,e){return O.SegmentIntersectionPPP(t.SourcePoint,t.TargetPoint,e)}static PointIsOnSegmentPPP(t,e,i){return C.EqualPP(t,i)||C.EqualPP(e,i)||C.GetDirections(t,i)===C.GetDirections(i,e)}static PointIsOnSegmentSP(t,e){return O.PointIsOnSegmentPPP(t.Start,t.End,e)}static IsVerticalD(t){return(t&5)!==0}static IsVerticalE(t){return O.IsVerticalD(C.GetDirections(t.SourcePoint,t.TargetPoint))}static IsVerticalPP(t,e){return O.IsVerticalD(C.GetDirections(t,e))}static IsVertical(t){return O.IsVerticalD(C.GetDirections(t.start,t.end))}static IsAscending(t){return(t&3)!==0}static Slope(t,e,i){let r=e.sub(t);return r.dot(i.PerpDirectionAsPoint)/r.dot(i.DirectionAsPoint)}static SortAscending(t,e){let i=C.GetDirections(t,e);return 0===i||O.IsAscending(i)?[t,e]:[e,t]}static RectangleBorderIntersect(t,e,i){switch(i){case 1:case 4:return new c(e.x,O.GetRectangleBound(t,i));case 2:case 8:return new c(O.GetRectangleBound(t,i),e.y);default:throw new Error}}static GetRectangleBound(t,e){switch(e){case 1:return t.top;case 4:return t.bottom;case 2:return t.right;case 8:return t.left;default:throw new Error}}static RectangleInteriorsIntersect(t,e){return C.Compare(t.bottom,e.top)<0&&C.Compare(e.bottom,t.top)<0&&C.Compare(t.left,e.right)<0&&C.Compare(e.left,t.right)<0}static PointIsInRectangleInterior(t,e){return C.Compare(t.y,e.top)<0&&C.Compare(e.bottom,t.y)<0&&C.Compare(t.x,e.right)<0&&C.Compare(e.left,t.x)<0}};var tn=class{get Dir(){return this.dir}set Dir(t){this.dir=t}constructor(t){this.Dir=t,this.DirectionAsPoint=v.toPoint(this.Dir),this.PerpDirection=1===t?2:1,this.PerpDirectionAsPoint=v.toPoint(this.PerpDirection),this.OppositeDirection=v.OppositeDir(t)}get IsHorizontal(){return 2===this.Dir}get IsVertical(){return 1===this.Dir}Compare(t,e){let i=this.ComparePerpCoord(t,e);return i!==0?i:this.CompareScanCoord(t,e)}CompareScanCoord(t,e){return C.Compare(t.sub(e).dot(this.DirectionAsPoint),0)}ComparePerpCoord(t,e){return C.Compare(t.sub(e).dot(this.PerpDirectionAsPoint),0)}IsFlatS(t){return this.IsFlatPP(t.Start,t.End)}IsFlatPP(t,e){return C.Equal(e.sub(t).dot(this.PerpDirectionAsPoint),0)}IsPerpendicularS(t){return this.IsPerpendicularPP(t.Start,t.End)}IsPerpendicularPP(t,e){return C.Equal(e.sub(t).dot(this.DirectionAsPoint),0)}Coord(t){return t.dot(this.DirectionAsPoint)}Min(t,e){return this.Compare(t,e)<=0?t:e}Max(t,e){return this.Compare(t,e)>=0?t:e}get PerpendicularInstance(){return this.IsHorizontal?tn.VerticalInstance:tn.HorizontalInstance}static GetInstance(t){return O.IsVerticalD(t)?tn.VerticalInstance:tn.HorizontalInstance}ToString(){return this.Dir.toString()}},Ae=tn;Ae.HorizontalInstance=new tn(2),Ae.VerticalInstance=new tn(1);var br=class extends zr{constructor(e,i,r,n){super();this.Update(e,i),this.Weight=r,this.GroupBoundaryPointAndCrossingsList=n}static mk(e,i){return new br(e,i,br.NormalWeight,null)}get Start(){return this.startPoint}get End(){return this.endPoint}get IsVertical(){return br.IsVerticalSegment(this.Start,this.End)}get ScanDirection(){return this.IsVertical?Ae.VerticalInstance:Ae.HorizontalInstance}get IsOverlapped(){return br.OverlappedWeight===this.Weight}get IsReflection(){return br.ReflectionWeight===this.Weight}static IsVerticalSegment(e,i){return e.x===i.x}MergeGroupBoundaryCrossingList(e){e!=null&&(this.GroupBoundaryPointAndCrossingsList==null&&(this.GroupBoundaryPointAndCrossingsList=new Yi),this.GroupBoundaryPointAndCrossingsList.MergeFrom(e))}TrimGroupBoundaryCrossingList(){this.GroupBoundaryPointAndCrossingsList!=null&&this.GroupBoundaryPointAndCrossingsList.Trim(this.Start,this.End)}Update(e,i){this.startPoint=e,this.endPoint=i}SetInitialVisibilityVertex(e){this.LowestVisibilityVertex=e,this.HighestVisibilityVertex=e}AppendVisibilityVertex(e,i){if(this.HighestVisibilityVertex==null)this.AddGroupCrossingsBeforeHighestVisibilityVertex(e,i)||this.SetInitialVisibilityVertex(i);else{if(C.IsPureLower(i.point,this.HighestVisibilityVertex.point))return;this.AddGroupCrossingsBeforeHighestVisibilityVertex(e,i)||this.AppendHighestVisibilityVertex(i)}}AddVisibilityEdge(e,i){let r=new Nt(e,i,this.Weight);return se.AddEdge(r),r}AppendHighestVisibilityVertex(e){C.EqualPP(this.HighestVisibilityVertex.point,e.point)||(this.AddVisibilityEdge(this.HighestVisibilityVertex,e),this.HighestVisibilityVertex=e)}LoadStartOverlapVertexIfNeeded(e){if(this.NeedStartOverlapVertex){let i=e.FindVertex(this.Start);this.AppendVisibilityVertex(e,i!=null?i:e.AddVertexP(this.Start))}}LoadEndOverlapVertexIfNeeded(e){if(this.NeedEndOverlapVertex){let i=e.FindVertex(this.End);this.AppendVisibilityVertex(e,i!=null?i:e.AddVertexP(this.End))}}OnSegmentIntersectorBegin(e){this.AppendGroupCrossingsThroughPoint(e,this.Start)||this.LoadStartOverlapVertexIfNeeded(e)}OnSegmentIntersectorEnd(e){this.AppendGroupCrossingsThroughPoint(e,this.End),this.GroupBoundaryPointAndCrossingsList=null,(this.HighestVisibilityVertex==null||C.IsPureLower(this.HighestVisibilityVertex.point,this.End))&&this.LoadEndOverlapVertexIfNeeded(e)}static Subsume(e,i,r,n,o,s,a,u){return u.extendStart=!0,u.extendEnd=!0,e.seg==null||!O.IntervalsOverlapPPPP(e.seg.Start,e.seg.End,i,r)?!1:e.seg.Weight!==n?e.seg.Start===i&&e.seg.End===r?(e.seg.Weight=Math.min(e.seg.Weight,n),!0):!1:(u.extendStart=s.CompareScanCoord(i,e.seg.Start)===-1,u.extendEnd=s.CompareScanCoord(r,e.seg.End)===1,(u.extendStart||u.extendEnd)&&(a.Remove(e.seg),e.seg.startPoint=s.Min(e.seg.Start,i),e.seg.endPoint=s.Max(e.seg.End,r),e.seg=a.InsertUnique(e.seg).item,e.seg.MergeGroupBoundaryCrossingList(o)),!0)}IntersectsSegment(e){return O.SegmentsIntersection(this,e)!==void 0}toString(){return"["+this.Start+" -> "+this.End+(this.IsOverlapped?" olap":" free")+"]"}ContainsPoint(e){return C.EqualPP(this.Start,e)||C.EqualPP(this.End,e)||C.GetDirections(this.Start,e)===C.GetDirections(e,this.End)}get HasSparsePerpendicularCoords(){return this.sparsePerpendicularCoords==null?!1:this.sparsePerpendicularCoords.size>0}CreatePointFromPerpCoord(e){return this.IsVertical?new c(this.Start.x,e):new c(e,this.Start.y)}AddSparseVertexCoord(e){this.sparsePerpendicularCoords==null&&(this.sparsePerpendicularCoords=new Set),this.sparsePerpendicularCoords.add(e)}AddSparseEndpoint(e){return this.sparsePerpendicularCoords.has(e)?!1:(this.sparsePerpendicularCoords.add(e),!0)}CreateSparseVerticesAndEdges(e){var i;if(this.sparsePerpendicularCoords!=null){this.AppendGroupCrossingsThroughPoint(e,this.Start);for(let r of Array.from(this.sparsePerpendicularCoords.values()).sort(Q)){let n=this.CreatePointFromPerpCoord(r);this.AppendVisibilityVertex(e,(i=e.FindVertex(n))!=null?i:e.AddVertexP(n))}this.AppendGroupCrossingsThroughPoint(e,this.End),this.GroupBoundaryPointAndCrossingsList=null,this.sparsePerpendicularCoords.clear(),this.sparsePerpendicularCoords=null}}HasVisibility(){return this.LowestVisibilityVertex!=null}AddGroupCrossingsBeforeHighestVisibilityVertex(e,i){return this.AppendGroupCrossingsThroughPoint(e,i.point)?(C.IsPureLower(this.HighestVisibilityVertex.point,i.point)&&(this.AddVisibilityEdge(this.HighestVisibilityVertex,i),this.HighestVisibilityVertex=i),!0):!1}AppendGroupCrossingsThroughPoint(e,i){var n;if(this.GroupBoundaryPointAndCrossingsList==null)return!1;let r=!1;for(;this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(i);){let o=this.GroupBoundaryPointAndCrossingsList.Pop(),s=null,a=null;C.ComparePP(o.Location,this.Start)>0&&(s=Yi.ToCrossingArray(o.Crossings,this.ScanDirection.OppositeDirection)),C.ComparePP(o.Location,this.End)<0&&(a=Yi.ToCrossingArray(o.Crossings,this.ScanDirection.Dir)),r=!0;let u=(n=e.FindVertex(o.Location))!=null?n:e.AddVertexP(o.Location);e.AddVertexP(o.Location),s!=null||a!=null?(this.AddLowCrossings(e,u,s),this.AddHighCrossings(e,u,a)):this.LowestVisibilityVertex==null?this.SetInitialVisibilityVertex(u):this.AppendHighestVisibilityVertex(u)}return r}static GetCrossingInteriorVertex(e,i,r){var o;let n=r.GetInteriorVertexPoint(i.point);return(o=e.FindVertex(n))!=null?o:e.AddVertexP(n)}AddCrossingEdge(e,i,r,n){let o=null;this.HighestVisibilityVertex!=null&&(C.EqualPP(this.HighestVisibilityVertex.point,r.point)?o=e.FindEdgePP(i.point,r.point):this.AppendHighestVisibilityVertex(i)),o==null&&(o=this.AddVisibilityEdge(i,r));let s=n.map(u=>u.Group.InputShape),a=o.IsPassable;a==null?o.IsPassable=()=>{for(let u of s)if(u.IsTransparent)return!0;return!1}:o.IsPassable=()=>{for(let u of s)if(u.IsTransparent||a())return!0;return!1},this.LowestVisibilityVertex==null&&this.SetInitialVisibilityVertex(i),this.HighestVisibilityVertex=r}AddLowCrossings(e,i,r){if(r!=null){let n=br.GetCrossingInteriorVertex(e,i,r[0]);this.AddCrossingEdge(e,n,i,r)}}AddHighCrossings(e,i,r){if(r!=null){let n=br.GetCrossingInteriorVertex(e,i,r[0]);this.AddCrossingEdge(e,i,n,r)}}},W=br;W.NormalWeight=Nt.DefaultWeight,W.ReflectionWeight=5,W.OverlappedWeight=500;var $o=class{constructor(t,e,i,r,n){this.IsClosed=!1;this.Vertex=t,this.Direction=e!=null?v.DirectionFromPointToPoint(e.Vertex.point,t.point):0,this.ResetEntry(e,i,r,n)}ResetEntry(t,e,i,r){this.PreviousEntry=t,this.Length=e,this.NumberOfBends=i,this.Cost=r}get PreviousVertex(){return this.PreviousEntry==null?null:this.PreviousEntry.Vertex}toString(){return this.Vertex.point+(" "+(this.Direction+(" "+(this.IsClosed+(" "+this.Cost)))))}};var es=class{constructor(){this.Clear()}Set(t,e){this.Vertex=t,this.Weight=e}Clear(){this.Vertex=null,this.Weight=Number.NaN}},Oe=class{constructor(){this.nextNeighbors=[new es,new es,new es];this.LengthImportance=1,this.BendsImportance=1}CombinedCost(t,e){return this.LengthImportance*t+this.BendsImportance*e}TotalCostFromSourceToVertex(t,e){return this.CombinedCost(t,e)+this.sourceCostAdjustment}InitPath(t,e,i){if(e===i||!this.InitEntryDirectionsAtTarget(i))return!1;this.Target=i,this.Source=e;let r=this.TotalCostFromSourceToVertex(0,0)+this.HeuristicDistanceFromVertexToTarget(e.point,0);return r>=this.upperBoundOnCost?!1:(this.queue=new nt(Q),this.visitedVertices=[e],t==null?this.EnqueueInitialVerticesFromSource(r):this.EnqueueInitialVerticesFromSourceEntries(t),this.queue.count>0)}InitEntryDirectionsAtTarget(t){this.EntryDirectionsToTarget=0;for(let e of t.OutEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|v.DirectionFromPointToPoint(e.TargetPoint,t.point);for(let e of t.InEdges)this.EntryDirectionsToTarget=this.EntryDirectionsToTarget|v.DirectionFromPointToPoint(e.SourcePoint,t.point);return this.EntryDirectionsToTarget!==0}static IsInDirs(t,e){return t===(t&e)}MultistageAdjustedCostBound(t){return Number.isFinite(t)?t+this.BendsImportance:t}HeuristicDistanceFromVertexToTarget(t,e){let i=this.Target.point.sub(t);if(N(i.x,0)&&N(i.y,0))return this.targetCostAdjustment;let r=v.VectorDirection(i),n;return e===0?(e=15,n=this.GetNumberOfBends(e,r)):n=this.GetNumberOfBends(e,r),this.CombinedCost(Oe.ManhattanDistance(t,this.Target.point),n)+this.targetCostAdjustment}GetNumberOfBends(t,e){return v.IsPureDirection(e)?this.GetNumberOfBendsForPureDirection(t,e):Oe.GetBendsForNotPureDirection(e,t,this.EntryDirectionsToTarget)}GetNumberOfBendsForPureDirection(t,e){return(e&t)===e?Oe.IsInDirs(e,this.EntryDirectionsToTarget)?0:Oe.IsInDirs(Oe.Left(e),this.EntryDirectionsToTarget)||Oe.IsInDirs(Oe.Right(e),this.EntryDirectionsToTarget)?2:4:this.GetNumberOfBendsForPureDirection(Oe.AddOneTurn[t],e)+1}static GetBendsForNotPureDirection(t,e,i){let r=t&e;if(r===0)return Oe.GetBendsForNotPureDirection(t,Oe.AddOneTurn[e],i)+1;let n=t&i;return n===0?Oe.GetBendsForNotPureDirection(t,e,Oe.AddOneTurn[i])+1:(r|n)===t?1:2}static Left(t){switch(t){case 0:return 0;case 1:return 8;case 2:return 1;case 4:return 2;case 8:return 4;default:throw new Error("direction")}}static Right(t){switch(t){case 0:return 0;case 1:return 2;case 2:return 4;case 4:return 8;case 8:return 1;default:throw new Error("direction")}}static RestorePathV(t){return Oe.RestorePath(t,null)}static RestorePath(t,e){if(t.entry==null)return[];let i=new Array,r=!1,n=0;for(;;){n===t.entry.Direction?r=!0:(r=!1,i.push(t.entry.Vertex.point),n=t.entry.Direction);let o=t.entry.PreviousEntry;if(o==null||t.entry.Vertex===e)break;t.entry=o}return r&&i.push(t.entry.Vertex.point),i.reverse(),i}QueueReversedEntryToNeighborVertexIfNeeded(t,e,i){let r={numberOfBends:0,length:0},n=e.PreviousVertex,o=Oe.GetLengthAndNumberOfBendsToNeighborVertex(t,n,i,r);if(this.CombinedCost(r.length,r.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)||t.Vertex.Degree===1){let s=this.TotalCostFromSourceToVertex(r.length,r.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(n.point,o);this.EnqueueEntry(t,n,r.length,r.numberOfBends,s)}}UpdateEntryToNeighborVertexIfNeeded(t,e,i){let r={numberOfBends:0,length:0},n=Oe.GetLengthAndNumberOfBendsToNeighborVertex(t,e.Vertex,i,r);if(this.CombinedCost(r.length,r.numberOfBends)<this.CombinedCost(e.Length,e.NumberOfBends)){let o=this.TotalCostFromSourceToVertex(r.length,r.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.Vertex.point,n);e.ResetEntry(t,r.length,r.numberOfBends,o),this.queue.DecreasePriority(e,o)}}CreateAndEnqueueEntryToNeighborVertex(t,e,i){let r={numberOfBends:0,length:0},n=Oe.GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,r),o=this.TotalCostFromSourceToVertex(r.length,r.numberOfBends)+this.HeuristicDistanceFromVertexToTarget(e.point,n);o<this.upperBoundOnCost&&(e.VertexEntries==null&&this.visitedVertices.push(e),this.EnqueueEntry(t,e,r.length,r.numberOfBends,o))}EnqueueEntry(t,e,i,r,n){let o=new $o(e,t,i,r,n);e.SetVertexEntry(o),this.queue.Enqueue(o,o.Cost)}static GetLengthAndNumberOfBendsToNeighborVertex(t,e,i,r){r.length=t.Length+Oe.ManhattanDistance(t.Vertex.point,e.point)*i;let n=v.DirectionFromPointToPoint(t.Vertex.point,e.point);return r.numberOfBends=t.NumberOfBends,t.Direction!==0&&n!==t.Direction&&r.numberOfBends++,n}static ManhattanDistance(t,e){return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)}GetPathWithCost(t,e,i,r,n,o,s){if(this.upperBoundOnCost=s,this.sourceCostAdjustment=i,this.targetCostAdjustment=o,!this.InitPath(t,e,n))return null;for(;this.queue.count>0;){let a=this.queue.Dequeue(),u=a.Vertex;if(u===this.Target){if(r==null)return this.Cleanup(),a;if(a.Direction,this.EntryDirectionsToTarget===0){let d=0;for(let g of this.Target.VertexEntries)r[d++]=g;return this.Cleanup(),null}this.upperBoundOnCost=Math.min(this.MultistageAdjustedCostBound(a.Cost),this.upperBoundOnCost);continue}a.IsClosed=!0;for(let d of this.nextNeighbors)d.Clear();let h=Oe.Right(a.Direction);this.ExtendPathAlongInEdges(a,u.InEdges,h),this.ExtendPathAlongOutEdges(a,u.OutEdges,h);for(let d of this.nextNeighbors)d.Vertex!=null&&this.ExtendPathToNeighborVertex(a,d.Vertex,d.Weight)}if(r!=null&&this.Target.VertexEntries!=null)for(let a=0;a<this.Target.VertexEntries.length;a++)r[a]=this.Target.VertexEntries[a];return this.Cleanup(),null}ExtendPathAlongInEdges(t,e,i){for(let r of e)this.ExtendPathAlongEdge(t,r,!0,i)}ExtendPathAlongOutEdges(t,e,i){let r=e.isEmpty()?null:e.treeMinimum();for(;r!=null;r=e.next(r))this.ExtendPathAlongEdge(t,r.item,!1,i)}ExtendPathAlongEdge(t,e,i,r){if(!Oe.IsPassable(e))return;let n=i?e.Source:e.Target;if(n===t.PreviousVertex){if(t.Vertex.Degree>1||t.Vertex!==this.Source)return;this.ExtendPathToNeighborVertex(t,n,e.Weight);return}let o=v.DirectionFromPointToPoint(t.Vertex.point,n.point),s=this.nextNeighbors[2];o!==t.Direction&&(s=this.nextNeighbors[o===r?1:0]),s.Set(n,e.Weight)}EnqueueInitialVerticesFromSource(t){let e=new $o(this.Source,null,0,0,t);e.IsClosed=!0;for(let i of this.Source.OutEdges)!Oe.IsPassable(i)||this.ExtendPathToNeighborVertex(e,i.Target,i.Weight);for(let i of this.Source.InEdges)!Oe.IsPassable(i)||this.ExtendPathToNeighborVertex(e,i.Source,i.Weight)}EnqueueInitialVerticesFromSourceEntries(t){for(let e of t)e!=null&&this.queue.Enqueue(e,e.Cost)}ExtendPathToNeighborVertex(t,e,i){let r=v.DirectionFromPointToPoint(t.Vertex.point,e.point),n=e.VertexEntries!=null?e.VertexEntries[v.ToIndex(r)]:null;n==null?this.CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i)||this.CreateAndEnqueueEntryToNeighborVertex(t,e,i):n.IsClosed||this.UpdateEntryToNeighborVertexIfNeeded(t,n,i)}CreateAndEnqueueReversedEntryToNeighborVertex(t,e,i){if(t.Vertex.VertexEntries!=null){let r=v.DirectionFromPointToPoint(e.point,t.Vertex.point),n=t.Vertex.VertexEntries[v.ToIndex(r)];if(n!=null)return this.QueueReversedEntryToNeighborVertexIfNeeded(t,n,i),!0}return!1}static IsPassable(t){return t.IsPassable==null||t.IsPassable()}Cleanup(){for(let t of this.visitedVertices)t.RemoveVertexEntries();this.visitedVertices=[],this.queue=null}},ri=Oe;ri.DefaultBendPenaltyAsAPercentageOfDistance=4,ri.AddOneTurn=[0,11,7,15,14,15,15,15,13,15,15,15,15,15,15,15];var rn=class{constructor(t){this.bendPenaltyAsAPercentageOfDistance=ri.DefaultBendPenaltyAsAPercentageOfDistance;this.currentPassTargetEntries=new Array(4);this.bendPenaltyAsAPercentageOfDistance=t}GetPath(t,e){let i={entry:this.GetPathStage(null,t,null,e)};return ri.RestorePathV(i)}GetPathStage(t,e,i,r){let n=new ri,o={bestEntry:null,bestCost:Number.MAX_VALUE/W.OverlappedWeight},s=Number.POSITIVE_INFINITY,a=rn.Barycenter(e),u=rn.Barycenter(r),h=ri.ManhattanDistance(a,u);n.BendsImportance=Math.max(.001,h*(this.bendPenaltyAsAPercentageOfDistance*.01));let d=n.LengthImportance,g=i!=null?this.currentPassTargetEntries:null,f=[];for(let w of e)for(let x of r)f.push([w,x]);f.sort(([w,x],[G,A])=>P(w,x)-P(G,A));for(let[w,x]of f){if(c.closeDistEps(w.point,x.point))continue;let G=y(w,a)*d,A=y(x,u)*d,M=o.bestCost;if(i!=null){for(let Me=0;Me<g.length;Me++)g[Me]=null;M=n.MultistageAdjustedCostBound(o.bestCost)}let Y=n.GetPathWithCost(t,w,G,g,x,A,M);if(g!=null){rn.UpdateTargetEntriesForEachDirection(i,g,o);continue}if(Y==null)continue;let K=Y.Cost/P(w,x);(Y.Cost<o.bestCost||N(Y.Cost,o.bestCost)&&K<s)&&(o.bestCost=Y.Cost,o.bestEntry=Y,s=Y.Cost/P(w,x))}return o.bestEntry;function P(w,x){return ri.ManhattanDistance(w.point,x.point)}function y(w,x){return ri.ManhattanDistance(w.point,x)}}static UpdateTargetEntriesForEachDirection(t,e,i){for(let r=0;r<e.length;r++){let n=e[r];n!=null&&(t[r]==null||n.Cost<t[r].Cost)&&(t[r]=n,n.Cost<i.bestCost&&(i.bestCost=n.Cost,i.bestEntry=n))}}static Barycenter(t){let e=new c(0,0);for(let i of t)e=e.add(i.point);return e.div(t.length)}};var ih=J(Qe(),1);var ca=class{get PathPoints(){return this._pathPoints}set PathPoints(t){this._pathPoints=t}get Width(){return this.GeomEdge.lineWidth}constructor(t){this.GeomEdge=t}get End(){return this.LastEdge.Target}get Start(){return this.FirstEdge.Source}ArrayOfPathPoints(){return this._pathPoints instanceof Bt?Array.from(th(this._pathPoints)):this._pathPoints}*PathEdges(){for(let t=this.FirstEdge;t!=null;t=t.Next)yield t}AddEdge(t){t.Path=this,this.LastEdge.Next=t,t.Prev=this.LastEdge,this.LastEdge=t}SetFirstEdge(t){this.FirstEdge=t,this.LastEdge=t,t.Path=this}toString(){let t=new ih.StringBuilder;this.PathPoints instanceof Bt&&t.Append("L");for(let e of th(this.PathPoints))t.Append(e.toString());return t.ToString()}};function*th(l){if(l instanceof Bt)for(let t=l;t!=null;t=t.Next)yield t.Point;else for(let t of l)yield t}var da=class extends qr{constructor(e,i,r,n){super(i);this.Slope=0;this.SlopeInverse=0;this.Obstacle=e,this.endVertex=n?i.nextOnPolyline:i.prevOnPolyline,r.IsPerpendicularPP(i.point,this.endVertex.point)||(this.Slope=O.Slope(i.point,this.endVertex.point,r),this.SlopeInverse=1/this.Slope)}get Obstacle(){return this.obstacle}set Obstacle(e){this.obstacle=e}get EndVertex(){return this.endVertex}},gt=class extends da{constructor(t,e,i){super(t,e,i,i.IsHorizontal)}},Sr=class extends da{constructor(t,e,i){super(t,e,i,i.IsVertical)}};var nn=class{get PaddedPolyline(){return this._PaddedPolyline}set PaddedPolyline(t){this._PaddedPolyline=t}get looseVisibilityPolyline(){return this._looseVisibilityPolyline==null&&(this._looseVisibilityPolyline=nn.CreateLoosePolyline(this.VisibilityPolyline)),this._looseVisibilityPolyline}set looseVisibilityPolyline(t){this._looseVisibilityPolyline=t}GetPortChanges(t){return t.addedPorts=sr(this.InputShape.Ports,this.Ports),t.removedPorts=sr(this.Ports,this.InputShape.Ports),t.addedPorts.size===0&&t.removedPorts.size===0?!1:(this.Ports=new Set(this.InputShape.Ports),!0)}get IsInConvexHull(){return this.ConvexHull!=null}get IsGroup(){return this.InputShape!=null&&this.InputShape.IsGroup}get VisibilityBoundingBox(){return this.VisibilityPolyline.boundingBox}get VisibilityPolyline(){return this.ConvexHull!=null?this.ConvexHull.Polyline:this.PaddedPolyline}static CreateSentinel(t,e,i,r){let n=nn.mk(t,e,r);return n.CreateInitialSides(n.PaddedPolyline.startPoint,i),n}CreateInitialSides(t,e){this.ActiveLowSide=new gt(this,t,e),this.ActiveHighSide=new Sr(this,t,e),e.IsFlatS(this.ActiveHighSide)&&(this.ActiveHighSide=new Sr(this,this.ActiveHighSide.EndVertex,e))}constructor(t,e){t!=null&&(this.PaddedPolyline=We.PaddedPolylineBoundaryOfNode(t.BoundaryCurve,e),nn.RoundVerticesAndSimplify(this.PaddedPolyline),this.IsRectangle=this.IsPolylineRectangle(),this.InputShape=t,this.Ports=new Set(this.InputShape.Ports))}static mk(t,e,i){let r=new nn(null,0);return r.PaddedPolyline=R.mkClosedFromPoints([c.RoundPoint(t),c.RoundPoint(e)]),r.Ordinal=i,r}IsPolylineRectangle(){if(this.PaddedPolyline.count!==4)return!1;let t=this.PaddedPolyline.startPoint,e=t.nextOnPolyline,i=v.VectorDirectionPP(t.point,e.point);if(!v.IsPureDirection(i))return!1;do{t=e,e=t.nextOnPolyline;let r=v.DirectionFromPointToPoint(t.point,e.point);if(r!==v.RotateRight(i))return!1;i=r}while(t!==this.PaddedPolyline.startPoint);return!0}static RoundVerticesAndSimplify(t){let e=t.startPoint;do e.point=c.RoundPoint(e.point),e=e.nextOnPolyline;while(e!==t.startPoint);nn.RemoveCloseAndCollinearVerticesInPlace(t),t.setInitIsRequired()}get IsPrimaryObstacle(){return this.ConvexHull==null||this===this.ConvexHull.PrimaryObstacle}static RemoveCloseAndCollinearVerticesInPlace(t){let e=m.intersectionEpsilon*10;for(let i=t.startPoint.next;i!=null;i=i.next)c.close(i.prev.point,i.point,e)&&(i.next==null?t.RemoveEndPoint():(i.prev.next=i.next,i.next.prev=i.prev));return c.close(t.start,t.end,e)&&t.RemoveStartPoint(),t=t.RemoveCollinearVertices(),t.endPoint.prev!=null&&t.endPoint.prev!==t.startPoint&&c.getTriangleOrientation(t.endPoint.prev.point,t.end,t.start)===2&&t.RemoveEndPoint(),t.startPoint.next!=null&&t.endPoint.prev!==t.startPoint&&c.getTriangleOrientation(t.end,t.start,t.startPoint.next.point)===2&&t.RemoveStartPoint(),t.setInitIsRequired(),t}get isOverlapped(){return this.clump!==void 0&&this.clump.length>0}get IsSentinel(){return this.InputShape==null}IsInSameClump(t){return this.isOverlapped&&this.clump===t.clump}Close(){this.ActiveLowSide=null,this.ActiveHighSide=null}SetConvexHull(t){this.clump=null,this.IsRectangle=!1,this.ConvexHull=t,this.looseVisibilityPolyline=null}static CreateLoosePolyline(t){let e=We.CreatePaddedPolyline(t,m.intersectionEpsilon*10);return nn.RoundVerticesAndSimplify(e),e}get IsTransparentAncestor(){return this.InputShape==null?!1:this.InputShape.IsTransparent}set IsTransparentAncestor(t){this.InputShape.IsTransparent=t}},st=nn;st.FirstSentinelOrdinal=1,st.FirstNonSentinelOrdinal=10;var rh=J(Qe(),1);var ga=class{constructor(t,e,i,r){this.IsOverlapped=!1;this.unpaddedToPaddedBorderWeight=W.NormalWeight;this.ObstaclePort=t,this.UnpaddedBorderIntersect=e,this.OutwardDirection=i;let n=S.mkPP(this.UnpaddedBorderIntersect,O.RectangleBorderIntersect(t.Obstacle.VisibilityBoundingBox,this.UnpaddedBorderIntersect,i)),o=p.getAllIntersections(n,t.Obstacle.VisibilityPolyline,!0);this.VisibilityBorderIntersect=c.RoundPoint(o[0].x);let s={pacList:null};this.MaxVisibilitySegment=r.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect,this.OutwardDirection,s),this.pointAndCrossingsList=s.pacList,(this.Obstacle.isOverlapped||this.Obstacle.IsGroup&&!this.Obstacle.IsInConvexHull)&&(this.IsOverlapped=r.IntersectionIsInsideAnotherObstacle(null,this.Obstacle,this.VisibilityBorderIntersect,Ae.GetInstance(this.OutwardDirection)),(!this.Obstacle.IsGroup||this.IsOverlapped||this.InteriorEdgeCrossesObstacle(r))&&(this.unpaddedToPaddedBorderWeight=W.OverlappedWeight)),this.Obstacle.IsInConvexHull&&this.unpaddedToPaddedBorderWeight===W.NormalWeight&&this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(r)}get Obstacle(){return this.ObstaclePort.Obstacle}get InitialWeight(){return this.IsOverlapped?W.OverlappedWeight:W.NormalWeight}get IsCollinearWithPort(){return v.IsPureDirection(C.GetDirections(this.VisibilityBorderIntersect,this.ObstaclePort.Location))}get IsVertical(){return O.IsVertical(this.MaxVisibilitySegment)}get WantVisibilityIntersection(){return!this.IsOverlapped&&this.CanExtend&&(!this.ObstaclePort.HasCollinearEntrances||this.IsCollinearWithPort)}get CanExtend(){return C.GetDirections(this.MaxVisibilitySegment.start,this.MaxVisibilitySegment.end)!==0}SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(t){(this.Obstacle.IsGroup?this.InteriorEdgeCrossesObstacle(t):this.InteriorEdgeCrossesConvexHullSiblings())&&(this.unpaddedToPaddedBorderWeight=W.OverlappedWeight)}InteriorEdgeCrossesObstacle(t){let e=I.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(e,i=>i.VisibilityPolyline,Array.from(t.Root.GetLeafRectangleNodesIntersectingRectangle(e)).filter(i=>!i.UserData.IsGroup&&i.UserData!==this.Obstacle).map(i=>i.UserData))}InteriorEdgeCrossesConvexHullSiblings(){let t=I.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect);return this.InteriorEdgeCrossesObstacleRFI(t,e=>e.PaddedPolyline,this.Obstacle.ConvexHull.Obstacles.filter(e=>e!==this.Obstacle))}InteriorEdgeCrossesObstacleRFI(t,e,i){let r=null;for(let n of i){let o=e(n);if(!O.RectangleInteriorsIntersect(t,o.boundingBox))continue;if(r=r!=null?r:S.mkPP(this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect),p.intersectionOne(r,o,!1)!=null||0!==p.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect,o))return!0}return!1}get HasGroupCrossings(){return this.pointAndCrossingsList!=null&&this.pointAndCrossingsList.Count()>0}HasGroupCrossingBeforePoint(t){if(!this.HasGroupCrossings)return!1;let e=O.IsAscending(this.OutwardDirection)?this.pointAndCrossingsList.First:this.pointAndCrossingsList.Last;return C.GetDirections(this.MaxVisibilitySegment.start,e.Location)===C.GetDirections(e.Location,t)}AddToAdjacentVertex(t,e,i,r){let n=t.VisGraph.FindVertex(this.VisibilityBorderIntersect);if(n!=null){this.ExtendEdgeChain(t,n,n,i,r);return}this.OutwardDirection===C.GetDirections(e.point,this.VisibilityBorderIntersect)?(this.VisibilityBorderIntersect=e.point,n=e):(n=t.FindOrAddVertex(this.VisibilityBorderIntersect),t.FindOrAddEdge(n,e,this.InitialWeight)),this.ExtendEdgeChain(t,n,e,i,r)}ExtendEdgeChain(t,e,i,r,n){t.ExtendEdgeChainVRLPB(i,r,this.MaxVisibilitySegment,this.pointAndCrossingsList,this.IsOverlapped);let o=t.FindOrAddVertex(this.UnpaddedBorderIntersect);t.FindOrAddEdge(o,e,this.unpaddedToPaddedBorderWeight),n&&t.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex,o,this.OutwardDirection,this.InitialWeight)}toString(){return rh.String.Format("{0} {1}~{2} {3}",this.ObstaclePort.Location,this.UnpaddedBorderIntersect,this.VisibilityBorderIntersect,this.OutwardDirection)}};var ma=class{constructor(t,e){this.HasCollinearEntrances=!1;this.VisibilityRectangle=I.mkEmpty();this.Port=t,this.Obstacle=e,this.PortEntrances=new Array,this.Location=c.RoundPoint(this.Port.Location)}CreatePortEntrance(t,e,i){let r=new ga(this,t,e,i);this.PortEntrances.push(r),this.VisibilityRectangle.add(r.MaxVisibilitySegment.end),this.HasCollinearEntrances=this.HasCollinearEntrances||r.IsCollinearWithPort}ClearVisibility(){this.PortEntrances=[]}AddToGraph(t,e){e&&(this.CenterVertex=t.FindOrAddVertex(this.Location))}RemoveFromGraph(){this.CenterVertex=null}get LocationHasChanged(){return!c.closeDistEps(this.Location,c.RoundPoint(this.Port.Location))}get PortCurve(){return this.Port.Curve}get PortLocation(){return this.Port.Location}toString(){return this.Port+this.Obstacle.toString()}};var pa=class{constructor(t,e){this.maxVisibilitySegmentsAndCrossings=new Array(4);this.OutOfBoundsDirectionFromGraph=0,this.GetVertex(t,e)}get Point(){return this.Vertex.point}get InitialWeight(){return this.IsOverlapped?W.OverlappedWeight:W.NormalWeight}get IsOutOfBounds(){return 0!==this.OutOfBoundsDirectionFromGraph}GetVertex(t,e){this.Vertex=t.FindOrAddVertex(e)}AddEdgeToAdjacentEdge(t,e,i,r){let n=O.SegmentIntersectionEP(e,this.Point),o=t.VisGraph.FindVertex(n);return o!=null?this.AddToAdjacentVertex(t,o,i,r):o=t.AddEdgeToTargetEdge(this.Vertex,e,n),this.ExtendEdgeChain(t,o,i,r),o}AddToAdjacentVertex(t,e,i,r){C.EqualPP(this.Point,e.point)||t.FindOrAddEdge(this.Vertex,e,this.InitialWeight),this.ExtendEdgeChain(t,e,i,r)}ExtendEdgeChain(t,e,i,r){let n=this.IsOverlapped;n&&(n=t.ObstacleTree.PointIsInsideAnObstaclePD(e.point,i));let o=this.GetSegmentAndCrossings(this.IsOverlapped?e:this.Vertex,i,t);t.ExtendEdgeChainVRLPB(e,r,o[0],o[1],n)}GetSegmentAndCrossings(t,e,i){let r=v.ToIndex(e),n=this.maxVisibilitySegmentsAndCrossings[r];if(n==null){let o={pacList:null};n=[i.ObstacleTree.CreateMaxVisibilitySegment(t.point,e,o),o.pacList],this.maxVisibilitySegmentsAndCrossings[r]=n}else C.GetDirections(t.point,n[0].start)===e&&(n[0].start=t.point);return n}MaxVisibilityInDirectionForNonOverlappedFreePoint(t,e){return this.GetSegmentAndCrossings(this.Vertex,t,e)[0].end}AddOobEdgesFromGraphCorner(t,e){let i=C.GetDirections(e,this.Vertex.point),r=t.VisGraph.FindVertex(e);t.ConnectVertexToTargetVertex(r,this.Vertex,i&5,W.NormalWeight),t.ConnectVertexToTargetVertex(r,this.Vertex,i&10,W.NormalWeight)}RemoveFromGraph(){this.Vertex=null}toString(){return this.Vertex.toString()}};var sh=J(Qe(),1);var nh=J(Qe(),1);var kn=class{constructor(t,e){this.BoundaryWidth=m.distanceEpsilon;this.Group=t,this.DirectionToInside=e}GetInteriorVertexPoint(t){return c.RoundPoint(t.add(v.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)))}toString(){return nh.String.Format("{0} {1}",this.DirectionToInside,this.Group)}};kn.BoundaryWidth=m.distanceEpsilon;var So=class extends Fe{constructor(e){super();this.site=e}get Site(){return this.site}};var on=class extends Wt{constructor(e,i){super(i);this.Obstacle=e}};var sn=class extends on{constructor(t,e){super(t,e)}};var fa=class{AddPendingPerpendicularCoord(t){this.pendingPerpCoords==null&&(this.pendingPerpCoords=new Array),this.pendingPerpCoords.push(t)}ResetForIntersections(){this.CurrentSegment=this.FirstSegment}get IsHorizontal(){return!this.FirstSegment.IsVertical}constructor(t){this.Coord=t}TraverseToSegmentContainingPoint(t){if(this.CurrentSegment.ContainsPoint(t))return!0;let e=this.IsHorizontal?t.y:t.x;if(!C.Equal(this.Coord,e)){for(;this.MoveNext(););return!1}for(;;){if((this.CurrentSegment.NextSegment==null||C.GetDirections(this.CurrentSegment.End,t)==C.GetDirections(t,this.CurrentSegment.NextSegment.Start))&&c.closeIntersections(this.CurrentSegment.End,t))return this.CurrentSegment.Update(this.CurrentSegment.Start,t),!0;if(!this.MoveNext())return!1;if(this.CurrentSegment.ContainsPoint(t))return!0;if(C.IsPureLower(t,this.CurrentSegment.Start))return this.CurrentSegment.Update(t,this.CurrentSegment.End),!0}}MoveNext(){return this.CurrentSegment=this.CurrentSegment.NextSegment,this.HasCurrent}get HasCurrent(){return this.CurrentSegment!=null}PointIsCurrentEndAndNextStart(t){return t.equal(this.CurrentSegment.End)&&this.CurrentSegment.NextSegment!=null&&t.equal(this.CurrentSegment.NextSegment.Start)}AddPerpendicularCoord(t){let e=this.IsHorizontal?new c(t,this.Coord):new c(this.Coord,t);this.TraverseToSegmentContainingPoint(e),this.CurrentSegment.AddSparseVertexCoord(t)}toString(){return this.FirstSegment==null?"-0- "+this.Coord:this.IsHorizontal?"(H) Y === "+this.Coord:"(V) X === "}AppendScanSegment(t){this.FirstSegment==null?this.FirstSegment=t:this.CurrentSegment.NextSegment=t,this.CurrentSegment=t}AddPendingPerpendicularCoordsToScanSegments(){if(this.pendingPerpCoords!=null){this.ResetForIntersections();for(let t of this.pendingPerpCoords)this.AddPerpendicularCoord(t)}}};var ts=class{constructor(t,e){this.CurrentSlotIndex=0;this.vector=[],this.IsHorizontal=e;let i=Array.from(t).sort((r,n)=>r>n?1:r<n?-1:0);for(let r of i)this.vector.push(new fa(r))}get Length(){return this.vector.length}get CurrentSlot(){return this.vector[this.CurrentSlotIndex]}Item(t){return this.vector[t]}CreateScanSegment(t,e,i,r){this.CurrentSlot.AppendScanSegment(new W(t,e,i,r))}ScanSegmentsCompleteForCurrentSlot(){this.CurrentSlotIndex++}ScanSegmentsComplete(){for(let t of this.vector)t.AddPendingPerpendicularCoordsToScanSegments()}Items(){return this.vector}ResetForIntersections(){for(let t of this.vector)t.ResetForIntersections()}FindNearest(t,e){let i=0,r=this.vector.length-1;if(t<=this.vector[i].Coord)return i;if(t>=this.vector[r].Coord)return r;for(;r-i>2;){let n=i+(r-i>>1),o=this.vector[n];if(t<o.Coord){r=n;continue}if(t>o.Coord){i=n;continue}return n}for(i++;i<=r;i++){let n=this.vector[i];if(t<n.Coord)return e>0?i:i-1;if(t===n.Coord)break}return i}CreateSparseVerticesAndEdges(t){for(let e of this.vector){e.ResetForIntersections();for(let i=e.FirstSegment;i!=null;i=i.NextSegment)i.CreateSparseVerticesAndEdges(t)}}GetParallelCoord(t){return this.IsHorizontal?t.y:t.x}GetPerpendicularCoord(t){return this.IsHorizontal?t.x:t.y}ConnectAdjoiningSegmentEndpoints(){for(let t of this.vector){t.ResetForIntersections();let e=t.FirstSegment;for(let i=e.NextSegment;i!=null;i=i.NextSegment){if(i.HasSparsePerpendicularCoords&&e.HasSparsePerpendicularCoords&&i.Start===e.End){let r=this.GetPerpendicularCoord(i.Start);e.AddSparseEndpoint(r),i.AddSparseEndpoint(r)}e=i}}}toString(){return(this.IsHorizontal?"(H) count":"(V) count === ")+this.vector.length}};var ni=class extends Fe{constructor(e,i,r){super();this.InitialObstacle=e,this.ReflectingObstacle=i,this.site=r}static mk(e,i,r){let n=new ni(e.ReflectingObstacle,i,r);return n.PreviousSite=e,n}IsStaircaseStep(e){return this.InitialObstacle===e}get Site(){return this.site}};var is=class{constructor(){this.eventTree=new Fr((t,e)=>this.Compare(t,e))}Reset(t){this.scanDirection=t}Enqueue(t){this.eventTree.Enqueue(t)}Dequeue(){return this.eventTree.Dequeue()}get Count(){return this.eventTree.Count}Compare(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=this.scanDirection.ComparePerpCoord(t.Site,e.Site);if(i)return i;let r=t instanceof ni?0:1,n=e instanceof ni?0:1;return i=r-n,i||this.scanDirection.CompareScanCoord(t.Site,e.Site)}};var oh=J(Qe(),1);var yo=class{constructor(){this.pointCrossingMap=new ve;this.pointList=new Array}AddIntersection(t,e,i){let r=this.pointCrossingMap.get(t);r||(r=new Array,this.pointCrossingMap.set(t,r));let n=r.length;for(let s=0;s<n;s++){let a=r[s];if(a.Group===e)return a}let o=new kn(e,i);return r.push(o),o}Clear(){this.pointCrossingMap.clear()}GetOrderedListBetween(t,e){if(this.pointCrossingMap.size===0)return null;if(C.ComparePP(t,e)>0){let n=t;t=e,e=n}this.pointList=[];for(let n of this.pointCrossingMap.keys())C.ComparePP(n,t)>=0&&C.ComparePP(n,e)<=0&&this.pointList.push(n);this.pointList.sort((n,o)=>n.compareTo(o));let i=new Yi,r=this.pointList.length;for(let n=0;n<r;n++){let o=this.pointList[n];i.Add(o,this.pointCrossingMap.get(o))}return i}toString(){return oh.String.Format("{0}",this.pointCrossingMap.size)}};var rs=class extends ni{constructor(e,i,r){super(e.ReflectingObstacle,i.Obstacle,r);this.Side=i}};var Pa=class{constructor(t){this.staleSites=new Array;this.scanDirection=t,this.eventTree=new Ee((e,i)=>this.CompareBB(e,i)),this.findFirstPred=e=>this.CompareToFindFirstPoint(e.Site)>=0}Add(t){this.eventTree.insert(t)}MarkStaleSite(t){this.staleSites.push(t)}RemoveStaleSites(){let t=this.staleSites.length;if(t>0){for(let e=0;e<t;e++)this.RemoveExact(this.staleSites[e]);this.staleSites=[]}}RemoveSitesForFlatBottom(t,e){for(let i=this.FindFirstInRange(t,e);i!=null;i=this.FindNextInRange(i,e))this.MarkStaleSite(i.item);this.RemoveStaleSites()}Find(t){return this.FindFirstInRange(t,t)}RemoveExact(t){let e=this.eventTree.find(t);return e!=null&&e.item.Site===t.Site?(this.eventTree.deleteNodeInternal(e),!0):!1}FindFirstInRange(t,e){this.findFirstPoint=t;let i=this.eventTree.findFirst(this.findFirstPred);return i!=null&&this.Compare(i.item.Site,e)<=0?i:null}CompareToFindFirstPoint(t){return this.Compare(t,this.findFirstPoint)}FindNextInRange(t,e){let i=this.eventTree.next(t);return i!=null&&this.Compare(i.item.Site,e)<=0?i:null}CompareBB(t,e){return this.scanDirection.CompareScanCoord(t.Site,e.Site)}Compare(t,e){return this.scanDirection.CompareScanCoord(t,e)}};var ns=class extends on{constructor(t,e){super(t,e)}},os=class extends on{constructor(t,e){super(t,e)}},ss=class extends on{constructor(t,e){super(t,e)}};var as=class extends ni{constructor(e,i,r){super(e.ReflectingObstacle,i.obstacle,r);this.Side=i}};var ls=class{get LowNeighborSide(){return this.LowNeighbor==null?null:this.LowNeighbor.item}get HighNeighborSide(){return this.HighNeighbor==null?null:this.HighNeighbor.item}Clear(){this.LowNeighbor=null,this.LowOverlapEnd=null,this.GroupSideInterveningBeforeLowNeighbor=null,this.HighNeighbor=null,this.HighOverlapEnd=null,this.GroupSideInterveningBeforeHighNeighbor=null}SetSides(t,e,i,r){if(O.IsAscending(t)){this.HighNeighbor=e,this.HighOverlapEnd=i,this.GroupSideInterveningBeforeHighNeighbor=r;return}this.LowNeighbor=e,this.LowOverlapEnd=i,this.GroupSideInterveningBeforeLowNeighbor=r}};var at=class{has(t){return this.hasxy(t.x,t.y)}remove(t){if(!(t.x<0||t.x>=this.arrayOfSets.length))return this.arrayOfSets[t.x].delete(t.y)}hasxy(t,e){if(t<0||t>=this.arrayOfSets.length)return!1;let i=this.arrayOfSets[t];return i!==void 0&&i.has(e)}constructor(){this.arrayOfSets=new Array}static mk(t){let e=new at;for(let i of t)e.add(i);return e}*values(){for(let t=0;t<this.arrayOfSets.length;t++){let e=this.arrayOfSets[t];if(!!e)for(let i of e.values())yield new F(t,i)}}add(t){let e=this.arrayOfSets[t.x];e==null&&(this.arrayOfSets[t.x]=e=new Set),e.add(t.y)}addNN(t,e){let i=this.arrayOfSets[t];i==null&&(this.arrayOfSets[t]=i=new Set),i.add(e)}clear(){for(let t of this.arrayOfSets)t&&t.clear()}};var us=class{constructor(t,e){this.Polyline=t,this.Obstacles=Array.from(e),this.PrimaryObstacle=this.Obstacles[0],st.RoundVerticesAndSimplify(this.Polyline)}};var Zi=class{static MungeClosestIntersectionInfo(t,e,i){let r=e.seg1.boundingBox,n=c.RoundPoint(e.x).clone();return i?new c(Zi.MungeIntersect(t.x,n.x,r.left,r.right),n.y):new c(n.x,Zi.MungeIntersect(t.y,n.y,r.bottom,r.top))}static MungeIntersect(t,e,i,r){if(t<e){let n=Math.min(i,r);e<n&&(e=n)}else if(t>e){let n=Math.max(i,r);e>n&&(e=n)}return c.RoundDouble(e)}};var Ie=class{constructor(){this.CurrentGroupBoundaryCrossingMap=new yo;this.overlapPairs=new at;this.hasOverlaps=!1;this.lookupIntPair=new F(-1,-1)}get GraphBox(){return this.Root.irect}Init(t,e,i){this.CreateObstacleListAndOrdinals(t),this.AncestorSets=e,this.CreateRoot(),this.shapeIdToObstacleMap=i}CreateObstacleListAndOrdinals(t){this.allObstacles=Array.from(t);let e=st.FirstNonSentinelOrdinal;for(let i of this.allObstacles)i.Ordinal=e++}OrdinalToObstacle(t){return this.allObstacles[t-st.FirstNonSentinelOrdinal]}CreateRoot(){this.Root=Ie.CalculateHierarchy(this.GetAllObstacles()),this.OverlapsExist()&&(this.AccreteClumps(),this.AccreteConvexHulls(),this.GrowGroupsToAccommodateOverlaps(),this.Root=Ie.CalculateHierarchy(this.GetAllObstacles().filter(t=>t.IsPrimaryObstacle)))}OverlapsExist(){return this.Root==null?!1:(Be(this.Root,this.Root,(t,e)=>this.CheckForInitialOverlaps(t,e)),this.hasOverlaps)}OverlapPairAlreadyFound(t,e){return this.lookupIntPair.x=e.Ordinal,this.lookupIntPair.y=t.Ordinal,this.overlapPairs.has(this.lookupIntPair)}CheckForInitialOverlaps(t,e){if(this.hasOverlaps)return;let i={bIsInsideA:!1,aIsInsideB:!1};if(Ie.ObstaclesIntersect(t,e,i)){this.hasOverlaps=!0;return}!i.aIsInsideB&&!i.bIsInsideA||t.IsGroup&&e.IsGroup||t.IsGroup&&i.bIsInsideA||e.IsGroup&&i.aIsInsideB||(this.hasOverlaps=!0)}AccreteClumps(){this.AccumulateObstaclesForClumps(),this.CreateClumps()}AccreteConvexHulls(){for(;;)if(this.AccumulateObstaclesForConvexHulls(),!this.CreateConvexHulls())return}static CalculateHierarchy(t){let e=Array.from(t).map(i=>Se(i,i.VisibilityBoundingBox));return ge(e)}AccumulateObstaclesForClumps(){this.overlapPairs.clear();let t=Ie.CalculateHierarchy(this.GetAllObstacles().filter(e=>!e.IsGroup&&e.IsRectangle));t!=null&&it(t,t,(e,i)=>this.EvaluateOverlappedPairForClump(e,i))}EvaluateOverlappedPairForClump(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1};!Ie.ObstaclesIntersect(t,e,i)&&!i.aIsInsideB&&!i.bIsInsideA||this.overlapPairs.add(new F(t.Ordinal,e.Ordinal))}AccumulateObstaclesForConvexHulls(){this.overlapPairs.clear();let t=Ie.CalculateHierarchy(this.GetAllObstacles().filter(e=>e.IsPrimaryObstacle&&!e.IsGroup));t!=null&&it(t,t,(e,i)=>this.EvaluateOverlappedPairForConvexHull(e,i))}EvaluateOverlappedPairForConvexHull(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1};!Ie.ObstaclesIntersect(t,e,i)&&!i.aIsInsideB&&!i.bIsInsideA||!t.IsInConvexHull&&!e.IsInConvexHull&&t.IsRectangle&&e.IsRectangle||(this.overlapPairs.add(new F(t.Ordinal,e.Ordinal)),this.AddClumpToConvexHull(t),this.AddClumpToConvexHull(e),this.AddConvexHullToConvexHull(t),this.AddConvexHullToConvexHull(e))}GrowGroupsToAccommodateOverlaps(){for(;;)if(this.AccumulateObstaclesForGroupOverlaps(),!this.GrowGroupsToResolveOverlaps())return}AccumulateObstaclesForGroupOverlaps(){let t=Ie.CalculateHierarchy(this.GetAllObstacles().filter(i=>i.IsGroup)),e=Ie.CalculateHierarchy(this.GetAllObstacles().filter(i=>i.IsPrimaryObstacle));t==null||e==null||it(t,e,(i,r)=>this.EvaluateOverlappedPairForGroup(i,r))}EvaluateOverlappedPairForGroup(t,e){if(t===e||this.OverlapPairAlreadyFound(t,e))return;let i={bIsInsideA:!1,aIsInsideB:!1},r=Ie.ObstaclesIntersect(t,e,i);if(!(!r&&!i.aIsInsideB&&!i.bIsInsideA)){if(t.IsRectangle&&e.IsRectangle){e.IsGroup||(i.aIsInsideB||Ie.FirstRectangleContainsACornerOfTheOther(e.VisibilityBoundingBox,t.VisibilityBoundingBox))&&(e.OverlapsGroupCorner=!0);return}!r&&(e.IsGroup||i.bIsInsideA)||this.overlapPairs.add(new F(t.Ordinal,e.Ordinal))}}static FirstRectangleContainsACornerOfTheOther(t,e){return t.contains(e.leftBottom)||t.contains(e.leftTop)||t.contains(e.rightTop)||t.contains(e.rightBottom)}static FirstPolylineStartIsInsideSecondPolyline(t,e){return p.PointRelativeToCurveLocation(t.start,e)!==0}AddClumpToConvexHull(t){if(t.isOverlapped){for(let e of t.clump.filter(i=>i.Ordinal!==t.Ordinal))this.overlapPairs.add(new F(t.Ordinal,e.Ordinal));t.clump=[]}}AddConvexHullToConvexHull(t){if(t.IsInConvexHull){for(let e of t.ConvexHull.Obstacles.filter(i=>i.Ordinal!==t.Ordinal))this.overlapPairs.add(new F(t.Ordinal,e.Ordinal));t.ConvexHull.Obstacles=[]}}CreateClumps(){let t=ao(Array.from(this.overlapPairs.values())),e=Ti(t);for(let i of e){if(i.length===1)continue;let r=i.map(n=>this.OrdinalToObstacle(n));for(let n of r)n.clump=r}}CreateConvexHulls(){let t=!1,e=ao(Array.from(this.overlapPairs.values())),i=Ti(e);for(let r of i){if(r.length===1)continue;t=!0;let n=r.map(this.OrdinalToObstacle),o=Vi(n,a=>a.VisibilityPolyline),s=new us(yt.createConvexHullAsClosedPolyline(o),n);for(let a of n)a.SetConvexHull(s)}return t}GrowGroupsToResolveOverlaps(){let t=!1;for(let e of this.overlapPairs.values()){t=!0;let i=this.OrdinalToObstacle(e.x),r=this.OrdinalToObstacle(e.y);Ie.ResolveGroupAndGroupOverlap(i,r)||Ie.ResolveGroupAndObstacleOverlap(i,r)}return this.overlapPairs.clear(),t}static ResolveGroupAndGroupOverlap(t,e){return e.IsGroup?(t.VisibilityPolyline.boundingBox.area>e.VisibilityPolyline.boundingBox.area?Ie.ResolveGroupAndObstacleOverlap(t,e):Ie.ResolveGroupAndObstacleOverlap(e,t),!0):!1}static ResolveGroupAndObstacleOverlap(t,e){let i=e.looseVisibilityPolyline;Ie.GrowGroupAroundLoosePolyline(t,i);let r={bIsInsideA:!1,aIsInsideB:!1};for(;Ie.ObstaclesIntersect(e,t,r)||!r.aIsInsideB;)i=st.CreateLoosePolyline(i),Ie.GrowGroupAroundLoosePolyline(t,i)}static GrowGroupAroundLoosePolyline(t,e){let i=Array.from(t.VisibilityPolyline).concat(Array.from(e));t.SetConvexHull(new us(yt.createConvexHullAsClosedPolyline(i),[t]))}static ObstaclesIntersect(t,e,i){return p.CurvesIntersect(t.VisibilityPolyline,e.VisibilityPolyline)?(i.aIsInsideB=!1,i.bIsInsideA=!1,!0):(i.aIsInsideB=Ie.FirstPolylineStartIsInsideSecondPolyline(t.VisibilityPolyline,e.VisibilityPolyline),i.bIsInsideA=!i.aIsInsideB&&Ie.FirstPolylineStartIsInsideSecondPolyline(e.VisibilityPolyline,t.VisibilityPolyline),t.IsRectangle&&e.IsRectangle?!1:Ie.ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i.aIsInsideB,i.bIsInsideA)?(i.aIsInsideB=!1,i.bIsInsideA=!1,!0):!1)}static ObstaclesAreCloseEnoughToBeConsideredTouching(t,e,i,r){if(!i&&!r)return p.CurvesIntersect(t.looseVisibilityPolyline,e.VisibilityPolyline);let n=i?t.looseVisibilityPolyline:e.looseVisibilityPolyline,o=i?e.VisibilityPolyline:t.VisibilityPolyline;for(let s of n)if(p.PointRelativeToCurveLocation(s,o)===0){let a=p.ClosestPoint(o,s);if(!c.closeIntersections(s,a))return!0}return!1}AdjustSpatialAncestors(){if(this.SpatialAncestorsAdjusted)return!1;for(let e of this.GetAllGroups()){let i=e.VisibilityBoundingBox;for(let r of this.Root.GetNodeItemsIntersectingRectangle(i))if(r!==e&&p.ClosedCurveInteriorsIntersect(r.VisibilityPolyline,e.VisibilityPolyline)){if(r.IsInConvexHull)for(let n of r.ConvexHull.Obstacles)this.AncestorSets.get(n.InputShape).add(e.InputShape);this.AncestorSets.get(r.InputShape).add(e.InputShape)}}let t=new Array;for(let e of this.Root.GetAllLeaves()){let i=e.VisibilityBoundingBox;t=t.concat(Array.from(this.AncestorSets.get(e.InputShape)).filter(r=>!i.intersects(this.shapeIdToObstacleMap.get(r).VisibilityBoundingBox)));for(let r of t)this.AncestorSets.get(e.InputShape).delete(r);t=[]}return this.SpatialAncestorsAdjusted=!0,!0}GetAllGroups(){return this.GetAllObstacles().filter(t=>t.IsGroup)}Clear(){this.Root=null,this.AncestorSets=null}CreateMaxVisibilitySegment(t,e,i){let r=O.RectangleBorderIntersect(this.GraphBox,t,e);if(C.GetDirections(t,r)===0)return i.pacList=null,S.mkPP(t,t);let n=this.RestrictSegmentWithObstacles(t,r);return i.pacList=this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(n.start,n.end),n}GetAllObstacles(){return this.allObstacles}GetAllPrimaryObstacles(){return this.Root.GetAllLeaves()}IntersectionIsInsideAnotherObstacle(t,e,i,r){return this.insideHitTestIgnoreObstacle1=e,this.insideHitTestIgnoreObstacle2=t,this.insideHitTestScanDirection=r,this.Root.FirstHitNodeWithPredicate(i,this.InsideObstacleHitTest.bind(this))!=null}PointIsInsideAnObstaclePD(t,e){return this.PointIsInsideAnObstacle(t,Ae.GetInstance(e))}PointIsInsideAnObstacle(t,e){return this.insideHitTestIgnoreObstacle1=null,this.insideHitTestIgnoreObstacle2=null,this.insideHitTestScanDirection=e,this.Root.FirstHitNodeWithPredicate(t,this.InsideObstacleHitTest.bind(this))!=null}InsideObstacleHitTest(t,e){if(e===this.insideHitTestIgnoreObstacle1||e===this.insideHitTestIgnoreObstacle2)return 0;if(e.IsGroup)return 0;if(!O.PointIsInRectangleInterior(t,e.VisibilityBoundingBox))return 0;let i=O.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint),r=O.RectangleBorderIntersect(e.VisibilityBoundingBox,t,this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint),n=S.mkPP(r,i),o=p.getAllIntersections(n,e.VisibilityPolyline,!0);if(o.length===2){let s=c.RoundPoint(o[0].x),a=c.RoundPoint(o[1].x);if(!C.EqualPP(t,s)&&!C.EqualPP(t,a)&&t.compareTo(s)!==t.compareTo(a)&&!N(Math.floor(o[0].par1),Math.floor(o[1].par1)))return 1}return 0}SegmentCrossesAnObstacle(t,e){this.stopAtGroups=!0,this.wantGroupCrossings=!1;let i=this.RestrictSegmentPrivate(t,e);return!C.EqualPP(i.end,e)}SegmentCrossesANonGroupObstacle(t,e){this.stopAtGroups=!1,this.wantGroupCrossings=!1;let i=this.RestrictSegmentPrivate(t,e);return!C.EqualPP(i.end,e)}RestrictSegmentWithObstacles(t,e){return this.stopAtGroups=!1,this.wantGroupCrossings=!0,this.RestrictSegmentPrivate(t,e)}RestrictSegmentPrivate(t,e){return this.GetRestrictedIntersectionTestSegment(t,e),this.currentRestrictedRay=S.mkPP(t,e),this.restrictedRayLengthSquared=t.sub(e).lengthSquared,this.CurrentGroupBoundaryCrossingMap.Clear(),this.RecurseRestrictRayWithObstacles(this.Root),this.currentRestrictedRay}GetRestrictedIntersectionTestSegment(t,e){let i=C.GetDirections(t,e),r=8===i?this.GraphBox.right:2===i?this.GraphBox.left:t.x,n=8===i?this.GraphBox.left:2===i?this.GraphBox.right:e.x,o=4===i?this.GraphBox.top*2:1===i?this.GraphBox.bottom:t.y,s=4===i?this.GraphBox.bottom:1===i?this.GraphBox.top:t.y;this.restrictedIntersectionTestSegment=S.mkPP(new c(r,o),new c(n,s))}RecurseRestrictRayWithObstacles(t){if(!O.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox,t.irect))return;let e=t.UserData;if(e!=null){let i=p.getAllIntersections(this.restrictedIntersectionTestSegment,e.VisibilityPolyline,!0);if(!e.IsGroup||this.stopAtGroups){this.LookForCloserNonGroupIntersectionToRestrictRay(i);return}this.wantGroupCrossings&&this.AddGroupIntersectionsToRestrictedRay(e,i);return}this.RecurseRestrictRayWithObstacles(t.Left),this.RecurseRestrictRayWithObstacles(t.Right)}LookForCloserNonGroupIntersectionToRestrictRay(t){let e=0,i=null,r=this.restrictedRayLengthSquared,n=C.GetDirections(this.restrictedIntersectionTestSegment.start,this.restrictedIntersectionTestSegment.end);for(let o of t){let s=c.RoundPoint(o.x),a=C.GetDirections(this.currentRestrictedRay.start,s);if(a===v.OppositeDir(n))continue;if(e++,0===a){r=0,i=o;continue}let u=s.sub(this.currentRestrictedRay.start).lengthSquared;if(u<r){if(o.x.sub(this.currentRestrictedRay.start).lengthSquared<m.squareOfDistanceEpsilon)continue;r=u,i=o}}if(i!=null){if(e===1){let o=c.RoundPoint(i.x);if(c.closeIntersections(o,this.currentRestrictedRay.start)||c.closeIntersections(o,this.currentRestrictedRay.end))return}this.restrictedRayLengthSquared=r,this.currentRestrictedRay.end=Zi.MungeClosestIntersectionInfo(this.currentRestrictedRay.start,i,!O.IsVerticalPP(this.currentRestrictedRay.start,this.currentRestrictedRay.end))}}AddGroupIntersectionsToRestrictedRay(t,e){for(let i of e){let r=c.RoundPoint(i.x);if(r.sub(this.currentRestrictedRay.start).lengthSquared>this.restrictedRayLengthSquared)continue;let o=C.GetDirections(this.currentRestrictedRay.start,this.currentRestrictedRay.end),s=i.seg1,a=v.VectorDirection(s.derivative(i.par1)),u=o;(a&v.RotateRight(o))!==0&&(u=v.OppositeDir(u)),this.CurrentGroupBoundaryCrossingMap.AddIntersection(r,t,u)}}};var ba=class{constructor(t,e){this.scanDirection=t,this.SideTree=new Ee((i,r)=>this.Compare(i,r)),this.linePositionAtLastInsertOrRemove=e}Insert(t,e){return this.linePositionAtLastInsertOrRemove=e,this.SideTree.insert(t)}get Count(){return this.SideTree.count}Remove(t,e){this.linePositionAtLastInsertOrRemove=e,this.SideTree.remove(t)}Find(t){return this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove,t.Start)===-1?null:this.SideTree.find(t)}NextLowB(t){return this.NextLowR(this.Find(t))}NextLowR(t){return this.SideTree.previous(t)}NextHighB(t){return this.NextHighR(this.Find(t))}NextHighR(t){return this.SideTree.next(t)}Next(t,e){return O.IsAscending(t)?this.SideTree.next(e):this.SideTree.previous(e)}Lowest(){return this.SideTree.treeMinimum()}Compare(t,e){if(t.Obstacle===e.Obstacle)return t===e?0:t instanceof gt?-1:1;let i=an.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,t,this.scanDirection),r=an.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove,e,this.scanDirection),n=i.compareTo(r);if(n===0){let o=t instanceof gt,s=e instanceof gt;n=nu(o,s),n===0&&(n=Q(t.Obstacle.Ordinal,e.Obstacle.Ordinal))}return n}};var Hn=class{constructor(t){this.lookupSegment=W.mk(new c(0,0),new c(0,1));this.ScanDirection=t,this.segmentTree=new Ee((e,i)=>this.Compare(e,i)),this.findIntersectorPred=e=>this.CompareIntersector(e),this.findPointPred=e=>this.CompareToPoint(e)}get Segments(){return this.segmentTree.allNodes()}InsertUnique(t){this.AssertValidSegmentForInsertion(t);let e=this.segmentTree.find(t);return e!=null?e:this.segmentTree.insert(t)}AssertValidSegmentForInsertion(t){}Remove(t){this.segmentTree.remove(t)}Find(t,e){this.lookupSegment.Update(t,e);let i=this.segmentTree.find(this.lookupSegment);return i!=null&&C.EqualPP(i.item.End,e)?i.item:null}FindLowestIntersector(t,e){let i=this.FindLowestIntersectorNode(t,e);return i!=null?i.item:null}FindLowestIntersectorNode(t,e){this.lookupSegment.Update(t,t);let i=this.segmentTree.findLast(this.findIntersectorPred);if(C.EqualPP(t,e))i!=null&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);i!=null&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.Start,e)>0)return null;i=this.segmentTree.next(i)}return i}FindHighestIntersector(t,e){this.lookupSegment.Update(e,e);let i=this.segmentTree.findLast(this.findIntersectorPred);if(C.EqualPP(t,e))i!=null&&this.ScanDirection.Compare(i.item.End,t)<0&&(i=null);else for(this.lookupSegment.Update(t,e);i!=null&&!i.item.IntersectsSegment(this.lookupSegment);){if(this.ScanDirection.Compare(i.item.End,t)<0)return null;i=this.segmentTree.previous(i)}return i!=null?i.item:null}CompareIntersector(t){return this.ScanDirection.Compare(t.Start,this.lookupSegment.Start)<=0}FindSegmentContainingPoint(t,e){return this.FindSegmentOverlappingPoints(t,t,e)}FindSegmentOverlappingPoints(t,e,i){this.lookupSegment.Update(t,e);let r=this.segmentTree.findFirst(this.findPointPred);if(r!=null){let n=r.item;if(this.ScanDirection.Compare(n.Start,e)<=0)return n}return null}CompareToPoint(t){return this.ScanDirection.Compare(t.End,this.lookupSegment.Start)>=0}MergeAndRemoveNextNode(t,e){return this.ScanDirection.Compare(t.End,e.item.End)===-1&&t.Update(t.Start,e.item.End),t.MergeGroupBoundaryCrossingList(e.item.GroupBoundaryPointAndCrossingsList),this.segmentTree.deleteNodeInternal(e),this.segmentTree.find(t)}MergeSegments(){if(this.segmentTree.count<2)return;let t=this.segmentTree.treeMinimum(),e=this.segmentTree.next(t);for(;e!=null;e=this.segmentTree.next(t))switch(this.ScanDirection.Compare(e.item.Start,t.item.End)){case 1:t=e;break;case 0:e.item.IsOverlapped===t.item.IsOverlapped?t=this.MergeAndRemoveNextNode(t.item,e):(t.item.NeedEndOverlapVertex=!0,e.item.NeedStartOverlapVertex=!0,t=e);break;default:if(t.item.IsOverlapped!==e.item.IsOverlapped){if(t.item.IsOverlapped)t.item.Start===e.item.Start?t=this.MergeAndRemoveNextNode(e.item,t):(t.item.Update(t.item.Start,e.item.Start),t=e);else if(t.item.End===e.item.End)t=this.MergeAndRemoveNextNode(t.item,e);else{let r=e.item,n=t.item;this.segmentTree.deleteNodeInternal(e),r.Update(n.End,r.End),this.segmentTree.insert(r),r.TrimGroupBoundaryCrossingList(),t=this.segmentTree.find(n)}break}t=this.MergeAndRemoveNextNode(t.item,e);break}}Compare(t,e){if(t===e)return 0;if(t==null)return-1;if(e==null)return 1;let i=this.ScanDirection.Compare(t.Start,e.Start);return i===0&&(i=this.ScanDirection.Compare(t.End,e.End)*-1),i}};var Sa=class extends Wi{constructor(e){super(e)}SetVertexEntry(e){this.VertexEntries==null&&(this.VertexEntries=new Array(4)),this.VertexEntries[v.ToIndex(e.Direction)]=e}RemoveVertexEntries(){this.VertexEntries=null}};var ze=class{constructor(t){this.ObstacleTree=new Ie;this.CurrentGroupBoundaryCrossingMap=new yo;this.LowNeighborSides=new ls;this.HighNeighborSides=new ls;this.ScanDirection=Ae.HorizontalInstance,this.eventQueue=new is,this.HorizontalScanSegments=new Hn(Ae.HorizontalInstance),this.VerticalScanSegments=new Hn(Ae.VerticalInstance),this.wantReflections=t}get ParallelScanSegments(){return this.ScanDirection.IsHorizontal?this.HorizontalScanSegments:this.VerticalScanSegments}get PerpendicularScanSegments(){return this.ScanDirection.IsHorizontal?this.VerticalScanSegments:this.HorizontalScanSegments}static NewVisibilityGraph(){let t=new se;return t.VertexFactory=e=>new Sa(e),t}GenerateVisibilityGraph(){if(this.ObstacleTree.Root==null)return;this.InitializeEventQueue(Ae.HorizontalInstance);let t=st.FirstSentinelOrdinal,e=new c(this.ObstacleTree.GraphBox.left-ze.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ze.SentinelOffset),i=new c(this.ObstacleTree.GraphBox.left-ze.SentinelOffset,this.ObstacleTree.GraphBox.top+ze.SentinelOffset),r=st.CreateSentinel(e,i,this.ScanDirection,t++);this.scanLine.Insert(r.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new c(this.ObstacleTree.GraphBox.right+ze.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ze.SentinelOffset),i=new c(this.ObstacleTree.GraphBox.right+ze.SentinelOffset,this.ObstacleTree.GraphBox.top+ze.SentinelOffset),r=st.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(r.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents(),this.InitializeEventQueue(Ae.VerticalInstance),e=new c(this.ObstacleTree.GraphBox.left-ze.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ze.SentinelOffset),i=new c(this.ObstacleTree.GraphBox.right+ze.SentinelOffset,this.ObstacleTree.GraphBox.bottom-ze.SentinelOffset),r=st.CreateSentinel(e,i,this.ScanDirection,t++),this.scanLine.Insert(r.ActiveHighSide,this.ObstacleTree.GraphBox.leftBottom),e=new c(this.ObstacleTree.GraphBox.left-ze.SentinelOffset,this.ObstacleTree.GraphBox.top+ze.SentinelOffset),i=new c(this.ObstacleTree.GraphBox.right+ze.SentinelOffset,this.ObstacleTree.GraphBox.top+ze.SentinelOffset),r=st.CreateSentinel(e,i,this.ScanDirection,t),this.scanLine.Insert(r.ActiveLowSide,this.ObstacleTree.GraphBox.leftBottom),this.ProcessEvents()}static ScanLineIntersectSidePBS(t,e,i){let r=e.Direction,n=e.Start.x,o=e.Start.y;return i.IsHorizontal?(n+=r.x/r.y*(t.y-e.Start.y),n=Zi.MungeIntersect(t.x,n,e.Start.x,e.End.x),o=t.y):(n=t.x,o+=r.y/r.x*(t.x-e.Start.x),o=Zi.MungeIntersect(t.y,o,e.Start.y,e.End.y)),new c(n,o)}GetOpenVertex(t){let e=t.startPoint,i=this.TraversePolylineForEvents(e),r=this.PointCompare(i.point,e.point);for(;;i=this.TraversePolylineForEvents(i)){let n=this.PointCompare(i.point,e.point);if(n<=0)e=i;else if(n>0&&r<=0)break;r=n}return e}TraversePolylineForEvents(t){return this.ScanDirection.IsHorizontal?t.nextOnPolyline:t.prevOnPolyline}InitializeEventQueue(t){this.ScanDirection=t,this.eventQueue.Reset(this.ScanDirection),this.EnqueueBottomVertexEvents(),this.scanLine=new ba(this.ScanDirection,this.ObstacleTree.GraphBox.leftBottom),this.lookaheadScan=new Pa(this.ScanDirection)}EnqueueBottomVertexEvents(){for(let t of this.ObstacleTree.GetAllPrimaryObstacles()){let e=this.GetOpenVertex(t.VisibilityPolyline);this.eventQueue.Enqueue(new sn(t,e))}}IsFlat(t){return this.ScanDirection.IsFlatS(t)}IsPerpendicular(t){return this.ScanDirection.IsPerpendicularS(t)}ScanLineIntersectSide(t,e){return ze.ScanLineIntersectSidePBS(t,e,this.ScanDirection)}SideReflectsUpward(t){return t instanceof gt?this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start)}SideReflectsDownward(t){return t instanceof gt?this.ScanDirection.Coord(t.End)<this.ScanDirection.Coord(t.Start):this.ScanDirection.Coord(t.End)>this.ScanDirection.Coord(t.Start)}StoreLookaheadSite(t,e,i,r){if(!!this.wantReflections&&!this.IsPerpendicular(e)){if(!r&&!O.PointIsInRectangleInterior(i,e.Obstacle.VisibilityBoundingBox))return;this.SideReflectsUpward(e)&&this.lookaheadScan.Find(i)==null&&this.lookaheadScan.Add(new ni(t,e.Obstacle,i))}}LoadReflectionEvents(t){this.LoadReflectionEventsBB(t,t)}LoadReflectionEventsBB(t,e){if(t==null||this.SideReflectsUpward(t)||this.IsPerpendicular(t))return;let i=I.mkPP(t.Start,t.End),r=I.mkPP(e.Start,e.End);if(this.ScanDirection.IsHorizontal?!i.intersectsOnX(r):!i.intersectsOnY(r))return;let n=I.intersect(i,r),o=n.leftBottom,s=n.rightTop,a=this.lookaheadScan.FindFirstInRange(o,s);for(;a!=null;){let u=ze.ScanLineIntersectSidePBS(a.item.Site,t,this.ScanDirection.PerpendicularInstance);this.ScanDirection.ComparePerpCoord(u,a.item.Site)>0?this.AddReflectionEvent(a.item,t,u):a.item.ReflectingObstacle!==t.Obstacle&&this.lookaheadScan.MarkStaleSite(a.item),a=this.lookaheadScan.FindNextInRange(a,s)}this.lookaheadScan.RemoveStaleSites()}AddPerpendicularReflectionSegment(t,e,i){if(this.lookaheadScan.RemoveExact(t.PreviousSite)){if(e==null)return!1;if(t.PreviousSite.IsStaircaseStep(t.ReflectingObstacle)){if(!O.PointIsInRectangleInterior(t.Site,t.ReflectingObstacle.VisibilityBoundingBox)||!this.InsertPerpendicularReflectionSegment(t.PreviousSite.Site,t.Site))return!1;if(i!=null&&t.IsStaircaseStep(i.Obstacle))return this.ScanLineCrossesObstacle(t.Site,i.Obstacle)}}return!1}AddParallelReflectionSegment(t,e,i,r){{let n=this.ScanLineIntersectSide(r.Site,e!=null?e:i),o=e!=null?n:r.Site,s=e!=null?r.Site:n;return e==null?e=this.scanLine.NextLowB(i).item:i=this.scanLine.NextHighB(e).item,this.InsertParallelReflectionSegment(o,s,t,e,i,r)}}AddReflectionEvent(t,e,i){let r=e;r!=null?this.eventQueue.Enqueue(new as(t,r,i)):this.eventQueue.Enqueue(new rs(t,e,i))}AddSideToScanLine(t,e){let i=this.scanLine.Insert(t,e);return this.LoadReflectionEvents(t),i}RemoveSideFromScanLine(t,e){this.scanLine.Remove(t.item,e)}PointCompare(t,e){return this.ScanDirection.Compare(t,e)}Clear(){this.ObstacleTree.Clear(),this.eventQueue=new is,this.HorizontalScanSegments=new Hn(Ae.HorizontalInstance),this.VerticalScanSegments=new Hn(Ae.VerticalInstance),this.VisibilityGraph=null}ProcessEvents(){for(;this.eventQueue.Count>0;){let t=this.eventQueue.Dequeue();t instanceof sn?this.ProcessEventO(t):t instanceof ns?this.ProcessEventLB(t):t instanceof os?this.ProcessEventHB(t):t instanceof ss?this.ProcessEventCV(t):t instanceof as?this.ProcessEventLR(t):t instanceof rs?this.ProcessEventHR(t):this.ProcessCustomEvent(t),this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear()}}ProcessCustomEvent(t){}ScanLineCrossesObstacle(t,e){return this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.leftBottom)>0&&this.ScanDirection.ComparePerpCoord(t,e.VisibilityBoundingBox.rightTop)<0}FindInitialNeighborSides(t,e){e.lowNborSideNode=this.scanLine.NextLowR(t),e.highNborSideNode=this.scanLine.NextHighR(t)}FindNeighborsBRR(t,e,i){this.LowNeighborSides.Clear(),this.HighNeighborSides.Clear(),this.FindNeighbors(t,e,this.LowNeighborSides),this.FindNeighbors(t,i,this.HighNeighborSides)}FindNeighbors(t,e,i){let r=t instanceof sn?e.item.Start:e.item.End,n={lowNborSideNode:null,highNborSideNode:null};this.FindInitialNeighborSides(e,n),this.SkipToNeighbor(this.ScanDirection.OppositeDirection,e.item,r,n.lowNborSideNode,i),this.SkipToNeighbor(this.ScanDirection.Dir,e.item,r,n.highNborSideNode,i)}SkipToNeighbor(t,e,i,r,n){let o=null,s=null;for(;;r=this.scanLine.Next(t,r))if(r.item.Obstacle!==e.Obstacle){if(r.item.Obstacle.IsGroup){this.ProcessGroupSideEncounteredOnTraversalToNeighbor(r,i,t)&&s==null&&(s=r.item);continue}if(r.item instanceof Sr===O.IsAscending(t)){this.ScanLineCrossesObstacle(i,r.item.Obstacle)&&(o=r,s=null);continue}break}n.SetSides(t,r,o,s)}ProcessGroupSideEncounteredOnTraversalToNeighbor(t,e,i){if(!this.ScanLineCrossesObstacle(e,t.item.Obstacle))return!1;let r=t.item instanceof gt===O.IsAscending(i)?i:v.OppositeDir(i),n=this.ScanLineIntersectSide(e,t.item);return this.CurrentGroupBoundaryCrossingMap.AddIntersection(n,t.item.Obstacle,r),!0}FindNeighborsAndProcessVertexEvent(t,e,i){this.CurrentGroupBoundaryCrossingMap.Clear(),this.FindNeighborsBRR(i,t,e),this.ProcessVertexEvent(t,e,i),this.CurrentGroupBoundaryCrossingMap.Clear()}ProcessEventO(t){var s,a;let e=t.Obstacle;e.CreateInitialSides(t.Vertex,this.ScanDirection),this.AddSideToScanLine(e.ActiveLowSide,t.Site);let i=this.AddSideToScanLine(e.ActiveHighSide,t.Site),r=this.scanLine.Find(e.ActiveLowSide);this.FindNeighborsAndProcessVertexEvent(r,i,t);let n=(s=this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor)!=null?s:this.LowNeighborSides.LowNeighborSide;this.SideReflectsUpward(n)&&this.LoadReflectionEvents(e.ActiveLowSide);let o=(a=this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor)!=null?a:this.HighNeighborSides.HighNeighborSide;if(this.SideReflectsUpward(o)&&this.LoadReflectionEvents(e.ActiveHighSide),e.ActiveHighSide.Start!==e.ActiveLowSide.Start){let u=new Sr(e,t.Vertex,this.ScanDirection);this.lookaheadScan.RemoveSitesForFlatBottom(u.Start,u.End)}this.EnqueueLowBendVertexEvent(e.ActiveLowSide),this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide)}ProcessEventLB(t){let e=t.Obstacle,i=new gt(e,t.Vertex,this.ScanDirection);this.ScanDirection.ComparePerpCoord(i.End,i.Start)>0&&(this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveLowSide),t.Site),this.AddSideToScanLine(i,t.Site),e.ActiveLowSide=i,this.EnqueueLowBendVertexEvent(i))}EnqueueLowBendVertexEvent(t){this.eventQueue.Enqueue(new ns(t.Obstacle,t.EndVertex))}ProcessEventHB(t){let e=t.Obstacle,i=new Sr(e,t.Vertex,this.ScanDirection);this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveHighSide),t.Site);let r=this.AddSideToScanLine(i,t.Site);if(e.ActiveHighSide=i,this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide),this.wantReflections&&this.ScanDirection.IsHorizontal&&i.Start.x===e.VisibilityBoundingBox.right&&this.SideReflectsUpward(i)){let n=this.scanLine.NextHighR(r);n.item instanceof gt&&this.SideReflectsDownward(n.item)&&(!e.isOverlapped||!this.ObstacleTree.PointIsInsideAnObstacle(i.Start,this.ScanDirection))&&(this.StoreLookaheadSite(n.item.Obstacle,i,i.Start,!0),this.LoadReflectionEvents(n.item))}}EnqueueHighBendOrCloseVertexEvent(t){let e=t.Obstacle,i=this.ScanDirection.IsHorizontal?t.EndVertex.prevOnPolyline:t.EndVertex.nextOnPolyline;this.ScanDirection.ComparePerpCoord(i.point,t.End)>0?this.eventQueue.Enqueue(new os(e,t.EndVertex)):this.eventQueue.Enqueue(new ss(e,t.EndVertex))}CreateCloseEventSegmentsAndFindNeighbors(t){let e=t.Obstacle,i=this.scanLine.Find(e.ActiveLowSide),r=this.scanLine.Find(e.ActiveHighSide);if(this.scanLine.Compare(e.ActiveLowSide,e.ActiveHighSide)===1){let n=i;i=r,r=n}if(this.FindNeighborsAndProcessVertexEvent(i,r,t),this.wantReflections&&e.isOverlapped)for(let n=this.scanLine.NextHighR(i);n.item!==r.item;n=this.scanLine.NextHighR(n))this.LoadReflectionEvents(n.item);this.scanLine.Remove(e.ActiveLowSide,t.Site),this.scanLine.Remove(e.ActiveHighSide,t.Site)}ProcessEventCV(t){this.CreateCloseEventSegmentsAndFindNeighbors(t);let e=this.LowNeighborSides.LowNeighbor.item,i=this.HighNeighborSides.HighNeighbor.item,r=t.Obstacle;this.LoadReflectionEvents(e),this.LoadReflectionEvents(i),r.Close()}ProcessEventLR(t){let e=t.Side.Obstacle,i=this.scanLine.NextLowB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,i,null,t)&&this.LoadReflectionEvents(e.ActiveLowSide)}ProcessEventHR(t){let e=t.Side.Obstacle,i=this.scanLine.NextHighB(t.Side).item;this.AddPerpendicularReflectionSegment(t,t.Side,i)&&this.AddParallelReflectionSegment(e,null,i,t)&&this.LoadReflectionEvents(e.ActiveHighSide)}MakeInBoundsLocation(t){let e=Math.max(t.x,this.ObstacleTree.GraphBox.left),i=Math.max(t.y,this.ObstacleTree.GraphBox.bottom);return new c(Math.min(e,this.ObstacleTree.GraphBox.right),Math.min(i,this.ObstacleTree.GraphBox.top))}IsInBoundsV(t){return this.IsInBoundsP(t.point)}IsInBoundsP(t){return C.EqualPP(t,this.MakeInBoundsLocation(t))}},an=ze;an.SentinelOffset=1;var mt=class extends an{constructor(){super(!1);this.horizontalVertexPoints=new ie;this.verticalVertexPoints=new ie;this.boundingBoxSteinerPoints=new ie;this.xCoordAccumulator=new Set;this.yCoordAccumulator=new Set;this.horizontalCoordMap=new Map;this.verticalCoordMap=new Map}Clear(){super.Clear(),this.Cleanup()}Cleanup(){this.horizontalVertexPoints.clear(),this.verticalVertexPoints.clear(),this.boundingBoxSteinerPoints.clear(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear(),this.horizontalCoordMap.clear(),this.verticalCoordMap.clear()}GenerateVisibilityGraph(){this.AccumulateVertexCoords(),this.CreateSegmentVectorsAndPopulateCoordinateMaps(),this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(),this.GenerateSparseIntersectionsFromVertexPoints(),this.CreateScanSegmentTrees(),this.Cleanup()}AccumulateVertexCoords(){for(let e of this.ObstacleTree.GetAllObstacles())this.xCoordAccumulator.add(e.VisibilityBoundingBox.left),this.xCoordAccumulator.add(e.VisibilityBoundingBox.right),this.yCoordAccumulator.add(e.VisibilityBoundingBox.top),this.yCoordAccumulator.add(e.VisibilityBoundingBox.bottom)}CreateSegmentVectorsAndPopulateCoordinateMaps(){this.horizontalScanSegmentVector=new ts(this.yCoordAccumulator,!0),this.verticalScanSegmentVector=new ts(this.xCoordAccumulator,!1);for(let e=0;e<this.horizontalScanSegmentVector.Length;e++)this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(e).Coord,e);for(let e=0;e<this.verticalScanSegmentVector.Length;e++)this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(e).Coord,e)}RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(){super.GenerateVisibilityGraph(),this.horizontalScanSegmentVector.ScanSegmentsComplete(),this.verticalScanSegmentVector.ScanSegmentsComplete(),this.xCoordAccumulator.clear(),this.yCoordAccumulator.clear()}InitializeEventQueue(e){super.InitializeEventQueue(e),this.SetVectorsAndCoordMaps(e),this.AddAxisCoordinateEvents(e)}AddAxisCoordinateEvents(e){if(e.IsHorizontal){for(let i of this.yCoordAccumulator)this.eventQueue.Enqueue(new So(new c(this.ObstacleTree.GraphBox.left-mt.SentinelOffset,i)));return}for(let i of this.xCoordAccumulator)this.eventQueue.Enqueue(new So(new c(i,this.ObstacleTree.GraphBox.bottom-mt.SentinelOffset)))}ProcessCustomEvent(e){this.ProcessAxisCoordinate(e)||this.ProcessCustomEvent(e)}ProcessAxisCoordinate(e){return e instanceof So?(this.CreateScanSegmentsOnAxisCoordinate(e.Site),!0):!1}InsertPerpendicularReflectionSegment(e,i){return!1}InsertParallelReflectionSegment(e,i,r,n,o,s){return!1}ProcessVertexEvent(e,i,r){let n=this.ScanDirection.IsHorizontal?this.horizontalVertexPoints:this.verticalVertexPoints;n.add(r.Site);let o=this.LowNeighborSides.LowNeighbor.item,s=this.HighNeighborSides.HighNeighbor.item,a=this.ScanDirection.Dir,u=this.ScanDirection.OppositeDirection,h=this.ScanLineIntersectSide(r.Site,o),d=this.ScanLineIntersectSide(r.Site,s);if(this.ObstacleTree.GraphBox.contains(h)){let f=O.RectangleBorderIntersect(o.Obstacle.VisibilityBoundingBox,h,a);C.IsPureLower(f,r.Site)&&this.boundingBoxSteinerPoints.add(f)}if(this.ObstacleTree.GraphBox.contains(d)){let f=O.RectangleBorderIntersect(s.Obstacle.VisibilityBoundingBox,d,u);C.IsPureLower(r.Site,f)&&this.boundingBoxSteinerPoints.add(f)}let g={lowCorner:void 0,highCorner:void 0};mt.GetBoundingCorners(e.item.Obstacle.VisibilityBoundingBox,r instanceof sn,this.ScanDirection.IsHorizontal,g),(C.IsPureLower(h,g.lowCorner)||o.Obstacle.IsInSameClump(r.Obstacle))&&n.add(g.lowCorner),(C.IsPureLower(g.highCorner,d)||s.Obstacle.IsInSameClump(r.Obstacle))&&n.add(g.highCorner)}static GetBoundingCorners(e,i,r,n){if(i){n.lowCorner=e.leftBottom,n.highCorner=r?e.rightBottom:e.leftTop;return}n.lowCorner=r?e.leftTop:e.rightBottom,n.highCorner=e.rightTop}CreateScanSegmentsOnAxisCoordinate(e){this.CurrentGroupBoundaryCrossingMap.Clear();let i=this.scanLine.Lowest(),r=this.scanLine.NextHighR(i),n=0,o=e,s=!1;for(;r!=null;r=this.scanLine.NextHighR(r)){if(this.SkipSide(o,r.item))continue;if(r.item.Obstacle.IsGroup){(n===0||s)&&this.HandleGroupCrossing(e,r.item);continue}if(r.item instanceof gt){if(n>0){n++;continue}o=this.CreateScanSegment(o,r.item,W.NormalWeight),this.CurrentGroupBoundaryCrossingMap.Clear(),n=1,s=r.item.Obstacle.isOverlapped;continue}n++,!(n>0)&&(o=r.item.Obstacle.isOverlapped||r.item.Obstacle.OverlapsGroupCorner?this.CreateScanSegment(o,r.item,W.OverlappedWeight):this.ScanLineIntersectSide(o,r.item),this.CurrentGroupBoundaryCrossingMap.Clear(),s=!1)}let a=this.ScanDirection.IsHorizontal?new c(this.ObstacleTree.GraphBox.right+mt.SentinelOffset,o.y):new c(o.x,this.ObstacleTree.GraphBox.top+mt.SentinelOffset);this.parallelSegmentVector.CreateScanSegment(o,a,W.NormalWeight,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(o,a)),this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot()}HandleGroupCrossing(e,i){if(!this.ScanLineCrossesObstacle(e,i.Obstacle))return;let r=i instanceof gt?this.ScanDirection.Dir:this.ScanDirection.OppositeDirection,n=this.ScanLineIntersectSide(e,i),o=this.CurrentGroupBoundaryCrossingMap.AddIntersection(n,i.Obstacle,r);this.AddPerpendicularCoordForGroupCrossing(n);let s=o.GetInteriorVertexPoint(n);this.AddPerpendicularCoordForGroupCrossing(s)}AddPerpendicularCoordForGroupCrossing(e){let i=this.FindPerpendicularSlot(e,0);i!==-1&&this.perpendicularSegmentVector.Item(i).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord)}SkipSide(e,i){if(i.Obstacle.IsSentinel)return!0;let r=i.Obstacle.VisibilityBoundingBox;return this.ScanDirection.IsHorizontal?e.y===r.bottom||e.y===r.top:e.x===r.left||e.x===r.right}CreateScanSegment(e,i,r){let n=this.ScanLineIntersectSide(e,i);return e!==n&&this.parallelSegmentVector.CreateScanSegment(e,n,r,this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(e,n)),n}GenerateSparseIntersectionsFromVertexPoints(){this.VisibilityGraph=mt.NewVisibilityGraph(),this.GenerateSparseIntersectionsAlongHorizontalAxis(),this.GenerateSparseIntersectionsAlongVerticalAxis(),this.ConnectAdjoiningScanSegments(),this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph),this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph)}GenerateSparseIntersectionsAlongHorizontalAxis(){this.currentAxisPointComparer=Zn;let e=Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer),i=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Ae.HorizontalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(e,i)}GenerateSparseIntersectionsAlongVerticalAxis(){this.currentAxisPointComparer=(r,n)=>r.compareTo(n);let e=Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer),i=Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);this.ScanDirection=Ae.VerticalInstance,this.SetVectorsAndCoordMaps(this.ScanDirection),this.GenerateSparseIntersections(e,i)}SetVectorsAndCoordMaps(e){e.IsHorizontal?(this.parallelSegmentVector=this.horizontalScanSegmentVector,this.perpendicularSegmentVector=this.verticalScanSegmentVector,this.perpendicularCoordMap=this.verticalCoordMap):(this.parallelSegmentVector=this.verticalScanSegmentVector,this.perpendicularSegmentVector=this.horizontalScanSegmentVector,this.perpendicularCoordMap=this.horizontalCoordMap)}ConnectAdjoiningScanSegments(){this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(),this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints()}GenerateSparseIntersections(e,i){this.perpendicularSegmentVector.ResetForIntersections(),this.parallelSegmentVector.ResetForIntersections();let r=1,n={j:0};for(let o of this.parallelSegmentVector.Items())for(;!(!o.CurrentSegment.ContainsPoint(e[r])&&(!this.AddSteinerPointsToInterveningSegments(e[r],i,n,o)||!o.TraverseToSegmentContainingPoint(e[r])));){if(this.AddPointsToCurrentSegmentIntersections(i,n,o),this.GenerateIntersectionsFromVertexPointForCurrentSegment(e[r],o),o.PointIsCurrentEndAndNextStart(e[r])){o.MoveNext();continue}if(++r>=e.length)return}}AddSteinerPointsToInterveningSegments(e,i,r,n){for(;r.j<i.length&&this.currentAxisPointComparer(i[r.j],e)===-1;){if(!n.TraverseToSegmentContainingPoint(i[r.j]))return!1;this.AddPointsToCurrentSegmentIntersections(i,r,n)}return!0}AddPointsToCurrentSegmentIntersections(e,i,r){for(;i.j<e.length&&r.CurrentSegment.ContainsPoint(e[i.j]);i.j++){let n=this.FindPerpendicularSlot(e[i.j],0);this.AddSlotToSegmentIntersections(r,n)}}GenerateIntersectionsFromVertexPointForCurrentSegment(e,i){let r=this.FindPerpendicularSlot(i.CurrentSegment.Start,1),n=this.FindPerpendicularSlot(i.CurrentSegment.End,-1),o=this.FindPerpendicularSlot(e,0);r>=n||(this.AddSlotToSegmentIntersections(i,r),this.AddSlotToSegmentIntersections(i,n),o>r&&o<n&&(this.AddSlotToSegmentIntersections(i,o),this.AddBinaryDivisionSlotsToSegmentIntersections(i,r,o,n)))}FindPerpendicularSlot(e,i){return mt.FindIntersectingSlot(this.perpendicularSegmentVector,this.perpendicularCoordMap,e,i)}static FindIntersectingSlot(e,i,r,n){let o=e.GetParallelCoord(r),s=i.get(o);return s!==void 0?s:n===0?-1:e.FindNearest(o,n)}AddSlotToSegmentIntersections(e,i){let r=this.perpendicularSegmentVector.Item(i);e.CurrentSegment.AddSparseVertexCoord(r.Coord),r.AddPerpendicularCoord(e.Coord)}AddBinaryDivisionSlotsToSegmentIntersections(e,i,r,n){let o=0,s=this.perpendicularSegmentVector.Length-1;for(;s-o>1;){let a=o+Math.floor((s-o)/2);if(r<=a){s=a,r<s&&s<=n&&this.AddSlotToSegmentIntersections(e,s);continue}o=a,r>o&&o>=i&&this.AddSlotToSegmentIntersections(e,o)}}CreateScanSegmentTrees(){mt.CreateScanSegmentTree(this.horizontalScanSegmentVector,this.HorizontalScanSegments),mt.CreateScanSegmentTree(this.verticalScanSegmentVector,this.VerticalScanSegments)}static CreateScanSegmentTree(e,i){for(let r of e.Items())for(let n=r.FirstSegment;n!=null;n=n.NextSegment)n.HasVisibility()&&i.InsertUnique(n)}};var vt=class{constructor(t){this.AddedVertices=new Array;this.AddedEdges=new Array;this.edgesToRestore=new Array;this.LimitPortVisibilitySpliceToEndpointBoundingBox=!1;this.GraphGenerator=t}get ObstacleTree(){return this.GraphGenerator.ObstacleTree}get VisGraph(){return this.GraphGenerator.VisibilityGraph}get IsSparseVg(){return this.GraphGenerator instanceof mt}AddVertex(t){let e=this.VisGraph.AddVertexP(t);return this.AddedVertices.push(e),e}FindOrAddVertex(t){let e=this.VisGraph.FindVertex(t);return e!=null?e:this.AddVertex(t)}FindOrAddEdgeVV(t,e){return this.FindOrAddEdge(t,e,W.NormalWeight)}FindOrAddEdge(t,e,i){let r=C.GetPureDirectionVV(t,e),n={bracketSource:void 0,bracketTarget:void 0,splitVertex:void 0};vt.GetBrackets(t,e,r,n);let o=this.VisGraph.FindEdgePP(n.bracketSource.point,n.bracketTarget.point);return o=o!=null?this.SplitEdge(o,n.splitVertex):this.CreateEdge(n.bracketSource,n.bracketTarget,i),o}static GetBrackets(t,e,i,r){if(r.splitVertex=e,!vt.FindBracketingVertices(t,e.point,i,r)){let n={bracketSource:null,bracketTarget:null};vt.FindBracketingVertices(e,t.point,v.OppositeDir(i),n)&&(r.bracketSource=n.bracketTarget,r.splitVertex=t),r.bracketTarget=n.bracketSource}}static FindBracketingVertices(t,e,i,r){for(r.bracketSource=t;r.bracketTarget=O.FindAdjacentVertex(r.bracketSource,i),r.bracketTarget!=null;){if(c.closeDistEps(r.bracketTarget.point,e))return!0;if(i!==C.GetDirections(r.bracketTarget.point,e))break;r.bracketSource=r.bracketTarget}return r.bracketTarget!=null}CreateEdge(t,e,i){let r=t,n=e;C.IsPureLower(r.point,n.point)||(r=e,n=t);let o=new Xe(r,n,i);return se.AddEdge(o),this.AddedEdges.push(o),o}RemoveFromGraph(){this.RemoveAddedVertices(),this.RemoveAddedEdges(),this.RestoreRemovedEdges()}RemoveAddedVertices(){for(let t of this.AddedVertices)this.VisGraph.FindVertex(t.point)!=null&&this.VisGraph.RemoveVertex(t);this.AddedVertices=[]}RemoveAddedEdges(){for(let t of this.AddedEdges)this.VisGraph.FindVertex(t.SourcePoint)!=null&&se.RemoveEdge(t);this.AddedEdges=[]}RestoreRemovedEdges(){for(let t of this.edgesToRestore)se.AddEdge(t);this.edgesToRestore=[]}FindNextEdge(t,e){return O.FindAdjacentEdge(t,e)}FindPerpendicularOrContainingEdge(t,e,i){for(;;){let r=O.FindAdjacentVertex(t,e);if(r==null)break;let n=C.GetDirections(r.point,i);if((v.OppositeDir(e)&n)!==0)return this.VisGraph.FindEdgePP(t.point,r.point);t=r}return null}FindNearestPerpendicularOrContainingEdge(t,e,i){let r;e&C.GetDirections(t.point,i);let n=t,o=r;for(;0!==o;){let a=O.FindAdjacentVertex(n,r);if(a==null||(v.OppositeDir(r)&C.GetDirections(a.point,i))!==0)break;n=a,e&C.GetDirections(n.point,i)}let s;for(;s=this.FindPerpendicularOrContainingEdge(n,e,i),!(s!=null||n===t);)n=O.FindAdjacentVertex(n,v.OppositeDir(r));return s}ConnectVertexToTargetVertex(t,e,i,r){if(c.closeDistEps(t.point,e.point))return;let n=C.GetDirections(t.point,e.point);if(C.IsPureDirectionD(n)){this.FindOrAddEdgeVV(t,e);return}let o=O.FindBendPointBetween(t.point,e.point,i),s=this.FindOrAddVertex(o);this.FindOrAddEdge(t,s,r),this.FindOrAddEdge(s,e,r)}AddEdgeToTargetEdge(t,e,i){let r=this.VisGraph.FindVertex(i);return r==null&&(r=this.AddVertex(i),this.SplitEdge(e,r)),this.FindOrAddEdgeVV(t,r),r}SplitEdge(t,e){return t==null?null:c.closeDistEps(t.Source.point,e.point)||c.closeDistEps(t.Target.point,e.point)?t:(t instanceof Xe||this.edgesToRestore.push(t),se.RemoveEdge(t),(this.IsSparseVg||t.Weight===W.OverlappedWeight)&&e.Degree>0?(this.FindOrAddEdge(e,t.Source,t.Weight),this.FindOrAddEdge(e,t.Target,t.Weight)):(this.CreateEdge(e,t.Target,t.Weight),this.CreateEdge(t.Source,e,t.Weight)))}ExtendEdgeChainVRLPB(t,e,i,r,n){let o=C.GetDirections(i.start,i.end);if(o===0)return;let s=O.GetRectangleBound(e,o),a=O.IsVerticalD(o)?c.RoundPoint(new c(t.point.x,s)):c.RoundPoint(new c(s,t.point.y));if(c.closeDistEps(a,t.point)||C.GetDirections(t.point,a)!==o)return;let u=i;C.GetDirections(a,u.end)===o&&(u=S.mkPP(u.start,a)),this.ExtendEdgeChain(t,o,u,i,r,n)}ExtendEdgeChain(t,e,i,r,n,o){if(C.GetDirections(t.point,i.end)!==e)return;let a=v.RotateLeft(e),u=O.FindAdjacentVertex(t,a);if(u==null&&(a=v.OppositeDir(a),u=O.FindAdjacentVertex(t,a),u==null))return;let h=v.OppositeDir(a),d={spliceTarget:null};this.ExtendSpliceWorker(u,e,h,i,r,o,d)&&this.ExtendSpliceWorker(d.spliceTarget,e,a,i,r,o,d),this.SpliceGroupBoundaryCrossings(n,t,i)}SpliceGroupBoundaryCrossings(t,e,i){if(t==null||t.Count()===0)return;t.Reset();let r=i.start,n=i.end,o=C.GetDirections(r,n);O.IsAscending(o)||(r=i.end,n=i.start,o=v.OppositeDir(o)),e=vt.TraverseToFirstVertexAtOrAbove(e,r,v.OppositeDir(o));for(let s=e;s!=null;s=O.FindAdjacentVertex(s,o)){let a=C.ComparePP(s.point,n)>=0;for(;t.CurrentIsBeforeOrAt(s.point);){let u=t.Pop();C.ComparePP(u.Location,e.point)>0&&C.ComparePP(u.Location,n)<=0&&this.SpliceGroupBoundaryCrossing(s,u,v.OppositeDir(o)),C.ComparePP(u.Location,e.point)>=0&&C.ComparePP(u.Location,n)<0&&this.SpliceGroupBoundaryCrossing(s,u,o)}if(a)break}}static TraverseToFirstVertexAtOrAbove(t,e,i){let r=t,n=v.OppositeDir(i);for(;;){let o=O.FindAdjacentVertex(r,i);if(o==null||C.GetDirections(o.point,e)===n)break;r=o}return r}SpliceGroupBoundaryCrossing(t,e,i){var n,o;let r=Yi.ToCrossingArray(e.Crossings,i);if(r!=null){let s=(n=this.VisGraph.FindVertex(e.Location))!=null?n:this.AddVertex(e.Location);t.point.equal(s.point)||this.FindOrAddEdgeVV(t,s);let a=r[0].GetInteriorVertexPoint(e.Location),u=(o=this.VisGraph.FindVertex(a))!=null?o:this.AddVertex(a),h=this.FindOrAddEdgeVV(s,u),d=r.map(g=>g.Group.InputShape);h.IsPassable=()=>d.some(g=>g.IsTransparent)}}ExtendSpliceWorker(t,e,i,r,n,o,s){let a=O.FindAdjacentVertex(t,i);s.spliceTarget=O.FindAdjacentVertex(a,i);let u={spliceSource:t};for(;vt.GetNextSpliceSource(u,i,e);){let h=O.FindBendPointBetween(a.point,u.spliceSource.point,v.OppositeDir(i));if(vt.IsPointPastSegmentEnd(n,h))break;if(s.spliceTarget=vt.GetSpliceTarget(u,i,h),s.spliceTarget==null){if(this.IsSkippableSpliceSourceWithNullSpliceTarget(u.spliceSource,e))continue;if(this.ObstacleTree.SegmentCrossesAnObstacle(u.spliceSource.point,h))return!1}let d=this.VisGraph.FindVertex(h);if(d!=null){if(s.spliceTarget==null||this.VisGraph.FindEdgePP(a.point,h)!=null)return s.spliceTarget==null&&this.FindOrAddEdge(a,d,o?W.OverlappedWeight:W.NormalWeight),!1}else d=this.AddVertex(h);if(this.FindOrAddEdge(a,d,o?W.OverlappedWeight:W.NormalWeight),this.FindOrAddEdge(u.spliceSource,d,o?W.OverlappedWeight:W.NormalWeight),o&&(o=this.SeeIfSpliceIsStillOverlapped(e,d)),a=d,(e&C.GetDirections(h,r.end))===0){s.spliceTarget=null;break}}return s.spliceTarget!=null}static GetNextSpliceSource(t,e,i){let r=O.FindAdjacentVertex(t.spliceSource,i);if(r==null)for(r=t.spliceSource;;){if(r=O.FindAdjacentVertex(r,v.OppositeDir(e)),r==null)return!1;let n=O.FindAdjacentVertex(r,i);if(n!=null){r=n;break}}return t.spliceSource=r,!0}static GetSpliceTarget(t,e,i){let r=C.GetDirections(t.spliceSource.point,i),n=r,o=t.spliceSource;for(;n===r&&(t.spliceSource=o,o=O.FindAdjacentVertex(t.spliceSource,e),o!=null);){if(c.closeDistEps(o.point,i)){o=O.FindAdjacentVertex(o,e);break}n=C.GetDirections(o.point,i)}return o}SeeIfSpliceIsStillOverlapped(t,e){let i=this.FindNextEdge(e,v.RotateLeft(t)),r=i==null?!1:W.NormalWeight===i.Weight;return r||(i=this.FindNextEdge(e,v.RotateRight(t)),r=i==null?!1:W.NormalWeight===i.Weight),!r||this.ObstacleTree.PointIsInsideAnObstaclePD(e.point,t)}IsSkippableSpliceSourceWithNullSpliceTarget(t,e){if(vt.IsSkippableSpliceSourceEdgeWithNullTarget(O.FindAdjacentEdge(t,e)))return!0;let i=O.FindAdjacentEdge(t,v.OppositeDir(e));return vt.IsSkippableSpliceSourceEdgeWithNullTarget(i)||vt.IsReflectionEdge(i)}static IsSkippableSpliceSourceEdgeWithNullTarget(t){return t!=null&&t.IsPassable!=null&&N(t.Length,kn.BoundaryWidth)}static IsReflectionEdge(t){return t!=null&&t.Weight===W.ReflectionWeight}static IsPointPastSegmentEnd(t,e){return C.GetDirections(t.start,t.end)===C.GetDirections(t.end,e)}toString(){return sh.String.Format("{0} {1}",this.AddedVertices.length,this.edgesToRestore.length)}};var ln=class{constructor(t){this.obstaclePortMap=new Map;this.freePointMap=new ve;this.freePointLocationsUsedByRouteEdges=new ie;this.RouteToCenterOfObstacles=!1;this.obstaclePortsInGraph=new Array;this.freePointsInGraph=new Set;this.activeAncestors=new Array;this.TransUtil=new vt(t),this.graphGenerator=t}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(t){this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox=t}get VisGraph(){return this.graphGenerator.VisibilityGraph}get HScanSegments(){return this.graphGenerator.HorizontalScanSegments}get VScanSegments(){return this.graphGenerator.VerticalScanSegments}get ObstacleTree(){return this.graphGenerator.ObstacleTree}get AncestorSets(){return this.ObstacleTree.AncestorSets}Clear(){this.TransUtil.RemoveFromGraph(),this.obstaclePortMap.clear()}CreateObstaclePorts(t){for(let e of t.Ports)this.CreateObstaclePort(t,e)}CreateObstaclePort(t,e){if(e.Curve==null)return null;let i=c.RoundPoint(e.Location);if(0===p.PointRelativeToCurveLocation(i,t.InputShape.BoundaryCurve)||t.InputShape.BoundaryCurve!==e.Curve&&0===p.PointRelativeToCurveLocation(i,e.Curve))return null;let r=new ma(e,t);return this.obstaclePortMap.set(e,r),r}FindVertices(t){let e=new Array,i=this.obstaclePortMap.get(t);if(i)if(this.RouteToCenterOfObstacles)e.push(i.CenterVertex);else for(let r of i.PortEntrances){let n=this.VisGraph.FindVertex(r.UnpaddedBorderIntersect);n!=null&&e.push(n)}else e.push(this.VisGraph.FindVertex(c.RoundPoint(t.Location)));return e}RemoveObstaclePorts(t){for(let e of t.Ports)this.RemoveObstaclePort(e)}RemoveObstaclePort(t){this.obstaclePortMap.delete(t)}AddControlPointsToGraph(t,e){this.GetPortSpliceLimitRectangle(t),this.activeAncestors=[];let i={oport:null},r={oport:null},n=this.FindAncestorsAndObstaclePort(t.sourcePort,i),o=this.FindAncestorsAndObstaclePort(t.targetPort,r);if(this.AncestorSets.size>0&&i.oport!=null&&r.oport!=null){let s=sr(o,n),a=sr(n,o);this.ActivateAncestors(a,s,e)}this.AddPortToGraph(t.sourcePort,i.oport),this.AddPortToGraph(t.targetPort,r.oport)}ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(t,e){if(t==null||!t.IsOutOfBounds)return;let i=this.FindVertices(e),r=t.OutOfBoundsDirectionFromGraph&5;this.ConnectToGraphAtPointsCollinearWithVertices(t,r,i),r=t.OutOfBoundsDirectionFromGraph&10,this.ConnectToGraphAtPointsCollinearWithVertices(t,r,i)}ConnectToGraphAtPointsCollinearWithVertices(t,e,i){if(0===e)return;let r=v.OppositeDir(e);for(let n of i){let o=this.InBoundsGraphBoxIntersect(n.point,e),s=this.VisGraph.FindVertex(o);s!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,s,r,W.NormalWeight)}}SetAllAncestorsActive(t,e){if(this.AncestorSets.size===0)return!1;this.ObstacleTree.AdjustSpatialAncestors(),this.ClearActiveAncestors();let i={oport:null},r={oport:null},n=this.FindAncestorsAndObstaclePort(t.sourcePort,r),o=this.FindAncestorsAndObstaclePort(t.targetPort,i);return this.AncestorSets.size>0&&n!=null&&o!=null?(this.ActivateAncestors(n,o,e),!0):!1}SetAllGroupsActive(){this.ClearActiveAncestors();for(let t of this.ObstacleTree.GetAllGroups())t.IsTransparentAncestor=!0,this.activeAncestors.push(t)}FindAncestorsAndObstaclePort(t,e){return e.oport=this.FindObstaclePort(t),this.AncestorSets.size===0?null:e.oport!=null?this.AncestorSets.get(e.oport.Obstacle.InputShape):new Set(Array.from(this.ObstacleTree.Root.AllHitItems(I.mkPP(t.Location,t.Location),i=>i.IsGroup)).map(i=>i.InputShape))}ActivateAncestors(t,e,i){for(let r of bi(t,e)){let n=i.get(r);n.IsTransparentAncestor=!0,this.activeAncestors.push(n)}}ClearActiveAncestors(){for(let t of this.activeAncestors)t.IsTransparentAncestor=!1;this.activeAncestors=[]}RemoveControlPointsFromGraph(){this.ClearActiveAncestors(),this.RemoveObstaclePortsFromGraph(),this.RemoveFreePointsFromGraph(),this.TransUtil.RemoveFromGraph(),this.portSpliceLimitRectangle=I.mkEmpty()}RemoveObstaclePortsFromGraph(){for(let t of this.obstaclePortsInGraph)t.RemoveFromGraph();this.obstaclePortsInGraph=[]}RemoveFreePointsFromGraph(){for(let t of this.freePointsInGraph)t.RemoveFromGraph();this.freePointsInGraph.clear()}RemoveStaleFreePoints(){if(this.freePointMap.size>this.freePointLocationsUsedByRouteEdges.size){let t=Array.from(this.freePointMap).filter(e=>!this.freePointLocationsUsedByRouteEdges.has(e[0]));for(let e of t)this.freePointMap.deleteP(e[0])}}ClearVisibility(){this.freePointMap.clear();for(let t of this.obstaclePortMap.values())t.ClearVisibility()}BeginRouteEdges(){this.RemoveControlPointsFromGraph(),this.freePointLocationsUsedByRouteEdges.clear()}EndRouteEdges(){this.RemoveStaleFreePoints()}FindObstaclePort(t){let e=this.obstaclePortMap.get(t);if(e){let i={removedPorts:null,addedPorts:null};if(e.Obstacle.GetPortChanges(i)){for(let r of i.addedPorts)this.CreateObstaclePort(e.Obstacle,r);for(let r of i.removedPorts)this.RemoveObstaclePort(r);e=this.obstaclePortMap.get(t)}}return e}AddPortToGraph(t,e){if(e!=null){this.AddObstaclePortToGraph(e);return}this.AddFreePointToGraph(t.Location)}AddObstaclePortToGraph(t){if(!(t.LocationHasChanged&&(this.RemoveObstaclePort(t.Port),t=this.CreateObstaclePort(t.Obstacle,t.Port),t==null))){t.AddToGraph(this.TransUtil,this.RouteToCenterOfObstacles),this.obstaclePortsInGraph.push(t),this.CreateObstaclePortEntrancesIfNeeded(t);for(let e of t.PortEntrances)this.AddObstaclePortEntranceToGraph(e)}}CreateObstaclePortEntrancesIfNeeded(t){t.PortEntrances.length>0||this.CreateObstaclePortEntrancesFromPoints(t)}GetPortVisibilityIntersection(t){let e=this.FindObstaclePort(t.sourcePort),i=this.FindObstaclePort(t.targetPort);if(e==null||i==null||e.Obstacle.IsInConvexHull||i.Obstacle.IsInConvexHull||(this.CreateObstaclePortEntrancesIfNeeded(e),this.CreateObstaclePortEntrancesIfNeeded(i),!e.VisibilityRectangle.intersects(i.VisibilityRectangle)))return null;for(let r of e.PortEntrances)if(!!r.WantVisibilityIntersection)for(let n of i.PortEntrances){if(!n.WantVisibilityIntersection)continue;let o=r.IsVertical===n.IsVertical?ln.GetPathPointsFromOverlappingCollinearVisibility(r,n):ln.GetPathPointsFromIntersectingVisibility(r,n);if(o!=null)return o}return null}static GetPathPointsFromOverlappingCollinearVisibility(t,e){return!O.IntervalsAreSame(t.MaxVisibilitySegment.start,t.MaxVisibilitySegment.end,e.MaxVisibilitySegment.end,e.MaxVisibilitySegment.start)||t.HasGroupCrossings||e.HasGroupCrossings||c.closeDistEps(t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect)?null:[t.UnpaddedBorderIntersect,e.UnpaddedBorderIntersect]}static GetPathPointsFromIntersectingVisibility(t,e){let i=O.SegmentsIntersectLL(t.MaxVisibilitySegment,e.MaxVisibilitySegment);return!i||t.HasGroupCrossingBeforePoint(i)||e.HasGroupCrossingBeforePoint(i)?null:[t.UnpaddedBorderIntersect,i,e.UnpaddedBorderIntersect]}CreateObstaclePortEntrancesFromPoints(t){let e=this.graphGenerator.ObstacleTree.GraphBox,i=I.mkPP(c.RoundPoint(t.PortCurve.boundingBox.leftBottom),c.RoundPoint(t.PortCurve.boundingBox.rightTop)),r=c.RoundPoint(t.PortLocation),n=!1,o={xx0:null,xx1:null};if(!C.Equal(r.y,i.top)&&!C.Equal(r.y,i.bottom)){n=!0;let s=new S(e.left,r.y,e.right,r.y);this.GetBorderIntersections(r,s,t.PortCurve,o);let a=new c(Math.min(o.xx0.x,o.xx1.x),r.y);a.x<i.left&&(a=new c(i.left,a.y));let u=new c(Math.max(o.xx0.x,o.xx1.x),r.y);u.x>i.right&&(u=new c(i.right,u.y)),this.CreatePortEntrancesAtBorderIntersections(i,t,r,a,u)}if(!C.Equal(r.x,i.left)&&!C.Equal(r.x,i.right)){n=!0;let s=new S(r.x,e.bottom,r.x,e.top);this.GetBorderIntersections(r,s,t.PortCurve,o);let a=new c(r.x,Math.min(o.xx0.y,o.xx1.y));a.y<e.bottom&&(a=new c(a.x,e.bottom));let u=new c(r.x,Math.max(o.xx0.y,o.xx1.y));u.y>e.top&&(u=new c(u.x,e.top)),this.CreatePortEntrancesAtBorderIntersections(i,t,r,a,u)}n||this.CreateEntrancesForCornerPort(i,t,r)}GetBorderIntersections(t,e,i,r){let n=p.getAllIntersections(e,i,!0);r.xx0=c.RoundPoint(n[0].x),r.xx1=c.RoundPoint(n[1].x)}CreatePortEntrancesAtBorderIntersections(t,e,i,r,n){let o=C.GetDirections(r,n);C.EqualPP(r,i)||this.CreatePortEntrance(t,e,n,o),C.EqualPP(n,i)||this.CreatePortEntrance(t,e,r,v.OppositeDir(o))}static GetDerivative(t,e){let i=t.PortCurve.closestParameter(e),r=t.PortCurve.derivative(i),n=(t.PortCurve.parStart+t.PortCurve.parEnd)/2;return We.CurveIsClockwise(t.PortCurve,t.PortCurve.value(n))||(r=r.mul(-1)),r}CreatePortEntrance(t,e,i,r){e.CreatePortEntrance(i,r,this.ObstacleTree);let n=Ae.GetInstance(r),o=O.GetRectangleBound(t,r)-n.Coord(i);if(o<0&&(o=-o),o>m.intersectionEpsilon){let s=v.VectorDirection(ln.GetDerivative(e,i)),a;r|v.OppositeDir(r),0!==(r&s)&&(a=v.OppositeDir(a)),e.CreatePortEntrance(i,a,this.ObstacleTree)}}CreateEntrancesForCornerPort(t,e,i){let r=1;C.EqualPP(i,t.leftBottom)?r=4:C.EqualPP(i,t.leftTop)?r=8:C.EqualPP(i,t.rightTop)?r=1:C.EqualPP(i,t.rightBottom)&&(r=2),e.CreatePortEntrance(i,r,this.ObstacleTree),e.CreatePortEntrance(i,v.RotateRight(r),this.ObstacleTree)}AddObstaclePortEntranceToGraph(t){let e=this.VisGraph.FindVertex(t.VisibilityBorderIntersect);if(e){t.ExtendEdgeChain(this.TransUtil,e,e,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles);return}let i={targetVertex:null},r=t.IsOverlapped?W.OverlappedWeight:W.NormalWeight;this.FindorCreateNearestPerpEdgePPDNT(t.MaxVisibilitySegment.end,t.VisibilityBorderIntersect,t.OutwardDirection,r,i)!=null&&t.AddToAdjacentVertex(this.TransUtil,i.targetVertex,this.portSpliceLimitRectangle,this.RouteToCenterOfObstacles)}InBoundsGraphBoxIntersect(t,e){return O.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox,t,e)}FindorCreateNearestPerpEdgePPDN(t,e,i,r){let n={targetVertex:null};return this.FindorCreateNearestPerpEdgePPDNT(t,e,i,r,n)}FindorCreateNearestPerpEdgePPDNT(t,e,i,r,n){let o=O.SortAscending(t,e),s=o[0],a=o[1],u=O.IsVerticalD(i)?this.HScanSegments:this.VScanSegments,h=O.IsAscending(i)?u.FindLowestIntersector(s,a):u.FindHighestIntersector(s,a);if(h==null)return n.targetVertex=null,null;let d=O.SegmentIntersectionSP(h,s);return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(O.IsAscending(i)?s:a,h,d,r,n)}FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t,e,i,r,n){var h;let o={segsegVertex:this.VisGraph.FindVertex(i),targetVertex:null};if(o.segsegVertex==null){let d=this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,i,e,r,o);if(d!=null)return d}else if(C.EqualPP(t,i))return n.targetVertex=o.segsegVertex,this.TransUtil.FindNextEdge(n.targetVertex,v.OppositeDir(e.ScanDirection.Dir));let s=C.GetDirections(i,t),a=C.GetDirections(o.segsegVertex.point,t);if(s===a){let d={bracketTarget:null,bracketSource:null};return vt.FindBracketingVertices(o.segsegVertex,t,s,d),(h=this.TransUtil.FindNextEdge(d.bracketSource,v.RotateLeft(s)))!=null?h:this.TransUtil.FindNextEdge(d.bracketSource,v.RotateRight(s))}a&=~s;let u=this.TransUtil.FindNearestPerpendicularOrContainingEdge(o.segsegVertex,a,t);return u==null?(n.targetVertex=this.TransUtil.AddVertex(i),this.TransUtil.FindOrAddEdge(n.targetVertex,e.HighestVisibilityVertex,e.Weight)):(o.segsegVertex=O.GetEdgeEnd(u,v.OppositeDir(a)),i=O.SegmentIntersectionPPP(t,i,o.segsegVertex.point),C.EqualPP(o.segsegVertex.point,i)?(n.targetVertex=o.segsegVertex,this.TransUtil.FindNextEdge(o.segsegVertex,a)):(n.targetVertex=this.TransUtil.FindOrAddVertex(i),this.TransUtil.FindOrAddEdge(o.segsegVertex,n.targetVertex,r)))}FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t,e,i,r,n){let s=(i.IsVertical?this.HScanSegments:this.VScanSegments).FindHighestIntersector(i.Start,e);if(s==null)return n.segsegVertex=null,n.targetVertex=this.TransUtil.AddVertex(e),this.TransUtil.FindOrAddEdge(n.targetVertex,i.LowestVisibilityVertex,i.Weight);let a=O.SegmentsIntersection(i,s);if(n.segsegVertex=this.VisGraph.FindVertex(a),!n.segsegVertex){n.segsegVertex=this.TransUtil.AddVertex(a);let u=this.AddEdgeToClosestSegmentEnd(i,n.segsegVertex,i.Weight);if(this.AddEdgeToClosestSegmentEnd(s,n.segsegVertex,s.Weight),C.EqualPP(n.segsegVertex.point,e))return n.targetVertex=n.segsegVertex,u}return C.EqualPP(t,e)?(n.targetVertex=this.TransUtil.FindOrAddVertex(e),this.TransUtil.FindOrAddEdge(n.segsegVertex,n.targetVertex,r)):(n.targetVertex=null,null)}AddEdgeToClosestSegmentEnd(t,e,i){return C.IsPureLower(t.HighestVisibilityVertex.point,e.point)?this.TransUtil.FindOrAddEdge(t.HighestVisibilityVertex,e,i):C.IsPureLower(e.point,t.LowestVisibilityVertex.point)?this.TransUtil.FindOrAddEdge(e,t.LowestVisibilityVertex,i):this.TransUtil.FindOrAddEdgeVV(t.LowestVisibilityVertex,e)}GetPortSpliceLimitRectangle(t){if(!this.LimitPortVisibilitySpliceToEndpointBoundingBox){this.portSpliceLimitRectangle=this.graphGenerator.ObstacleTree.GraphBox;return}this.portSpliceLimitRectangle=this.GetPortRectangle(t.sourcePort),this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(t.targetPort))}GetPortRectangle(t){let e=this.obstaclePortMap.get(t);return e?e.Obstacle.VisibilityBoundingBox.clone():I.mkOnPoints([c.RoundPoint(t.Location)])}AddToLimitRectangle(t){this.graphGenerator.IsInBoundsP(t)&&this.portSpliceLimitRectangle.add(t)}FindOrCreateFreePoint(t){let e=this.freePointMap.get(t);return e?e.GetVertex(this.TransUtil,t):(e=new pa(this.TransUtil,t),this.freePointMap.set(t,e)),this.freePointsInGraph.add(e),this.freePointLocationsUsedByRouteEdges.add(t),e}AddFreePointToGraph(t){t=c.RoundPoint(t);let e=this.VisGraph.FindVertex(t),i=this.FindOrCreateFreePoint(t);if(e!=null)return i;if(!this.graphGenerator.IsInBoundsP(t))return this.CreateOutOfBoundsFreePoint(i),i;let r=null;i.IsOverlapped=this.ObstacleTree.PointIsInsideAnObstacle(i.Point,this.HScanSegments.ScanDirection);let n;if(this.VScanSegments.FindSegmentContainingPoint(t,!0),n!=null){let s={targetVertex:null};r=this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t,n,t,i.InitialWeight,s)}let o=4;if(r!=null)o=O.EdgeDirectionVE(r),this.ConnectFreePointToLateralEdge(i,v.RotateLeft(o)),this.ConnectFreePointToLateralEdge(i,v.RotateRight(o));else for(let s=0;s<4;s++)this.ConnectFreePointToLateralEdge(i,o),o=v.RotateLeft(o);return i}CreateOutOfBoundsFreePoint(t){let e=t.Point,i=this.graphGenerator.MakeInBoundsLocation(e),r=C.GetDirections(i,e);if(t.OutOfBoundsDirectionFromGraph=r,!C.IsPureDirectionD(r)){t.AddOobEdgesFromGraphCorner(this.TransUtil,i);return}let n=this.VisGraph.FindVertex(i),o=v.OppositeDir(r);if(n!=null)t.AddToAdjacentVertex(this.TransUtil,n,o,this.portSpliceLimitRectangle);else{let u=this.FindorCreateNearestPerpEdgePPDN(e,i,r,W.NormalWeight);u!=null&&(n=t.AddEdgeToAdjacentEdge(this.TransUtil,u,o,this.portSpliceLimitRectangle))}let s=O.FindAdjacentVertex(n,v.RotateLeft(o));s!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,s,o,W.NormalWeight);let a=O.FindAdjacentVertex(n,v.RotateRight(o));a!=null&&this.TransUtil.ConnectVertexToTargetVertex(t.Vertex,a,o,W.NormalWeight)}ConnectFreePointToLateralEdge(t,e){let i=t.IsOverlapped?this.InBoundsGraphBoxIntersect(t.Point,e):t.MaxVisibilityInDirectionForNonOverlappedFreePoint(e,this.TransUtil),r=this.FindorCreateNearestPerpEdgePPDN(i,t.Point,e,t.InitialWeight);r!=null&&t.AddEdgeToAdjacentEdge(this.TransUtil,r,e,this.portSpliceLimitRectangle)}};var Ye=class extends H{constructor(e,i,r){super(null);this.Padding=0;this.CornerFitRadius=0;this.edgeSeparatian=3;this.BendPenaltyAsAPercentageOfDistance=0;this.ShapeToObstacleMap=new Map;this.EdgesToRoute=new Array;this.removeStaircases=!0;this.selfEdges=new Array;this.Padding=i,this.CornerFitRadius=r,this.BendPenaltyAsAPercentageOfDistance=ri.DefaultBendPenaltyAsAPercentageOfDistance,this.GraphGenerator=new mt,this.PortManager=new ln(this.GraphGenerator),this.AddShapes(e)}get RouteToCenterOfObstacles(){return this.PortManager.RouteToCenterOfObstacles}set RouteToCenterOfObstacles(e){this.PortManager.RouteToCenterOfObstacles=e}get LimitPortVisibilitySpliceToEndpointBoundingBox(){return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox}set LimitPortVisibilitySpliceToEndpointBoundingBox(e){this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox=e}AddEdgeGeometryToRoute(e){c.closeDistEps(c.RoundPoint(e.sourcePort.Location),c.RoundPoint(e.targetPort.Location))?this.selfEdges.push(e):this.EdgesToRoute.push(e)}get EdgeGeometriesToRoute(){return this.EdgesToRoute}RemoveAllEdgeGeometriesToRoute(){this.EdgesToRoute=[]}get UseSparseVisibilityGraph(){return this.GraphGenerator instanceof mt}get Obstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(e=>e.InputShape)}get PaddedObstacles(){return Array.from(this.ShapeToObstacleMap.values()).map(e=>e.PaddedPolyline)}AddObstacles(e){this.AddShapes(e),this.RebuildTreeAndGraph()}AddShapes(e){for(let i of e)this.AddObstacleWithoutRebuild(i)}AddObstacle(e){this.AddObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}UpdateObstacles(e){for(let i of e)this.UpdateObstacleWithoutRebuild(i);this.RebuildTreeAndGraph()}UpdateObstacle(e){this.UpdateObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}RemoveObstacles(e){for(let i of e)this.RemoveObstacleWithoutRebuild(i);this.RebuildTreeAndGraph()}RemoveObstacle(e){this.RemoveObstacleWithoutRebuild(e),this.RebuildTreeAndGraph()}AddObstacleWithoutRebuild(e){if(e.BoundaryCurve==null)throw new Error("Shape must have a BoundaryCurve");this.CreatePaddedObstacle(e)}UpdateObstacleWithoutRebuild(e){if(e.BoundaryCurve==null)throw new Error("Shape must have a BoundaryCurve");this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(e)),this.CreatePaddedObstacle(e)}CreatePaddedObstacle(e){let i=new st(e,this.Padding);this.ShapeToObstacleMap.set(e,i),this.PortManager.CreateObstaclePorts(i)}RemoveObstacleWithoutRebuild(e){let i=this.ShapeToObstacleMap.get(e);this.ShapeToObstacleMap.delete(e),this.PortManager.RemoveObstaclePorts(i)}RemoveAllObstacles(){this.InternalClear(!1)}RebuildTreeAndGraph(){let e=this.ObsTree.Root!=null,i=this.GraphGenerator.VisibilityGraph!=null;this.InternalClear(!0),e&&this.GenerateObstacleTree(),i&&this.GenerateVisibilityGraph()}get VisibilityGraph(){return this.GenerateVisibilityGraph(),this.GraphGenerator.VisibilityGraph}Clear(){this.InternalClear(!1)}static constructorEmpty(){return Ye.constructorC(null)}static constructorC(e){return new Ye([],Ye.DefaultPadding,Ye.DefaultCornerFitRadius)}static constructorI(e){return new Ye(e,Ye.DefaultPadding,Ye.DefaultCornerFitRadius)}static constructorINN(e,i,r){return new Ye(e,i,r)}static constructorGNAN(e,i,r,n){let o=new Ye(ot.GetShapes(e),r,n);if(i==null)for(let s of e.deepEdges)o.AddEdgeGeometryToRoute(s);else for(let s of i)o.AddEdgeGeometryToRoute(s);return o}run(){this.GenerateVisibilityGraph(),this.GeneratePaths()}GeneratePaths(){let e=this.EdgesToRoute.map(i=>new ca(i));this.FillEdgePathsWithShortestPaths(e),this.NudgePaths(e),this.RouteSelfEdges(),this.FinaliseEdgeGeometries()}RouteSelfEdges(){for(let e of this.selfEdges){let i={smoothedPolyline:null};e.curve=Pe.RouteSelfEdge(e.sourcePort.Curve,Math.max(this.Padding,2*e.GetMaxArrowheadLength()),i)}}FillEdgePathsWithShortestPaths(e){this.PortManager.BeginRouteEdges();let i=new rn(this.BendPenaltyAsAPercentageOfDistance);for(let r of e)this.AddControlPointsAndGeneratePath(i,r);this.PortManager.EndRouteEdges()}AddControlPointsAndGeneratePath(e,i){let r=this.PortManager.GetPortVisibilityIntersection(i.GeomEdge);if(r!=null){this.GeneratePathThroughVisibilityIntersection(i,r);return}this.SpliceVisibilityAndGeneratePath(e,i)}GeneratePathThroughVisibilityIntersection(e,i){e.PathPoints=i}SpliceVisibilityAndGeneratePath(e,i){this.PortManager.AddControlPointsToGraph(i.GeomEdge,this.ShapeToObstacleMap),this.GeneratePath(e,i,!1)||this.RetryPathsWithAdditionalGroupsEnabled(e,i),this.PortManager.RemoveControlPointsFromGraph()}GeneratePath(e,i,r){let n=this.PortManager.FindVertices(i.GeomEdge.sourcePort),o=this.PortManager.FindVertices(i.GeomEdge.targetPort);return Ye.GetSingleStagePath(i,e,n,o,r)}static GetSingleStagePath(e,i,r,n,o){return e.PathPoints=i.GetPath(r,n),o&&Ye.EnsureNonNullPath(e),e.PathPoints!=null&&e.PathPoints.length>0}static EnsureNonNullPath(e){e.PathPoints==null&&(C.IsPureDirection(e.GeomEdge.sourcePort.Location,e.GeomEdge.targetPort.Location)?e.PathPoints=[e.GeomEdge.sourcePort.Location,e.GeomEdge.targetPort.Location]:e.PathPoints=[e.GeomEdge.sourcePort.Location,new c(e.GeomEdge.sourcePort.Location.x,e.GeomEdge.targetPort.Location.y),e.GeomEdge.targetPort.Location])}RetryPathsWithAdditionalGroupsEnabled(e,i){(!this.PortManager.SetAllAncestorsActive(i.GeomEdge,this.ShapeToObstacleMap)||!this.GeneratePath(e,i,!1))&&(this.PortManager.SetAllGroupsActive(),this.GeneratePath(e,i,!0))}NudgePaths(e){let i=this.ObsTree.SpatialAncestorsAdjusted?$.GetAncestorSetsMap(this.Obstacles):this.AncestorsSets;fe.NudgePaths(e,this.edgeSeparatian,this.PaddedObstacles,i,this.RemoveStaircases)}get RemoveStaircases(){return this.removeStaircases}set RemoveStaircases(e){this.removeStaircases=e}FinaliseEdgeGeometries(){for(let e of this.EdgesToRoute.concat(this.selfEdges)){if(e.curve==null)continue;e.curve instanceof R&&(e.curve=Ye.FitArcsIntoCorners(this.CornerFitRadius,Array.from(e.curve))),Ye.CalculateArrowheads(e)}}CreateVisibilityGraph(){this.GraphGenerator.Clear(),this.InitObstacleTree(),this.GraphGenerator.GenerateVisibilityGraph()}static CalculateArrowheads(e){we.trimSplineAndCalculateArrowheadsII(e,e.sourcePort.Curve,e.targetPort.Curve,e.curve,!0)}get ObsTree(){return this.GraphGenerator.ObstacleTree}GenerateObstacleTree(){if(this.Obstacles==null||this.Obstacles.length===0)throw new Error("No obstacles have been added");this.ObsTree.Root==null&&this.InitObstacleTree()}InitObstacleTree(){this.AncestorsSets=$.GetAncestorSetsMap(this.Obstacles),this.ObsTree.Init(this.ShapeToObstacleMap.values(),this.AncestorsSets,this.ShapeToObstacleMap)}InternalClear(e){this.GraphGenerator.Clear(),this.ClearShortestPaths(),e?this.PortManager.ClearVisibility():(this.PortManager.Clear(),this.ShapeToObstacleMap.clear(),this.EdgesToRoute=[])}ClearShortestPaths(){for(let e of this.EdgesToRoute)e.curve=null}GenerateVisibilityGraph(){if(this.Obstacles==null||this.Obstacles.length===0)throw new Error("No obstacles have been set");this.GraphGenerator.VisibilityGraph==null&&this.CreateVisibilityGraph()}static FitArcsIntoCorners(e,i){if(e==0)return R.mkFromPoints(i);let r=Ye.GetFittedArcSegs(e,i),n=new p,o=null;for(let s of r){let a=Ye.EllipseIsAlmostLineSegment(s);o!=null?a?p.continueWithLineSegmentP(n,Ye.CornerPoint(s)):(p.continueWithLineSegmentP(n,s.start),n.addSegment(s)):a?p.addLineSegment(n,i[0],Ye.CornerPoint(s)):(p.addLineSegment(n,i[0],s.start),n.addSegment(s)),o=s}return n.segs.length>0?p.continueWithLineSegmentP(n,i[i.length-1]):p.addLineSegment(n,i[0],i[i.length-1]),n}static CornerPoint(e){return e.center.add(e.aAxis.add(e.bAxis))}static EllipseIsAlmostLineSegment(e){return e.aAxis.lengthSquared<1e-4||e.aAxis.lengthSquared<1e-4}static*GetFittedArcSegs(e,i){let r=i[1].sub(i[0]),n=r.normalize(),o=Math.min(e,r.length/2);for(let s=1;s<i.length-1;s++){r=i[s+1].sub(i[s]);let a=r.length;if(a<m.intersectionEpsilon){yield new k(0,0,new c(0,0),new c(0,0),i[s]);continue}let u=r.div(a);Math.abs(u.dot(n))>.9&&(yield new k(0,0,new c(0,0),new c(0,0),i[s]));let h=Math.min(e,r.length/2),d=u.mul(-h),g=n.mul(o);yield new k(0,Math.PI/2,d,g,i[s].sub(g.add(d))),n=u,o=h}}},Ki=Ye;Ki.DefaultPadding=1,Ki.DefaultCornerFitRadius=3;var ah=J(Qe(),1),Qt=class{constructor(t,e,i,r=1){this.Source=t,this.Target=e,this.CrossingWeight=i,this.Weight=r}toString(){return ah.String.Format("{0}->{1}",this.Source,this.Target)}};var un=class{static FindClosestPoints(t,e){let i=p.minDistWithinIntervals(t,e,t.parStart,t.parEnd,e.parStart,e.parEnd,(t.parStart+t.parEnd)/2,(e.parStart+e.parEnd)/2);if(i)return{curveClosestPoint:i.aX,labelSideClosest:i.bX}}static GetSegmentInFrontOfLabel(t,e){if(t instanceof p){for(let i of t.segs)if((i.start.y-e)*(i.end.y-e)<=0)return i}return null}static ShiftLabel(t,e,i){let r=t.lineWidth/2,n=e.sub(i),o=n.length;o>r&&t.label.positionCenter(t.label.center.add(n.div(o*(o-r))))}static updateLabel(t,e){let i=null;e.labelIsToTheRightOfTheSpline?(t.label.positionCenter(new c(e.x+e.rightAnchor/2,e.y)),i=S.mkPP(t.label.boundingBox.leftTop,t.label.boundingBox.leftBottom)):e.labelIsToTheLeftOfTheSpline&&(t.label.positionCenter(new c(e.x-e.leftAnchor/2,e.y)),i=S.mkPP(t.label.boundingBox.rightTop,t.label.boundingBox.rightBottom));let r=un.GetSegmentInFrontOfLabel(t.curve,t.label.center.y);if(r!=null&&p.getAllIntersections(t.curve,p.polyFromBox(t.label.boundingBox),!1).length===0){let n=un.FindClosestPoints(r,i);if(n)un.ShiftLabel(t,n.curveClosestPoint,n.labelSideClosest);else{let o,s,a=r.closestParameter(i.start),u=r.closestParameter(i.end);r.value(a).sub(i.start).length<r.value(u).sub(i.end).length?(o=r.value(a),s=i.start):(o=r.value(u),s=i.end),un.ShiftLabel(t,o,s)}}}},pt=class{constructor(t,e,i,r=1,n=1){this.reversed=!1;this.source=t,this.target=e,this.edge=i,this.weight=r,this.separation=n}get CrossingWeight(){return 1}get hasLabel(){return this.edge.label!=null}get labelWidth(){return this.edge.label.width}get labelHeight(){return this.edge.label.height}reverse(){let t=this.source;this.source=this.target,this.target=t,this.reversed=!this.reversed}toString(){return"edge("+this.source+"->"+this.target+")"}get curve(){return this.edge.curve}set curve(t){this.edge.curve=t}get underlyingPolyline(){return this.edge.smoothedPolyline}set underlyingPolyline(t){this.edge.smoothedPolyline=t}get LayerSpan(){return this.LayerEdges!=null?this.LayerEdges.length:0}isSelfEdge(){return this.source===this.target}reversedClone(){let t=new pt(this.target,this.source,this.edge);if(this.LayerEdges!=null){let e=this.LayerEdges.length;t.LayerEdges=new Array(e);for(let i=0;i<e;i++){let r=this.LayerEdges[e-1-i];t.LayerEdges[i]=new Qt(r.Target,r.Source,r.CrossingWeight)}t.LayerEdges[0].Source=this.target,t.LayerEdges[this.LayerEdges.length-1].Target=this.source}return t}get count(){return this.LayerEdges.length}getNode(t){if(t>=0){if(t<this.LayerEdges.length)return this.LayerEdges[t].Source;if(t===this.LayerEdges.length)return this.LayerEdges[t-1].Target}throw new Error("wrong index "+t)}updateEdgeLabelPosition(t){if(this.edge.label!=null){let e=this.LayerEdges.length/2,i=this.LayerEdges[e];un.updateLabel(this.edge,t[i.Source])}}[Symbol.iterator](){return this.nodes()}*nodes(){yield this.LayerEdges[0].Source;for(let t of this.LayerEdges)yield t.Target}};var ya=class{constructor(){this.maxLayerOfGeomGraph=new Set;this.minLayerOfGeomGraph=new Set;this.sameLayerConstraints=new Array;this.upDownConstraints=new Array;this.gluedUpDownIntConstraints=new at;this.sameLayerDictionaryOfRepresentatives=new Map;this.representativeToItsLayer=new Map;this.maxLayerInt=new Array;this.minLayerInt=new Array;this.sameLayerInts=new Array;this.upDownInts=new Array}getFeedbackSetExternal(t,e){throw new Error("Method not implemented.")}pinNodeToMaxLayer(t){this.maxLayerOfGeomGraph.add(t)}pinNodeToMinLayer(t){this.minLayerOfGeomGraph.add(t)}get isEmpty(){return this.maxLayerOfGeomGraph.size===0&&this.minLayerOfGeomGraph.size===0&&this.sameLayerConstraints.length===0&&this.upDownConstraints.length===0}clear(){this.maxLayerOfGeomGraph.clear(),this.minLayerOfGeomGraph.clear(),this.sameLayerConstraints=[],this.upDownConstraints=[]}getFeedbackSetImp(t,e){return this.nodeIdToIndex=e,this.intGraph=t,this.maxRepresentative=-1,this.minRepresentative=-1,this.createIntegerConstraints(),this.glueTogetherSameConstraintsMaxAndMin(),this.addMaxMinConstraintsToGluedConstraints(),this.removeCyclesFromGluedConstraints(),this.getFeedbackSet()}removeCyclesFromGluedConstraints(){let t=rt(Array.from(this.gluedUpDownIntConstraints.values()),this.intGraph.nodeCount),e=jt.getFeedbackSetWithConstraints(t,null);for(let i of e)this.gluedUpDownIntConstraints.remove(i)}addMaxMinConstraintsToGluedConstraints(){if(this.maxRepresentative!==-1)for(let t=0;t<this.intGraph.nodeCount;t++){let e=this.nodeToRepr(t);e!==this.maxRepresentative&&this.gluedUpDownIntConstraints.add(new F(this.maxRepresentative,e))}if(this.minRepresentative!==-1)for(let t=0;t<this.intGraph.nodeCount;t++){let e=this.nodeToRepr(t);e!==this.minRepresentative&&this.gluedUpDownIntConstraints.add(new F(e,this.minRepresentative))}}glueTogetherSameConstraintsMaxAndMin(){this.createDictionaryOfSameLayerRepresentatives();let t=this.upDownInts.map(this.gluedIntPairNN);this.gluedUpDownIntConstraints=new at}gluedIntPairNN(t){return new F(this.nodeToRepr(t[0]),this.nodeToRepr(t[1]))}gluedIntPairI(t){return new F(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntPair(t){return new F(this.nodeToRepr(t.source),this.nodeToRepr(t.target))}gluedIntEdge(t){let e=this.nodeToRepr(t.source),i=this.nodeToRepr(t.target),r=new pt(e,i,t.edge);return r.separation=t.separation,r.weight=0,r}nodeToRepr(t){let e=this.sameLayerDictionaryOfRepresentatives.get(t);return e||t}createDictionaryOfSameLayerRepresentatives(){let t=this.createGraphOfSameLayers();for(let e of Ti(t))this.glueSameLayerNodesOfALayer(e)}createGraphOfSameLayers(){return rt(this.createEdgesOfSameLayers(),this.intGraph.nodeCount)}createEdgesOfSameLayers(){let t=new Array;return this.maxRepresentative!==-1&&this.maxLayerInt.filter(e=>e!==this.maxRepresentative).map(e=>new F(this.maxRepresentative,e)).forEach(e=>t.push(e)),this.minRepresentative!==-1&&this.minLayerInt.filter(e=>e!==this.minRepresentative).map(e=>new F(this.minRepresentative,e)).forEach(e=>t.push(e)),this.sameLayerInts.forEach(e=>t.push(new F(e[0],e[1]))),t}glueSameLayerNodesOfALayer(t){if(t.length>1){let e=-1;if(this.componentsIsMaxLayer(t))for(let i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.maxRepresentative);else if(this.componentIsMinLayer(t))for(let i of t)this.sameLayerDictionaryOfRepresentatives.set(i,e=this.minRepresentative);else for(let i of t)e===-1&&(e=i),this.sameLayerDictionaryOfRepresentatives.set(i,e);this.representativeToItsLayer.set(e,t)}}componentIsMinLayer(t){return t.findIndex(e=>this.minRepresentative===e)>=0}componentsIsMaxLayer(t){return t.findIndex(e=>this.maxRepresentative===e)>=0}createIntegerConstraints(){this.createMaxIntConstraints(),this.createMinIntConstraints(),this.createUpDownConstraints(),this.createSameLayerConstraints()}createSameLayerConstraints(){this.sameLayerInts=this.createIntConstraintsFromStringCouples(this.sameLayerConstraints)}createUpDownConstraints(){this.upDownInts=this.createIntConstraintsFromStringCouples(this.upDownConstraints)}createIntConstraintsFromStringCouples(t){return t.map(e=>[this.nodeIndex(e[0]),this.nodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1)}createMinIntConstraints(){this.minLayerInt=this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph),this.minLayerInt.length>0&&(this.minRepresentative=this.minLayerInt[0])}createMaxIntConstraints(){this.maxLayerInt=this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph),this.maxLayerInt.length>0&&(this.maxRepresentative=this.maxLayerInt[0])}createIntConstraintsFromExtremeLayer(t){return Array.from(t).map(e=>this.nodeIndex(e)).filter(e=>e!==-1)}nodeIndex(t){let e=this.nodeIdToIndex.get(t.node.id);return e||-1}getFeedbackSet(){return this.gluedIntGraph=this.createGluedGraph(),Array.from(this.unglueIntPairs(jt.getFeedbackSetWithConstraints(this.gluedIntGraph,this.gluedUpDownIntConstraints)))}*unglueIntPairs(t){for(let e of t)for(let i of this.unglueEdge(e))yield i}*unglueEdge(t){for(let e of this.unglueNode(t.source))for(let i of this.intGraph.outEdges[e])this.nodeToRepr(i.target)===t.target&&(yield i)}createGluedGraph(){let t=new at;return this.intGraph.edges.forEach(e=>t.add(this.gluedIntPairI(e))),rt(Array.from(t.values()),this.intGraph.nodeCount)}unglueNode(t){let e=this.representativeToItsLayer.get(t);return e||[t]}getGluedNodeCounts(){let t=new Array(this.nodeIdToIndex.size).fill(0);for(let e=0;e<t.length;e++)t[this.nodeToRepr(e)]++;return t}};function Wc(l,t){return[l,t]}var Ca=class{constructor(){this.leftRightConstraints=new Array;this.leftRightNeighbors=new Array;this.nodeToBlockRoot=new Map;this.upDownVerticalConstraints=new Array;this.BlockRootToBlock=new Map}get IsEmpty(){return this.leftRightNeighbors.length===0&&this.upDownVerticalConstraints.length===0&&this.leftRightConstraints.length===0}AddSameLayerNeighbors(t){for(let e=0;e<t.length-1;e++)this.AddSameLayerNeighborsPair(t[e],t[e+1])}AddSameLayerNeighborsPair(t,e){this.leftRightNeighbors.push([t,e])}NodeToBlockRootSoft(t){let e=this.nodeToBlockRoot.get(t);return e||t}CreateMappingOfNeibBlocks(){let t=this.BasicGraphFromLeftRightIntNeibs();for(let e=0;e<t.nodeCount;e++)if(t.inEdges[e].length===0&&!this.nodeToBlockRoot.has(e)){let i=new Array,r=e;for(let n=t.outEdges[r];n.length>0;n=t.outEdges[r])r=n[0].y,i.push(r),this.nodeToBlockRoot.set(r,e);i.length>0&&this.BlockRootToBlock.set(e,i)}}BasicGraphFromLeftRightIntNeibs(){return ao(Array.from(this.LeftRightIntNeibs.values()).map(t=>new F(t.x,t.y)))}NodeIndex(t){let e=this.nodeIdToIndex.get(t.id);return e||-1}PrepareForOrdering(t,e){this.nodeIdToIndex=t,this.MapNodesToToIntegers(e),this.CreateMappingOfNeibBlocks(),this.LiftLeftRightRelationsToNeibBlocks()}LiftLeftRightRelationsToNeibBlocks(){this.LeftRighInts=at.mk(this.leftRightConstraints.map(e=>Wc(this.NodeIndex(e[0]),this.NodeIndex(e[1]))).filter(e=>e[0]!==-1&&e[1]!==-1).map(e=>new F(this.NodeToBlockRootSoft(e[0]),this.NodeToBlockRootSoft(e[1]))).filter(e=>e.x!==e.x));let t=jt.getFeedbackSet(ao(Array.from(this.LeftRighInts.values())));for(let e of t)this.LeftRighInts.remove(new F(e.source,e.target))}MapNodesToToIntegers(t){this.LeftRightIntNeibs=at.mk(Array.from(this.leftRightNeighbors.values()).map(e=>[this.NodeIndex(e[0]),this.NodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1).map(e=>new F(e[0],e[1]))),this.VerticalInts=at.mk(this.upDownVerticalConstraints.map(e=>[this.NodeIndex(e[0]),this.NodeIndex(e[1])]).filter(e=>e[0]!==-1&&e[1]!==-1&&t[e[0]]>t[e[1]]).map(e=>new F(e[0],e[1])))}};var Ea=(n=>(n[n.TB=0]="TB",n[n.LR=1]="LR",n[n.BT=2]="BT",n[n.RL=3]="RL",n[n.None=4]="None",n))(Ea||{});var Wn=(s=>(s[s.Spline=0]="Spline",s[s.SplineBundling=1]="SplineBundling",s[s.StraightLine=2]="StraightLine",s[s.SugiyamaSplines=3]="SugiyamaSplines",s[s.Rectilinear=4]="Rectilinear",s[s.RectilinearToCenter=5]="RectilinearToCenter",s[s.None=6]="None",s))(Wn||{});var wi=class{constructor(){this.coneAngle=30*(Math.PI/180);this.padding=2;this.polylinePadding=1;this.routingToParentConeAngle=Math.PI/6;this.simpleSelfLoopsForParentEdgesThreshold=200;this.incrementalRoutingThreshold=5e6;this.routeMultiEdgesAsBundles=!0;this.KeepOriginalSpline=!1;this.EdgeRoutingMode=0}toJSON(){let t={};return this.EdgeRoutingMode!=0&&(t.edgeRoutingMode=0),this.ConeAngle!=30*(Math.PI/180)&&(t.coneAngle=this.ConeAngle),this.padding!=3&&(t.padding=this.padding),this.polylinePadding!=1.5&&(t.polylinePadding=this.polylinePadding),this.bundlingSettings&&(t.bundlingSettingsJSON=this.bundlingSettings.toJSON()),t}static fromJSON(t){let e=new wi;return t.edgeRoutingMode&&(t.edgeRoutingMode=e.edgeRoutingMode),t.coneAngle&&(e.coneAngle=t.coneAngle),t.padding&&(e.padding=t.padding),t.polylinePadding&&(e.polylinePadding=t.polylinePadding),t.bundlingSettingsJSON&&(e.bundlingSettings=Kt.createFromJSON(t.bundlingSettingsJSON)),t.routingToParentConeAngle&&(e.routingToParentConeAngle=t.routingToParentConeAngle),t.simpleSelfLoopsForParentEdgesThreshold&&(e.simpleSelfLoopsForParentEdgesThreshold=t.simpleSelfLoopsForParentEdgesThreshold),t.incrementalRoutingThreshold&&(e.incrementalRoutingThreshold=t.incrementalRoutingThreshold),t.routeMultiEdgesAsBundles&&(e.routeMultiEdgesAsBundles=t.routeMultiEdgesAsBundles),t.KeepOriginalSpline&&(e.KeepOriginalSpline=t.KeepOriginalSpline),e}get EdgeRoutingMode(){return this.edgeRoutingMode}set EdgeRoutingMode(t){t===1&&this.bundlingSettings==null&&this.bundlingSettings==null&&(this.bundlingSettings=new Kt),this.edgeRoutingMode=t}get ConeAngle(){return this.coneAngle}set ConeAngle(t){this.coneAngle=t}get Padding(){return this.padding}set Padding(t){this.padding=t}get PolylinePadding(){return this.polylinePadding}set PolylinePadding(t){this.polylinePadding=t}get RoutingToParentConeAngle(){return this.routingToParentConeAngle}set RoutingToParentConeAngle(t){this.routingToParentConeAngle=t}get SimpleSelfLoopsForParentEdgesThreshold(){return this.simpleSelfLoopsForParentEdgesThreshold}set SimpleSelfLoopsForParentEdgesThreshold(t){this.simpleSelfLoopsForParentEdgesThreshold=t}get IncrementalRoutingThreshold(){return this.incrementalRoutingThreshold}set IncrementalRoutingThreshold(t){this.incrementalRoutingThreshold=t}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(t){this.routeMultiEdgesAsBundles=t}};var Oi=class{constructor(){this.edgeRoutingSettings=new wi;this.nodeSeparation=10;this.packingAspectRatio=1.5}static fromJSON(t){let e=new Oi;return t.nodeSeparation!=10&&(e.nodeSeparation=t.nodeSeparation),t.packingAspectRatio&&(e.packingAspectRatio=t.packingAspectRatio),t.edgeRoutingSettings&&(e.edgeRoutingSettings=wi.fromJSON(t.edgeRoutingSettings)),e}toJSON(){let t=!1,e={};return this.nodeSeparation!=10&&(e.nodeSeparation=this.nodeSeparation,t=!0),this.packingAspectRatio!=1.5&&(e.packingAspectRatio=this.packingAspectRatio,t=!0),(e.edgeRoutingSettings=this.edgeRoutingSettings.toJSON())&&(t=!0),t?e:void 0}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get PackingAspectRatio(){return this.packingAspectRatio}set PackingAspectRatio(t){this.packingAspectRatio=t}};var Xt=class{constructor(){this.commonSettings=new Oi;this.verticalConstraints=new ya;this.horizontalConstraints=new Ca;this.NoGainAdjacentSwapStepsBound=5;this.NoGainStepsForOrderingMultiplier=1;this.AspectRatio=0;this.MaxNumberOfPassesInOrdering=24;this.BrandesThreshold=600;this.LabelCornersPreserveCoefficient=.1;this.MinNodeHeight=72*.5/4;this.MinNodeWidth=72*.75/4;this.SnapToGridByY=0;this.yLayerSep=10*3;this.transform=Ce.getIdentity();this.GridSizeByY=0;this.GridSizeByX=0;this.commonSettings.edgeRoutingSettings.EdgeRoutingMode=3}get NodeSeparation(){return this.commonSettings.NodeSeparation}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}toJSON(){let t={};return this.sameRanks&&(t.sameRanks=this.sameRanks),this.verticalConstraints&&(t.verticalConstraints=this.verticalConstraints),this.horizontalConstraints&&(t.horizontalConstraints=this.horizontalConstraints),this.NoGainAdjacentSwapStepsBound!=5&&(t.horizontalConstraints=this.horizontalConstraints),this.NoGainStepsForOrderingMultiplier!=1&&(t.RepetitionCoefficientForOrdering=this.NoGainStepsForOrderingMultiplier),this.AspectRatio&&(t.AspectRatio=this.AspectRatio),this.MaxNumberOfPassesInOrdering!=24&&(t.MaxNumberOfPassesInOrdering=this.MaxNumberOfPassesInOrdering),this.BrandesThreshold!=600&&(t.BrandesThreshold=this.BrandesThreshold),this.LabelCornersPreserveCoefficient!=.1&&(t.LabelCornersPreserveCoefficient=this.LabelCornersPreserveCoefficient),this.MinNodeHeight!=72*.5/4&&(t.MinNodeHeight=this.MinNodeHeight),this.MinNodeWidth!=72*.75/4&&(t.MinNodeWidth=this.MinNodeWidth),this.SnapToGridByY!=0&&(t.SnapToGridByY=this.SnapToGridByY),this.yLayerSep!=10*3&&(t.yLayerSep=this.yLayerSep),this.transform&&(t.transform=this.transform.elements),this.GridSizeByY&&(t.GridSizeByY=this.GridSizeByY),this.GridSizeByX&&(t.GridSizeByX=this.GridSizeByX),t.commonLayoutSettings=this.commonSettings.toJSON(),t}static fromJSON(t){let e=new Xt;return t.sameRanks&&(e.sameRanks=t.sameRanks),t.verticalConstraints&&(e.verticalConstraints=t.verticalConstraints),t.horizontalConstraints&&(e.horizontalConstraints=t.horizontalConstraints),t.NoGainAdjacentSwapStepsBound&&(e.horizontalConstraints=t.horizontalConstraints),t.RepetitionCoefficientForOrdering&&(e.NoGainStepsForOrderingMultiplier=t.RepetitionCoefficientForOrdering),t.AspectRatio&&(e.AspectRatio=t.AspectRatio),t.MaxNumberOfPassesInOrdering&&(e.MaxNumberOfPassesInOrdering=t.MaxNumberOfPassesInOrdering),t.BrandesThreshold&&(e.BrandesThreshold=t.BrandesThreshold),t.LabelCornersPreserveCoefficient&&(e.LabelCornersPreserveCoefficient=t.LabelCornersPreserveCoefficient),t.MinNodeHeight&&(e.MinNodeHeight=t.MinNodeHeight),t.MinNodeWidth&&(e.MinNodeWidth=e.MinNodeWidth),t.SnapToGridByY&&(e.SnapToGridByY=t.SnapToGridByY),t.yLayerSep&&(e.yLayerSep=t.yLayerSep),t.transform&&(e.transform=new Ce(t.transform[0][0],t.transform[0][1],t.transform[0][2],t.transform[1][0],t.transform[1][1],t.transform[1][2])),t.GridSizeByY&&(e.GridSizeByY=t.GridSizeByY),t.GridSizeByX&&(e.GridSizeByX=t.GridSizeByX),t.commonLayoutSettings&&(e.commonSettings=Oi.fromJSON(t.commonLayoutSettings)),e}get LayerSeparation(){return this.yLayerSep}set LayerSeparation(t){this.yLayerSep=Math.max(10*3,t)}ActualLayerSeparation(t){return t?this.LayerSeparation/2:this.LayerSeparation}transformIsRotation(t){let e=Ce.rotation(t);for(let i=0;i<2;i++)for(let r=0;r<3;r++)if(!N(e.elements[i][r],this.transform.elements[i][r]))return!1;return!0}get layerDirection(){if(this.transformIsRotation(0))return 0;if(this.transformIsRotation(Math.PI/2))return 1;if(this.transformIsRotation(-Math.PI/2))return 3;if(this.transformIsRotation(Math.PI))return 2;throw new Error("unexpected layout direction")}set layerDirection(t){switch(t){case 0:this.transform=Ce.getIdentity();break;case 1:this.transform=Ce.rotation(Math.PI/2);break;case 3:this.transform=Ce.rotation(-Math.PI/2);break;case 2:this.transform=Ce.rotation(Math.PI);break;default:throw new Error("unexpected layout direction")}}};var Co=class extends H{constructor(e,i,r){super(null);this.graph=e,this.source=i,this.length=r}get Result(){return this.result}run(){let e=new nt((n,o)=>n-o),i=new Map;for(let n of this.graph.shallowNodes){let o=n===this.source?0:Number.POSITIVE_INFINITY;e.Enqueue(n,o),i.set(n,o)}for(;e.count>0;){let n={priority:0},o=e.DequeueAndGetPriority(n);i.set(o,n.priority);let s=i.get(o);for(let a of o.inEdges()){let u=a.source,h=s+this.length(a);i.get(u)>h&&(i.set(u,h),e.DecreasePriority(u,h))}for(let a of o.outEdges()){let u=a.target,h=s+this.length(a);i.get(u)>h&&(i.set(u,h),e.DecreasePriority(u,h))}}this.result=new Array(this.graph.shallowNodeCount);let r=0;for(let n of this.graph.shallowNodes){let o=i.get(n);o!==void 0?this.result[r++]=o:this.result[r++]=Number.POSITIVE_INFINITY}}};var Eo=class extends H{constructor(e,i){super(null);this.graph=e,this.length=i}get Result(){return this.result}set Result(e){this.result=e}run(){this.result=new Array(this.graph.shallowNodeCount);let e=0;for(let i of this.graph.shallowNodes){let r=new Co(this.graph,i,this.length);r.run(),this.Result[e++]=r.Result}}static Stress(e,i){let r=0;if(e.edgeCount===0)return r;let n=new Eo(e,i);n.run();let o=n.Result,s=0;for(let u of e.shallowEdges)s+=i(u);s/=e.edgeCount;let a=0;for(let u of e.shallowNodes){let h=0;for(let d of e.shallowNodes){if(a!==h){let g=u.center.sub(d.center).length,f=s*o[a][h],P=f-g;r+=P*P/(f*f)}h++}a++}return r}};var Ia=class extends H{constructor(e,i,r){super(null);this.graph=e,this.pivotArray=i,this.length=r}get Result(){return this.result}run(){this.result=new Array(this.pivotArray.length);let e=Array.from(this.graph.shallowNodes),i=new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY),r=e[0];this.pivotArray[0]=0;for(let n=0;;n++){let o=new Co(this.graph,r,this.length);if(o.run(),this.Result[n]=o.Result,n+1<this.pivotArray.length){let s=0;for(let a=0;a<this.Result[n].length;a++)i[a]=Math.min(i[a],this.Result[n][a]),i[a]>i[s]&&(s=a);r=e[s],this.pivotArray[n+1]=s}else break}}};var va=class{static Rotate(t,e,i){let r=Math.sin(i*(Math.PI/180)),n=Math.cos(i*(Math.PI/180));for(let o=0;o<t.length;o++){let s=n*t[o]+r*e[o];e[o]=n*e[o]-r*t[o],t[o]=s}}};var me=class{static DoubleCenter(t){let e=new Array(t.length).fill(0),i=new Array(t[0].length).fill(0),r=0;for(let n=0;n<t.length;n++)for(let o=0;o<t[0].length;o++)e[n]+=t[n][o],i[o]+=t[n][o],r+=t[n][o];for(let n=0;n<t.length;n++)e[n]/=t.length;for(let n=0;n<t[0].length;n++)i[n]/=t[0].length;r/=t.length,r/=t[0].length;for(let n=0;n<t.length;n++)for(let o=0;o<t[0].length;o++)t[n][o]-=e[n]+i[o]-r}static SquareEntries(t){for(let e=0;e<t.length;e++)for(let i=0;i<t[0].length;i++)t[e][i]=Math.pow(t[e][i],2)}static Multiply(t,e){for(let i=0;i<t.length;i++)for(let r=0;r<t[0].length;r++)t[i][r]*=e}static MultiplyX(t,e){if(t[0].length!==e.length)return null;let i=new Array(e.length).fill(0);for(let r=0;r<t.length;r++)for(let n=0;n<t[0].length;n++)i[r]+=t[r][n]*e[n];return i}static Norm(t){let e=0;for(let i=0;i<t.length;i++)e+=Math.pow(t[i],2);return Math.sqrt(e)}static Normalize(t){let e=me.Norm(t);if(e<=0)return 0;for(let i=0;i<t.length;i++)t[i]/=e;return e}static RandomUnitLengthVector(t){let e=new Array(t);for(let i=0;i<t;i++)e[i]=Qi();return me.Normalize(e),e}static SpectralDecomposition(t,e){me.SpectralDecompositionIE(t,e,30,1e-6)}static SpectralDecompositionIE(t,e,i,r){let n=t[0].length;e.u1=me.RandomUnitLengthVector(n),e.lambda1=0,e.u2=me.RandomUnitLengthVector(n),e.lambda2=0;let o=0,s=1-r;for(let a=0;a<i&&o<s;a++){let u=me.MultiplyX(t,e.u1),h=me.MultiplyX(t,e.u2);e.lambda1=me.Normalize(u),e.lambda2=me.Normalize(h),me.MakeOrthogonal(h,u),me.Normalize(h),o=Math.min(me.DotProduct(e.u1,u),me.DotProduct(e.u2,h)),e.u1=u,e.u2=h}}static DotProduct(t,e){if(t.length!==e.length)return 0;let i=0;for(let r=0;r<t.length;r++)i+=t[r]*e[r];return i}static MakeOrthogonal(t,e){if(t.length!==e.length)return;let i=me.DotProduct(t,e)/me.DotProduct(e,e);for(let r=0;r<t.length;r++)t[r]-=i*e[r]}static ClassicalScaling(t,e){let i=new Array(t.length);for(let r=0;r<t.length;r++)i[r]=t[r].slice();me.SquareEntries(i),me.DoubleCenter(i),me.Multiply(i,-.5),me.SpectralDecomposition(i,e),e.lambda1=Math.sqrt(Math.abs(e.lambda1)),e.lambda2=Math.sqrt(Math.abs(e.lambda2));for(let r=0;r<e.u1.length;r++)e.u1[r]*=e.lambda1,e.u2[r]*=e.lambda2}static DistanceScalingSubset(t,e,i,r,n){let o=e.length,s=t.length,a=new Array(s);for(let h=0;h<s;h++)for(let d=0;d<o;d++)t[h][d]===0&&(a[h]=d);let u=new Array(s).fill(0);for(let h=0;h<s;h++)for(let d=0;d<o;d++)a[h]!==d&&(u[h]+=r[h][d]);for(let h=0;h<n;h++)for(let d=0;d<s;d++){let g=0,f=0;for(let P=0;P<o;P++)if(d!==P){let y=Math.sqrt(Math.pow(e[a[d]]-e[P],2)+Math.pow(i[a[d]]-i[P],2));y>0&&(y=1/y),g+=r[d][P]*(e[P]+t[d][P]*(e[a[d]]-e[P])*y),f+=r[d][P]*(i[P]+t[d][P]*(i[a[d]]-i[P])*y)}e[a[d]]=g/u[d],i[a[d]]=f/u[d]}}static DistanceScaling(t,e,i,r,n){let o=e.length,s=new Array(o).fill(0);for(let a=0;a<o;a++)for(let u=0;u<o;u++)a!==u&&(s[a]+=r[a][u]);for(let a=0;a<n;a++)for(let u=0;u<o;u++){let h=0,d=0;for(let g=0;g<o;g++)if(u!==g){let f=Math.sqrt(Math.pow(e[u]-e[g],2)+Math.pow(i[u]-i[g],2));f>0&&(f=1/f),h+=r[u][g]*(e[g]+t[u][g]*(e[u]-e[g])*f),d+=r[u][g]*(i[g]+t[u][g]*(i[u]-i[g])*f)}e[u]=h/s[u],i[u]=d/s[u]}}static ExponentialWeightMatrix(t,e){let i=new Array(t.length);for(let r=0;r<t.length;r++){i[r]=new Array(t[r].length).fill(0);for(let n=0;n<t[r].length;n++)t[r][n]>0&&(i[r][n]=Math.pow(t[r][n],e))}return i}static EuclideanDistanceMatrix(t,e){let i=new Array(t.length);for(let r=0;r<t.length;r++){i[r]=new Array(t.length);for(let n=0;n<t.length;n++)i[r][n]=Math.sqrt(Math.pow(t[r]-t[n],2)+Math.pow(e[r]-e[n],2))}return i}static LandmarkClassicalScaling(t,e,i){let r=new Array(t.length);for(let s=0;s<t.length;s++){r[s]=new Array(t.length);for(let a=0;a<t.length;a++)r[s][a]=t[s][i[a]]}me.SquareEntries(r);let n=new Array(t.length).fill(0);for(let s=0;s<t.length;s++){for(let a=0;a<t.length;a++)n[s]+=r[s][a];n[s]/=t.length}me.DoubleCenter(r),me.Multiply(r,-.5);let o={u1:new Array,u2:new Array,lambda1:0,lambda2:0};me.SpectralDecomposition(r,o),o.lambda1=Math.sqrt(Math.abs(o.lambda1)),o.lambda2=Math.sqrt(Math.abs(o.lambda2)),e.x=new Array(t[0].length).fill(0),e.y=new Array(t[0].length).fill(0);for(let s=0;s<e.x.length;s++)for(let a=0;a<r.length;a++){let u=(Math.pow(t[a][s],2)-n[a])/2;e.x[s]-=o.u1[a]*u,e.y[s]-=o.u2[a]*u}}};var lh=J(Qe(),1);var xa=class{constructor(t,e){this.constrained=!1;this.Capacity=1e6;ne.AbovePP(t.point,e.point)===1?(this.upperSite=t,this.lowerSite=e):(this.lowerSite=t,this.upperSite=e),this.upperSite.AddEdgeToSite(this)}get CcwTriangle(){return this.ccwTriangle}set CcwTriangle(t){this.ccwTriangle=t}get CwTriangle(){return this.cwTriangle}set CwTriangle(t){this.cwTriangle=t}GetOtherTriangle_c(t){return this.cwTriangle.Contains(t)?this.ccwTriangle:this.cwTriangle}IsAdjacent(t){return t===this.upperSite||t===this.lowerSite}GetOtherTriangle_T(t){return this.ccwTriangle===t?this.cwTriangle:this.ccwTriangle}toString(){return lh.String.Format("({0},{1})",this.upperSite,this.lowerSite)}OtherSite(t){return this.upperSite===t?this.lowerSite:this.upperSite}};var hn=class{constructor(t){this.Owner=null;this.InEdges=new Array;this.point=t}cleanRemovedEdges(){for(let t of this.Edges)t.CcwTriangle===null&&t.CwTriangle===null&&this.Edges.splice(this.Edges.indexOf(t),1)}static mkSO(t,e){let i=new hn(t);return i.Owner=e,i}AddEdgeToSite(t){this.Edges==null&&(this.Edges=new Array),this.Edges.push(t)}EdgeBetweenUpperSiteAndLowerSite(t){if(this.Edges!=null){for(let e of this.Edges)if(e.lowerSite===t)return e}return null}AddInEdge(t){this.InEdges.push(t)}*Triangles(){let t;if(this.Edges!=null&&this.Edges.length>0)t=this.Edges[0];else if(this.InEdges!=null&&this.InEdges.length>0)t=this.InEdges[0];else return;let e=t;do{let i=e.upperSite===this?e.CcwTriangle:e.CwTriangle;if(i==null){e=null;break}yield i,e=i.Edges.getItem(i.Edges.index(e)+2)}while(e!==t);if(e!==t){e=t;do{let i=e.upperSite===this?e.CwTriangle:e.CcwTriangle;if(i==null)break;yield i,e=i.Edges.getItem(i.Edges.index(e)+1)}while(!0)}}toString(){return this.point.toString()}};var Vl=J(ai(),1);var yr=class{get x(){return this.LeftSite.point.x}constructor(t,e){this.RightSite=e.upperSite===t?e.lowerSite:e.upperSite,this.LeftSite=t,this.Edge=e}toString(){return"("+this.LeftSite.toString()+", "+this.Edge.toString()+","+this.RightSite.toString()+")"}};var zn=class{has(t){return t===this.item0||t===this.item1||t===this.item2}index(t){return t===this.item0?0:t===this.item1?1:t===this.item2?2:-1}getItem(t){switch(t){case 0:case 3:case-3:return this.item0;case 1:case 4:case-2:return this.item1;case 2:case 5:case-1:return this.item2;default:throw new Error}}setItem(t,e){switch(t){case 0:case 3:case-3:this.item0=e;break;case 1:case 4:case-2:this.item1=e;break;case 2:case 5:case-1:this.item2=e;break;default:throw new Error}}[Symbol.iterator](){return this.GetEnumerator()}*GetEnumerator(){yield this.item0,yield this.item1,yield this.item2}};var lt=class{constructor(){this.Edges=new zn;this.Sites=new zn}containsPoint(t){return lt.PointLocationForTriangle(t,this)!==0}static PointLocationForTriangle(t,e){let i=!1;for(let r=0;r<3;r++){let n=c.signedDoubledTriangleArea(t,e.Sites.getItem(r).point,e.Sites.getItem(r+1).point);if(n<-m.distanceEpsilon)return 0;n<m.distanceEpsilon&&(i=!0)}return i?1:2}intersectsLine(t,e,i){if(lt.PointLocationForTriangle(t,this)!=0||lt.PointLocationForTriangle(e,this)!=0)return!0;for(let r of this.Edges)if(this.abIntersectsTrianglSide(t,e,r))return!0;return!1}abIntersectsTrianglSide(t,e,i){return Os(t,e,i.lowerSite.point,i.upperSite.point)}static mkSSSD(t,e,i,r){let n=c.getTriangleOrientation(t.point,e.point,i.point),o=new lt;switch(n){case 1:o.FillCcwTriangle(t,e,i,r);break;case 0:o.FillCcwTriangle(t,i,e,r);break;default:throw new Error}return o}static mkSED(t,e,i){let r=new lt;switch(c.getTriangleOrientation(e.upperSite.point,e.lowerSite.point,t.point)){case 1:e.CcwTriangle=r,r.Sites.setItem(0,e.upperSite),r.Sites.setItem(1,e.lowerSite);break;case 0:e.CwTriangle=r,r.Sites.setItem(0,e.lowerSite),r.Sites.setItem(1,e.upperSite);break;default:throw new Error}return r.Edges.setItem(0,e),r.Sites.setItem(2,t),r.CreateEdge(1,i),r.CreateEdge(2,i),r}static mkSSSEE(t,e,i,r,n,o){let s=lt.mkSSSD(t,e,i,o);return s.Edges.setItem(0,r),s.Edges.setItem(1,n),s.BindEdgeToTriangle(t,r),s.BindEdgeToTriangle(e,n),s.CreateEdge(2,o),s}BindEdgeToTriangle(t,e){t===e.upperSite?e.CcwTriangle=this:e.CwTriangle=this}FillCcwTriangle(t,e,i,r){this.Sites.setItem(0,t),this.Sites.setItem(1,e),this.Sites.setItem(2,i);for(let n=0;n<3;n++)this.CreateEdge(n,r)}CreateEdge(t,e){let i=this.Sites.getItem(t),r=this.Sites.getItem(t+1),n=e(i,r);this.Edges.setItem(t,n),this.BindEdgeToTriangle(i,n)}Contains(t){return this.Sites.has(t)}OppositeEdge(t){let e=this.Sites.index(t);return this.Edges.getItem(e+1)}OppositeSite(t){let e=this.Edges.index(t);return this.Sites.getItem(e+2)}BoundingBox(){let t=I.mkPP(this.Sites.getItem(0).point,this.Sites.getItem(1).point);return t.add(this.Sites.getItem(2).point),t}static mkSSSEED(t,e,i,r,n,o){let s=new lt;return s.Sites.setItem(0,t),s.Sites.setItem(1,e),s.Sites.setItem(2,i),s.Edges.setItem(0,r),s.Edges.setItem(1,n),s.BindEdgeToTriangle(t,r),s.BindEdgeToTriangle(e,n),s.CreateEdge(2,o),s}toString(){return this.Sites.getItem(0).toString()+","+this.Sites.getItem(1).toString()+","+this.Sites.getItem(2).toString()}};var hs=class{constructor(t){this.Edge=t}};var qe=class extends H{constructor(e,i,r,n){super(null);this.front=new Ee((e,i)=>e.x-i.x);this.triangles=new Set;if(this.listOfSites=e,this.listOfSites.length===0)return;this.p_1=i,this.p_2=r,this.createEdgeDelegate=n;let o=lt.mkSSSD(i,r,this.listOfSites[0],n);this.triangles.add(o),this.front.insert(new yr(i,o.Edges.getItem(2))),this.front.insert(new yr(this.listOfSites[0],o.Edges.getItem(1)))}run(){if(this.listOfSites.length!==0){for(let e=1;e<this.listOfSites.length;e++)this.ProcessSite(this.listOfSites[e]);this.FinalizeTriangulation()}}FinalizeTriangulation(){this.RemoveP1AndP2Triangles(),this.triangles.size>0&&this.MakePerimeterConvex()}MakePerimeterConvex(){let e=this.CreateDoubleLinkedListOfPerimeter();do{let i=this.FindConcaveEdge(e);if(i==null)return;e=this.ShortcutTwoListElements(i)}while(!0)}FindConcaveEdge(e){let i=e,r;do{if(r=i.Next,c.getTriangleOrientation(i.Start.point,i.End.point,r.End.point)===1)return i;i=r}while(r!==e);return null}static FindPivot(e){let i=e,r=e;do r=r.Next,(r.Start.point.x<i.Start.point.x||r.Start.point.x===i.Start.point.x&&r.Start.point.y<i.Start.point.y)&&(i=r);while(r!==e);return i}FindFirsePerimeterEdge(){for(let e of this.triangles)for(let i of e.Edges)if(i.GetOtherTriangle_T(e)==null)return i;return null}CreateDoubleLinkedListOfPerimeter(){let e=this.FindFirsePerimeterEdge(),i=e,r=null,n,o=null,s=new Array;do n=qe.CreatePerimeterElementFromEdge(i),s.push(S.mkPP(n.Start.point,n.End.point)),i=qe.FindNextEdgeOnPerimeter(i),o!=null?(n.Prev=o,o.Next=n):r=n,o=n;while(i!==e);return r.Prev=n,n.Next=r,r}static FindNextEdgeOnPerimeter(e){var r;let i=(r=e.CwTriangle)!=null?r:e.CcwTriangle;for(e=i.Edges.getItem(i.Edges.index(e)+2);e.CwTriangle!=null&&e.CcwTriangle!=null;)i=e.GetOtherTriangle_T(i),e=i.Edges.getItem(i.Edges.index(e)+2);return e}static CreatePerimeterElementFromEdge(e){let i=new hs(e);return e.CwTriangle!=null?(i.Start=e.upperSite,i.End=e.lowerSite):(i.End=e.upperSite,i.Start=e.lowerSite),i}RemoveP1AndP2Triangles(){let e=new Set;for(let i of this.triangles)(i.Sites.has(this.p_1)||i.Sites.has(this.p_2))&&e.add(i);for(let i of e)qe.RemoveTriangleWithEdges(this.triangles,i)}static RemoveTriangleWithEdges(e,i){e.delete(i);for(let r of i.Edges)r.CwTriangle===i?r.CwTriangle=null:r.CcwTriangle=null,r.CwTriangle==null&&r.CcwTriangle==null&&Ml(r.upperSite.Edges,r)}static RemoveTriangleButLeaveEdges(e,i){e.delete(i);for(let r of i.Edges)r.CwTriangle===i?r.CwTriangle=null:r.CcwTriangle=null}ProcessSite(e){this.PointEvent(e);for(let i=0;i<e.Edges.length;i++){let r=e.Edges[i];r.constrained&&this.EdgeEvent(r)}}EdgeEvent(e){qe.EdgeIsProcessed(e)||(this.traversingEdge=e,this.runEdgeInserter())}static EdgeIsProcessed(e){return e.CwTriangle!=null||e.CcwTriangle!=null}ShowFrontWithSite(e,i=null){let r=new Array;if(e.Edges!=null)for(let n of e.Edges)r.push(z.mkDebugCurveTWCI(200,.8,n.constrained?"Pink":"Brown",S.mkPP(n.upperSite.point,n.lowerSite.point)));r.push(z.mkDebugCurveTWCI(200,1,"Brown",k.mkFullEllipseNNP(.5,.5,e.point)));for(let n of this.triangles)for(let o=0;o<3;o++){let s=n.Edges.getItem(o);r.push(z.mkDebugCurveTWCI(s.constrained?155:100,s.constrained?.8:.4,s.constrained?"Pink":"Navy",S.mkPP(s.upperSite.point,s.lowerSite.point)))}if(i!=null)for(let n of i)r.push(z.mkDebugCurveTWCI(100,.5,"Red",n));for(let n of this.front)r.push(z.mkDebugCurveTWCI(100,5.5,"Green",S.mkPP(n.Edge.upperSite.point,n.Edge.lowerSite.point)))}Show(e){qe.ShowCdt(Array.from(this.triangles.values()),this.front,null,null,[],e)}static ShowCdt(e,i,r,n,o,s){let a=new Array;if(r!=null)for(let u of r)a.push(z.mkDebugCurveTWCI(200,.1,"Red",u));if(n!=null)for(let u of n)a.push(z.mkDebugCurveTWCI(200,.1,"Blue",u));if(i!=null)for(let u of i)a.push(z.mkDebugCurveTWCI(200,.1,"Green",S.mkPP(u.Edge.upperSite.point,u.Edge.lowerSite.point)));for(let u of e)for(let h=0;h<3;h++){let d=u.Edges.getItem(h);a.push(qe.GetDebugCurveOfCdtEdge(d))}a=a.concat(o)}static GetDebugCurveOfCdtEdge(e){return e.CcwTriangle==null||e.CwTriangle==null?z.mkDebugCurveTWCI(255,.5,e.constrained?"Brown":"Black",S.mkPP(e.upperSite.point,e.lowerSite.point)):z.mkDebugCurveTWCI(200,e.constrained?.8:.2,e.constrained?"Pink":"Navy",S.mkPP(e.upperSite.point,e.lowerSite.point))}PointEvent(e){let i=this.ProjectToFront(e),r={rightSite:null},n=i.item.x+m.distanceEpsilon<e.point.x?this.MiddleCase(e,i,r):this.LeftCase(e,i,r),o=this.InsertSiteIntoFront(n,e,r.rightSite);this.TriangulateEmptySpaceToTheRight(o),o=qe.FindNodeInFrontBySite(this.front,n),this.TriangulateEmptySpaceToTheLeft(o)}LeftCase(e,i,r){let n=i.item;this.InsertAndLegalizeTriangle(e,n);let o=this.front.previous(i),s=o.item.LeftSite;r.rightSite=i.item.RightSite,this.InsertAndLegalizeTriangle(e,o.item),this.front.deleteNodeInternal(o);let a=this.front.remove(n);return s}MiddleCase(e,i,r){let n=i.item.LeftSite;return r.rightSite=i.item.RightSite,this.InsertAndLegalizeTriangle(e,i.item),this.front.deleteNodeInternal(i),n}TriangulateEmptySpaceToTheLeft(e){let i=e.item.RightSite,r=this.front.previous(e);for(;r!=null;){let n=r.item,o=n.LeftSite,s=n.RightSite;if(s.point.sub(i.point).dot(o.point.sub(s.point))<0)e=this.ShortcutTwoFrontElements(r,e),r=this.front.previous(e);else{this.TryTriangulateBasinToTheLeft(e);break}}}ShortcutTwoListElements(e){var s;let i=e.Next,r=lt.mkSSSEE(e.Start,e.End,i.End,e.Edge,i.Edge,this.createEdgeDelegate);this.triangles.add(r);let n=r.Edges.getItem(2);this.LegalizeEdge(e.Start,r.OppositeEdge(e.Start)),r=(s=n.CcwTriangle)!=null?s:n.CwTriangle,this.LegalizeEdge(i.End,r.OppositeEdge(i.End));let o=new hs(n);return o.Start=e.Start,o.End=i.End,e.Prev.Next=o,o.Prev=e.Prev,o.Next=i.Next,i.Next.Prev=o,o}ShortcutTwoFrontElements(e,i){var a;let r=e.item,n=i.item,o=lt.mkSSSEED(r.LeftSite,r.RightSite,n.RightSite,r.Edge,n.Edge,this.createEdgeDelegate);this.triangles.add(o),this.front.deleteNodeInternal(e),this.front.remove(n);let s=o.Edges.getItem(2);return this.LegalizeEdge(r.LeftSite,o.OppositeEdge(r.LeftSite)),o=(a=s.CcwTriangle)!=null?a:s.CwTriangle,this.LegalizeEdge(n.RightSite,o.OppositeEdge(n.RightSite)),this.front.insert(new yr(r.LeftSite,s))}TryTriangulateBasinToTheLeft(e){if(!qe.DropsSharpEnoughToTheLeft(e.item))return;let i=new Vl.Stack;for(i.push(e.item.LeftSite);;){let r=i.pop();e=qe.FindNodeInFrontBySite(this.front,r);let n=this.front.previous(e);if(n==null)return;if(c.getTriangleOrientation(n.item.LeftSite.point,e.item.LeftSite.point,e.item.RightSite.point)==1)i.push(n.item.LeftSite),this.ShortcutTwoFrontElements(n,e);else if(e.item.LeftSite.point.y>e.item.RightSite.point.y)i.push(n.item.LeftSite);else{if(n.item.LeftSite.point.y<=n.item.RightSite.point.y)return;i.push(n.item.LeftSite)}}}static DropsSharpEnoughToTheLeft(e){let i=e.Edge;if(e.RightSite!==i.upperSite)return!1;let r=i.lowerSite.point.sub(i.upperSite.point);return r.x>=.5*r.y}InsertSiteIntoFront(e,i,r){let n=null,o=null;for(let s of i.Edges)if(o==null&&s.lowerSite===e&&(o=s),n==null&&s.lowerSite===r&&(n=s),o!=null&&n!=null)break;return this.front.insert(new yr(e,o)),this.front.insert(new yr(i,n))}TriangulateEmptySpaceToTheRight(e){let r=e.item.LeftSite.point,n=this.front.next(e);for(;n!=null;){let o=n.item,s=o.LeftSite,a=o.RightSite;if(s.point.sub(r).dot(a.point.sub(s.point))<0)e=this.ShortcutTwoFrontElements(e,n),n=this.front.next(e);else{this.TryTriangulateBasinToTheRight(e);break}}}TryTriangulateBasinToTheRight(e){if(!qe.DropsSharpEnoughToTheRight(e.item))return;let i=new Vl.Stack;for(i.push(e.item.LeftSite);;){let r=i.pop();e=qe.FindNodeInFrontBySite(this.front,r);let n=this.front.next(e);if(n==null)return;if(c.getTriangleOrientation(e.item.LeftSite.point,e.item.RightSite.point,n.item.RightSite.point)==1)this.ShortcutTwoFrontElements(e,n),i.push(r);else if(e.item.LeftSite.point.y>e.item.RightSite.point.y)i.push(e.item.RightSite);else{if(n.item.LeftSite.point.y>=n.item.RightSite.point.y)return;i.push(e.item.RightSite)}}}static DropsSharpEnoughToTheRight(e){let i=e.Edge;if(e.LeftSite!==i.upperSite)return!1;let r=i.lowerSite.point.sub(i.upperSite.point);return r.x<=-.5*r.y}static FindNodeInFrontBySite(e,i){return e.findLast(r=>r.LeftSite.point.x<=i.point.x)}InsertAndLegalizeTriangle(e,i){var r;if(c.getTriangleOrientation(e.point,i.LeftSite.point,i.RightSite.point)!==2){let n=lt.mkSED(e,i.Edge,this.createEdgeDelegate);this.triangles.add(n),this.LegalizeEdge(e,n.Edges.getItem(0))}else{let n=i.Edge;Ml(n.upperSite.Edges,n);let o=(r=n.CcwTriangle)!=null?r:n.CwTriangle,s=o.OppositeSite(n);qe.RemoveTriangleButLeaveEdges(this.triangles,o),o=lt.mkSSSD(i.LeftSite,s,e,this.createEdgeDelegate);let a=lt.mkSSSD(i.RightSite,s,e,this.createEdgeDelegate);this.triangles.add(o),this.triangles.add(a),this.LegalizeEdge(e,o.OppositeEdge(e)),this.LegalizeEdge(e,a.OppositeEdge(e))}}LegalizeEdge(e,i){i.constrained||i.CcwTriangle==null||i.CwTriangle==null||(i.CcwTriangle.Contains(e)?this.LegalizeEdgeForOtherCwTriangle(e,i):this.LegalizeEdgeForOtherCcwTriangle(e,i))}LegalizeEdgeForOtherCwTriangle(e,i){let r=i.CwTriangle.Edges.index(i);if(uh(e,i.upperSite,i.CwTriangle.Sites.getItem(r+2),i.lowerSite)){let n=hh(e,i);this.LegalizeEdge(e,n.CwTriangle.OppositeEdge(e)),this.LegalizeEdge(e,n.CcwTriangle.OppositeEdge(e))}}LegalizeEdgeForOtherCcwTriangle(e,i){let r=i.CcwTriangle.Edges.index(i);if(uh(e,i.lowerSite,i.CcwTriangle.Sites.getItem(r+2),i.upperSite)){let n=hh(e,i);this.LegalizeEdge(e,n.CwTriangle.OppositeEdge(e)),this.LegalizeEdge(e,n.CcwTriangle.OppositeEdge(e))}}ProjectToFront(e){return this.front.findLast(i=>i.x<=e.point.x)}runEdgeInserter(){this.initEdgeInserter(),this.TraceEdgeThroughTriangles(),this.TriangulatePolygon0(this.rightPolygon,this.traversingEdge.upperSite,this.traversingEdge.lowerSite,!0),this.TriangulatePolygon0(this.leftPolygon,this.traversingEdge.upperSite,this.traversingEdge.lowerSite,!1),this.UpdateFront()}initEdgeInserter(){this.rightPolygon=new Array,this.leftPolygon=new Array,this.addedTriangles=new Array,this.piercedEdge=null,this.piercedTriangle=null,this.piercedToTheLeftFrontElemNode=null,this.piercedToTheRightFrontElemNode=null}UpdateFront(){let e=new Set;for(let i of this.addedTriangles)for(let r of i.Edges)if(r.CwTriangle==null||r.CcwTriangle==null){if(r.lowerSite==this.p_2&&r.upperSite==this.p_1)continue;e.add(r)}for(let i of e)this.AddEdgeToFront(i)}AddEdgeToFront(e){let i=e.upperSite.point.x<e.lowerSite.point.x?e.upperSite:e.lowerSite;this.front.insert(new yr(i,e))}TriangulatePolygon0(e,i,r,n){e.length>0&&this.TriangulatePolygon1(0,e.length-1,e,i,r,n)}TriangulatePolygon1(e,i,r,n,o,s){let a=r[e],u=e;for(let g=e+1;g<=i;g++){let f=r[g];d(f)&&(u=g,a=f)}let h=lt.mkSSSD(n,o,a,this.createEdgeDelegate);this.triangles.add(h),this.addedTriangles.push(h),e<u&&this.TriangulatePolygon1(e,u-1,r,n,a,s),u<i&&this.TriangulatePolygon1(u+1,i,r,a,o,s);function d(g){return s?Dl(g,n,a,o):Dl(g,n,o,a)}}TraceEdgeThroughTriangles(){this.initEdgeTracer(),this.Traverse()}Traverse(){for(;!this.BIsReached();)this.piercedToTheLeftFrontElemNode!=null?this.ProcessLeftFrontPiercedElement():this.piercedToTheRightFrontElemNode!=null?this.ProcessRightFrontPiercedElement():this.ProcessPiercedEdge();this.piercedTriangle!=null&&this.removePiercedTriangle(this.piercedTriangle),this.FindMoreRemovedFromFrontElements();for(let e of this.elementsToBeRemovedFromFront)this.front.remove(e)}ProcessLeftFrontPiercedElement(){let e=this.piercedToTheLeftFrontElemNode;do this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToLeftPolygon(e.item.LeftSite),e=this.front.previous(e);while(c.pointToTheLeftOfLine(e.item.LeftSite.point,this.a.point,this.b.point));if(this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToRightPolygon(e.item.LeftSite),e.item.LeftSite===this.b){this.piercedToTheLeftFrontElemNode=e;return}this.FindPiercedTriangle(e),this.piercedToTheLeftFrontElemNode=null}FindPiercedTriangle(e){var o;let i=e.item.Edge,r=(o=i.CcwTriangle)!=null?o:i.CwTriangle,n=r.Edges.index(i);for(let s=1;s<=2;s++){let a=r.Edges.getItem(s+n),u=ti.sign(c.signedDoubledTriangleArea(a.lowerSite.point,this.a.point,this.b.point));if(ti.sign(c.signedDoubledTriangleArea(a.upperSite.point,this.a.point,this.b.point))*u<=0){this.piercedTriangle=r,this.piercedEdge=a;break}}}FindMoreRemovedFromFrontElements(){for(let e of this.removedTriangles)for(let i of e.Edges)if(i.CcwTriangle==null&&i.CwTriangle==null){let r=i.upperSite.point.x<i.lowerSite.point.x?i.upperSite:i.lowerSite,n=qe.FindNodeInFrontBySite(this.front,r);n.item.Edge===i&&this.elementsToBeRemovedFromFront.push(n.item)}}ProcessPiercedEdge(){this.piercedEdge.CcwTriangle===this.piercedTriangle?(this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite),this.AddSiteToRightPolygon(this.piercedEdge.upperSite)):(this.AddSiteToLeftPolygon(this.piercedEdge.upperSite),this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)),this.removePiercedTriangle(this.piercedTriangle),this.PrepareNextStateAfterPiercedEdge()}PrepareNextStateAfterPiercedEdge(){var r,n;let e=(r=this.piercedEdge.CwTriangle)!=null?r:this.piercedEdge.CcwTriangle,i=e.Edges.index(this.piercedEdge);for(let o=1;o<=2;o++){let s=e.Edges.getItem(o+i),a=ti.sign(c.signedDoubledTriangleArea(s.lowerSite.point,this.a.point,this.b.point));if(ti.sign(c.signedDoubledTriangleArea(s.upperSite.point,this.a.point,this.b.point))*a<=0){if(s.CwTriangle!=null&&s.CcwTriangle!=null){this.piercedTriangle=e,this.piercedEdge=s;break}this.piercedTriangle=null,this.piercedEdge=null;let h=s.upperSite.point.x<s.lowerSite.point.x?s.upperSite:s.lowerSite,d=qe.FindNodeInFrontBySite(this.front,h);h.point.x<this.a.point.x?this.piercedToTheLeftFrontElemNode=d:this.piercedToTheRightFrontElemNode=d,this.removePiercedTriangle((n=s.CwTriangle)!=null?n:s.CcwTriangle);break}}}removePiercedTriangle(e){this.triangles.delete(e);for(let i of e.Edges)i.CwTriangle===e?i.CwTriangle=null:i.CcwTriangle=null,this.removedTriangles.push(e)}ProcessRightFrontPiercedElement(){let e=this.piercedToTheRightFrontElemNode;do this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToRightPolygon(e.item.RightSite),e=this.front.next(e);while(c.pointToTheRightOfLine(e.item.RightSite.point,this.a.point,this.b.point));if(this.elementsToBeRemovedFromFront.push(e.item),this.AddSiteToLeftPolygon(e.item.RightSite),e.item.RightSite===this.b){this.piercedToTheRightFrontElemNode=e;return}this.FindPiercedTriangle(e),this.piercedToTheRightFrontElemNode=null}AddSiteToLeftPolygon(e){this.AddSiteToPolygonWithCheck(e,this.leftPolygon)}AddSiteToPolygonWithCheck(e,i){e!==this.b&&(i.length===0||i[i.length-1]!==e)&&i.push(e)}AddSiteToRightPolygon(e){this.AddSiteToPolygonWithCheck(e,this.rightPolygon)}BIsReached(){var i;let e=(i=this.piercedToTheLeftFrontElemNode)!=null?i:this.piercedToTheRightFrontElemNode;return e!=null?e.item.Edge.IsAdjacent(this.b):this.piercedEdge.IsAdjacent(this.b)}initEdgeTracer(){this.elementsToBeRemovedFromFront=[],this.a=this.traversingEdge.upperSite,this.b=this.traversingEdge.lowerSite,this.removedTriangles=[];let e=qe.FindNodeInFrontBySite(this.front,this.a),i=this.front.previous(e);if(c.pointToTheLeftOfLine(this.b.point,i.item.LeftSite.point,i.item.RightSite.point))this.piercedToTheLeftFrontElemNode=i;else if(c.pointToTheRightOfLine(this.b.point,e.item.RightSite.point,e.item.LeftSite.point))this.piercedToTheRightFrontElemNode=e;else for(let r of this.a.Edges){let n=r.CcwTriangle;if(n==null||c.pointToTheLeftOfLine(this.b.point,r.lowerSite.point,r.upperSite.point))continue;let o=n.Edges.index(r),s=n.Sites.getItem(o+2);if(c.pointToTheLeftOfLineOrOnLine(this.b.point,s.point,r.upperSite.point)){this.piercedEdge=n.Edges.getItem(o+1),this.piercedTriangle=n;break}}}};function Ml(l,t){if(l.length===0)return;let e=l.findIndex(i=>t===i);e>=0&&(e!==l.length-1&&(l[e]=l[l.length-1]),l.pop())}function uh(l,t,e,i){return zc(l,t,e,i)&&Dl(l,t,e,i)}function zc(l,t,e,i){return c.getTriangleOrientation(t.point,l.point,e.point)===0&&c.getTriangleOrientation(e.point,l.point,i.point)===0}function Dl(l,t,e,i){let r=t.point.x-l.point.x,n=t.point.y-l.point.y,o=e.point.x-l.point.x,s=e.point.y-l.point.y,a=i.point.x-l.point.x,u=i.point.y-l.point.y,h=r*r+n*n,d=o*o+s*s,g=a*a+u*u;return r*(s*g-u*d)-o*(n*g-u*h)+a*(n*d-s*h)>m.tolerance}function hh(l,t){let e,i;t.CcwTriangle.Contains(l)?(e=t.CcwTriangle,i=t.CwTriangle):(e=t.CwTriangle,i=t.CcwTriangle);let r=e.Edges.index(t),n=i.Edges.index(t),o=i.Sites.getItem(n+2),s=e.Edges.getItem(r+1),a=i.Edges.getItem(n+1),u=ne.GetOrCreateEdge(l,o);return e.Sites.setItem(r+1,o),e.Edges.setItem(r,a),e.Edges.setItem(r+1,u),i.Sites.setItem(n+1,l),i.Edges.setItem(n,s),i.Edges.setItem(n+1,u),a.lowerSite===o?a.CcwTriangle=e:a.CwTriangle=e,s.lowerSite===l?s.CcwTriangle=i:s.CwTriangle=i,u.upperSite===l?(u.CcwTriangle=i,u.CwTriangle=e):(u.CcwTriangle=e,u.CwTriangle=i),Ml(t.upperSite.Edges,t),u}var ne=class extends H{constructor(e,i,r){super(null);this.isolatedSites=[];this.obstacles=[];this.PointsToSites=new ve;this.simplifyObstacles=!0;this.rectangleNodeOnTriangles=null;this.isolatedSites=e,this.obstacles=i,this.isolatedSegments=r}static constructor_(e){let i=new ne(null,null,null);return i.isolatedSitesWithObject=e,i}FillAllInputSites(){if(this.isolatedSitesWithObject!=null)for(let e of this.isolatedSitesWithObject)this.AddSite(e[0],e[1]);if(this.isolatedSites!=null)for(let e of this.isolatedSites)this.AddSite(e,null);if(this.obstacles!=null)for(let e of this.obstacles)this.AddPolylineToAllInputSites(e);if(this.isolatedSegments!=null)for(let e of this.isolatedSegments)this.AddConstrainedEdge(e.A,e.B,null);this.AddP1AndP2(),this.allInputSites=Array.from(this.PointsToSites.values())}AddSite(e,i){let r;return(r=this.PointsToSites.get(e))?r.Owner=i:(r=hn.mkSO(e,i),this.PointsToSites.set(e,r)),r}AddP1AndP2(){let e=I.mkEmpty();for(let n of this.PointsToSites.keys())e.add(n);let i=10,r=10;this.P1=new hn(e.leftBottom.add(new c(-i,-r))),this.P2=new hn(e.rightBottom.add(new c(i,-r)))}AddPolylineToAllInputSites(e){if(this.simplifyObstacles)for(let i=e.startPoint;i!=null;){let r=i.point;if(i=i.next,!i)break;for(;i.next&&c.getTriangleOrientation(r,i.point,i.next.point)===2;)i=i.next;this.AddConstrainedEdge(r,i.point,e)}else for(let i=e.startPoint;i.next!=null;i=i.next)this.AddConstrainedEdge(i.point,i.next.point,e);e.closed&&this.AddConstrainedEdge(e.endPoint.point,e.startPoint.point,e)}AddConstrainedEdge(e,i,r){let n=ne.AbovePP(e,i),o,s;n>0?(o=this.AddSite(e,r),s=this.AddSite(i,r)):(o=this.AddSite(i,r),s=this.AddSite(e,r));let a=ne.CreateEdgeOnOrderedCouple(o,s);a.constrained=!0}static GetOrCreateEdge(e,i){if(ne.AboveCC(e,i)===1){let r=e.EdgeBetweenUpperSiteAndLowerSite(i);return r!=null?r:ne.CreateEdgeOnOrderedCouple(e,i)}else{let r=i.EdgeBetweenUpperSiteAndLowerSite(e);return r!=null?r:ne.CreateEdgeOnOrderedCouple(i,e)}}static CreateEdgeOnOrderedCouple(e,i){return new xa(e,i)}GetTriangles(){return this.sweeper.triangles}run(){this.Initialization(),this.SweepAndFinalize()}SweepAndFinalize(){this.sweeper=new qe(this.allInputSites,this.P1,this.P2,ne.GetOrCreateEdge),this.sweeper.run(),this.cleanRemovedEdges()}cleanRemovedEdges(){for(let e of this.PointsToSites.values())e.cleanRemovedEdges()}Initialization(){this.FillAllInputSites(),this.allInputSites.sort(ne.OnComparison)}static OnComparison(e,i){return ne.AboveCC(e,i)}static AbovePP(e,i){let r=e.y-i.y;return r>0?1:r<0?-1:(r=e.x-i.x,r>0?-1:r<0?1:0)}static AboveCC(e,i){return ne.AbovePP(e.point,i.point)}RestoreEdgeCapacities(){for(let e of this.allInputSites)for(let i of e.Edges)i.constrained||(i.ResidualCapacity=i.Capacity)}SetInEdges(){for(let e of this.PointsToSites.values())for(let i of e.Edges)i.lowerSite.AddInEdge(i)}FindSite(e){return this.PointsToSites.get(e)}static PointIsInsideOfTriangle(e,i){for(let r=0;r<3;r++){let n=i.Sites.getItem(r).point,o=i.Sites.getItem(r+1).point;if(c.signedDoubledTriangleArea(e,n,o)<m.distanceEpsilon*-1)return!1}return!0}getRectangleNodeOnTriangles(){return this.rectangleNodeOnTriangles==null&&(this.rectangleNodeOnTriangles=ge(Array.from(this.GetTriangles().values()).map(e=>Se(e,e.BoundingBox())))),this.rectangleNodeOnTriangles}};function Ta(l){let t=Array.from(l.GetAllLeaves()),e=l.irect,i=e.diagonal/4,r=e.clone();return r.pad(i),qc(t.concat([r.perimeter()]))}function qc(l){let t=new ne(null,l,null);return t.run(),t}var cn=class{constructor(t,e){this.start=t,this.end=e}add(t){this.add_d(t)}add_rect(t){let e=t,i=this.clone();return i.add_d(e.start),i.add_d(e.end),i}clone(){return new cn(this.start,this.end)}contains_point(t){return this.contains_d(t)}contains_rect(t){let e=t;return this.contains_d(e.start)&&this.contains_d(e.end)}intersection_rect(t){let e=t;return new cn(Math.max(this.start,e.start),Math.min(this.end,e.end))}intersects_rect(t){let e=t;return this.intersects(e)}contains_point_radius(t,e){return this.contains_d(t-e)&&this.contains_d(t+e)}static mkInterval(t,e){let i=new cn(t.start,t.end);return i.add_d(e.start),i.add_d(e.end),i}add_d(t){this.start>t&&(this.start=t),this.end<t&&(this.end=t)}get Start(){return this.start}set Start(t){this.start=t}get Length(){return this.end-this.start}contains_d(t){return this.start<=t&&t<=this.end}GetInRange(t){return t<this.start?this.start:t>this.end?this.end:t}intersects(t){return t.start>this.end+m.distanceEpsilon?!1:!(t.end<this.start-m.distanceEpsilon)}};var Io=class{constructor(t){this.heapSize=0;this._priors=new Array(t),this._heap=new Array(t+1),this._reverse_heap=new Array(t)}get Count(){return this.heapSize}SwapWithParent(t){let e=this._heap[t>>1];this.PutAtI(t>>1,this._heap[t]),this.PutAtI(t,e)}Enqueue(t,e){this.heapSize++;let i=this.heapSize;for(this._priors[t]=e,this.PutAtI(i,t);i>1&&this._priors[this._heap[i>>1]]>e;)this.SwapWithParent(i),i>>=1}PutAtI(t,e){this._heap[t]=e,this._reverse_heap[e]=t}Dequeue(){if(this.heapSize===0)throw new Error;let t=this._heap[1];if(this.heapSize>1){this.PutAtI(1,this._heap[this.heapSize]);let e=1;for(;;){let i=e,r=e<<1;r<=this.heapSize&&this._priors[this._heap[r]]<this._priors[this._heap[e]]&&(i=r);let n=r+1;if(n<=this.heapSize&&this._priors[this._heap[n]]<this._priors[this._heap[i]]&&(i=n),i!==e)this.SwapWithParent(i);else break;e=i}}return this.heapSize--,t}IsEmpty(){return this.heapSize===0}DecreasePriority(t,e){this._priors[t]=e;let i=this._reverse_heap[t];for(;i>1&&this._priors[this._heap[i]]<this._priors[this._heap[i>>1]];){this.SwapWithParent(i);i>>=1}}};var Aa=class{constructor(t,e,i,r){this._numberOfOverlaps=0;this._proximityEdges=t,this._nodeSizes=e,this._nodePositions=i,this._forLayers=r,this._q=new Io(e.length*2)}Run(){return this.InitQueue(),this.FindOverlaps(),this._numberOfOverlaps}FindOverlaps(){for(;this._q.Count>0;){let t=this._q.Dequeue();t<this._nodePositions.length?(this.FindOverlapsWithInterval(t),this.AddIntervalToTree(t)):(t-=this._nodePositions.length,this.RemoveIntervalFromTree(t))}}RemoveIntervalFromTree(t){this._intervalTree.Remove(this.GetInterval(t),t)}AddIntervalToTree(t){let e=this.GetInterval(t);this._intervalTree==null&&(this._intervalTree=yi([])),this._intervalTree.Add(e,t)}FindOverlapsWithInterval(t){if(this._intervalTree==null)return;let e=this.GetInterval(t);for(let i of this._intervalTree.GetAllIntersecting(e)){let r=xt.GetIdealEdge(t,i,this._nodePositions[t],this._nodePositions[i],this._nodeSizes);if(r.overlapFactor<=1)return;this._proximityEdges.push(r),this._numberOfOverlaps++}}GetInterval(t){let e=this._nodeSizes[t].width/2,i=this._nodePositions[t].x;return new cn(i-e,i+e)}InitQueue(){for(let t=0;t<this._nodeSizes.length;t++){let e=this._nodeSizes[t].height/2,i=this._nodePositions[t].y;this._q.Enqueue(t,i-e),this._q.Enqueue(this._nodeSizes.length+t,i+e)}}};var cs=class{constructor(t,e,i){this.treeNodes=new Set;this.hedgehog=new Map;this.graph=t,this.weight=e,this.root=i,this.q=new Io(this.graph.nodeCount)}NodeIsInTree(t){return this.treeNodes.has(t)}GetTreeEdges(){let t=new Array;for(this.Init();t.length<this.graph.nodeCount-1&&this.q.Count>0;)this.AddEdgeToTree(t);return t}AddEdgeToTree(t){let e=this.q.Dequeue(),i=this.hedgehog.get(e);this.treeNodes.add(e),t.push(i),this.UpdateOutEdgesOfV(e),this.UpdateInEdgesOfV(e)}UpdateOutEdgesOfV(t){for(let e of this.graph.outEdges[t]){let i=e.target;if(this.NodeIsInTree(i))continue;let r=this.hedgehog.get(i);if(r){let n=this.weight(r),o=this.weight(e);o<n&&(this.q.DecreasePriority(i,o),this.hedgehog.set(i,e))}else this.q.Enqueue(i,this.weight(e)),this.hedgehog.set(i,e)}}UpdateInEdgesOfV(t){for(let e of this.graph.inEdges[t]){let i=e.source;if(this.NodeIsInTree(i))continue;let r=this.hedgehog.get(i);if(r){let n=this.weight(r),o=this.weight(e);o<n&&(this.q.DecreasePriority(i,o),this.hedgehog.set(i,e))}else this.q.Enqueue(i,this.weight(e)),this.hedgehog.set(i,e)}}Init(){this.treeNodes.add(this.root);for(let t of this.graph.outEdges[this.root]){let e=this.weight(t);this.q.Enqueue(t.target,e),this.hedgehog.set(t.target,t)}for(let t of this.graph.inEdges[this.root]){let e=this.weight(t);this.q.Enqueue(t.source,e),this.hedgehog.set(t.source,t)}}};var vo=class{static GetMst(t,e){if(t.length===0)return null;let i=t.map(a=>new F(a.source,a.target)),r=i.reduce((a,u)=>Math.max(a,Math.max(u.x,u.y)),0),n=new ct(r+1);for(let a=0;a<t.length;a++)n.setPair(i[a],t[a]);let o=rt(i,e);return new cs(o,a=>n.get(a.source,a.target).weight,i[0].source).GetTreeEdges().map(a=>n.get(a.source,a.target))}static GetMstOnCdt(t,e){let i=Array.from(t.PointsToSites.values()),r=new Map;for(let a=0;a<i.length;a++)r.set(i[a],a);let n=vo.GetEdges(i,r),o=zs(Array.from(n.keys()));return new cs(o,a=>e(n.get(a.source,a.target)),0).GetTreeEdges().map(a=>n.get(a.source,a.target))}static GetEdges(t,e){let i=new ct(t.length);for(let r=0;r<t.length;r++){let n=t[r],o=e.get(n);for(let s of n.Edges)i.set(o,e.get(s.lowerSite),s)}return i}};var xo=class{constructor(){this.epsilon=.01;this.iterationsMax=1e3;this.stopOnMaxIterat=!1;this.nodeSeparation=4;this.randomizationSeed=1;this.randomizationShift=.1}get StopOnMaxIterat(){return this.stopOnMaxIterat}set StopOnMaxIterat(t){this.stopOnMaxIterat=t}get Epsilon(){return this.epsilon}set Epsilon(t){this.epsilon=t}get IterationsMax(){return this.iterationsMax}set IterationsMax(t){this.iterationsMax=t}get NodeSeparation(){return this.nodeSeparation}set NodeSeparation(t){this.nodeSeparation=t}get RandomizationSeed(){return this.randomizationSeed}set RandomizationSeed(t){this.randomizationSeed=t}get RandomizationShift(){return this.randomizationShift}set RandomizationShift(t){this.randomizationShift=t}Clone(){let t=new xo;return t.Epsilon=this.Epsilon,t.IterationsMax=this.IterationsMax,t.StopOnMaxIterat=this.StopOnMaxIterat,t.NodeSeparation=this.NodeSeparation,t.RandomizationSeed=this.RandomizationSeed,t.RandomizationShift=this.randomizationShift,t}};var xt=class{constructor(t,e){this._settings=t,this._nodes=e}static RemoveOverlaps(t,e){let i=new xo;i.RandomizationShift=1,i.NodeSeparation=e,new xt(i,t).RemoveOverlaps()}RemoveOverlaps(){if(this._nodes.length<3){this.RemoveOverlapsOnTinyGraph();return}let t={nodePositions:new Array,nodeSizes:new Array};for(jc(this._settings,this._nodes,t,this._settings.RandomizationShift),this.lastRunNumberIterations=0;this.OneIteration(t.nodePositions,t.nodeSizes,!1);)this.lastRunNumberIterations++;for(;this.OneIteration(t.nodePositions,t.nodeSizes,!0);)this.lastRunNumberIterations++;for(let e=0;e<this._nodes.length;e++)this._nodes[e].center=t.nodePositions[e]}RemoveOverlapsOnTinyGraph(){if(this._nodes.length!==1&&this._nodes.length===2){let t=this._nodes[0],e=this._nodes[1];c.closeDistEps(t.center,e.center)&&(e.center=e.center.add(new c(.001,0)));let i=this.GetIdealDistanceBetweenTwoNodes(t,e),r=c.middle(t.center,e.center),n=t.center.sub(e.center),o=n.length;n=n.mul(.5*(i/o)),t.center=r.add(n),e.center=r.sub(n)}}GetIdealDistanceBetweenTwoNodes(t,e){let i=t.center.sub(e.center),r=Math.abs(i.x),n=Math.abs(i.y),o=(t.width+e.width)/2+this._settings.NodeSeparation,s=(t.height+e.height)/2+this._settings.NodeSeparation,a=Number.POSITIVE_INFINITY,u=Number.POSITIVE_INFINITY;return r>m.tolerance&&(a=o/r),n>m.tolerance&&(u=s/n),Math.min(a,u)*i.length}static AvgEdgeLength(t){let e=0,i=0;for(let r of t)for(let n of r.outEdges())i+=r.center.sub(n.target.center).length,e++;return e>0?i/e:1}OneIteration(t,e,i){let r=new Array;for(let h=0;h<t.length;h++)r.push([t[h],h]);let n=ne.constructor_(r);n.run();let o=new Map;for(let h=0;h<t.length;h++)o.set(n.PointsToSites.get(t[h]),h);let s=0,a=new Array;for(let h of n.PointsToSites.values())for(let d of h.Edges){let g=d.upperSite.point,f=d.lowerSite.point,P=o.get(d.upperSite),y=o.get(d.lowerSite),w=xt.GetIdealEdge(P,y,g,f,e);a.push(w),w.overlapFactor>1&&s++}if(s===0||i){let h=this.FindProximityEdgesWithSweepLine(a,e,t);if(s===0&&h===0||s===0&&!i)return!1}let u=vo.GetMst(a,t.length);return xt.MoveNodePositions(u,t,u[0].source),!0}FindProximityEdgesWithSweepLine(t,e,i){return new Aa(t,e,i,this._overlapForLayers).Run()}static GetIdealEdge(t,e,i,r,n){let o={overlapFactor:0},s=xt.GetIdealEdgeLength(t,e,i,r,n,o),a=i.sub(r).length,u=I.mkSizeCenter(n[t],i),h=I.mkSizeCenter(n[e],r),d=o.overlapFactor>1?a-s:xt.GetDistanceRects(u,h);return{source:Math.min(t,e),target:Math.max(t,e),overlapFactor:o.overlapFactor,idealDistance:s,weight:d}}static GetIdealEdgeLength(t,e,i,r,n,o){let s=i.sub(r),a=s.length,u=Math.abs(s.x),h=Math.abs(s.y),d=(n[t].width+n[e].width)/2,g=(n[t].height+n[e].height)/2;if(u>=d||h>=g)return o.overlapFactor=1,s.length;let f,P=1e-10;if(u>P)h>P?f=Math.min(d/u,g/h):f=d/u;else if(h>P)f=g/h;else return o.overlapFactor=2,Math.sqrt(d*d+g*g)/4;return f=Math.max(f,1.001),o.overlapFactor=f,f*a}static GetDistanceRects(t,e){if(t.intersects(e))return 0;let i=0,r=0;return(t.right<e.left||e.right<t.left)&&(r=t.left-e.right),t.top<e.bottom?i=e.bottom-t.top:e.top<t.bottom&&(i=t.bottom-e.top),Math.sqrt(r*r+i*i)}static MoveNodePositions(t,e,i){let r=e.map(o=>o.clone()),n=new Set;n.add(i);for(let o=0;o<t.length;o++){let s=t[o];n.has(s.source)?xt.MoveNode(s.source,s.target,r,e,n,s.idealDistance):xt.MoveNode(s.target,s.source,r,e,n,s.idealDistance)}}static MoveNode(t,e,i,r,n,o){let s=i[e].sub(i[t]);s=s.mul(o/s.length+.01),r[e]=r[t].add(s),n.add(e)}GetLastRunIterations(){return this.lastRunNumberIterations}};function jc(l,t,e,i){e.nodePositions=t.map(r=>r.center),i&&Uc(e.nodePositions,new jr(0,0),i),e.nodeSizes=t.map(r=>{let n=r.boundingBox.size;return n.width+=l.NodeSeparation,n.height+=l.NodeSeparation,n})}function Uc(l,t,e){let i=new ie;for(let r=0;r<l.length;r++){let n=l[r];if(e||i.has(n))do{let o=n.x+(2*t.random()-1)*e,s=n.y+(2*t.random()-1)*e;n=new c(o,s)}while(i.has(n));l[r]=n,i.add(n)}}var Cr=class extends H{constructor(e,i,r,n){super(r);this.settings=e,this.graph=i,this.length=n}run(){this.LayoutConnectedGraphWithMds(),this.graph.pumpTheBoxToTheGraphWithMargins()}static ScaleToAverageEdgeLength(e,i,r,n){let o=new Map,s=0;for(let h of e.shallowNodes)o.set(h,s),s++;let a=0,u=0;for(let h of e.shallowEdges){let d=o.get(h.source),g=o.get(h.target);u+=Math.sqrt(Math.pow(i[d]-i[g],2)+Math.pow(r[d]-r[g],2)),a+=n(h)}if(a>0&&(u/=a),u>0)for(let h=0;h<i.length;h++)i[h]/=u,r[h]/=u}static LayoutGraphWithMds(e,i,r,n){if(r.x=new Array(e.shallowNodeCount),r.y=new Array(e.shallowNodeCount),r.x.length===0)return;if(r.x.length===1){r.x[0]=r.y[0]=0;return}let o=Math.min(i.PivotNumber,e.shallowNodeCount),s=i.GetNumberOfIterationsWithMajorization(e.shallowNodeCount),a=i.Exponent,u=new Array(o),h=new Ia(e,u,n);h.run();let d=h.Result;if(me.LandmarkClassicalScaling(d,r,u),Cr.ScaleToAverageEdgeLength(e,r.x,r.y,n),s>0){let g=new Eo(e,n);g.run();let f=g.Result,P=me.ExponentialWeightMatrix(f,a);me.DistanceScalingSubset(f,r.x,r.y,P,s)}}LayoutConnectedGraphWithMds(){let e={x:[],y:[]};Cr.LayoutGraphWithMds(this.graph,this.settings,e,this.length),this.settings.RotationAngle!==0&&va.Rotate(e.x,e.y,this.settings.RotationAngle);let i=0;for(let r of this.graph.shallowNodes)r.boundingBox&&(r.center=new c(e.x[i]*this.settings.ScaleX,e.y[i]*this.settings.ScaleY)),i++;this.settings.removeOverlaps&&xt.RemoveOverlaps(Array.from(this.graph.shallowNodes),this.settings.NodeSeparation),this.graph.pumpTheBoxToTheGraphWithMargins()}ScaleNodes(e,i){for(let r of e)r.center=r.center.mul(i)}static PackGraphs(e,i){if(e.length===0)return I.mkEmpty();if(e.length===1)return e[0].boundingBox;let r=e.map(s=>s.boundingBox),n=new Array;for(let s of e)n.push({g:s,lb:s.boundingBox.leftBottom.clone()});let o=new Dr(r,i.PackingAspectRatio);o.run();for(let{g:s,lb:a}of n){let u=s.boundingBox.leftBottom.sub(a);s.translate(u)}return new I({left:0,bottom:0,right:o.PackedWidth,top:o.PackedHeight})}};var Dt=class{constructor(){this.commonSettings=new Oi;this.pivotNumber=50;this.iterationsWithMajorization=30;this.scaleX=100;this.scaleY=100;this.exponent=-2;this.rotationAngle=0;this._removeOverlaps=!0;this._callIterationsWithMajorizationThreshold=2e3;this.adjustScale=!1}static fromJSON(t){let e=new Dt;return t.pivotNumber&&(e.pivotNumber=t.pivotNumber),t.iterationsWithMajorization&&(e.iterationsWithMajorization=t.iterationsWithMajorization),t.scaleX&&(e.scaleX=t.scaleX),t.scaleY&&(e.scaleY=t.scaleY),t.exponent&&(e.exponent=t.exponent),t.rotationAngle&&(e.rotationAngle=t.rotationAngle),t.removeOverlaps!=null&&(e._removeOverlaps=t.removeOverlaps),t._callIterationsWithMajorizationThreshold&&(e._callIterationsWithMajorizationThreshold=t._callIterationsWithMajorizationThreshold),e}toJSON(){let t={};return this.pivotNumber!=50&&(t.pivotNumber=this.pivotNumber),this.iterationsWithMajorization!=30&&(t.iterationsWithMajorization=this.iterationsWithMajorization),this.scaleX!=200&&(t.scaleX=this.scaleX),this.scaleY!=200&&(t.scaleY=this.scaleY),this.exponent!=-2&&(t.exponent=this.exponent),this.rotationAngle!=0&&(t.rotationAngle=this.rotationAngle),this._removeOverlaps||(t.removeOverlaps=this._removeOverlaps),this._callIterationsWithMajorizationThreshold!=3e3&&(t._callIterationsWithMajorizationThreshold=this._callIterationsWithMajorizationThreshold),t}get NodeSeparation(){return this.commonSettings.NodeSeparation}set NodeSeparation(t){this.commonSettings.NodeSeparation=t}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}get removeOverlaps(){return this._removeOverlaps}set removeOverlaps(t){this._removeOverlaps=t}get PivotNumber(){return this.pivotNumber}set PivotNumber(t){this.pivotNumber=t}get IterationsWithMajorization(){return this.iterationsWithMajorization}set IterationsWithMajorization(t){this.iterationsWithMajorization=t}get ScaleX(){return this.scaleX}set ScaleX(t){this.scaleX=t}get ScaleY(){return this.scaleY}set ScaleY(t){this.scaleY=t}get Exponent(){return this.exponent}set Exponent(t){this.exponent=t}get RotationAngle(){return this.rotationAngle}set RotationAngle(t){this.rotationAngle=t%360}get AdjustScale(){return this.adjustScale}set AdjustScale(t){this.adjustScale=t}GetNumberOfIterationsWithMajorization(t){return t>this.CallIterationsWithMajorizationThreshold?0:this.IterationsWithMajorization}get CallIterationsWithMajorizationThreshold(){return this._callIterationsWithMajorizationThreshold}set CallIterationsWithMajorizationThreshold(t){this._callIterationsWithMajorizationThreshold=t}};function ch(l,t=null){let e=l.layoutSettings instanceof Dt?l.layoutSettings:new Dt;ds(l,e),gn(l,t,Qc,dn,to)}var Er=class extends H{constructor(e,i,r,n){super(i);this.graph=e,this.length=r,this.settings=n,this.settings.ScaleX=this.settings.ScaleY=200}get scaleX(){return this.settings.ScaleX}set scaleX(e){this.settings.ScaleX=e}get scaleY(){return this.settings.ScaleY}set scaleY(e){this.settings.ScaleY=e}run(){new Cr(this.settings,this.graph,this.cancelToken,this.length).run()}};function Qc(l,t){new Er(l,t,()=>1,l.layoutSettings).run()}function wa(l,t,e){if(t)for(let i of t){if(e&&e.canceled)return;ft.RouteEdge(i,l.padding)}else for(let i of l.nodesBreadthFirst){if(e&&e.canceled)return;for(let r of i.outEdges())r.curve==null&&ft.RouteEdge(r,l.padding);for(let r of i.selfEdges())r.curve==null&&ft.RouteEdge(r,l.padding)}}var ft=class extends H{constructor(e,i){super(null);this.edges=e,this.padding=i}run(){$.CreatePortsIfNeeded(this.edges);for(let e of this.edges)ft.RouteEdge(e,this.padding)}static RouteEdge(e,i){let r=e;r.sourcePort==null&&(r.sourcePort=$e.mk(()=>e.source.boundaryCurve,()=>e.source.center)),r.targetPort==null&&(r.targetPort=$e.mk(()=>e.target.boundaryCurve,()=>e.target.center)),ft.ContainmentLoop(r,i)||(r.curve=ft.GetEdgeLine(e)),we.trimSplineAndCalculateArrowheadsII(r,r.sourcePort.Curve,r.targetPort.Curve,e.curve,!1)}static ContainmentLoop(e,i){let r=e.sourcePort.Curve,n=e.targetPort.Curve;if(r==null||n==null)return!1;let o=r.boundingBox,s=n.boundingBox,a=o.containsRect(s),u=!a&&s.containsRect(o);return a||u?(e.curve=ft.CreateLoop(o,s,u,i),!0):!1}static CreateLoop(e,i,r,n){return r?ft.CreateLoop_(e,i,n,!1):ft.CreateLoop_(i,e,n,!0)}static CreateLoop_(e,i,r,n){let o=e.center,s=ft.FindClosestPointOnBoxBoundary(e.center,i),a=s.sub(o),h=(Math.abs(a.x)<m.distanceEpsilon?Math.min(o.y-i.bottom,i.top-o.y):Math.min(o.x-i.left,i.right-o.x))/2,d=Math.min(r,h);a.length<=m.distanceEpsilon&&(a=new c(1,0));let g=a.normalize(),f=g.rotate(Math.PI/2),P=s.add(g.mul(r)),y=P.add(f.mul(d)),w=s.add(f.mul(d)),x=o.add(f.mul(d));return(n?oe.mkFromPoints([x,w,y,P,s,o]):oe.mkFromPoints([o,s,P,y,w,x])).createCurve()}static FindClosestPointOnBoxBoundary(e,i){let r=e.x-i.left<i.right-e.x?i.left:i.right,n=e.y-i.bottom<i.top-e.y?i.bottom:i.top;return Math.abs(r-e.x)<Math.abs(n-e.y)?new c(r,e.y):new c(e.x,n)}static GetEdgeLine(e){let i,r;e.sourcePort==null?(i=e.source.center,r=e.source.boundaryCurve):(i=e.sourcePort.Location,r=e.sourcePort.Curve);let n,o;e.targetPort==null?(n=e.target.center,o=e.target.boundaryCurve):(n=e.targetPort.Location,o=e.targetPort.Curve);let s=S.mkPP(i,n),a=p.getAllIntersections(r,s,!1);if(a.length>0){let u=s.trim(a[0].par1,1);u instanceof S&&(s=u,a=p.getAllIntersections(o,s,!1),a.length>0&&(u=s.trim(0,a[0].par1),u instanceof S&&(s=u)))}return s}static CreateSimpleEdgeCurveWithUnderlyingPolyline(e){let i=e.sourcePort?e.sourcePort.Location:e.source.center,r=e.targetPort?e.targetPort.Location:e.target.center;if(e.source===e.target){let n=2/(3*e.source.boundaryCurve.boundingBox.width),o=e.source.boundingBox.height/4;e.smoothedPolyline=ft.CreateUnderlyingPolylineForSelfEdge(i,n,o),e.curve=e.smoothedPolyline.createCurve()}else e.smoothedPolyline=oe.mkFromPoints([i,r]),e.curve=e.smoothedPolyline.createCurve();we.trimSplineAndCalculateArrowheadsII(e,e.source.boundaryCurve,e.target.boundaryCurve,e.curve,!1)}static CreateUnderlyingPolylineForSelfEdge(e,i,r){let n=e.add(new c(0,r)),o=e.add(new c(i,r)),s=e.add(new c(i,r*-1)),a=e.add(new c(0,r*-1)),u=_.mkSiteP(e),h=new oe(u);return u=_.mkSiteSP(u,n),u=_.mkSiteSP(u,o),u=_.mkSiteSP(u,s),u=_.mkSiteSP(u,a),_.mkSiteSP(u,e),h}static SetStraightLineEdgesWithUnderlyingPolylines(e){$.CreatePortsIfNeeded(Array.from(e.deepEdges));for(let i of e.deepEdges)ft.CreateSimpleEdgeCurveWithUnderlyingPolyline(i)}};var dh,Fl=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});function r(n,o,s){if(n.length===0)return-1;let a=0,u=n.length-1;for(;a<=u;){let h=a+(u-a>>1),d=n[h];switch(Math.sign(s.compare(d,o))){case-1:a=h+1;break;case 0:return h;case 1:u=h-1;break}}return~a}e.binarySearch=r}(l,l.exports,null),l.exports}(),kl=class{constructor(...t){this._values=[];let e,i;if(t.length>0){let r=t[0];r===void 0||r!=null&&Symbol.iterator in Object(r)?(e=r,t.length>1&&(i=t[1])):i=r}if(i??(i=ui.defaultComparer),this._comparer=typeof i=="function"?ui.create(i):i,e)for(let r of e)this.add(r)}get comparer(){return this._comparer}get size(){return this._values.length}has(t){return(0,Fl.binarySearch)(this._values,t,this._comparer)>=0}add(t){let e=(0,Fl.binarySearch)(this._values,t,this._comparer);return e>=0?this._values[e]=t:this._values.splice(~e,0,t),this}delete(t){let e=(0,Fl.binarySearch)(this._values,t,this._comparer);return e>=0?(this._values.splice(e,1),!0):!1}clear(){this._values.length=0}keys(){return this._values.values()}values(){return this._values.values()}*entries(){for(let t=0;t<this._values.length;t++)yield[this._values[t],this._values[t]]}[Symbol.iterator](){return this.values()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let i of this)t.call(e,i,i,this)}get[Ve.size](){return this.size}[Ve.has](t){return this.has(t)}[Ve.add](t){this.add(t)}[Ve.delete](t){return this.delete(t)}[Ve.clear](){this.clear()}};dh=kl;Object.defineProperty(dh.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"SortedSet"});var gh,Ft=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});let r=2**31-1,n=2146435069,o=101,s=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function a(b){if(b&1){let T=Math.sqrt(b)|0;for(let L=3;L<=T;L+=2)if(!(b%L))return!1;return!0}return b===2}function u(b){if(b<0)throw new RangeError;for(let T=0;T<s.length;T++){let L=s[T];if(L>=b)return L}for(let T=b|1;T<r;T+=2)if(a(T)&&(T-1)%o)return T;return b}function h(b){let T=2*b;return T>n&&n>b?n:u(T)}function d(){return{prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0}}function g(b,T){let L=d(),V={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:b,head:L,tail:L};return f(V,T),V}e.createHashData=g;function f(b,T){let L=u(T);return b.freeList=-1,b.buckets=new Int32Array(L),b.entries=new Array(L),L}function P(b,T){let L=b.size,V=new Int32Array(T),B=b.entries?b.entries.slice():[];B.length=T;for(let D=0;D<L;D++){let Z=B[D];if(Z&&Z.hashCode>=0){let ue=Z.hashCode%T;Z.next=V[ue]-1,V[ue]=D+1}}b.buckets=V,b.entries=B}function y(b,T){let L=-1;if(b.buckets&&b.entries){let V=b.equaler.hash(T)&r;L=b.buckets[V%b.buckets.length]-1;let B=b.entries.length;for(;L>>>0<B;){let D=b.entries[L];if(D.hashCode===V&&b.equaler.equals(D.key,T))break;L=D.next}}return L}e.findEntryIndex=y;function w(b,T){let L=y(b,T);return L>=0?b.entries[L].value:void 0}e.findEntryValue=w;function x(b,T,L){if(b.buckets||f(b,0),!b.buckets||!b.entries)throw new Error;let V=b.equaler.hash(T)&r,B=V%b.buckets.length,D=b.buckets[B]-1;for(;D>>>0<b.entries.length;){let Rr=b.entries[D];if(Rr.hashCode===V&&b.equaler.equals(Rr.key,T)){Rr.value=L;return}D=Rr.next}let Z=!1,ue;if(b.freeSize>0)ue=b.freeList,Z=!0,b.freeSize--;else{let Rr=b.size;if(Rr===b.entries.length){if(P(b,h(b.size)),!b.buckets||!b.entries)throw new Error;B=V%b.buckets.length}ue=Rr,b.size=Rr+1}let Lt=b.entries[ue]||(b.entries[ue]=d());Z&&(b.freeList=Lt.next),Lt.hashCode=V,Lt.next=b.buckets[B]-1,Lt.key=T,Lt.value=L,Lt.skipNextEntry=!1;let Pi=b.tail;Pi.nextEntry=Lt,Lt.prevEntry=Pi,b.tail=Lt,b.buckets[B]=ue+1}e.insertEntry=x;function G(b,T){if(b.buckets&&b.entries){let L=b.equaler.hash(T)&r,V=L%b.buckets.length,B=-1,D;for(let Z=b.buckets[V]-1;Z>=0;Z=D.next){if(D=b.entries[Z],D.hashCode===L&&b.equaler.equals(D.key,T)){B<0?b.buckets[V]=D.next+1:b.entries[B].next=D.next;let ue=D.prevEntry;return ue.nextEntry=D.nextEntry,ue.nextEntry&&(ue.nextEntry.prevEntry=ue),b.tail===D&&(b.tail=ue),D.hashCode=-1,D.next=b.freeList,D.key=void 0,D.value=void 0,D.prevEntry=void 0,D.nextEntry=ue,D.skipNextEntry=!0,b.freeList=Z,b.freeSize++,!0}B=Z}}return!1}e.deleteEntry=G;function A(b){if(b.size>0){b.buckets&&b.buckets.fill(0),b.entries&&b.entries.fill(void 0);let L=b.head.nextEntry;for(;L;){let V=L.nextEntry;L.prevEntry=void 0,L.nextEntry=b.head,L.skipNextEntry=!0,L=V}b.head.nextEntry=void 0,b.tail=b.head,b.size=0,b.freeList=-1,b.freeSize=0}}e.clearEntries=A;function M(b,T){if(T<0)throw new RangeError;let L=b.entries?b.entries.length:0;if(L>=T)return L;if(!b.buckets)return f(b,T);let V=u(T);return P(b,u(T)),V}e.ensureCapacity=M;function Y(b,T=b.size-b.freeSize){if(T<b.size)throw new RangeError;if(!b.buckets||!b.entries)return;let L=u(T),V=b.entries;if(L>=(V?V.length:0))return;let B=b.size;if(f(b,L),!b.buckets||!b.entries)throw new Error;let D=0;for(let Z=0;Z<B;Z++){let ue=V[Z].hashCode;if(ue>=0){let Lt=ue%L;b.entries[D]=V[Z],b.entries[D].next=b.buckets[Lt]-1,b.buckets[Lt]=D+1,D++}}b.size=D,b.freeSize=0}e.trimExcessEntries=Y;function K(b){return b.key}e.selectEntryKey=K;function Me(b){return b.value}e.selectEntryValue=Me;function nr(b){return[b.key,b.value]}e.selectEntryEntry=nr;function*Lr(b,T){let L=b;for(;L;){let V=L.skipNextEntry;L=L.nextEntry,!V&&L&&(yield T(L))}}e.iterateEntries=Lr;function E(b,T,L,V){let B=T;for(;B;){let D=B.skipNextEntry;B=B.nextEntry,!D&&B&&L.call(V,B.value,B.key,b)}}e.forEachEntry=E}(l,l.exports,null),l.exports}(),gs=class{constructor(...t){let e,i,r;if(t.length>0){let n=t[0];if(typeof n=="number"){if(!(Object.is(n,n|0)&&n>=0))throw new RangeError("Argument out of range: capacity");e=n,t.length>1&&(r=t[1])}else n===void 0||n!=null&&Symbol.iterator in Object(n)?(i=n,t.length>1&&(r=t[1])):r=n}if(e??(e=0),r??(r=dt.defaultEqualer),this._hashData=(0,Ft.createHashData)(r,e),i)for(let[n,o]of i)this.set(n,o)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return(0,Ft.findEntryIndex)(this._hashData,t)>=0}get(t){return(0,Ft.findEntryValue)(this._hashData,t)}set(t,e){return(0,Ft.insertEntry)(this._hashData,t,e),this}delete(t){return(0,Ft.deleteEntry)(this._hashData,t)}clear(){(0,Ft.clearEntries)(this._hashData)}ensureCapacity(t){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity");return(0,Ft.ensureCapacity)(this._hashData,t)}trimExcess(t){if(t!==void 0){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity")}(0,Ft.trimExcessEntries)(this._hashData,t)}keys(){return(0,Ft.iterateEntries)(this._hashData.head,Ft.selectEntryKey)}values(){return(0,Ft.iterateEntries)(this._hashData.head,Ft.selectEntryValue)}entries(){return(0,Ft.iterateEntries)(this._hashData.head,Ft.selectEntryEntry)}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");(0,Ft.forEachEntry)(this,this._hashData.head,t,e)}get[Ut.size](){return this.size}[Ut.has](t){return this.has(t)}[Ut.get](t){return this.get(t)}[Ut.keys](){return this.keys()}[Ut.values](){return this.values()}[Mt.set](t,e){this.set(t,e)}[Mt.delete](t){return this.delete(t)}[Mt.clear](){this.clear()}};gh=gs;Object.defineProperty(gh.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashMap"});var mh,kt=function(){var l={exports:{}};return function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});let r=2**31-1,n=2146435069,o=101,s=[3,7,11,17,23,29,37,47,59,71,89,107,131,163,197,239,293,353,431,521,631,761,919,1103,1327,1597,1931,2333,2801,3371,4049,4861,5839,7013,8419,10103,12143,14591,17519,21023,25229,30293,36353,43627,52361,62851,75431,90523,108631,130363,156437,187751,225307,270371,324449,389357,467237,560689,672827,807403,968897,1162687,1395263,1674319,2009191,2411033,2893249,3471899,4166287,4999559,5999471,7199369];function a(E){if(E&1){let b=Math.sqrt(E)|0;for(let T=3;T<=b;T+=2)if(!(E%T))return!1;return!0}return E===2}function u(E){if(E<0)throw new RangeError;for(let b=0;b<s.length;b++){let T=s[b];if(T>=E)return T}for(let b=E|1;b<r;b+=2)if(a(b)&&(b-1)%o)return b;return E}function h(E){let b=2*E;return b>n&&n>E?n:u(b)}function d(){return{prevEntry:void 0,nextEntry:void 0,skipNextEntry:!1,next:0,hashCode:0,key:void 0,value:void 0}}function g(E,b){let T=d(),L={buckets:void 0,entries:void 0,freeSize:0,freeList:0,size:0,equaler:E,head:T,tail:T};return f(L,b),L}e.createHashData=g;function f(E,b){let T=u(b);return E.freeList=-1,E.buckets=new Int32Array(T),E.entries=new Array(T),T}function P(E,b){let T=E.size,L=new Int32Array(b),V=E.entries?E.entries.slice():[];V.length=b;for(let B=0;B<T;B++){let D=V[B];if(D&&D.hashCode>=0){let Z=D.hashCode%b;D.next=L[Z]-1,L[Z]=B+1}}E.buckets=L,E.entries=V}function y(E,b){let T=-1;if(E.buckets&&E.entries){let L=E.equaler.hash(b)&r;T=E.buckets[L%E.buckets.length]-1;let V=E.entries.length;for(;T>>>0<V;){let B=E.entries[T];if(B.hashCode===L&&E.equaler.equals(B.key,b))break;T=B.next}}return T}e.findEntryIndex=y;function w(E,b,T){if(E.buckets||f(E,0),!E.buckets||!E.entries)throw new Error;let L=E.equaler.hash(b)&r,V=L%E.buckets.length,B=E.buckets[V]-1;for(;B>>>0<E.entries.length;){let Pi=E.entries[B];if(Pi.hashCode===L&&E.equaler.equals(Pi.key,b)){Pi.value=T;return}B=Pi.next}let D=!1,Z;if(E.freeSize>0)Z=E.freeList,D=!0,E.freeSize--;else{let Pi=E.size;if(Pi===E.entries.length){if(P(E,h(E.size)),!E.buckets||!E.entries)throw new Error;V=L%E.buckets.length}Z=Pi,E.size=Pi+1}let ue=E.entries[Z]||(E.entries[Z]=d());D&&(E.freeList=ue.next),ue.hashCode=L,ue.next=E.buckets[V]-1,ue.key=b,ue.value=T,ue.skipNextEntry=!1;let Lt=E.tail;Lt.nextEntry=ue,ue.prevEntry=Lt,E.tail=ue,E.buckets[V]=Z+1}e.insertEntry=w;function x(E,b){if(E.buckets&&E.entries){let T=E.equaler.hash(b)&r,L=T%E.buckets.length,V=-1,B;for(let D=E.buckets[L]-1;D>=0;D=B.next){if(B=E.entries[D],B.hashCode===T&&E.equaler.equals(B.key,b)){V<0?E.buckets[L]=B.next+1:E.entries[V].next=B.next;let Z=B.prevEntry;return Z.nextEntry=B.nextEntry,Z.nextEntry&&(Z.nextEntry.prevEntry=Z),E.tail===B&&(E.tail=Z),B.hashCode=-1,B.next=E.freeList,B.key=void 0,B.value=void 0,B.prevEntry=void 0,B.nextEntry=Z,B.skipNextEntry=!0,E.freeList=D,E.freeSize++,!0}V=D}}return!1}e.deleteEntry=x;function G(E){if(E.size>0){E.buckets&&E.buckets.fill(0),E.entries&&E.entries.fill(void 0);let T=E.head.nextEntry;for(;T;){let L=T.nextEntry;T.prevEntry=void 0,T.nextEntry=E.head,T.skipNextEntry=!0,T=L}E.head.nextEntry=void 0,E.tail=E.head,E.size=0,E.freeList=-1,E.freeSize=0}}e.clearEntries=G;function A(E,b){if(b<0)throw new RangeError;let T=E.entries?E.entries.length:0;if(T>=b)return T;if(!E.buckets)return f(E,b);let L=u(b);return P(E,u(b)),L}e.ensureCapacity=A;function M(E,b=E.size-E.freeSize){if(b<E.size)throw new RangeError;if(!E.buckets||!E.entries)return;let T=u(b),L=E.entries;if(T>=(L?L.length:0))return;let V=E.size;if(f(E,T),!E.buckets||!E.entries)throw new Error;let B=0;for(let D=0;D<V;D++){let Z=L[D].hashCode;if(Z>=0){let ue=Z%T;E.entries[B]=L[D],E.entries[B].next=E.buckets[ue]-1,E.buckets[ue]=B+1,B++}}E.size=B,E.freeSize=0}e.trimExcessEntries=M;function Y(E){return E.key}e.selectEntryKey=Y;function K(E){return E.value}e.selectEntryValue=K;function Me(E){return[E.key,E.value]}e.selectEntryEntry=Me;function*nr(E,b){let T=E;for(;T;){let L=T.skipNextEntry;T=T.nextEntry,!L&&T&&(yield b(T))}}e.iterateEntries=nr;function Lr(E,b,T,L){let V=b;for(;V;){let B=V.skipNextEntry;V=V.nextEntry,!B&&V&&T.call(L,V.value,V.key,E)}}e.forEachEntry=Lr}(l,l.exports,null),l.exports}(),Ir=class{constructor(...t){let e,i,r;if(t.length>0){let n=t[0];if(typeof n=="number"){if(!(Object.is(n,n|0)&&n>=0))throw new RangeError("Argument out of range: capacity");e=n,t.length>1&&(r=t[1])}else n===void 0||n!=null&&Symbol.iterator in Object(n)?(i=n,t.length>1&&(r=t[1])):r=n}if(e??(e=0),r??(r=dt.defaultEqualer),this._hashData=(0,kt.createHashData)(r,e),i)for(let n of i)this.add(n)}get equaler(){return this._hashData.equaler}get size(){return this._hashData.size-this._hashData.freeSize}has(t){return(0,kt.findEntryIndex)(this._hashData,t)>=0}add(t){return(0,kt.insertEntry)(this._hashData,t,t),this}tryAdd(t){let e=this.size;return(0,kt.insertEntry)(this._hashData,t,t),this.size>e}delete(t){return(0,kt.deleteEntry)(this._hashData,t)}clear(){(0,kt.clearEntries)(this._hashData)}ensureCapacity(t){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity");return(0,kt.ensureCapacity)(this._hashData,t)}trimExcess(t){if(t!==void 0){if(typeof t!="number")throw new TypeError("Number expected: capacity");if(!(Object.is(t,t|0)&&t>=0))throw new RangeError("Argument out of range: capacity")}(0,kt.trimExcessEntries)(this._hashData,t)}keys(){return(0,kt.iterateEntries)(this._hashData.head,kt.selectEntryKey)}values(){return(0,kt.iterateEntries)(this._hashData.head,kt.selectEntryValue)}entries(){return(0,kt.iterateEntries)(this._hashData.head,kt.selectEntryEntry)}[Symbol.iterator](){return this.values()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");(0,kt.forEachEntry)(this,this._hashData.head,t,e)}get[Ve.size](){return this.size}[Ve.has](t){return this.has(t)}[Ve.add](t){this.add(t)}[Ve.delete](t){return this.delete(t)}[Ve.clear](){this.clear()}};mh=Ir;Object.defineProperty(mh.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"HashSet"});var ph,Hl=class{constructor(...t){var e,i;this._size=0;let r,n,o;Yc(t)?[r,o={}]=t:(r=0,Jc(t)?[n,o={}]=t:o={});let s=(e=o?.keyEqualer)!==null&&e!==void 0?e:dt.defaultEqualer,a=(i=o?.valueEqualer)!==null&&i!==void 0?i:dt.defaultEqualer;if(this._map=new gs(r,s),this._keyEqualer=s,this._valueEqualer=a,n)for(let[u,h]of n)this.add(u,h)}get keyEqualer(){return this._keyEqualer}get valueEqualer(){return this._valueEqualer}get size(){return this._size}has(t){return this._map.has(t)}hasValue(t,e){let i=this._map.get(t);return i?i.has(e):!1}get(t){return this._map.get(t)}add(t,e){let i=this._map.get(t);i||(i=new Ir(this._valueEqualer),this._map.set(t,i));let r=i.size;return i.add(e),this._size+=i.size-r,this}delete(t){let e=this._map.get(t);return e?(this._size-=e.size,this._map.delete(t),e.size):0}deleteValue(t,e){let i=this._map.get(t);if(i){let r=i.size;if(i.delete(e))return this._size+=i.size-r,i.size<=0&&this._map.delete(t),!0}return!1}clear(){this._map.clear(),this._size=0}ensureCapacity(t){return this._map.ensureCapacity(t)}trimExcess(t){this._map.trimExcess(t)}keys(){return this._map.keys()}*values(){for(let t of this._map.values())yield*t}*entries(){for(let[t,e]of this._map)for(let i of e)yield[t,i]}[Symbol.iterator](){return this.entries()}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");for(let[i,r]of this._map)for(let n of r)t.call(e,n,i,this)}get[It.size](){return this.size}[It.has](t){return this.has(t)}[It.hasValue](t,e){return this.hasValue(t,e)}[It.get](t){return this.get(t)}[It.keys](){return this.keys()}[It.values](){return this.values()}[Mn.add](t,e){this.add(t,e)}[Mn.delete](t){return this.delete(t)}[Mn.deleteValue](t,e){return this.deleteValue(t,e)}[Mn.clear](){this.clear()}};ph=Hl;Object.defineProperty(ph.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"MultiMap"});function Jc(l){let[t,e]=l;return(t===void 0||t!=null&&Symbol.iterator in Object(t))&&(e===void 0||typeof e=="object"&&e!==null||typeof e=="function")}function Yc(l){let[t,e]=l;return typeof t=="number"&&(e===void 0||typeof e=="object"&&e!==null||typeof e=="function")}var fh,Ph,Wl,qn,mn,jn,pn,ut=class{constructor(t){this._list=void 0,this._previous=void 0,this._next=void 0,this.value=t}get list(){return this._list}get previous(){if(this._previous&&this._list&&this!==this._list.first)return this._previous}get next(){if(this._next&&this._list&&this._next!==this._list.first)return this._next}detachSelf(){return this._list?this._list.deleteNode(this):!1}};fh=ut;Wl=(l,t)=>{l._list=t},qn=l=>l._previous,mn=(l,t)=>{l._previous=t},jn=l=>l._next,pn=(l,t)=>{l._next=t},Object.defineProperty(fh.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedListNode"});var $i=class{constructor(...t){this._size=0,this._head=void 0;let e,i;if(t.length>0){let r=t[0];r===void 0||r!=null&&Symbol.iterator in Object(r)?(e=r,t.length>1&&(i=t[1])):i=r}if(i??(i=dt.defaultEqualer),this._equaler=typeof i=="function"?dt.create(i):i,e)for(let r of e)this.push(r)}get equaler(){return this._equaler}get first(){return this._head}get last(){if(this._head)return qn(this._head)}get size(){return this._size}[Symbol.iterator](){return this.values()}*values(){for(let t of this.nodes())yield t.value}*nodes(){let t,e=this.first;for(;e!==void 0;)t=e,e=t.next,yield t}*drain(){for(let t of this.nodes())this.deleteNode(t),yield t.value}nodeOf(t,e){if(e!=null&&!(e instanceof ut))throw new TypeError("LinkedListNode expected: fromNode");if(e!=null&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e??this.first;i;i=i.next)if(this._equaler.equals(i.value,t))return i}lastNodeOf(t,e){if(e!=null&&!(e instanceof ut))throw new TypeError("LinkedListNode expected: fromNode");if(e!=null&&e.list!==this)throw new TypeError("Wrong list.");for(let i=e??this.last;i;i=i.previous)if(this._equaler.equals(i.value,t))return i}find(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.first;for(;r!==void 0;){i=r,r=i.next;let n=i.value;if(t.call(e,n,i,this))return n}}findLast(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.last;for(;r!==void 0;){i=r,r=i.previous;let n=i.value;if(t.call(e,n,i,this))return n}}findNode(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.first;for(;r!==void 0;)if(i=r,r=i.next,t.call(e,i.value,i,this))return i}findLastNode(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.last;for(;r!==void 0;)if(i=r,r=i.previous,t.call(e,i.value,i,this))return i}has(t){return this.nodeOf(t)!==void 0}insertBefore(t,e){if(t!=null&&!(t instanceof ut))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return this._insertNode(t??void 0,new ut(e),0)}insertNodeBefore(t,e){if(t!=null&&!(t instanceof ut))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");if(!(e instanceof ut))throw new TypeError("LinkedListNode expected: newNode");if(e.list)throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,0)}insertAfter(t,e){if(t!=null&&!(t instanceof ut))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return this._insertNode(t||void 0,new ut(e),1)}insertNodeAfter(t,e){if(t!=null&&!(t instanceof ut))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");if(!(e instanceof ut))throw new TypeError("LinkedListNode expected: newNode");if(e.list)throw new Error("Node is already attached to a list.");this._insertNode(t||void 0,e,1)}push(t){return this._insertNode(void 0,new ut(t),1)}pushNode(t){if(!(t instanceof ut))throw new TypeError("LinkedListNode expected: newNode");if(t.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,1)}pop(){let t=this.popNode();return t?t.value:void 0}popNode(){let t=this.last;if(this.deleteNode(t))return t}shift(){let t=this.shiftNode();return t?t.value:void 0}shiftNode(){let t=this.first;if(this.deleteNode(t))return t}unshift(t){return this._insertNode(void 0,new ut(t),0)}unshiftNode(t){if(!(t instanceof ut))throw new TypeError("LinkedListNode expected: newNode");if(t.list)throw new Error("Node is already attached to a list.");this._insertNode(void 0,t,0)}delete(t){let e=this.nodeOf(t);if(e&&this.deleteNode(e))return e}deleteNode(t){if(t!=null&&!(t instanceof ut))throw new TypeError("LinkedListNode expected: node");if(t!=null&&t.list!==this)throw new TypeError("Wrong list.");return t==null||!t.list?!1:this._deleteNode(t)}deleteAll(t,e){if(typeof t!="function")throw new TypeError("Function expected: predicate");let i=0,r=this.first;for(;r;){let n=r.next;t.call(e,r.value,r,this)&&r.list===this&&(this._deleteNode(r),++i),r=n}return i}clear(){for(;this.size>0;)this.deleteNode(this.last)}forEach(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.first;for(;r!==void 0;)i=r,r=i.next,t.call(e,i.value,i,this)}map(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=new $i,r,n=this.first;for(;n!==void 0;){r=n,n=r.next;let o=t.call(e,r.value,r,this);i.push(o)}return i}filter(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=new $i(this.equaler),r,n=this.first;for(;n!==void 0;){r=n,n=r.next;let o=r.value;t.call(e,o,r,this)&&i.push(o)}return i}reduce(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=arguments.length>1,r=e,n,o=this.first;for(;o!==void 0;){n=o,o=n.next;let s=n.value;i?r=t(r,s,n,this):(r=s,i=!0)}return r}reduceRight(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=arguments.length>1,r=e,n,o=this.last;for(;o!==void 0;){n=o;let s=n.value;i?r=t(r,s,n,this):(r=s,i=!0),o=n.previous}return r}some(t,e){if(t!==void 0&&typeof t!="function")throw new TypeError("Function expected: callback");let i,r=this.first;for(;r!==void 0;)if(i=r,r=i.next,!t||t.call(e,i.value,i,this))return!0;return!1}every(t,e){if(typeof t!="function")throw new TypeError("Function expected: callback");let i=!1,r,n=this.first;for(;n!==void 0;){if(r=n,n=r.next,!t.call(e,r.value,r,this))return!1;i=!0}return i}_deleteNode(t){return jn(t)===t?this._head=void 0:(mn(jn(t),qn(t)),pn(qn(t),jn(t)),this._head===t&&(this._head=jn(t))),Wl(t,void 0),mn(t,void 0),pn(t,void 0),this._size--,!0}_insertNode(t,e,i){if(Wl(e,this),this._head===void 0)pn(e,e),mn(e,e),this._head=e;else switch(i){case 0:t===void 0?(t=this._head,this._head=e):t===this._head&&(this._head=e),pn(e,t),mn(e,qn(t)),pn(qn(t),e),mn(t,e);break;case 1:t===void 0&&(t=qn(this._head)),mn(e,t),pn(e,jn(t)),mn(jn(t),e),pn(t,e);break}return this._size++,e}get[Vt.size](){return this.size}[Vt.has](t){return this.has(t)}[Ve.add](t){this.push(t)}[Ve.delete](t){return!!this.delete(t)}[Ve.clear](){this.clear()}};Ph=$i;Object.defineProperty(Ph.prototype,Symbol.toStringTag,{configurable:!0,writable:!0,value:"LinkedList"});var bh=(r=>(r[r.OverlapsOtherLabels=0]="OverlapsOtherLabels",r[r.OverlapsNodes=1]="OverlapsNodes",r[r.OverlapsEdges=2]="OverlapsEdges",r[r.OverlapsNothing=Number.MAX_VALUE]="OverlapsNothing",r))(bh||{});var zl=class{},ql=class{constructor(){this.points=new $i;this.coveredLength=0}AddFirst(t){if(this.points.size!==0){let e=this.points.first.value;this.coveredLength=this.coveredLength+t.Center.sub(e.Center).length}return this.points.insertBefore(null,t),this.coveredLength}AddLast(t){if(this.points.size!==0){let e=this.points.last.value;this.coveredLength=this.coveredLength+t.Center.sub(e.Center).length}return this.points.insertAfter(null,t),this.coveredLength}};var Oa=class{constructor(t){this.location=t,this.boundingBox=I.rectangleOnPoint(t)}},Un=class{constructor(t,e){this.data=e,this.boundingBox=t}},jl=class{constructor(t){this.innerPoints=[];this.outerPoints=[];this.placementSide=0;this.placementOffset=.5;this.edgePoints=t,this.placementSide}},ae=class extends H{constructor(e,i){super(null);this.placementStrategy=[1,0];this.obstacleMaps=[];this.edgeInfos=new Map;this.granularity=ae.MinGranularity;this.ScaleCollisionGranularity=!0;this.granularity=this.ScaleCollisionGranularity?this.interpolateGranularity(i.length):ae.MinGranularity,this.InitializeObstacles(e,i),this.edges=i}get CollisionGranularity(){return this.granularity}set CollisionGranularity(e){this.granularity=e}static constructorG(e){return new ae(Array.from(e.nodesBreadthFirst),Array.from(e.deepEdges).filter(i=>i.label))}static constructorGA(e,i){return new ae(Array.from(e.nodesBreadthFirst),i.filter(r=>r.label))}interpolateGranularity(e){if(e<=ae.LowerEdgeBound)return ae.MaxGranularity;if(e>=ae.UpperEdgeBound)return ae.MinGranularity;let i=(ae.UpperEdgeBound-ae.LowerEdgeBound)/(e-ae.LowerEdgeBound);return Math.ceil(ae.MinGranularity+i)}InitializeObstacles(e,i){let r=this.GetEdgeObstacles(i);this.obstacleMaps[1]=yi(e.map(n=>[n.boundingBox,new Un(n.boundingBox,n)])),this.obstacleMaps[2]=yi(r.map(n=>[n.boundingBox,new Un(n.boundingBox,n)]))}static CurvePoints(e,i){let r=[],n=e.end.sub(e.start).lengthSquared/(i*i);return ae.SubdivideCurveSegment(r,e,n,e.parStart,e.parEnd),r.sort(ae.compareByArgument),r}static compareByArgument(e,i){return e[0]<i[0]?-1:e[0]>i[0]?1:0}static SubdivideCurveSegment(e,i,r,n,o){if(e.length>64)return;let s=i.value(n),a=i.value(o);if(s.sub(a).lengthSquared>r){let u=(n+o)/2;ae.SubdivideCurveSegment(e,i,r,n,u),ae.SubdivideCurveSegment(e,i,r,u,o)}else e.push([n,s])}static PlaceLabelsAtDefaultPositions(e,i){for(let r of i)r.label&&new ae([r.source,r.target],[r]).run()}GetEdgeObstacles(e){let i=[];for(let r of e){if(r.curve==null)continue;let n=ae.CurvePoints(r.curve,this.CollisionGranularity);this.edgeInfos.set(r,new jl(n));for(let o of n)i.push(new Oa(o[1]))}return i}AddLabelObstacle(e){this.labelObstacleMap==null?(this.labelObstacleMap=yi([[e.boundingBox,e]]),this.obstacleMaps[0]=this.labelObstacleMap):this.labelObstacleMap.Add(e.boundingBox,e)}run(){this.edges.sort((e,i)=>this.edgeInfos.get(e).edgePoints.length-this.edgeInfos.get(i).edgePoints.length);for(let e of this.edges)this.PlaceLabel(e)}PlaceLabel(e){let i=!1;for(let r of this.placementStrategy){switch(r){case 0:i=this.PlaceEdgeLabelOnCurve(e.label);break;case 1:i=this.PlaceEdgeLabelHorizontally(e);break;default:throw new Error("unexpected case")}if(i)break}i?this.CalculateCenterLabelInfoCenter(e.label):this.PlaceLabelAtFirstPosition(e.label)}getLabelInfo(e){let i=e.parent;return this.edgeInfos.get(i)}PlaceLabelAtFirstPosition(e){let i=e.parent,r=i.curve,n=this.edgeInfos.get(i).edgePoints,o=this.StartIndex(e,n.map(f=>f[1])),s=n[o][1],a=r.derivative(n[o][0]);a.length<m.distanceEpsilon&&(a=new c(1,1)),a=a.normalize();let u=new Ke(e.width,e.height),h=this.getLabelInfo(e),d=ae.GetPossibleSides(h.placementSide,a)[0],g=ae.GetLabelBounds(s,a,u,d);this.SetLabelBounds(this.getLabelInfo(e),g)}StartIndex(e,i){let r=this.getLabelInfo(e);return Math.min(i.length-1,Math.max(0,Math.floor(i.length*r.placementOffset)))}CalculateCenterLabelInfoCenter(e){let i=this.getLabelInfo(e),r=new c(0,0);for(let n of i.innerPoints)r=r.add(n);for(let n of i.outerPoints)r=r.add(n);e.positionCenter(r.div(i.innerPoints.length+i.outerPoints.length))}PlaceEdgeLabelHorizontally(e){let i=e.label,n=this.getLabelInfo(i).edgePoints,o=new Ke(i.width,i.height),s=-1,a=I.mkEmpty(),u=e.curve;for(let h of ae.ExpandingSearch(this.StartIndex(i,n.map(d=>d[1])),0,n.length)){let d=n[h],g=u.derivative(d[0]);if(!N(g.lengthSquared,0)){g=g.normalize();for(let f of ae.GetPossibleSides(this.getLabelInfo(i).placementSide,g)){let P=ae.GetLabelBounds(d[1],g,o,f),y=this.ConflictIndexRL(P,i);if(y>s&&(s=y,a=P,s===Number.MAX_VALUE))break}if(s===Number.MAX_VALUE)break}}if(s>=0){this.SetLabelBounds(this.getLabelInfo(i),a);let h=new Un(a,null);this.AddLabelObstacle(h);let d=this.getLabelInfo(i);return s===0?d.placementResult=0:s===1?d.placementResult=1:s===2?d.placementResult=2:d.placementResult=bh.OverlapsNothing,!0}return!1}static GetLabelBounds(e,i,r,n){let o=i.rotate(Math.PI/2).mul(n),s=e.add(o),a=1,u=o.x>0?s.x:s.x-r.width,h=o.y>0?s.y:s.y-r.height;if(Math.abs(o.x)<.75){let d=Math.acos(Math.abs(o.y)/a),g=a/Math.sin(d),f=a/Math.cos(d);u+=(o.x>0?-1:1)*Math.min(g,r.width/2),h+=(o.y>0?1:-1)*f}else if(Math.abs(o.y)<.75){let d=Math.acos(Math.abs(o.x)/a),g=a/Math.sin(d),f=a/Math.cos(d);u+=(o.x>0?1:-1)*f,h+=(o.y>0?-1:1)*Math.min(g,r.height/2)}return I.mkLeftBottomSize(u,h,r)}SetLabelBounds(e,i){e.innerPoints=[i.leftTop,i.rightTop],e.outerPoints=[i.leftBottom,i.rightBottom]}static GetPossibleSides(e,i){switch(i.length===0&&(e=0),e){case 1:return[-1];case 2:return[1];case 3:return N(i.x,0)?ae.GetPossibleSides(5,i):[1];case 4:return N(i.x,0)?ae.GetPossibleSides(6,i):[i.x<0?-1:1];case 5:return N(i.y,0)?ae.GetPossibleSides(3,i):[i.y<0?-1:1];case 6:return N(i.y,0)?ae.GetPossibleSides(4,i):[i.y<0?1:-1];default:return[-1,1]}}static*ExpandingSearch(e,i,r){let n=e+1,o=n;for(;o>i;)yield--o;for(;n<r;)yield n++}static PointSetLength(e){let i=0,r=null;for(let n of e)r!=null&&(i+=r.sub(n.Center).length),r=n.Center;return i}PlaceEdgeLabelOnCurve(e){let i=e.parent,r=this.getLabelInfo(e);r.innerPoints=null;let n=r.edgePoints,o=3,s=e.height/2,a=new Ke(s,s),u=e.width;for(let h of ae.ExpandingSearch(this.StartIndex(e,n),0,n.length)){let d=this.GetSidesAndEdgeCurve(e,i,n,h);for(let g of d){let f=new ql,P={coveredLength:0};if(this.ProcessExpandingSearchOnSide(h,n,i.curve,g,s,o,a,P,f,u),P.coveredLength>=u)return this.CaseOfCoveredLengthGreaterThanLabelLength(e,f,P.coveredLength,u,a),!0}}return!1}CaseOfCoveredLengthGreaterThanLabelLength(e,i,r,n,o){let s=new Array,a=new Array,u=Array.from(i.points),h=r-n;if(h>0){let g=u[u.length-1],f=u[u.length-2],P=g.Center.sub(f.Center),y=P.length;h>y&&(g=u[0],f=u[1],P=g.Center.sub(f.Center),y=P.length);let w=P.mul((y-h)/y);g.Center=f.Center.add(w),g.Inner=f.Inner.add(w),g.Outer=f.Outer.add(w)}this.GoOverOrderedPointsAndAddLabelObstacels(u,s,a,o);let d=this.getLabelInfo(e);d.innerPoints=s,d.outerPoints=a}GoOverOrderedPointsAndAddLabelObstacels(e,i,r,n){for(let o of e){let s=o.Center;i.push(o.Inner),r.push(o.Outer);let a=new Un(I.mkSizeCenter(new Ke(n.width*2,n.height*2),s),null);this.AddLabelObstacle(a)}}ProcessExpandingSearchOnSide(e,i,r,n,o,s,a,u,h,d){for(let g of ae.ExpandingSearch(e,0,i.length)){let[f,P]=i[g],y=r.derivative(f);if(N(y.lengthSquared,0))continue;let w=y.rotate(Math.PI/2).normalize().mul(n),x=P.add(w.mul(o+s));if(this.Conflict(x,o,a))break;{let G=new zl;if(G.Center=x,G.Inner=P.add(w.mul(s)),G.Outer=P.add(w.mul(2*o+s)),u.coveredLength=g<=e?h.AddFirst(G):h.AddLast(G),u.coveredLength>=d)break}}}GetSidesAndEdgeCurve(e,i,r,n){let o=i.curve.derivative(r[n][0]);return ae.GetPossibleSides(this.getLabelInfo(e).placementSide,o)}Conflict(e,i,r){return this.ConflictIndex(e,i,r)!==Number.MAX_VALUE}ConflictIndexRL(e,i){let r=i.parent,n=r.source,o=r.target;for(let s=0;s<this.obstacleMaps.length;s++)if(this.obstacleMaps[s]!=null){for(let a of this.obstacleMaps[s].GetAllIntersecting(e))if(!(s===1&&a instanceof Un&&a.data instanceof de&&(n.node.isDescendantOf(a.data.graph)||o.node.isDescendantOf(a.data))))return s}return Number.MAX_VALUE}ConflictIndex(e,i,r){let n=I.creatRectangleWithSize(new Ke(r.width*2,r.height*2),e),o=i*i;for(let s=0;s<this.obstacleMaps.length;s++)if(this.obstacleMaps[s]!=null){for(let a=0;a<this.obstacleMaps.length;a++)if(this.obstacleMaps[a]!=null)for(let u of this.obstacleMaps[a].GetAllIntersecting(n))if(u instanceof Oa){if(e.sub(u.location).lengthSquared<o)return a}else return a;return Number.MAX_VALUE}}},hi=ae;hi.MinGranularity=5,hi.MaxGranularity=50,hi.LowerEdgeBound=500,hi.UpperEdgeBound=3e3;var oi=class extends Gr{constructor(e,i=null){super(e,Le.AlgorithmDataIndex);this.data=i}clone(){throw new Error("Method not implemented.")}rebind(e){this.entity=e,this.bind(Le.AlgorithmDataIndex)}static getAlgData(e){return e.getAttr(Le.AlgorithmDataIndex)}};function ms(l){let t=oi.getAlgData(l.node);return t==null?null:t.data}var La=class{constructor(t,e){this.force=new c(0,0);this.stayWeight=1;this.index=t,this.geomNode=e,this.ResetBounds()}get Center(){return this.center}set Center(t){this.geomNode.center=t,this.center=t}ResetBounds(){this.previousCenter=this.geomNode.center,this.center=this.geomNode.center,this.Width=this.geomNode.width,this.Height=this.geomNode.height}ToString(){return"FINode("+(this.index+("):"+this.geomNode))}};var Ra=class{constructor(t){this._length=1;this.mEdge=t,this.sourceFiNode=ms(this.mEdge.source),this.targetFiNode=ms(this.mEdge.target)}get source(){return this.sourceFiNode.index}get target(){return this.targetFiNode.index}get length(){return this._length}set length(t){this._length=t}vector(){return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center)}};var Sh=J(Mi(),1);var ci=class{get Center(){return this.c}get Radius(){return this.r}Distance2(t){let e=this.c.y-t.y,i=this.c.x-t.x;return i*i+e*e}Contains(t){return this.Distance2(t)-1e-7<=this.r2}ContainsPN(t,e){for(let i=0;i<t.length;i++)if(e.findIndex(r=>r==i)==-1&&!this.Contains(t[i]))return!1;return!0}static constructorP(t){let e=new ci;return e.c=t,e.r=0,e.r2=0,e}static midPoint(t,e){return new c((e.x+t.x)/2,(e.y+t.y)/2)}static constructorPP(t,e){let i=new ci;return i.c=ci.midPoint(t,e),i.r2=i.Distance2(t),i.r=Math.sqrt(i.r2),X.assert(i.OnBoundary(t)),X.assert(i.OnBoundary(e)),i}OnBoundary(t){let e=this.Distance2(t);return Math.abs(e-this.r2)/(e+this.r2)<1e-5}static centre(t,e,i){X.assert(e.x!=t.x),X.assert(i.x!=e.x);let r=(e.y-t.y)/(e.x-t.x),n=(i.y-e.y)/(i.x-e.x);X.assert(n!=r);let o,s=(r*n*(t.y-i.y)+n*(t.x+e.x)-r*(e.x+i.x))/(2*(n-r));return Math.abs(r)>Math.abs(n)?o=(t.y+e.y)/2-(s-(t.x+e.x)/2)/r:o=(e.y+i.y)/2-(s-(e.x+i.x)/2)/n,new c(s,o)}static Collinear(t,e,i){return t.x*(e.y-i.y)+(e.x*(i.y-t.y)+i.x*(t.y-e.y))==0}static constructorPPP(t,e,i){ci.count++;let r=new ci;if(ci.Collinear(t,e,i)){let n=new c(Math.min(t.x,Math.min(e.x,i.x)),Math.min(t.y,Math.max(e.y,i.y))),o=new c(Math.max(t.x,Math.max(e.x,i.x)),Math.max(t.y,Math.max(e.y,i.y)));r.c=ci.midPoint(n,o),r.r2=r.Distance2(o),r.r=Math.sqrt(r.r2)}else{let n=e.x-t.x,o=i.x-e.x,s=i.x-t.x;n!=0?o!=0?r.c=ci.centre(t,e,i):(X.assert(s!=0),r.c=ci.centre(e,t,i)):(X.assert(o!=0),r.c=ci.centre(e,i,t)),r.r2=r.Distance2(t),r.r=Math.sqrt(r.r2),X.assert(r.OnBoundary(t)),X.assert(r.OnBoundary(e)),X.assert(r.OnBoundary(i))}return r}},Li=ci;Li.count=0;var Ul=class{constructor(t,e){switch(this.boundary=e,X.assert(e.length<=3),e.length){case 0:this.disc=null;break;case 1:this.disc=Li.constructorP(t[e[0]]);break;case 2:this.disc=Li.constructorPP(t[e[0]],t[e[1]]);break;case 3:this.disc=Li.constructorPPP(t[e[0]],t[e[1]],t[e[2]]);break}}contains(t){return this.disc==null?!1:this.disc.Contains(t)}},Ql=class{constructor(t){this.ps=t,this.L=new $i;for(let i=0;i<this.ps.length;i++)this.L.push(i);let e=this.mtf_md(null,new Array);this.disc=e.disc,this.boundary=e.boundary}collinear3(t){return t.length==3?Li.Collinear(this.ps[t[0]],this.ps[t[1]],this.ps[t[2]]):!1}mtf_md(t,e){X.assert(e.length<=3);let i=new Ul(this.ps,e);if(e.length==3)return i;let r=this.L.first;for(;r!=null&&r!=t;){let n=r.next,o=r.value;if(!i.contains(this.ps[o])){let s=Array.from(e);s.push(o),X.assert(!this.collinear3(s),"Collinear points on boundary of minimal enclosing disc"),i=this.mtf_md(r,s),this.L.deleteNode(r),this.L.insertNodeBefore(null,r)}r=n}return i}},Ga=class{static LinearComputation(t){return new Ql(t).disc}static SlowComputation(t){let e=t.length,i=null,r=null;for(let n=0;n<e;n++)for(let o=0;o<e;o++){if(n!=o){let s=Li.constructorPP(t[n],t[o]);s.ContainsPN(t,[n,o])&&(i==null||i.Radius>s.Radius)&&(i=s,r=[n,o])}for(let s=0;s<e;s++)if(s!=n&&s!=o&&!Li.Collinear(t[n],t[o],t[s])){let a=Li.constructorPPP(t[n],t[o],t[s]);a.ContainsPN(t,[n,o,s])&&(i==null||i.Radius>a.Radius)&&(i=a,r=[n,o,s])}}return X.assert(r!=null),i}};var Tt=class{static constructorNPA(t,e,i){let r=new Tt;r.p=t,r.z0=new xe(e.x,e.y),r.a=new Array(t);for(let n=0;n<t;n++)r.a[n]=r.compute(n,i);return r}static constructorPMM(t,e,i){let r=new Tt;X.assert(e.p==i.p),r.p=e.p,r.z0=new xe(t.x,t.y);let n=i.shift(r.z0),o=e.shift(r.z0);r.a=new Array(r.p);for(let s=0;s<r.p;s++)r.a[s]=Xl(o[s],n[s]);return r}static factorial(t){let e=1;for(let i=2;i<=t;i++)e*=i;return e}static binomial(t,e){return Tt.factorial(t)/(Tt.factorial(e)*Tt.factorial(t-e))}sum(t,e){let i=xe.constructorN(0);for(let r=1;r<=t;r++){let n=xe.constructorN(Tt.binomial(t-1,r-1));i=Xl(i,fn(this.a[r],fn(xe.Pow(e,t-r),n)))}return i}shift(t){let e=new Array(this.p),i=e[0]=this.a[0],r=ps(this.z0,t);for(let n=1;n<this.p;n++){let o=xe.constructorN(n);e[n]=Xl(fn(Kc(i),_l(xe.Pow(r,n),o)),this.sum(n,r))}return e}compute(t,e){let i=e.length,r=xe.constructorN(0);if(t==0)r.re=i;else{for(let n=0;n<i;n++){let o=e[n],s=new xe(o.x,o.y);r=ps(r,xe.Pow(ps(s,this.z0),t))}r.divideBy(t)}return r}ApproximateForce(t){let e=new xe(t.x,t.y),i=ps(e,this.z0),r=_l(this.a[0],i),n=i,o=0;for(;r=ps(r,_l(Zc(this.a[o],o),n)),o++,o!=this.p;)n=fn(n,i);return new c(r.re,-r.im)}static Force(t,e){let i=e.sub(t),r=i.lengthSquared;return r<.1?r!=0?i.div(.1):new c(1,0):i.div(r)}},xe=class{constructor(t,e){this.re=t,this.im=e}static constructorN(t){return new xe(t,0)}divideBy(t){this.re/=t,this.im/=t}static Pow(t,e){switch(X.assert(e>=0),e){case 0:return xe.constructorN(1);case 1:return t;case 2:return fn(t,t);case 3:return fn(t,fn(t,t));default:return fn(xe.Pow(t,e/2),xe.Pow(t,e/2+e%2))}}};function Xl(l,t){return new xe(l.re+t.re,l.im+t.im)}function fn(l,t){return new xe(l.re*t.re-l.im*t.im,l.re*t.im+t.re*l.im)}function Zc(l,t){return new xe(l.re*t,l.im*t)}function ps(l,t){return new xe(l.re-t.re,l.im-t.im)}function Kc(l){return new xe(-l.re,-l.im)}function _l(l,t){let e=t.re*t.re+t.im*t.im;if(e==0)return xe.constructorN(0);let i=l.re*t.re+l.im*t.im,r=l.im*t.re-l.re*t.im;return new xe(i/e,r/e)}var Na=class{intersects(t){return t.med.Center.sub(this.med.Center).length<t.med.Radius+this.med.Radius}},Jl=class extends Na{constructor(e,i,r){super();this.med=e,this.parent=i.parent,this.parent!=null&&(this.parent.leftChild==i?this.parent.leftChild=this:this.parent.rightChild=this),this.leftChild=i,this.rightChild=r,i.parent=this,r.parent=this}computeMultipoleCoefficients(e){this.leftChild.computeMultipoleCoefficients(e),this.rightChild.computeMultipoleCoefficients(e),this.multipoleCoefficients=Tt.constructorPMM(this.med.Center,this.leftChild.multipoleCoefficients,this.rightChild.multipoleCoefficients)}},To=class extends Na{constructor(e){super();this.particles=e,this.ComputeMinimumEnclosingDisc()}computeMultipoleCoefficients(e){this.multipoleCoefficients=Tt.constructorNPA(e,this.med.Center,this.ps)}ComputeMinimumEnclosingDisc(){let e=this.Size();this.ps=new Array(e);for(let i=0;i<e;i++)this.ps[i]=this.particles[0][i].point;return this.med=Ga.LinearComputation(this.ps)}Min(e){return this.particles[e][0].pos(e)}Size(){return this.particles[0].length}Max(e){return this.particles[e][this.Size()-1].pos(e)}Dimension(e){return this.Max(e)-this.Min(e)}Split(e){let i=this.Dimension(0)>this.Dimension(1)?0:1,r=i==0?1:0,n=this.Size(),o=n>>1,s=n-o,a=[new Array(o),new Array(o)],u=[new Array(s),new Array(s)],h=0,d=0;for(let f=0;f<n;f++){let P=this.particles[i][f];f<o?(a[i][f]=P,P.splitLeft=!0):(u[i][f-o]=P,P.splitLeft=!1)}for(let f=0;f<n;f++){let P=this.particles[r][f];P.splitLeft?a[r][d++]=P:u[r][h++]=P}let g=this.med;return this.particles=a,this.ComputeMinimumEnclosingDisc(),e.rightSibling=new To(u),new Jl(g,this,e.rightSibling)}ComputeForces(){for(let e of this.particles[0])for(let i of this.particles[0])e!=i&&(e.force=e.force.add(Tt.Force(e.point,i.point)))}},Ba=class{pos(t){return t==0?this.point.x:this.point.y}constructor(t){this.point=t,this.force=new c(0,0)}},Va=class{particlesBy(t){return this.particles.map(e=>e).sort((e,i)=>e.pos(t)-i.pos(t))}constructor(t,e){this.particles=t;let i=new Array;i.push(this.particlesBy(0)),i.push(this.particlesBy(1)),this.leaves=new Array;let r=new To(i);this.leaves.push(r);let n={rightSibling:null};this.root=r.Split(n),this.leaves.push(n.rightSibling);let o=new Yl(e);for(o.EnqueueLL(r,n.rightSibling);o.length>0;)r=o.dequeue(),r.Split(n),this.leaves.push(n.rightSibling),o.EnqueueLL(r,n.rightSibling)}ComputeForces(t){this.root.computeMultipoleCoefficients(t);for(let e of this.leaves){e.ComputeForces();let i=new Array;for(i.push(this.root);i.length>0;){let r=i.pop();if(e.intersects(r))if(r instanceof To)for(let n of e.particles[0])for(let o of r.particles[0])n!=o&&(n.force=n.force.add(Tt.Force(n.point,o.point)));else{let n=r;i.push(n.leftChild),i.push(n.rightChild)}else for(let n of e.particles[0])n.force=n.force.sub(r.multipoleCoefficients.ApproximateForce(n.point))}}}},Yl=class extends Sh.Queue{constructor(e){super();this.B=e}EnqueueLL(e,i){e.Size()>this.B&&this.enqueue(e),i.Size()>this.B&&this.enqueue(i)}};var vr=class extends H{constructor(e,i,r){super(null);this.clustersInfo=new Map;this.clusterEdges=new Array;if(this.graph=e,this.settings=i,this.initFiNodesEdges(),this.edges=Array.from(this.graph.shallowEdges).map(n=>oi.getAlgData(n.edge).data),this.nodes=Array.from(this.graph.shallowNodes).map(n=>oi.getAlgData(n.node).data),this.components=new Array,this.settings.InterComponentForces)this.components.push(this.nodes);else{this.basicGraph=rt(this.edges,this.nodes.length);for(let n of Ti(this.basicGraph)){let o=new Array(n.length),s=0;for(let a of n)o[s++]=this.nodes[a];this.components.push(o)}}this.computeWeight(e),this.setCurrentConstraintLevel(r)}initFiNodesEdges(){let e=0;for(let i of this.graph.shallowNodes){let r=new La(e++,i);new oi(i.node,r)}for(let i of this.graph.shallowEdges){let r=new Ra(i);new oi(i.edge,r)}}getCurrentConstraintLevel(){return this.currentConstraintLevel}setCurrentConstraintLevel(e){this.currentConstraintLevel=e,this.settings.Unconverge()}ResetNodePositions(){for(let e of this.nodes)e.ResetBounds()}AddRepulsiveForce(e,i){e.force=i.mul(10*this.settings.RepulsiveForceConstant)}AddLogSpringForces(e,i,r){let n=i.length,o=7e-4*this.settings.AttractiveForceConstant*n*Math.log((n+.1)/(r+.1));e.sourceFiNode.force=e.sourceFiNode.force.add(i.mul(o)),e.targetFiNode.force=e.targetFiNode.force.sub(i.mul(o))}AddSquaredSpringForces(e,i,r){let n=i.length,o=r*r+.1,s=this.settings.AttractiveForceConstant*(n-r)/o;e.sourceFiNode.force=e.sourceFiNode.force.add(i.mul(s)),e.targetFiNode.force=e.targetFiNode.force.sub(i.mul(s))}AddSpringForces(e){let i;if(this.settings.RespectEdgePorts){let r=e.sourceFiNode.Center,n=e.targetFiNode.Center,o=e.mEdge.sourcePort;o instanceof Ue&&(r=o.Location);let s=e.mEdge.targetPort;s instanceof Ue&&(n=s.Location),i=r.sub(n)}else i=e.vector();this.settings.LogScaleEdgeForces?this.AddLogSpringForces(e,i,e.length):this.AddSquaredSpringForces(e,i,e.length)}static AddGravityForce(e,i,r){r!=null&&(r.force=r.force.sub(e.sub(r.Center).mul(i*1e-4)))}ComputeRepulsiveForces(e){let i=e.length;if(i>16&&this.settings.ApproximateRepulsion){let r=new Array(e.length),n=2*(Math.PI/i),o=0;for(let a=0;a<i;a++)r[a]=new Ba(e[a].Center.add(new c(Math.cos(o),Math.sin(o)).mul(1e-5))),o+=n;new Va(r,8).ComputeForces(5);for(let a=0;a<e.length;a++)this.AddRepulsiveForce(e[a],r[a].force)}else for(let r of e){let n=new c(0,0);for(let o of e)r!=o&&(n=n.add(Tt.Force(r.Center,o.Center)));this.AddRepulsiveForce(r,n)}}SetBarycenter(e){let i=this.clustersInfo.get(e);if(i!=null)return i.barycenter;let r=new c(0,0);if(e.shallowNodeCount||$c(e)){let n=this.clustersInfo.get(e);if((n==null||n.weight==null)&&this.computeWeight(e),n.weight!=null){for(let o of e.shallowNodes)o instanceof je?r=r.add(o.center):r=r.add(this.SetBarycenter(o).mul(this.clustersInfo.get(o).weight));this.clustersInfo.get(e).barycenter=r=r.div(n.weight)}}else this.clustersInfo.get(e).barycenter=r;return r}computeWeight(e){let i=0;for(let n of e.shallowNodes)n.entity instanceof ce?i+=this.computeWeight(n):i++;let r=this.clustersInfo.get(e);return r==null&&this.clustersInfo.set(e,r={barycenter:new c(0,0)}),r.weight=i,i}AddClusterForces(e){if(e!=null){this.SetBarycenter(e);for(let i of this.clusterEdges){let r=q.getGeom(i.source),n=q.getGeom(i.target),o=oi.getAlgData(i.source).data,s=oi.getAlgData(i.target).data,a=r.hasOwnProperty("shallowNodes"),u=a?this.clustersInfo.get(r).barycenter:r.center,h=n.hasOwnProperty("shallowNodes"),d=h?this.clustersInfo.get(n).barycenter:n.center,g=u.sub(d),f=g.length,P=1e-8*(this.settings.AttractiveInterClusterForceConstant*(f*Math.log(f+.1)));if(g=g.mul(P),a){let y=r;for(let w of y.shallowNodes){let x=oi.getAlgData(w.node).data;x.force=x.force.add(g)}}else o.force=o.force.add(g);if(h){let y=n;for(let w of y.shallowNodes){let x=oi.getAlgData(w.node).data;x.force=x.force.sub(g)}}else s.force=s.force.sub(g)}for(let i of e.subgraphsDepthFirst){let r=this.clustersInfo.get(i).barycenter;for(let n of i.shallowNodes)vr.AddGravityForce(r,this.settings.ClusterGravity,ms(n))}}}ComputeForces(){if(this.components!=null)for(let e of this.components)this.ComputeRepulsiveForces(e);else this.ComputeRepulsiveForces(this.nodes);this.edges.forEach(e=>this.AddSpringForces(e));for(let e of this.components){let i=new c(0,0);for(let n=0;n<e.length;n++)i=i.add(e[n].Center);i=i.div(e.length);let r=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let o=e[n];vr.AddGravityForce(i,this.settings.GravityConstant,o),o.force.length>r&&(r=o.force.length)}if(r>100)for(let n=0;n<e.length;n++)e[n].force=e[n].force.mul(100/r)}this.AddClusterForces(this.graph)}VerletIntegration(){let e=this.energy;this.energy=this.ComputeDescentDirection(1),this.UpdateStepSize(e);let i=0;for(let r=0;r<this.nodes.length;r++){let n=this.nodes[r];i+=n.Center.sub(n.previousCenter).lengthSquared}return i}ComputeDescentDirection(e){this.ResetForceVectors(),this.settings.ApplyForces&&this.ComputeForces();let i=0;for(let r of this.nodes){i=i+r.force.lengthSquared;let n=r.Center.sub(r.previousCenter).mul(this.settings.Friction),o=r.force.mul(-this.stepSize*e);r.previousCenter=r.Center,X.assert(!Number.isNaN(o.x),"!double.IsNaN(a.X)"),X.assert(!Number.isNaN(o.y),"!double.IsNaN(a.Y)"),X.assert(Number.isFinite(o.x),"!double.IsInfinity(a.X)"),X.assert(Number.isFinite(o.y),"!double.IsInfinity(a.Y)"),n=n.add(o),n=n.div(r.stayWeight),r.Center=r.Center.add(n)}return i}ResetForceVectors(){for(let e of this.nodes)e.force=new c(0,0)}UpdateStepSize(e){this.energy<e?++this.progress>=3&&(this.progress=0,this.stepSize/=this.settings.Decay):(this.progress=0,this.stepSize*=this.settings.Decay)}RungeKuttaIntegration(){let e=new Array(this.nodes.length),i=new Array(this.nodes.length),r=new Array(this.nodes.length),n=new Array(this.nodes.length),o=new Array(this.nodes.length),s=this.energy;for(let u=0;u<this.nodes.length;u++)this.nodes[u].previousCenter=this.nodes[u].Center,e[u]=this.nodes[u].Center;let a=3;this.ComputeDescentDirection(a);for(let u=0;u<this.nodes.length;u++)i[u]=this.nodes[u].Center.sub(this.nodes[u].previousCenter),this.nodes[u].Center=e[u].add(i[u].mul(.5));this.ComputeDescentDirection(a);for(let u=0;u<this.nodes.length;u++)r[u]=this.nodes[u].Center.sub(this.nodes[u].previousCenter),this.nodes[u].previousCenter=e[u],this.nodes[u].Center=e[u].add(r[u].mul(.5));this.ComputeDescentDirection(a);for(let u=0;u<this.nodes.length;u++)n[u]=this.nodes[u].Center.sub(this.nodes[u].previousCenter),this.nodes[u].previousCenter=e[u],this.nodes[u].Center=e[u].add(n[u]);this.energy=this.ComputeDescentDirection(a);for(let u=0;u<this.nodes.length;u++){o[u]=this.nodes[u].Center.sub(this.nodes[u].previousCenter),this.nodes[u].previousCenter=e[u];let h=i[u].add(r[u].mul(2).add(n[u].mul(2)).add(o[u])).div(6);this.nodes[u].Center=e[u].add(h)}return this.UpdateStepSize(s),this.nodes.reduce((u,h)=>h.Center.sub(h.previousCenter).lengthSquared+u,0)}run(){this.settings.Converged=!1,this.settings.EdgeRoutesUpToDate=!1,this.settings.Iterations++==0&&(this.stepSize=this.settings.InitialStepSize,this.energy=Number.MAX_VALUE,this.progress=0);for(let e=0;e<this.settings.MinorIterations;e++){if((this.settings.RungeKuttaIntegration?this.RungeKuttaIntegration():this.VerletIntegration())<this.settings.DisplacementThreshold||this.settings.Iterations>this.settings.MaxIterations){this.settings.Converged=!0;break}this.ProgressStep()}}};function $c(l){for(let t of l.Clusters)return!0;return!1}var Pt=class{constructor(){this.commonSettings=new Oi;this.maxIterations=100;this.clusterMargin=10;this.minorIterations=3;this.projectionIterations=5;this.approximateRepulsion=!0;this.RungeKuttaIntegration=!1;this.initialStepSize=1.4;this.decay=.9;this.friction=.8;this.repulsiveForceConstant=1;this.attractiveForceConstant=1;this.gravity=1;this.interComponentForces=!0;this.applyForces=!0;this.AvoidOverlaps=!0;this.approximateRouting=!0;this.logScaleEdgeForces=!0;this.displacementThreshold=.1;this.maxConstraintLevel=2;this.minConstraintLevel=0;this.attractiveInterClusterForceConstant=1;this.clusterGravity=1;this.commonSettings.NodeSeparation*=2}get edgeRoutingSettings(){return this.commonSettings.edgeRoutingSettings}set edgeRoutingSettings(t){this.commonSettings.edgeRoutingSettings=t}get PackingAspectRatio(){return this.commonSettings.PackingAspectRatio}set PackingAspectRatio(t){this.commonSettings.PackingAspectRatio=t}get NodeSeparation(){return this.commonSettings.NodeSeparation}set NodeSeparation(t){this.commonSettings.NodeSeparation=t}get MaxIterations(){return this.maxIterations}set MaxIterations(t){this.maxIterations=t}get MinorIterations(){return this.minorIterations}set MinorIterations(t){this.minorIterations=t}get Iterations(){return this.iterations}set Iterations(t){this.iterations=t}get ProjectionIterations(){return this.projectionIterations}set ProjectionIterations(t){this.projectionIterations=t}get ApproximateRepulsion(){return this.approximateRepulsion}set ApproximateRepulsion(t){this.approximateRepulsion=t}get InitialStepSize(){return this.initialStepSize}set InitialStepSize(t){if(t<=0||t>2)throw new Error("ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)");this.initialStepSize=t}get Decay(){return this.decay}set Decay(t){if(t<.1||t>1)throw new Error("Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value");this.decay=t}get Friction(){return this.friction}set Friction(t){if(t<0||t>1)throw new Error("Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity");this.friction=t}get RepulsiveForceConstant(){return this.repulsiveForceConstant}set RepulsiveForceConstant(t){this.repulsiveForceConstant=t}get AttractiveForceConstant(){return this.attractiveForceConstant}set AttractiveForceConstant(t){this.attractiveForceConstant=t}get GravityConstant(){return this.gravity}set GravityConstant(t){this.gravity=t}get InterComponentForces(){return this.interComponentForces}set InterComponentForces(t){this.interComponentForces=t}get ApplyForces(){return this.applyForces}set ApplyForces(t){this.applyForces=t}ResetLayout(){this.Unconverge(),this.algorithm!=null&&this.algorithm.ResetNodePositions()}Unconverge(){this.iterations=0,this.converged=!1}InitializeLayoutGN(t,e){this.InitializeLayout(t,e)}InitializeLayout(t,e){this.algorithm=new vr(t,this,e),this.ResetLayout()}Uninitialize(){this.algorithm=null}get IsInitialized(){return this.algorithm!=null}IncrementalRunG(t){this.IncrementalRunGF(t)}SetupIncrementalRun(t){this.IsInitialized?this.IsDone&&this.ResetLayout():this.InitializeLayout(t,this.MaxConstraintLevel)}IncrementalRunGF(t){this.SetupIncrementalRun(t),this.algorithm.run()}IncrementalRun(t,e){t!=null&&t.throwIfCanceled(),this.SetupIncrementalRun(e),this.algorithm.cancelToken=t,this.algorithm.run()}Clone(){return Pt.ctorClone(this)}get ApproximateRouting(){return this.approximateRouting}set ApproximateRouting(t){this.approximateRouting=t}get LogScaleEdgeForces(){return this.logScaleEdgeForces}set LogScaleEdgeForces(t){this.logScaleEdgeForces=t}get DisplacementThreshold(){return this.displacementThreshold}set DisplacementThreshold(t){this.displacementThreshold=t}get Converged(){return this.converged}set Converged(t){this.converged=t}get PercentDone(){return this.Converged?100:100*this.iterations/this.MaxIterations}get IsDone(){return this.Converged||this.iterations>=this.MaxIterations}get Energy(){return this.algorithm!=null?this.algorithm.energy:0}get MaxConstraintLevel(){return this.maxConstraintLevel}set MaxConstraintLevel(t){this.maxConstraintLevel!=t&&(this.maxConstraintLevel=t,this.IsInitialized&&this.Uninitialize())}get MinConstraintLevel(){return this.minConstraintLevel}set MinConstraintLevel(t){this.minConstraintLevel=t}getCurrentConstraintLevel(){return this.algorithm==null?0:this.algorithm.getCurrentConstraintLevel()}setCurrentConstraintLevel(t){this.algorithm.setCurrentConstraintLevel(t)}get AttractiveInterClusterForceConstant(){return this.attractiveInterClusterForceConstant}set AttractiveInterClusterForceConstant(t){this.attractiveInterClusterForceConstant=t}static ctorClone(t){let e=new Pt;return e.maxIterations=t.maxIterations,e.minorIterations=t.minorIterations,e.projectionIterations=t.projectionIterations,e.approximateRepulsion=t.approximateRepulsion,e.initialStepSize=t.initialStepSize,e.RungeKuttaIntegration=t.RungeKuttaIntegration,e.decay=t.decay,e.friction=t.friction,e.repulsiveForceConstant=t.repulsiveForceConstant,e.attractiveForceConstant=t.attractiveForceConstant,e.gravity=t.gravity,e.interComponentForces=t.interComponentForces,e.applyForces=t.applyForces,e.AvoidOverlaps=t.AvoidOverlaps,e.RespectEdgePorts=t.RespectEdgePorts,e.RouteEdges=t.RouteEdges,e.approximateRouting=t.approximateRouting,e.logScaleEdgeForces=t.logScaleEdgeForces,e.displacementThreshold=t.displacementThreshold,e.minConstraintLevel=t.minConstraintLevel,e.maxConstraintLevel=t.maxConstraintLevel,e.attractiveInterClusterForceConstant=t.attractiveInterClusterForceConstant,e.clusterGravity=t.clusterGravity,e.PackingAspectRatio=t.PackingAspectRatio,e.NodeSeparation=t.NodeSeparation,e.clusterMargin=t.clusterMargin,e}get ClusterGravity(){return this.clusterGravity}set ClusterGravity(t){this.clusterGravity=t}static CreateFastIncrementalLayoutSettings(){let t=new Pt;return t.ApplyForces=!1,t.ApproximateRepulsion=!0,t.ApproximateRouting=!0,t.AttractiveForceConstant=1,t.AttractiveInterClusterForceConstant=1,t.AvoidOverlaps=!0,t.ClusterGravity=1,t.Decay=.9,t.DisplacementThreshold=5e-8,t.Friction=.8,t.GravityConstant=1,t.InitialStepSize=2,t.InterComponentForces=!1,t.Iterations=0,t.LogScaleEdgeForces=!1,t.MaxConstraintLevel=2,t.MaxIterations=20,t.MinConstraintLevel=0,t.MinorIterations=1,t.ProjectionIterations=5,t.RepulsiveForceConstant=2,t.RespectEdgePorts=!1,t.RouteEdges=!1,t.RungeKuttaIntegration=!0,t.NodeSeparation=20,t}};var Ma=class{constructor(t){this.topNodes=t}get nodesBreadthFirst(){return this.nodesBreadthFirst_()}*nodesBreadthFirst_(){for(let t of this.topNodes)if(yield je.getGeom(t),t instanceof ce)for(let e of t.nodesBreadthFirst)yield je.getGeom(e)}get Clusters(){return this.clusters()}*clusters(){for(let t of this.topNodes)t instanceof ce&&(yield de.getGeom(t))}get subgraphsDepthFirst(){return this.subgraphsDepthFirst_()}*subgraphsDepthFirst_(){for(let t of this.topNodes)if(t instanceof ce){let e=de.getGeom(t);yield*e.subgraphsDepthFirst,yield e}}get shallowEdges(){return this.edges_()}*edges_(){for(let t of this.topNodes){for(let e of t.outEdges)yield Pe.getGeom(e);for(let e of t.selfEdges)yield Pe.getGeom(e)}}get shallowNodes(){return this.shallowNodes_()}*shallowNodes_(){for(let t of this.topNodes)yield je.getGeom(t)}pumpTheBoxToTheGraphWithMargins(){let t={b:I.mkEmpty()};return Ms(this,t),this.boundingBox=t.b}get shallowNodeCount(){return this.topNodes.length}translate(t){this.boundingBox&&(this.boundingBox.center=this.boundingBox.center.add(t));for(let e of this.topNodes)je.getGeom(e).translate(t)}};var fs=class{static LinearInterpolation(t,e,i,r,n){if(t<e)return r;if(t>i)return n;let o=(t-e)/(i-e);return r+o*(n-r)}static NegativeLinearInterpolation(t,e,i,r,n){if(t<e)return n;if(t>i)return r;let o=(t-e)/(i-e);return r+(1-o)*(n-r)}};var Da=class extends H{constructor(e,i){super(null);this.SingleComponent=!1;this.graph=e,this.settings=Pt.ctorClone(i),this.settings.ApplyForces=!0,this.settings.InterComponentForces=!0,this.settings.RungeKuttaIntegration=!1,this.settings.RespectEdgePorts=!1}run(){if(this.SingleComponent)this.componentCount=1,this.LayoutComponent(this.graph);else{let e=Array.from(this.graph.graph.getClusteredConnectedComponents()).map(i=>new Ma(i));this.componentCount=e.length;for(let i of e)this.LayoutComponent(i);this.graph.boundingBox=Cr.PackGraphs(e,this.settings.commonSettings)}}LayoutComponent(e){if(e.shallowNodeCount>1){if(this.settings.MaxIterations=fs.NegativeLinearInterpolation(e.shallowNodeCount,50,500,5,10),this.settings.MinorIterations=fs.NegativeLinearInterpolation(e.shallowNodeCount,50,500,3,20),this.settings.MinConstraintLevel==0){let r=new Dt;r.removeOverlaps=!1,r.IterationsWithMajorization=0,new Er(e,null,()=>1,new Dt).run()}let i=new vr(e,this.settings,this.settings.MinConstraintLevel);for(let r of this.GetConstraintLevels(e)){if(r>this.settings.MaxConstraintLevel)break;r>this.settings.MinConstraintLevel&&i.setCurrentConstraintLevel(r);do i.run();while(!this.settings.IsDone)}this.settings.AvoidOverlaps&&xt.RemoveOverlaps(Array.from(this.graph.shallowNodes),this.settings.NodeSeparation)}e.pumpTheBoxToTheGraphWithMargins(),e.uniformMargins=this.settings.NodeSeparation,e.translate(e.boundingBox.leftBottom.mul(-1))}GetConstraintLevels(e){let i=new Set;return i.add(0),this.settings.AvoidOverlaps&&e.shallowNodeCount<2e3&&i.add(2),i}};function yh(l){if(l instanceof Xt)return 0;if(l instanceof Pt)return 1;if(l instanceof Dt)return 2;if(l instanceof Pt)return 3;throw new Error("not implemented")}function ds(l,t){(!l.layoutSettings||yh(l.layoutSettings)!==yh(t))&&(l.layoutSettings=t);for(let e of l.shallowNodes)e instanceof de&&ds(e,l.layoutSettings)}function Ch(l){l.layoutSettings||(l.layoutSettings=Eh(l))}function ed(l){let t=l.parent;for(;t;){if(t.layoutSettings)return t.layoutSettings;t=t.parent}return null}function Eh(l){let t=ed(l);if(t)return t;if(l.graph.shallowNodeCount>2e3||l.graph.deepEdgesCount>4e3)return new Pt;let i=!1;for(let r of l.deepEdges)if(r.sourceArrowhead!=null||r.targetArrowhead!=null){i=!0;break}return i?new Xt:new Pt}function td(l,t,e=()=>1){if(Ch(l),l.layoutSettings instanceof Xt)new Pn(l,l.layoutSettings,t).run();else if(l.layoutSettings instanceof Dt)new Er(l,t,e,l.layoutSettings).run();else if(l.layoutSettings instanceof Pt){let i=new Da(l,l.layoutSettings);i.SingleComponent=!0,i.run()}else throw new Error("not implemented")}function Ih(l,t=null){Ch(l),gn(l,t,td,dn,to)}function Zl(l){do{if(l.layoutSettings&&l.layoutSettings.commonSettings.edgeRoutingSettings)return l.layoutSettings.commonSettings.edgeRoutingSettings;let e=l.graph.parent;if(e)l=q.getGeom(e);else break}while(!0);let t=new wi;return t.EdgeRoutingMode=0,t}function dn(l,t,e){let i=Zl(l);i.EdgeRoutingMode===4?Kl(l,t,e):i.EdgeRoutingMode===0||i.EdgeRoutingMode===1?xh(l,t,e):i.EdgeRoutingMode===2?wa(l,t,e):i.EdgeRoutingMode!==6&&new $(l,t).run(),vh(l,t)}function gn(l,t,e,i,r,n=1,o=()=>1){if(l.graph.isEmpty())return;l.parent==null&&(Qr(n),nd(l));let s=g();d(l);let a=id(l.graph),u=rd(l);if(f(),a.forEach(P=>{P[0].edge.remove(),P[1].add()}),u.forEach(P=>{for(let y of P.graph.shallowNodes)y.parent=l.graph}),s.forEach(P=>P.add()),l.graph.parent==null){let P=h(l);i(l,P,t),vh(l,P),l.pumpTheBoxToTheGraphWithMargins()}function h(P){let y=[];for(let w of P.nodesBreadthFirst){for(let x of w.outEdges())x.curve==null&&y.push(x);for(let x of w.selfEdges())x.curve==null&&y.push(x)}return y}function d(P){for(let y of P.shallowNodes)y instanceof de&&gn(y,t,e,i,r)}function g(){let P=new Set,y=l.graph;if(y.parent==null)return P;for(let w of y.shallowNodes){for(let x of w.outEdges){let G=y.liftNode(x.target);(G==null||G===w)&&P.add(x)}for(let x of w.inEdges){let G=y.liftNode(x.source);(G==null||G===w)&&P.add(x)}}for(let w of P)w.remove();return P}function f(){if(u.length===1)e(l,t,o);else{for(let P of u)e(P,t,o),P.boundingBox=P.pumpTheBoxToTheGraphWithMargins();r(l,u)}}}function id(l){let t=new Array;for(let e of l.nodesBreadthFirst){let i=l.liftNode(e);if(i!=null)for(let r of e.outEdges.values()){let n=r.target,o=l.liftNode(n);if(o==null||i===e&&o===n||i===o)continue;r.remove();let s=new Fi(i,o),a=new Pe(s);t.push([a,r])}}return t}function rd(l){var n;let t=l.graph,e=gu(t),i=[],r=0;for(let o of e){let s=new ce(t.id+r++);s.parent=t;let a=new de(s);a.layoutSettings=(n=l.layoutSettings)!=null?n:Eh(l);for(let u of o)u.parent=s,s.addNode(u);i.push(a)}return i}function Kl(l,t,e,i=1,r=3,n=3){let o=Ki.constructorGNAN(l,t,i,r);o.edgeSeparatian=n,o.run()}function vh(l,t){if(t.length===0)return;hi.constructorGA(l,t).run()}function nd(l){for(let t of l.deepEdges)t.label&&(t.label.isPositioned=!1)}function $l(l){if(de.getGeom(l)==null)return!1;for(let t of l.shallowNodes){let e=q.getGeom(t);if(e==null||e.boundaryCurve==null||t instanceof ce&&$l(t)===!1)return!1}for(let t of l.edges)if(Pe.getGeom(t)==null)return!1;return!0}function eu(l){let t=de.getGeom(l);if(t==null||t.boundingBox==null||t.boundingBox.isEmpty())return!1;for(let e of l.shallowNodes){let i=q.getGeom(e);if(i==null||i.boundaryCurve==null||e instanceof ce&&eu(e)===!1)return!1}for(let e of l.deepEdges){let i=Pe.getGeom(e);if(i==null||i.curve==null)return!1}return!0}var Ao=class{static constructorStatic(t,e){let i=new Ao;i.edges=t,i.nodeBoundaries=e,i.boundingBox=I.mkEmpty();for(let r of i.nodeBoundaries)i.boundingBox=i.boundingBox.addRec(r.boundingBox);return i}AddGraph(t){this.edges=this.edges.concat(t.edges),this.nodeBoundaries=bi(this.nodeBoundaries,t.nodeBoundaries),this.boundingBox.addRec(t.boundingBox)}AddNodeBoundary(t){this.nodeBoundaries.add(t),this.boundingBox.addRec(t.boundingBox)}};var Th=J(ai(),1);var bn=class{get CurrentPiercedEdge(){return this.currentPiercedEdge}get CurrentTriangle(){return this.currentTriangle}constructor(t,e,i){this.currentTriangle=t,this.start=e,this.end=i}FindFirstPiercedEdge(){let t=this.GetHyperplaneSign(this.currentTriangle.Sites.item0),e=this.GetHyperplaneSign(this.currentTriangle.Sites.item1);if(t!==e&&c.getTriangleOrientation(this.end,this.currentTriangle.Sites.item0.point,this.currentTriangle.Sites.item1.point)==0)return this.positiveSign=t,this.negativeSign=e,this.currentTriangle.Edges.item0;let i=this.GetHyperplaneSign(this.currentTriangle.Sites.item2);return e!==i&&c.getTriangleOrientation(this.end,this.currentTriangle.Sites.item1.point,this.currentTriangle.Sites.item2.point)==0?(this.positiveSign=e,this.negativeSign=i,this.currentTriangle.Edges.item1):(this.positiveSign=i,this.negativeSign=t,this.currentTriangle.Edges.item2)}FindNextPierced(){if(this.currentTriangle=this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle),this.currentTriangle==null){this.currentPiercedEdge=null;return}let t=this.currentTriangle.Edges.index(this.currentPiercedEdge),e,i=this.currentTriangle.Sites.getItem(t+2),r=this.GetHyperplaneSign(i);this.negativeSign===0?r===-1||r===0?(this.negativeSign=r,e=t+1):e=t+2:this.positiveSign===0?r===1||r===0?(this.positiveSign=r,e=t+2):e=t+1:r!==this.positiveSign?(this.negativeSign=r,e=t+1):(this.positiveSign=r,e=t+2),this.currentPiercedEdge=c.signedDoubledTriangleArea(this.end,this.currentTriangle.Sites.getItem(e).point,this.currentTriangle.Sites.getItem(e+1).point)<-m.distanceEpsilon?this.currentTriangle.Edges.getItem(e):null}GetHyperplaneSign(t){let e=c.signedDoubledTriangleArea(this.start,t.point,this.end);return e>m.distanceEpsilon?1:e<-m.distanceEpsilon?-1:0}MoveNext(){return this.currentPiercedEdge==null?this.currentPiercedEdge=this.FindFirstPiercedEdge():this.FindNextPierced(),this.currentPiercedEdge!=null}};var wo=class{constructor(t,e){this.ComputeForcesForBundles=!1;this.metroGraphData=t,this.bundlingSettings=e}EdgeIsLegal_(t,e,i,r){if(ne.PointIsInsideOfTriangle(e,i))return!0;let n=new bn(i,t,e);for(;n.MoveNext();){let o=n.CurrentPiercedEdge;if(o.constrained){let s=o.lowerSite.Owner;if(!r.has(s))return!1}}return!0}BundleAvoidsObstacles(t,e,i,r,n,o){o.closestDist=new Array;let s=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e),a=this.FindCloseObstaclesForBundle(e.cdtTriangle,r,i,s,n);if(a==null)return!1;for(let u of a){let h=u[1];o.closestDist.push(h)}return!0}FindCloseObstaclesForBundle(t,e,i,r,n){let o=new Map,s=[];if(!this.ThreadLineSegmentThroughTriangles(t,e,i,r,s))return null;if(!this.ComputeForcesForBundles&&!this.bundlingSettings.HighestQuality)return o;let a=new Ir;for(let u of s)for(let h of u.Sites){if(a.has(h))continue;a.add(h);let d=h.Owner;if(r.has(d))continue;let g=wo.FindPolylinePoint(d,h.point),f=S.minDistBetweenLineSegments(g.point,g.nextOnPolyline.point,e,i),P=f.dist,y=f.parab,w=f.parcd,x=S.minDistBetweenLineSegments(g.point,g.prevOnPolyline.point,e,i),G=x.dist,A=x.parab,M=x.parcd,Y,K,Me;if(P<G){if(Me=P,Me>n)continue;Y=g.point.add(g.nextOnPolyline.point.sub(g.point).mul(y)),K=e.add(i.sub(e).mul(w))}else{if(Me=G,Me>n)continue;Y=g.point.add(g.prevOnPolyline.point.sub(g.point).mul(A)),K=e.add(i.sub(e).mul(M))}o.get(d)||o.set(d,[Y,K])}return o}ThreadLineSegmentThroughTriangles(t,e,i,r,n){if(ne.PointIsInsideOfTriangle(i,t))return n.push(t),!0;let o=new bn(t,e,i);for(n.push(t);o.MoveNext();){n.push(o.CurrentTriangle);let s=o.CurrentPiercedEdge;if(s.constrained){let a=s.lowerSite.Owner;if(!r.has(a))return!1}}return o.CurrentTriangle!=null&&n.push(o.CurrentTriangle),!0}static PointLocationInsideTriangle(t,e){let i=!1;for(let r=0;r<3;r++){let n=c.signedDoubledTriangleArea(t,e.Sites.getItem(r).point,e.Sites.getItem(r+1).point);if(n<m.distanceEpsilon*-1)return 0;n<m.distanceEpsilon&&(i=!0)}return i?1:2}static FindPolylinePoint(t,e){for(let i of t.polylinePoints())if(i.point.equal(e))return i;throw new Error("polyline point "+e+" not found")}EdgeIsLegal(t,e,i,r){let n=[],o=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,e);return this.ThreadLineSegmentThroughTriangles(t.cdtTriangle,i,r,o,n)}EdgeIsLegalSSPPS(t,e,i){let r=t.Position,n=t.cdtTriangle,o=e.Position;if(ne.PointIsInsideOfTriangle(o,n))return!0;let s=new bn(n,r,o);for(;s.MoveNext();){let a=s.CurrentPiercedEdge;if(a.constrained){let u=a.lowerSite.Owner;if(!i.has(u))return!1}}return!0}};var At=class{constructor(t,e,i,r){this.metroGraphData=t,this.obstaclesToIgnoreLambda=r,this.bundlingSettings=e,this.obstacleTree=i}ObstaclesToIgnoreForBundle(t,e){return t!=null&&e!=null?bi(this.obstaclesToIgnoreLambda(t),this.obstaclesToIgnoreLambda(e)):t==null&&e==null?new Set:t!=null?this.obstaclesToIgnoreLambda(t):this.obstaclesToIgnoreLambda(e)}HubAvoidsObstaclesSPNBA(t,e,i,r){let n={minimalDistance:i};return At.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),r.touchedObstacles,n)}HubAvoidsObstaclesPNS__(t,e,i){let r={touchedObstacles:Array()},n={minimalDistance:0};return this.HubAvoidsObstaclesPNSTT(t,e,i,r,n)}GetMinimalDistanceToObstacles(t,e,i){let r=new Array,n={minimalDistance:i};return At.IntersectCircleWithTree(this.obstacleTree,e,i,this.obstaclesToIgnoreLambda(t),r,n)?n.minimalDistance:0}HubAvoidsObstaclesPNSTT(t,e,i,r,n){return r.touchedObstacles=new Array,n.minimalDistance=e,At.IntersectCircleWithTree(this.obstacleTree,t,e,i,r.touchedObstacles,n)}static IntersectCircleWithTree(t,e,i,r,n,o){if(!t.irect.contains_point_radius(e,i))return!0;if(t.UserData==null){let s=At.IntersectCircleWithTree(t.Left,e,i,r,n,o);if(!s||(s=At.IntersectCircleWithTree(t.Right,e,i,r,n,o),!s))return!1}else{let s=t.UserData;if(r.has(s))return!0;if(p.PointRelativeToCurveLocation(e,s)!==0)return At.containingPoly=s,!1;let u=s.value(s.closestParameter(e)),h=u.sub(e).length;h<=i&&n.push([s,u]),o.minimalDistance=Math.min(h,o.minimalDistance)}return!0}static Create4gon(t,e,i,r){let n=e.sub(t).normalize();return n=new c(n.y,n.x*-1),R.mkFromPoints([t.add(n.mul(i/2)),t.sub(n.mul(i/2)),e.sub(n.mul(r/2)),e.add(n.mul(r/2))])}};var Fa=class{constructor(t,e,i,r){this.Width=e,this.Polyline=t,this.sourceAndTargetLoosePolylines=i,this.Index=r}UpdateLengths(){let t=0;for(let e=this.Polyline.startPoint;e.next!=null;e=e.next)t+=e.next.point.sub(e.point).length;this.Length=t,this.IdealLength=this.Polyline.end.sub(this.Polyline.start).length}};var ka=class{constructor(t,e,i){this.metroline=t,this.station=e,this.polyPoint=i}get Metroline(){return this.metroline}get PolyPoint(){return this.polyPoint}};var Ha=class{constructor(t,e,i){this.Radius=0;this.BundleBases=new Map;this.MetroNodeInfos=new Array;this._cachedIdealRadius=0;this.SerialNumber=t,this.IsReal=e,this.Position=i}debStop(){return this.SerialNumber===28&&this.Position.sub(new c(841.2662778763244,303.3817005853006)).length<.001}get Position(){return this._Position}set Position(t){this._Position=t}getELP(){return this.EnterableLoosePolylines}setELP(t){this.EnterableLoosePolylines=t}addEL(t){this.EnterableLoosePolylines.add(t)}get cachedIdealRadius(){return this._cachedIdealRadius}set cachedIdealRadius(t){this._cachedIdealRadius=t}AddEnterableLoosePolyline(t){this.EnterableLoosePolylines==null&&(this.EnterableLoosePolylines=new Set),this.EnterableLoosePolylines.add(t)}AddEnterableTightPolyline(t){this.EnterableTightPolylines==null&&(this.EnterableTightPolylines=new Set),this.EnterableTightPolylines.add(t)}};var Wa=class{constructor(){this.Width=0;this.Metrolines=new Array;this.cachedBundleCost=0}get Count(){return this.Metrolines.length}};var Ge=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}CreateNodeRadii(){for(let t of this.metroGraphData.VirtualStations())t.Radius=0,t.cachedIdealRadius=Ge.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t);this.GrowHubs(!1),this.GrowHubs(!0);for(let t of this.metroGraphData.VirtualStations())t.Radius=Math.max(t.Radius,this.bundlingSettings.MinHubRadius)}GrowHubs(t){let e=new nt(Q);for(let r of this.metroGraphData.VirtualStations())e.Enqueue(r,-this.CalculatePotential(r,t));let i=!1;for(;!e.IsEmpty();){let r={priority:0},n=e.DequeueAndGetPriority(r);if(r.priority>=0)break;this.TryGrowHub(n,t)&&(e.Enqueue(n,-this.CalculatePotential(n,t)),i=!0)}return i}TryGrowHub(t,e){let i=this.CalculateAllowedHubRadius(t);if(t.Radius>=i)return!1;let r=e?Ge.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;if(t.Radius>=r)return!1;let o=.05*(r-t.Radius);o<1&&(o=1);let s=Math.min(t.Radius+o,i);return s<=t.Radius?!1:(t.Radius=s,!0)}CalculatePotential(t,e){let i=e?Ge.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings,t):t.cachedIdealRadius;return i<=t.Radius?0:(i-t.Radius)/i}CalculateAllowedHubRadius(t){let e=this.bundlingSettings.MaxHubRadius;for(let r of t.Neighbors){let n=r.Position.sub(t.Position).length;e=Math.min(e,n/1.05-r.Radius)}let i=this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);return i<e&&(e=i-.001),Math.max(e,.1)}static CalculateIdealHubRadius(t,e,i){let r=1;for(let n of i.Neighbors){let s=t.GetWidthSSN(n,i,e.EdgeSeparation)/2+e.EdgeSeparation;r=Math.max(r,s)}return r=Math.min(r,2*e.MaxHubRadius),r}static CalculateIdealHubRadiusWithNeighborsMBS(t,e,i){return Ge.CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,i.Position)}static CalculateIdealHubRadiusWithNeighborsMBNP(t,e,i,r){let n=Ge.CalculateIdealHubRadius(t,e,i);if(i.Neighbors.length>1){let o=i.Neighbors;for(let s=0;s<o.length;s++){let a=o[s],u=o[(s+1)%o.length];n=Math.max(n,Ge.GetMinRadiusForTwoAdjacentBundles(n,i,r,a,u,t,e))}}return n=Math.min(n,2*e.MaxHubRadius),n}static CalculateIdealHubRadiusWithAdjacentEdges(t,e){let i=t.MaxHubRadius;for(let r of e.Neighbors)i=Math.min(i,e.Position.sub(r.Position).length/2);return i}static GetMinRadiusForTwoAdjacentBundles(t,e,i,r,n,o,s){let a=o.GetWidthSSN(e,r,s.EdgeSeparation),u=o.GetWidthSSN(e,n,s.EdgeSeparation);return Ge.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,i,r.Position,n.Position,a,u,s)}static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t,e,i,r,n,o,s){if(n<m.distanceEpsilon||o<m.distanceEpsilon)return t;let a=c.anglePCP(i,e,r);if(a=Math.min(a,Math.PI*2-a),a<m.distanceEpsilon)return 2*s.MaxHubRadius;if(a>=Math.PI/2)return t*1.05;let u=Math.sin(a),h=Math.cos(a),d=n/(4*u),g=o/(4*u),f=2*Math.sqrt(d*d+(g*g+2*(d*(g*h))));return f=Math.min(f,2*s.MaxHubRadius),f=Math.max(f,t),f}};var Sn=class{constructor(t,e,i,r){this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=i,this.cdt=r}InitializeCostCache(){for(let t of this.metroGraphData.VirtualStations())t.cachedIdealRadius=Ge.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(let t of this.metroGraphData.VirtualEdges()){let e=t[0],i=t[1],r=this.metroGraphData.GetIjInfo(e,i);r.cachedBundleCost=this.costCalculator.BundleCost(e,i,e.Position),e.cachedBundleCost+=r.cachedBundleCost,i.cachedBundleCost+=r.cachedBundleCost}}UpdateCostCache(t){let e=this.cdt.getRectangleNodeOnTriangles();t.cdtTriangle=e.FirstHitNodeWithPredicate(t.Position,Sn.testPointInside).UserData,t.cachedIdealRadius=Ge.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,t),t.cachedRadiusCost=this.costCalculator.RadiusCost(t,t.Position),t.cachedBundleCost=0;for(let i of t.Neighbors){i.IsReal||(i.cachedIdealRadius=Ge.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData,this.bundlingSettings,i),i.cachedRadiusCost=this.costCalculator.RadiusCost(i,i.Position));let r=this.metroGraphData.GetIjInfo(t,i);i.cachedBundleCost-=r.cachedBundleCost,r.cachedBundleCost=this.costCalculator.BundleCost(t,i,t.Position),t.cachedBundleCost+=r.cachedBundleCost,i.cachedBundleCost+=r.cachedBundleCost}}static testPointInside(t,e){return ne.PointIsInsideOfTriangle(t,e)?1:0}};var Oo=class{constructor(){this.mainMap=new Map}get isEmpty(){return this.mainMap.size===0||this.everyMapIsEmpty()}everyMapIsEmpty(){for(let t of this.mainMap.values())if(t.size)return!1;return!0}get(t,e){let i=this.mainMap.get(t);if(i)return i.get(e)}has(t,e){let i=this.mainMap.get(t);return i?i.has(e):!1}set(t,e,i){let r=this.mainMap.get(t);r||(r=new Map,this.mainMap.set(t,r)),r.set(e,i)}*[Symbol.iterator](){for(let[t,e]of this.mainMap)for(let[i,r]of e)yield[t,i,r]}*keys(){for(let[t,e]of this.mainMap)for(let[i]of e)yield[t,i]}};var za=class{constructor(t,e,i,r,n,o,s,a){this.cachedEnterableLooseForEnd=new ve;this.bundlingSettings=r,this.regularEdges=t,n!=null?this.cdt=n:this.cdt=Ta(e),this.EdgeLooseEnterable=o,this.EdgeTightEnterable=s,this.LoosePolylineOfPort=a,this.looseIntersections=new At(this,r,e,u=>u.getELP()),this.tightIntersections=new At(this,r,i,u=>u.EnterableTightPolylines),this.cdtIntersections=new wo(this,r),this.Initialize(!1)}get Ink(){return this.ink}get Edges(){return this.regularEdges}VirtualStations(){return Array.from(this.Stations).filter(t=>!t.IsReal)}get Metrolines(){return this.metrolines}get LooseTree(){return this.looseIntersections.obstacleTree}get TightTree(){return this.tightIntersections.obstacleTree}*VirtualEdges(){for(let t of this.edgeInfoDictionary.keys())yield t}RealEdgeCount(t,e){let i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],r=this.edgeInfoDictionary.get(i[0],i[1]);return r?r.Count:0}MetroNodeInfosOfNode(t){return t.MetroNodeInfos}GetIjInfo(t,e){let i=t.SerialNumber<e.SerialNumber?[t,e]:[e,t];return this.edgeInfoDictionary.get(i[0],i[1])}MoveNode(t,e){let i=t.Position;this.PointToStations.deleteP(i),this.PointToStations.set(e,t),t.Position=e;for(let r of this.MetroNodeInfosOfNode(t))r.PolyPoint.point=e;for(let r of this.MetroNodeInfosOfNode(t)){let n=r.Metroline,o=r.PolyPoint.prev.point,s=r.PolyPoint.next.point;n.Length+=s.sub(e).length+o.sub(e).length-s.sub(i).length-o.sub(i).length}for(let r of t.Neighbors)this.ink+=e.sub(r.Position).length-i.sub(r.Position).length;this.SortNeighbors(t);for(let r of t.Neighbors)this.SortNeighbors(r)}GetWidthSSN(t,e,i){let r=t.SerialNumber<e.SerialNumber?[t,e]:[e,t],n=this.edgeInfoDictionary.get(r[0],r[1]);return n?n.Width+(n.Count-1)*i:0}GetWidthAN(t,e){let i=0;for(let n of t)i+=n.Width;let r=t.length;return i+=r>0?(r-1)*e:0,i}Initialize(t){this.SimplifyRegularEdges(),this.InitializeStationData(),this.InitializeEdgeData(),this.InitializeVirtualGraph(),this.InitializeEdgeNodeInfo(t),this.InitializeCdtInfo()}SimplifyRegularEdges(){for(let t of this.regularEdges)this.SimplifyRegularEdge(t)}SimplifyRegularEdge(t){let e=t.curve,i=new Th.Stack,r=new ie;for(let n=e.endPoint;n!=null;n=n.prev){let o=n.point;if(r.has(n.point)){let s=n.next;do{let a=i.top;if(!a.equal(o))r.delete(a),i.pop(),s=s.next;else break}while(!0);s.prev=n.prev,s.prev.next=s}else i.push(o),r.add(o)}}InitializeStationData(){this.Stations=[],this.PointToStations=new ve;for(let t of this.regularEdges){let e=t.curve;this.ProcessPolylinePoints(e)}}ProcessPolylinePoints(t){let e=t.startPoint;for(this.RegisterStation(e,!0),e=e.next;e!==t.endPoint;e=e.next)this.RegisterStation(e,!1);this.RegisterStation(e,!0)}RegisterStation(t,e){if(!this.PointToStations.has(t.point)){let i=new Ha(this.Stations.length,e,t.point);this.PointToStations.set(t.point,i),this.Stations.push(i)}}InitializeEdgeData(){this.metrolines=new Array;for(let t=0;t<this.regularEdges.length;t++){let e=this.regularEdges[t];this.InitEdgeData(e,t)}}InitEdgeData(t,e){let i=new Fa(t.curve,this.bundlingSettings.ActualEdgeWidth(t),this.EdgeSourceAndTargetFunc(t),e);this.metrolines.push(i),this.PointToStations.get(i.Polyline.start).BoundaryCurve=t.sourcePort.Curve,this.PointToStations.get(i.Polyline.end).BoundaryCurve=t.targetPort.Curve}EdgeSourceAndTargetFunc(t){return()=>[this.LoosePolylineOfPort(t.sourcePort),this.LoosePolylineOfPort(t.targetPort)]}InitializeVirtualGraph(){let t=new Map;for(let e of this.metrolines){let i=this.PointToStations.get(e.Polyline.start),r;for(let n=e.Polyline.startPoint;n.next!=null;n=n.next,i=r)r=this.PointToStations.get(n.next.point),xn(t,i,r),xn(t,r,i)}for(let e of this.Stations)e.Neighbors=Array.from(t.get(e))}GetUnorderedIjInfo(t,e){return t.SerialNumber<e.SerialNumber?this.GetCreateOrderedIjInfo(t,e):this.GetCreateOrderedIjInfo(e,t)}static closedeb(t,e){return t.Position.sub(new c(360.561,428.416)).length<.1&&e.Position.sub(new c(414.281,440.732)).length<.1}GetCreateOrderedIjInfo(t,e){let i=this.edgeInfoDictionary.get(t,e);return i||(i=new Wa,this.edgeInfoDictionary.set(t,e,i),i)}InitializeEdgeNodeInfo(t){this.edgeInfoDictionary=new Oo,this.InitAllMetroNodeInfos(t),this.SortAllNeighbors(),this.InitEdgeIjInfos(),this.ink=0;for(let e of this.VirtualEdges())this.ink+=e[0].Position.sub(e[1].Position).length}InitAllMetroNodeInfos(t){for(let e=0;e<this.metrolines.length;e++){let i=this.metrolines[e];this.InitMetroNodeInfos(i),this.InitNodeEnterableLoosePolylines(i,this.regularEdges[e]),t&&this.InitNodeEnterableTightPolylines(i,this.regularEdges[e]),i.UpdateLengths()}}InitMetroNodeInfos(t){for(let e=t.Polyline.startPoint;e!=null;e=e.next){let i=this.PointToStations.get(e.point);i.MetroNodeInfos.push(new ka(t,i,e))}}InitNodeEnterableLoosePolylines(t,e){let i=this.EdgeLooseEnterable!=null?this.EdgeLooseEnterable.get(e):new Set;for(let r=t.Polyline.startPoint.next;r!=null&&r.next!=null;r=r.next){let n=this.PointToStations.get(r.point);n.getELP()!=null?n.setELP(Si(n.getELP(),i)):n.setELP(new Set(i))}this.AddLooseEnterableForMetrolineStartEndPoints(t)}AddLooseEnterableForMetrolineStartEndPoints(t){this.AddLooseEnterableForEnd(t.Polyline.start),this.AddLooseEnterableForEnd(t.Polyline.end)}AddTightEnterableForMetrolineStartEndPoints(t){this.AddTightEnterableForEnd(t.Polyline.start),this.AddTightEnterableForEnd(t.Polyline.end)}AddLooseEnterableForEnd(t){let e=this.PointToStations.get(t);if(this.cachedEnterableLooseForEnd.has(t))e.setELP(this.cachedEnterableLooseForEnd.get(t));else{for(let i of this.LooseTree.AllHitItems_(t))p.PointRelativeToCurveLocation(t,i)===2&&e.AddEnterableLoosePolyline(i);this.cachedEnterableLooseForEnd.set(t,e.getELP())}}AddTightEnterableForEnd(t){let e=this.PointToStations.get(t);for(let i of this.TightTree.AllHitItems_(t))p.PointRelativeToCurveLocation(t,i)===2&&e.AddEnterableTightPolyline(i)}InitNodeEnterableTightPolylines(t,e){let i=this.EdgeTightEnterable!=null?this.EdgeTightEnterable.get(e):new Set;for(let r=t.Polyline.startPoint.next;r!=null&&r.next!=null;r=r.next){let n=this.PointToStations.get(r.point),o=n.EnterableTightPolylines;o!=null?n.EnterableTightPolylines=Si(o,i):n.EnterableTightPolylines=new Set(i)}this.AddTightEnterableForMetrolineStartEndPoints(t)}SortAllNeighbors(){for(let t of this.Stations)this.SortNeighbors(t)}SortNeighbors(t){if(t.Neighbors.length<=2)return;let e=t.Neighbors[0].Position,i=t.Position;t.Neighbors.sort((r,n)=>er(e.sub(i),r.Position.sub(i),n.Position.sub(i)))}InitEdgeIjInfos(){for(let t of this.metrolines){let e=t.Polyline,i=this.PointToStations.get(e.start),r;for(let n=t.Polyline.startPoint;n.next!=null;n=n.next,i=r){r=this.PointToStations.get(n.next.point);let o=this.GetUnorderedIjInfo(i,r);o.Width+=t.Width,o.Metrolines.push(t)}}}InitializeCdtInfo(){let t=this.cdt.getRectangleNodeOnTriangles();for(let e of this.Stations)e.cdtTriangle=t.FirstHitNodeWithPredicate(e.Position,Sn.testPointInside).UserData}PointIsAcceptableForEdge(t,e){if(this.LoosePolylineOfPort==null)return!0;let i=t.sourceAndTargetLoosePolylines();return p.PointRelativeToCurveLocation(e,i[0])===0&&p.PointRelativeToCurveLocation(e,i[1])===0}};function er(l,t,e){let i=c.crossProduct(l,e),r=l.dot(e),n=c.crossProduct(l,t),o=l.dot(t);return N(n,0)&&Ps(o,0)?N(i,0)&&Ps(r,0)?0:1:N(i,0)&&Ps(r,0)?-1:N(n,0)||N(i,0)||n*i>0?Bo(c.crossProduct(e,t),0):-Bo(Math.sign(n),0)}function Ps(l,t){return Bo(l,t)>=0}var wh=J(ai(),1);var tr=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static InkError(t,e,i){return(t-e)*i.InkImportance}static PathLengthsError(t,e,i,r){return(t-e)*(r.PathLengthImportance/i)}static RError(t,e,i){return t<=e?0:i.HubRepulsionImportance*((1-e/t)*(t-e))}static BundleError(t,e,i){return t<=e?0:i.BundleRepulsionImportance*((1-e/t)*(t-e))}static Cost(t,e){let i=e.InkImportance*t.Ink;for(let r of t.Metrolines)i+=e.PathLengthImportance*r.Length/r.IdealLength;return i+=this.CostOfForces(t),i}static CostOfForces(t){let e=0;for(let i of t.VirtualStations())e=e+i.cachedRadiusCost;for(let i of t.VirtualEdges()){let r=i[0],n=i[1];e+=t.GetIjInfo(r,n).cachedBundleCost}return e}InkGain(t,e){let i=this.metroGraphData.Ink,r=this.metroGraphData.Ink;for(let n of t.Neighbors){let o=n.Position;r-=o.sub(t.Position).length,r+=o.sub(e).length}return tr.InkError(i,r,this.bundlingSettings)}PathLengthsGain(t,e){let i=0;for(let r of this.metroGraphData.MetroNodeInfosOfNode(t)){let n=r.Metroline.Length,o=r.PolyPoint.prev.point,s=r.PolyPoint.next.point,a=r.Metroline.Length+s.sub(e).length+o.sub(e).length-s.sub(t.Position).length-o.sub(t.Position).length;i+=tr.PathLengthsError(n,a,r.Metroline.IdealLength,this.bundlingSettings)}return i}RadiusGain(t,e){let i=0;return i=i+t.cachedRadiusCost,i=i-this.RadiusCost(t,e),i}RadiusCost(t,e){let i;c.closeDistEps(t.Position,e)?i=t.cachedIdealRadius:i=Ge.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData,this.bundlingSettings,t,e);let r={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,e,i,r))return tr.Inf;let n=0;for(let o of r.touchedObstacles){let s=o[1].sub(e).length;n+=tr.RError(i,s,this.bundlingSettings)}return n}BundleGain(t,e){let i=t.cachedBundleCost;for(let r of t.Neighbors){let n=this.BundleCost(t,r,e);if(Ps(n,tr.Inf))return-tr.Inf;i-=n}return i}BundleCost(t,e,i){let r=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),n={closestDist:[]};if(!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,i,e.Position,r,n))return tr.Inf;let o=0;for(let s of n.closestDist){let a=s[0].sub(s[1]).length;o+=tr.BundleError(r/2,a,this.bundlingSettings)}return o}},ht=tr;ht.Inf=1e9;var Ah=J(Mi(),1);var qa=class{constructor(t){this.polylineToEdgeGeom=new Map;this.pathsThroughPoints=new ve;this.interestingPoints=new ie;this.metroGraphData=t}get Polylines(){return Array.from(this.polylineToEdgeGeom.keys())}Run(){this.Init(),this.SwitchFlips()}Init(){for(let t of this.metroGraphData.Edges)this.polylineToEdgeGeom.set(t.curve,t);for(let t of this.Polylines)this.RegisterPolylinePointInPathsThrough(t.polylinePoints())}RegisterPolylinePointInPathsThrough(t){for(let e of t)this.RegisterPolylinePointInPathsThroughP(e)}RegisterPolylinePointInPathsThroughP(t){od(this.pathsThroughPoints,t.point,t)}UnregisterPolylinePointsInPathsThrough(t){for(let e of t)this.UnregisterPolylinePointInPathsThrough(e)}UnregisterPolylinePointInPathsThrough(t){sd(this.pathsThroughPoints,t.point,t)}SwitchFlips(){let t=new Set(this.Polylines),e=new Ah.Queue;for(let i of this.Polylines)e.enqueue(i);for(;e.length>0;){let i=e.dequeue();t.delete(i);let r=this.ProcessPolyline(i);r!=null&&(t.has(i)||(t.add(i),e.enqueue(i)),t.has(r)||(t.add(r),e.enqueue(r)))}}ProcessPolyline(t){let e=new Map;for(let i=t.startPoint.next;i!=null;i=i.next){this.FillDepartedPolylinePoints(i,e);for(let r of this.pathsThroughPoints.get(i.point)){let n=e.get(r.polyline);if(n){if(this.ProcessFlip(i,n))return r.polyline;e.delete(r.polyline)}}}return null}FillDepartedPolylinePoints(t,e){let i=t.prev.point;for(let r of this.pathsThroughPoints.get(i))this.IsNeighborOnTheSamePolyline(r,t)||e.has(r.polyline)||e.set(r.polyline,r)}ProcessFlip(t,e){let i=t.polyline,r=e.polyline,n=t.point,o=e.point,s=this.polylineToEdgeGeom.get(i),a=this.polylineToEdgeGeom.get(r);if(s.lineWidth!==a.lineWidth||this.metroGraphData.EdgeLooseEnterable==null||!vn(this.metroGraphData.EdgeLooseEnterable.get(s),this.metroGraphData.EdgeLooseEnterable.get(a)))return!1;let u=this.FindPointsOnPolyline(i,n,o),h=u[0],d=u[1],g=u[2];u=this.FindPointsOnPolyline(r,n,o);let f=u[0],P=u[1],y=u[2],w=this.FindRelationOnFirstPoint(h,f,g,y),x=this.FindRelationOnLastPoint(d,P,g,y);return w!==2&&x!==2||w===1||x===1?!1:(this.UnregisterPolylinePointsInPathsThrough(i.polylinePoints()),this.UnregisterPolylinePointsInPathsThrough(r.polylinePoints()),this.Swap(h,f,d,P,g,y),this.RegisterPolylinePointInPathsThrough(i.polylinePoints()),this.RegisterPolylinePointInPathsThrough(r.polylinePoints()),this.RegisterInterestingPoint(h.point),this.RegisterInterestingPoint(d.point),this.numberOfReducedCrossings++,!0)}FindPointsOnPolyline(t,e,i){let r,n;for(let o=t.startPoint;o!=null;o=o.next)if(r==null)if(o.point.equal(e)){if(n!=null)return[o,n,!1];r=o}else n==null&&o.point.equal(i)&&(n=o);else if(o.point.equal(i))return[r,o,!0]}PolylinePointsAreInForwardOrder(t,e){for(let i=t;i!=null;i=i.next)if(i===e)return!0;return!1}Next(t,e){return e?t.next:t.prev}Prev(t,e){return e?t.prev:t.next}FindRelationOnFirstPoint(t,e,i,r){let n=t,o=e;for(;;){let s=this.Prev(t,i),a=this.Prev(e,r);if(s==null||a==null)return 0;if(!s.point.equal(a.point))break;t=s,e=a}return this.PolylinesIntersect(n,o,t,e,i,r)}FindRelationOnLastPoint(t,e,i,r){let n=t,o=e;for(;;){let s=this.Next(t,i),a=this.Next(e,r);if(s==null||a==null)return 0;if(!s.point.equal(a.point))break;t=s,e=a}for(;this.Next(t,i).point.equal(this.Prev(e,r).point);)t=this.Next(t,i),e=this.Prev(e,r);return this.PolylinesIntersect(t,e,n,o,i,r)}PolylinesIntersect(t,e,i,r,n,o){let s=this.Prev(t,n),a=this.Next(t,n),u=this.Next(i,n),h=this.Prev(i,n),d=this.Next(e,o),g=this.Prev(r,o);if(t.point.equal(i.point)){let f=t.point,P=er(h.point.sub(f),g.point.sub(f),a.point.sub(f)),y=er(h.point.sub(f),d.point.sub(f),a.point.sub(f));return P===y?1:2}else{let f=er(s.point.sub(t.point),a.point.sub(t.point),d.point.sub(t.point)),P=er(u.point.sub(i.point),g.point.sub(i.point),h.point.sub(i.point));return f===P?1:2}}Swap(t,e,i,r,n,o){let s=this.GetRangeOnPolyline(this.Next(t,n),i,n),a=this.GetRangeOnPolyline(this.Next(e,o),r,o);this.ChangePolylineSegment(t,i,n,a),this.ChangePolylineSegment(e,r,o,s),xr.RemoveSelfCyclesFromPolyline(t.polyline),xr.RemoveSelfCyclesFromPolyline(e.polyline)}ChangePolylineSegment(t,e,i,r){let n=t;for(let o of r){let s=Ne.mkFromPoint(o.point);s.polyline=n.polyline,i?(s.prev=n,n.next=s):(s.next=n,n.prev=s),n=s}i?(n.next=e,e.prev=n):(n.prev=e,e.next=n)}GetRangeOnPolyline(t,e,i){let r=new Array;for(let n=t;n!==e;n=this.Next(n,i))r.push(n);return r}IsNeighborOnTheSamePolyline(t,e){return t.prev!=null&&t.prev.point.equal(e.point)||t.next!=null&&t.next.point.equal(e.point)}RegisterInterestingPoint(t){this.interestingPoints.has(t)||this.interestingPoints.add(t)}GetChangedHubs(){return this.interestingPoints}NumberOfReducedCrossings(){return this.numberOfReducedCrossings}PolylineIsOK(t){let e=new ie;for(let i=t.startPoint;i!=null;i=i.next){if(i===t.startPoint){if(i.prev!=null)return!1}else if(i.prev.next!==i)return!1;if(i===t.endPoint){if(i.next!=null)return!1}else if(i.next.prev!==i)return!1;if(e.has(i.point))return!1;e.add(i.point)}return!(t.startPoint.prev!=null||t.endPoint.next!=null)}};function od(l,t,e){let i=l.get(t);i||(i=new Set,l.set(t,i)),i.add(e)}function sd(l,t,e){let i=l.get(t);!i||(i.delete(e),i.size===0&&l.deleteP(t))}var xr=class{constructor(t,e){this.foundCrossings=new ie;this.crossingsThatShouldBecomeHubs=new ie;this.metroGraphData=t,this.polylineAcceptsPoint=e}*Vertices(){for(let t of this.Polylines)for(let e of t.polylinePoints())yield e}get Polylines(){return this.metroGraphData.Edges.map(t=>t.curve)}Edges(){let t=new Gt;for(let e of this.Vertices())e.next&&t.set(new he(e.point,e.next.point),0);return Array.from(t.keys())}run(){if(this.metroGraphData.Edges.length===0)return!1;let t=new Gt,e=new ki(null);for(let s of this.Vertices()){let a=I.mkOnPoints([s.point]);a.pad(m.intersectionEpsilon),e.Add(a,s.point)}let i=or(this.Edges(),s=>I.mkPP(s.first,s.second));Be(i,i,(s,a)=>this.IntersectTwoEdges.bind(s,a,t,e)),this.SortInsertedPoints(t);let r=this.InsertPointsIntoPolylines(t),n=this.FixPaths(),o=this.RemoveUnimportantCrossings();return n||r||o}FixPaths(){let t=!1;return this.RemoveSelfCycles()&&(t=!0),this.ReduceEdgeCrossings()&&(t=!0),t}SortInsertedPoints(t){for(let e of t)this.SortInsideSegment(e[0],e[1])}SortInsideSegment(t,e){e.sort((i,r)=>Q(te(i,t.first),te(r,t.first)))}InsertPointsIntoPolylines(t){let e=!1;for(let i of this.metroGraphData.Metrolines)return this.InsertPointsIntoPolyline(i,t)&&(e=!0),e}InsertPointsIntoPolyline(t,e){let i=!1;for(let r=t.Polyline.startPoint;r.next!=null;r=r.next)this.InsertPointsOnPolypoint(r,e,t)&&(i=!0);return i}InsertPointsOnPolypoint(t,e,i){let r=new he(t.point,t.next.point),n=t.point!==r.first,o=e.get(r);if(!o)return!1;let s=t.next,a=t.polyline;if(n)for(let u=o.length-1;u>=0;u--){if(this.polylineAcceptsPoint!=null&&!this.polylineAcceptsPoint(i,o[u]))continue;let h=Ne.mkFromPoint(o[u]);h.prev=t,h.polyline=a,t.next=h,t=h}else for(let u=0;u<o.length;u++){if(this.polylineAcceptsPoint!=null&&!this.polylineAcceptsPoint(i,o[u]))continue;let h=Ne.mkFromPoint(o[u]);h.prev=t,h.polyline=a,t.next=h,t=h}return t.next=s,s.prev=t,!0}RemoveSelfCycles(){let t=!1;for(let e of this.Polylines)xr.RemoveSelfCyclesFromPolyline(e)&&(t=!0);return t}static RemoveSelfCyclesFromPolyline(t){let e=!1,i=new ve;for(let r=t.startPoint;r!=null;r=r.next){let n=r.point,o=i.get(n);if(o){for(let s=o.next;s!==r.next;s=s.next)i.deleteP(s.point);o.next=r.next,r.next.prev=o,e=!0}else i.set(r.point,r)}return e}ReduceEdgeCrossings(){let t=new qa(this.metroGraphData);t.Run();for(let e of t.GetChangedHubs())this.crossingsThatShouldBecomeHubs.add(e);return t.NumberOfReducedCrossings()>0}RemoveUnimportantCrossings(){let t=!1;this.pointsToDelete=hu(this.foundCrossings,this.crossingsThatShouldBecomeHubs);for(let e of this.Polylines)this.RemoveUnimportantCrossingsFromPolyline(e)&&(t=!0);return t}RemoveUnimportantCrossingsFromPolyline(t){let e=!1;for(let i=t.startPoint.next;i!=null&&i.next!=null;i=i.next)if(this.pointsToDelete.has(i.point)&&c.getTriangleOrientation(i.prev.point,i.point,i.next.point)===2){let r=i.prev,n=i.next;r.next=n,n.prev=r,i=r,e=!0}return e}IntersectTwoEdges(t,e,i,r){let n=S.IntersectPPPP(t.first,t.second,e.first,e.second);if(n){let o=this.FindExistingVertexOrCreateNew(r,n);(this.AddVertexToSplittingList(t,i,o)||this.AddVertexToSplittingList(e,i,o))&&this.foundCrossings.add(o)}}FindExistingVertexOrCreateNew(t,e){let i=t.RootNode.FirstHitNode(e);if(i!=null)return i.UserData;let r=I.mkOnPoints([e]);return r.pad(m.intersectionEpsilon),t.Add(r,e),e}AddVertexToSplittingList(t,e,i){if(!p.closeIntersectionPoints(i,t.first)&&!p.closeIntersectionPoints(i,t.second)){let r=e.get(t);if(r||(r=new Array,e.set(t,r)),!r.find(n=>n.equal(i)))return r.push(i),!0}return!1}};var bs=class{isCorrectlyOrienected(){return c.getTriangleOrientation(this.Curve.boundingBox.center,this.Curve.value(this.parEnd),this.Curve.value(this.parStart))!==1}get Count(){return this.points.length}constructor(t,e,i,r){this.BelongsToRealNode=r,this.Curve=e,this.Position=i,this.points=new Array(t),this.tangents=new Array(t),this.OrientedHubSegments=new Array(t)}get CurveCenter(){return this.Curve.boundingBox.center}get OppositeBase(){return this.OutgoingBundleInfo!=null?this.OutgoingBundleInfo.TargetBase:this.IncomingBundleInfo.SourceBase}get length(){return this.points.length}get Points(){return this.points}get Tangents(){return this.tangents}get InitialMidParameter(){return this.initialMidParameter}set InitialMidParameter(t){this.initialMidParameter=t,this.InitialMidPoint=this.Curve.value(t)}get ParStart(){return this.parStart}set ParStart(t){this.parStart=t,this.StartPoint=this.Curve.value(this.parStart)}get ParEnd(){return this.parEnd}set ParEnd(t){this.parEnd=t,this.EndPoint=this.Curve.value(this.parEnd)}get ParMid(){return(this.parStart+this.parEnd)/2}get MidPoint(){return c.middle(this.StartPoint,this.EndPoint)}get Span(){return this.SpanBetweenTwoParameters(this.parStart,this.parEnd)}SpanBetweenTwoParameters(t,e){return t<=e?e-t:e-t+Zt(this.Curve)}RotateLeftPoint(t,e){return t===0?this.EndPoint:this.RotatePoint(t,this.parEnd,e)}RotateRigthPoint(t,e){return t===0?this.StartPoint:this.RotatePoint(t,this.parStart,e)}RotatePoint(t,e,i){let r=Zt(this.Curve)*i;return e+=t*r,e=this.AdjustParam(e),this.Curve.value(e)}AdjustParam(t){return t>this.Curve.parEnd?t=this.Curve.parStart+(t-this.Curve.parEnd):t<this.Curve.parStart&&(t=this.Curve.parEnd-(this.Curve.parStart-t)),t}RotateBy(t,e,i){let r=Zt(this.Curve)*i;t!==0&&(this.ParStart=this.AdjustParam(this.ParStart+t*r)),e!==0&&(this.ParEnd=this.AdjustParam(this.ParEnd+e*r))}RelativeOrderOfBasesIsPreserved(t,e,i){let r=Zt(this.Curve)*i,n=this.parStart+t*r,o=this.parStart<this.parEnd?this.parEnd+e*r:this.parEnd+Zt(this.Curve)+e*r;if(n>o||this.SpanBetweenTwoParameters(n,o)>Zt(this.Curve)/2)return!1;if(this.Prev==null||this.SpanBetweenTwoParameters(this.Prev.ParMid,this.ParMid)>r&&this.SpanBetweenTwoParameters(this.ParMid,this.Next.ParMid)>r)return!0;let s=this.RotateLeftPoint(e,i),a=this.RotateRigthPoint(t,i),u=c.middle(s,a),h=this.MidPoint;return!(c.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,h)!=c.getTriangleOrientation(this.CurveCenter,this.Prev.MidPoint,u)||c.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,h)!=c.getTriangleOrientation(this.CurveCenter,this.Next.MidPoint,u))}};var Qn=class{constructor(t,e,i,r){this.SourceBase=t,this.TargetBase=e,this.obstaclesToIgnore=i,this.HalfWidthArray=r,this.TotalRequiredWidth=this.HalfWidthArray.reduce((o,s)=>o+s,0)*2,this.longEnoughSideLength=t.Curve.boundingBox.addRec(e.Curve.boundingBox).diagonal;let n=Math.max(t.Curve.boundingBox.diagonal,e.Curve.boundingBox.diagonal);if(this.TotalRequiredWidth>n){let o=this.TotalRequiredWidth/n;for(let s=0;s<this.HalfWidthArray.length;s++)this.HalfWidthArray[s]/=o;this.TotalRequiredWidth/=o}}SetParamsFeasiblySymmetrically(t){this.CalculateTightObstaclesForBundle(t,this.obstaclesToIgnore),this.SetEndParamsSymmetrically()}CalculateTightObstaclesForBundle(t,e){let i=this.SourceBase.Curve.boundingBox.diagonal/2,r=this.TargetBase.Curve.boundingBox.diagonal/2,n=At.Create4gon(this.SourceBase.Position,this.TargetBase.Position,i*2,r*2);this.tightObstaclesInTheBoundingBox=Array.from(t.AllHitItems(n.boundingBox,o=>!e.has(o)&&p.ClosedCurveInteriorsIntersect(n,o)))}SetEndParamsSymmetrically(){let t=this.TargetBase.Position,e=this.SourceBase.Position,i=t.sub(e).normalize(),r=i.rotate90Ccw(),n=c.middle(t,e),o=i.mul(this.longEnoughSideLength),s=n.add(o),a=n.sub(o);if(this.SetRLParamsIfWidthIsFeasible(r.mul(this.TotalRequiredWidth/2),s,a)){this.SetInitialMidParams();return}let u=this.TotalRequiredWidth,h=0,d=u/2;for(;u-h>Qn.FeasibleWidthEpsilon;)this.SetRLParamsIfWidthIsFeasible(r.mul(d/2),s,a)?h=d:u=d,d=.5*(u+h);d<=Qn.FeasibleWidthEpsilon&&(this.SetRLParamsIfWidthIsFeasible_(r.mul(Qn.FeasibleWidthEpsilon),new c(0,0),s,a)||this.SetRLParamsIfWidthIsFeasible_(new c(0,0),r.mul(-Qn.FeasibleWidthEpsilon),s,a))&&(d=2*Qn.FeasibleWidthEpsilon),this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParStart+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParStart+this.TargetBase.Span/2)}mkNameFromLRST(){return"./tmp/leftRight"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}SetRLParamsIfWidthIsFeasible(t,e,i){return this.SetRLParamsIfWidthIsFeasible_(t,t.neg(),e,i)}SetRLParamsIfWidthIsFeasible_(t,e,i,r){let n={par:0},o={par:0},s={par:0},a={par:0},u=this.TrimSegWithBoundaryCurves(S.mkPP(i.add(t),r.add(t)),o,s);return u==null||this.tightObstaclesInTheBoundingBox.find(d=>p.intersectionOne(u,d,!1)!=null)||(u=this.TrimSegWithBoundaryCurves(S.mkPP(i.add(e),r.add(e)),a,n),u==null)||this.tightObstaclesInTheBoundingBox.find(d=>p.intersectionOne(u,d,!1)!=null)?!1:(this.SourceBase.IsParent?(this.SourceBase.ParStart=o.par,this.SourceBase.ParEnd=a.par):(this.SourceBase.ParStart=a.par,this.SourceBase.ParEnd=o.par),this.TargetBase.IsParent?(this.TargetBase.ParStart=n.par,this.TargetBase.ParEnd=s.par):(this.TargetBase.ParStart=s.par,this.TargetBase.ParEnd=n.par),!0)}SetInitialMidParams(){let t={par:0},e={par:0};this.TrimSegWithBoundaryCurves(S.mkPP(this.TargetBase.CurveCenter,this.TargetBase.CurveCenter),e,t)!=null?(this.SourceBase.InitialMidParameter=e.par,this.TargetBase.InitialMidParameter=t.par):(this.SourceBase.InitialMidParameter=this.SourceBase.AdjustParam(this.SourceBase.ParStart+this.SourceBase.Span/2),this.TargetBase.InitialMidParameter=this.TargetBase.AdjustParam(this.TargetBase.ParStart+this.TargetBase.Span/2))}mkNameFromST(){return"./tmp/mparam"+this.SourceBase.Position.toString()+"_"+this.TargetBase.Position.toString()+".svg"}TrimSegWithBoundaryCurves(t,e,i){let r=p.getAllIntersections(t,this.SourceBase.Curve,!0);if(r.length===0)return i.par=0,e.par=0,null;let n;if(r.length===1?n=r[0]:this.SourceBase.IsParent?n=r[0].par0<r[1].par0?r[1]:r[0]:n=r[0].par0<r[1].par0?r[0]:r[1],r=p.getAllIntersections(t,this.TargetBase.Curve,!0),r.length===0)return i.par=0,e.par=0,null;let o;return r.length===1?o=r[0]:this.TargetBase.IsParent?o=r[0].par0>r[1].par0?r[1]:r[0]:o=r[0].par0>r[1].par0?r[0]:r[1],e.par=n.par1,i.par=o.par1,S.mkPP(n.x,o.x)}RotateBy(t,e,i,r,n){let o=t!==0||e!==0,s=i!==0||r!==0;o&&this.SourceBase.RotateBy(t,e,n),s&&this.TargetBase.RotateBy(i,r,n),this.UpdateSourceAndTargetBases(o,s)}UpdateSourceAndTargetBases(t,e){t&&this.UpdatePointsOnBundleBase(this.SourceBase),e&&this.UpdatePointsOnBundleBase(this.TargetBase),this.UpdateTangentsOnBases()}UpdateTangentsOnBases(){let t=this.TargetBase.length;for(let e=0;e<t;e++){let i=this.TargetBase.Points[e].sub(this.SourceBase.Points[t-1-e]),r=i.length;r>=m.tolerance&&(i=i.div(r),this.TargetBase.Tangents[e]=i,this.SourceBase.Tangents[t-1-e]=i.neg())}}UpdatePointsOnBundleBase(t){let e=t.length,i=t.Points,r=S.mkPP(t.EndPoint,t.StartPoint),n=1/this.TotalRequiredWidth,o=this.HalfWidthArray[0];i[0]=r.value(o*n);for(let s=1;s<e;s++)o+=this.HalfWidthArray[s-1]+this.HalfWidthArray[s],i[s]=r.value(o*n)}RotationIsLegal(t,e,i,r,n){if(!this.SourceBase.IsParent&&!this.TargetBase.IsParent){if(e!==0||i!==0){let o=this.SourceBase.RotateLeftPoint(e,n),s=this.TargetBase.RotateRigthPoint(i,n);if(!this.LineIsLegal(o,s))return!1}if(t!==0||r!==0){let o=this.SourceBase.RotateRigthPoint(t,n),s=this.TargetBase.RotateLeftPoint(r,n);if(!this.LineIsLegal(o,s))return!1}}else{if(e!==0||r!==0){let o=this.SourceBase.RotateLeftPoint(e,n),s=this.TargetBase.RotateLeftPoint(r,n);if(!this.LineIsLegal(o,s))return!1}if(t!==0||i!==0){let o=this.SourceBase.RotateRigthPoint(t,n),s=this.TargetBase.RotateRigthPoint(i,n);if(!this.LineIsLegal(o,s))return!1}}return!((t!==0||e!==0)&&!this.SourceBase.RelativeOrderOfBasesIsPreserved(t,e,n)||(i!==0||r!==0)&&!this.TargetBase.RelativeOrderOfBasesIsPreserved(i,r,n))}LineIsLegal(t,e){return this.tightObstaclesInTheBoundingBox.find(i=>p.intersectionOne(S.mkPP(t,e),i,!1)!=null)==null}},Ss=Qn;Ss.FeasibleWidthEpsilon=.1;var ys=class{get Segment(){return this.segment}set Segment(t){this.segment=t}constructor(t,e,i,r){this.Segment=t,this.Reversed=e,this.Index=i,this.BundleBase=r}value(t){return this.Reversed?this.Segment.value(this.Segment.parEnd-t):this.Segment.value(t)}};var le=class{constructor(t,e,i){this.fixedBundles=new Ir;this.stepsWithProgress=0;this.metroOrdering=t,this.metroGraphData=e,this.bundlingSettings=i}Run(){this.AllocateBundleBases(),this.SetBasesRightLeftParamsToTheMiddles(),this.bundlingSettings.KeepOverlaps?(this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs()):(this.SetRightLeftParamsFeasiblySymmetrically(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases(),this.CreateOrientedSegs(),this.bundlingSettings.RotateBundles&&this.RotateBundlesToDiminishCost(),this.AdjustStartEndParamsToAvoidBaseOverlaps(),this.UpdateSourceAndTargetBases())}AllocateBundleBases(){this.externalBases=new Map,this.internalBases=new Map,this.Bundles=new Array;for(let t of this.metroGraphData.Stations)t.BoundaryCurve==null&&(t.BoundaryCurve=k.mkCircle(t.Radius,t.Position));for(let t of this.metroGraphData.Stations)for(let e of t.Neighbors)if(t.SerialNumber<e.SerialNumber){let i=new bs(this.metroGraphData.RealEdgeCount(t,e),t.BoundaryCurve,t.Position,t.IsReal);t.BundleBases.set(e,i);let r=new bs(this.metroGraphData.RealEdgeCount(t,e),e.BoundaryCurve,e.Position,e.IsReal);e.BundleBases.set(t,r),p.PointRelativeToCurveLocation(e.Position,t.BoundaryCurve)!==0?(i.IsParent=!0,Tn(this.internalBases,t,i),Tn(this.externalBases,e,r)):p.PointRelativeToCurveLocation(t.Position,e.BoundaryCurve)!==0?(r.IsParent=!0,Tn(this.externalBases,t,i),Tn(this.internalBases,e,r)):(Tn(this.externalBases,t,i),Tn(this.externalBases,e,r));let n=this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(t,e),o=new Ss(i,r,n,Array.from(this.metroOrdering.GetOrder(t,e)).map(s=>s.Width/2));i.OutgoingBundleInfo=r.IncomingBundleInfo=o,this.Bundles.push(o)}this.SetBundleBaseNeighbors()}SetBundleBaseNeighbors(){for(let t of this.externalBases.keys()){let e=this.externalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}for(let t of this.internalBases.keys()){let e=this.internalBases.get(t);this.SortBundlesCounterClockwise(e),this.SetLeftRightBases(e)}}SortBundlesCounterClockwise(t){if(t.length>2){let e=t[0].OppositeBase.Position,i=t[0].CurveCenter;t.sort((r,n)=>er(e.sub(i),r.OppositeBase.Position.sub(i),n.OppositeBase.Position.sub(i)))}}SetLeftRightBases(t){let e=t.length;if(!(e<=1))for(let i=0;i<e;i++)t[i].Prev=t[(i-1+e)%e],t[i].Next=t[(i+1)%e]}CreateOrientedSegs(){for(let t of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(t)}CreateOrientedSegsOnLine(t){for(let e=t.Polyline.startPoint.next;e.next!=null;e=e.next)this.CreateOrientedSegsOnLineVertex(t,e)}CreateOrientedSegsOnLineVertex(t,e){let i=this.metroGraphData.PointToStations.get(e.prev.point),r=this.metroGraphData.PointToStations.get(e.point),n=this.metroGraphData.PointToStations.get(e.next.point),o=r.BundleBases.get(i),s=r.BundleBases.get(n),a=this.metroOrdering.GetLineIndexInOrder(i,r,t),u=this.metroOrdering.GetLineIndexInOrder(n,r,t),h=o.OrientedHubSegments[a]=new ys(null,!1,a,o),d=s.OrientedHubSegments[u]=new ys(null,!0,u,s);d.Other=h,h.Other=d}UpdateSourceAndTargetBases(){for(let t of this.Bundles)t.UpdateSourceAndTargetBases(!0,!0)}SetBasesRightLeftParamsToTheMiddles(){for(let t of this.Bundles){let e=t.SourceBase,i=t.TargetBase;e.ParEnd=e.ParStart=this.GetBaseMiddleParamInDirection(e,e.Position,i.Position),i.ParEnd=i.ParStart=this.GetBaseMiddleParamInDirection(i,i.Position,e.Position)}}GetBaseMiddleParamInDirection(t,e,i){let r=t.Curve;if(r instanceof k){let s=r;if(s.isArc())return c.angle(s.aAxis,i.sub(e))}let o=p.getAllIntersections(r,S.mkPP(e,i),!0);for(let s of o){let a=s.x;if(a.sub(e).dot(a.sub(i))<=0)return s.par0}throw new Error}SetRightLeftParamsFeasiblySymmetrically(){for(let t of this.Bundles)t.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree)}AdjustStartEndParamsToAvoidBaseOverlaps(){for(let t of this.externalBases.values())this.AdjustCurrentBundleWidthsOnCurve(t);for(let t of this.internalBases.values())this.AdjustCurrentBundleWidthsOnCurve(t)}AdjustCurrentBundleWidthsOnCurve(t){let e=t.length;if(!(e<=1))for(let i=0;i<e;i++){let r=t[i],n=r.Next;this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(r,n)}}ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(t,e){let i=ad(t,e);if(i==null||N(i.start,i.end))return;let r=i.rbaseMiddle,n=i.lbaseMiddle;if(r<n){let u=t;t=e,e=u}let o=t.Span,s=e.Span,a=(i.end*o+i.start*s)/(s+o);t.ParStart=t.AdjustParam(a+m.distanceEpsilon),e.ParEnd=e.AdjustParam(a-m.distanceEpsilon)}RegularCut(t,e,i,r,n,o){let s=(n*r+o*t)/(n+o),a=Math.min(e,r),u=Math.max(t,i);return s<u&&(s=u),s>a&&(s=a),s}RotateBundlesToDiminishCost(){let t=le.MaxParameterChange,e={cost:this.Cost()},i=0;for(;i++<le.MaxIterations;){let r=e.cost;if(this.RotateBundlesToDiminishCostOneIteration(t,e),t=this.UpdateParameterChange(t,r,e.cost),t<le.MinParameterChange)break}}UpdateParameterChange(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,this.fixedBundles.clear())):(this.stepsWithProgress=0,t*=.8,this.fixedBundles.clear()),t}RotateBundlesToDiminishCostOneIteration(t,e){let i=!1;for(let r of this.Bundles)this.fixedBundles.has(r)||(this.OptimizeBundle(r,t,e)?i=!0:this.fixedBundles.add(r));return i}OptimizeBundle(t,e,i){let r=this.CostBi(t);if(r<le.CostThreshold)return!1;let n=0,o=-1,s=-1;for(let a=0;a<le.Deltas.length-1;a++){let u=this.DeltaWithChangedAngles(le.Deltas[a][0],le.Deltas[a][1],0,0,t,r,e);u>le.CostDeltaThreshold&&u>n&&(s=a,o=le.Deltas.length-1,n=u),u=this.DeltaWithChangedAngles(0,0,le.Deltas[a][0],le.Deltas[a][1],t,r,e),u>le.CostDeltaThreshold&&u>n&&(s=le.Deltas.length-1,o=a,n=u)}return n<le.CostDeltaThreshold?!1:(i.cost-=n,t.RotateBy(le.Deltas[s][0],le.Deltas[s][1],le.Deltas[o][0],le.Deltas[o][1],e),!0)}DeltaWithChangedAngles(t,e,i,r,n,o,s){if(!n.RotationIsLegal(t,e,i,r,s))return 0;n.RotateBy(t,e,i,r,s);let a=this.CostBN(n,o);return n.RotateBy(t*-1,e*-1,i*-1,r*-1,s),o-a}CostBi(t){return le.SeparationCoeff*this.SeparationCost(t)+(le.SqueezeCoeff*this.SqueezeCost(t)+(le.AssymetryCoeff*this.AssymetryCost(t)+le.CenterCoeff*this.CenterCostBi(t)))}CostBN(t,e){let i=0;return i=i+le.CenterCoeff*this.CenterCostBi(t),i>e||(i=i+le.SeparationCoeff*this.SeparationCost(t),i>e)||(i=i+le.SqueezeCoeff*this.SqueezeCost(t),i>e)||(i=i+le.AssymetryCoeff*this.AssymetryCost(t)),i}SqueezeCost(t){let i=t.TargetBase.MidPoint.sub(t.SourceBase.MidPoint).normalize().rotate90Ccw(),r=Math.abs(t.SourceBase.StartPoint.sub(t.SourceBase.EndPoint).dot(i)),n=Math.abs(t.TargetBase.StartPoint.sub(t.TargetBase.EndPoint).dot(i)),o=Math.abs(t.TotalRequiredWidth-r)/t.TotalRequiredWidth,s=Math.abs(t.TotalRequiredWidth-n)/t.TotalRequiredWidth,a=Math.abs(r-n)/t.TotalRequiredWidth;return Math.exp(o*10)-1+(Math.exp(s*10)-1)+a}CenterCostBi(t){return!t.SourceBase.BelongsToRealNode&&!t.TargetBase.BelongsToRealNode?0:this.CenterCostBb(t.SourceBase)+this.CenterCostBb(t.TargetBase)}CenterCostBb(t){if(!t.BelongsToRealNode)return 0;let e=t.ParMid,i=Math.min(t.InitialMidParameter,e),r=Math.max(t.InitialMidParameter,e),n=Math.min(r-i,i+(Zt(t.Curve)-r));return t.CurveCenter.equal(t.Position)||t.IsParent?25*(n*n):500*(n*n)}AssymetryCost(t){return this.GetAssymetryCostForBase(t.SourceBase)+this.GetAssymetryCostForBase(t.TargetBase)}GetAssymetryCostForBase(t){if(t.BelongsToRealNode)return 0;let e=t.OppositeBase.BelongsToRealNode?200:500,i=0;for(let r of t.OrientedHubSegments){let n=r.Index,o=r.Other.Index,s=t.Points[n],a=t.Tangents[n],u=r.Other.BundleBase,h=u.Points[o],d=u.Tangents[o],g=t.Count+u.Count;i+=this.GetAssymetryCostOnData(s,a,h,d,e)/g}return i}GetAssymetryCostOnData(t,e,i,r,n){let o=t.sub(i),s=o.length;if(s<m.distanceEpsilon)return 0;let a=e.add(r).dot(o),u=c.crossProduct(o,e),h=c.crossProduct(o,r),d=u-h,g=a*a+d*d,f=u*u+h*h;return 10*g+n*f}SeparationCost(t){return this.SeparationCostForBundleBase(t.SourceBase)+this.SeparationCostForBundleBase(t.TargetBase)}SeparationCostForBundleBase(t){return t.Prev==null?0:this.SeparationCostForAdjacentBundleBases(t,t.Prev)+this.SeparationCostForAdjacentBundleBases(t,t.Next)}SeparationCostForAdjacentBundleBases(t,e){let i=t.Curve,r=this.IntervalsOverlapLength(t.ParStart,t.ParEnd,e.ParStart,e.ParEnd,i),n=Math.min(t.Span,e.Span);return Math.exp(r/(n*10))-1}IntervalsOverlapLength(t,e,i,r,n){let o=n.parStart,s=n.parEnd;return t<e?i<r?this.IntersectRegularIntervals(t,e,i,r):this.IntersectRegularIntervals(t,e,i,s)+this.IntersectRegularIntervals(t,e,o,r):i<r?this.IntersectRegularIntervals(t,s,i,r)+this.IntersectRegularIntervals(o,e,i,r):this.IntersectRegularIntervals(t,s,i,s)+this.IntersectRegularIntervals(o,e,o,r)}IntersectRegularIntervals(t,e,i,r){let n=Math.max(t,i),o=Math.min(e,r);return n<o?o-n:0}Cost(){let t=0;for(let e of this.Bundles){let i=le.SeparationCoeff*this.SeparationCost(e),r=le.AssymetryCoeff*this.AssymetryCost(e),n=le.SqueezeCoeff*this.SqueezeCost(e),o=le.CenterCoeff*this.CenterCostBi(e);t+=(i+r)/2+n+o}return t}},_t=le;_t.Deltas=[[1,-1],[1,-1]],_t.SeparationCoeff=1,_t.SqueezeCoeff=1,_t.CenterCoeff=10,_t.AssymetryCoeff=1,_t.MaxIterations=200,_t.MaxParameterChange=8/360,_t.MinParameterChange=.1/360,_t.CostThreshold=1e-5,_t.CostDeltaThreshold=.01;function ad(l,t){let e=Zt(l.Curve),i=l.ParEnd,r=l.ParStart<l.ParEnd?l.ParStart:l.ParStart-e,n=t.ParEnd,o=t.ParStart<t.ParEnd?t.ParStart:t.ParStart-e;i>n?i-o>e&&(o+=e,n+=e):n-r>e&&(r+=e,i+=e);let s=Math.min(i,n),a=Math.max(r,o);return a<=s?{start:a,end:s,rbaseMiddle:(r+i)/2,lbaseMiddle:(o+n)/2}:null}var ja=class{constructor(){this.Metrolines=new Array}Add(t){this.Metrolines.push(t)}};var Xn=class{constructor(t){this.Metrolines=t,this.BuildOrder()}*GetOrder(t,e){let i=new he(t.Position,e.Position),r=this.bundles.get(i).Metrolines;if(t.Position===i.first)for(let n=0;n<r.length;n++)yield r[n];else for(let n=r.length-1;n>=0;n--)yield r[n]}GetLineIndexInOrder(t,e,i){let r=new he(t.Position,e.Position),n=t.Position!==r.first,o=this.bundles.get(r).LineIndexInOrder;return n?o.size-1-o.get(i):o.get(i)}BuildOrder(){this.bundles=new Gt;for(let t of this.Metrolines)for(let e=t.Polyline.startPoint;e.next!=null;e=e.next){let i=new he(e.point,e.next.point),r=this.bundles.get(i);r||this.bundles.set(i,r=new ja),r.Add(t)}for(let t of this.bundles)this.BuildOrderPP(t[0],t[1])}BuildOrderPP(t,e){if(!e.orderFixed){e.Metrolines.sort((i,r)=>this.CompareLines(i,r,t.first,t.second)),e.orderFixed=!0,e.LineIndexInOrder=new Map;for(let i=0;i<e.Metrolines.length;i++)e.LineIndexInOrder.set(e.Metrolines[i],i)}}CompareLines(t,e,i,r){let n={polyPoint:null,next:null,prev:null};this.FindStationOnLine(i,r,t,n);let o=n.polyPoint,s=n.next,a=n.prev;this.FindStationOnLine(i,r,e,n);let u=n.polyPoint,h=n.next,d=n.prev,g=o,f=u,P,y;for(;(y=a(g))!=null&&(P=d(f))!=null&&y.point.equal(P.point);){let w=new he(y.point,g.point);if(this.bundles.get(w).orderFixed)return this.CompareOnFixedOrder(w,t,e,!y.point.equal(w.first));g=y,f=P}if(y!=null&&P!=null){let w=g.point;return-Xn.IsLeft(s(g).point.sub(w),y.point.sub(w),P.point.sub(w))}for(g=o,f=u;(y=s(g))!=null&&(P=h(f))!=null&&y.point.equal(P.point);){let w=new he(y.point,g.point);if(this.bundles.get(w).orderFixed)return this.CompareOnFixedOrder(w,t,e,!g.point.equal(w.first));g=y,f=P}if(y!=null&&P!=null){let w=g.point;return Xn.IsLeft(a(g).point.sub(w),y.point.sub(w),P.point.sub(w))}return Q(t.Index,e.Index)}CompareOnFixedOrder(t,e,i,r){let n=this.bundles.get(t).LineIndexInOrder;return(r?-1:1)*Q(n.get(e),n.get(i))}FindStationOnLine(t,e,i,r){for(let n=i.Polyline.startPoint;n.next!=null;n=n.next){if(n.point.equal(t)&&n.next.point.equal(e)){r.next=o=>o.next,r.prev=o=>o.prev,r.polyPoint=n;return}if(n.point.equal(e)&&n.next.point.equal(t)){r.next=o=>o.prev,r.prev=o=>o.next,r.polyPoint=n.next;return}}throw new Error}static IsLeft(t,e,i){return er(t,e,i)}};var pe=class extends H{constructor(e,i){super(null);this.metroGraphData=e,this.bundlingSettings=i}run(){this.CreateMetroOrdering(),this.InitRadii(),this.FinalizePaths()}InitRadii(){new Ge(this.metroGraphData,this.bundlingSettings).CreateNodeRadii()}CreateMetroOrdering(){this.metroOrdering=new Xn(this.metroGraphData.Metrolines)}FinalizePaths(){this.CreateBundleBases(),this.CreateSegmentsInsideHubs(),this.CreateCurves()}CreateBundleBases(){new _t(this.metroOrdering,this.metroGraphData,this.bundlingSettings).Run()}CreateCurves(){for(let e=0;e<this.metroGraphData.Metrolines.length;e++)this.CreateCurveLine(this.metroGraphData.Metrolines[e],this.metroGraphData.Edges[e])}CreateCurveLine(e,i){let r=new p,o=pe.FindCurveStart(this.metroGraphData,this.metroOrdering,e),s=pe.HubSegsOfLine(this.metroGraphData,this.metroOrdering,e);for(let a of s)a!=null&&(r.addSegment(S.mkPP(o,a.start)),r.addSegment(a),o=a.end);r.addSegment(S.mkPP(o,pe.FindCurveEnd(this.metroGraphData,this.metroOrdering,e))),i.curve=r}static FindCurveStart(e,i,r){let n=e.PointToStations.get(r.Polyline.startPoint.point),o=e.PointToStations.get(r.Polyline.startPoint.next.point),s=n.BundleBases.get(o),a=s.IsParent?i.GetLineIndexInOrder(n,o,r):i.GetLineIndexInOrder(o,n,r);return s.Points[a]}static FindCurveEnd(e,i,r){let n=e.PointToStations.get(r.Polyline.endPoint.prev.point),o=e.PointToStations.get(r.Polyline.endPoint.point),s=o.BundleBases.get(n),a=s.IsParent?i.GetLineIndexInOrder(o,n,r):i.GetLineIndexInOrder(n,o,r);return s.Points[a]}static*HubSegsOfLine(e,i,r){for(let n=r.Polyline.startPoint.next;n.next!=null;n=n.next)yield pe.SegOnLineVertex(e,i,r,n)}static SegOnLineVertex(e,i,r,n){let o=e.PointToStations.get(n.prev.point),s=e.PointToStations.get(n.point),a=s.BundleBases.get(o),u=i.GetLineIndexInOrder(o,s,r);if(a.OrientedHubSegments[u]==null||a.OrientedHubSegments[u].Segment==null){let h=e.PointToStations.get(n.next.point),d=s.BundleBases.get(h),g=i.GetLineIndexInOrder(h,s,r);return S.mkPP(a.Points[u],d.Points[g])}return a.OrientedHubSegments[u].Segment}CreateSegmentsInsideHubs(){for(let e of this.metroGraphData.Metrolines)this.CreateOrientedSegsOnLine(e);this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs&&this.FanBezierSegs()}CreateOrientedSegsOnLine(e){for(let i=e.Polyline.startPoint.next;i.next!=null;i=i.next)this.CreateICurveForOrientedSeg(e,i)}CreateICurveForOrientedSeg(e,i){let r=this.metroGraphData.PointToStations.get(i.prev.point),n=this.metroGraphData.PointToStations.get(i.point),o=this.metroGraphData.PointToStations.get(i.next.point),s=n.BundleBases.get(r),a=n.BundleBases.get(o),u=this.metroOrdering.GetLineIndexInOrder(r,n,e),h=this.metroOrdering.GetLineIndexInOrder(o,n,e),d=this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs?pe.StandardBezier(s.Points[u],s.Tangents[u],a.Points[h],a.Tangents[h]):pe.BiArc(s.Points[u],s.Tangents[u],a.Points[h],a.Tangents[h]);s.OrientedHubSegments[u].Segment=d,a.OrientedHubSegments[h].Segment=d}static ShowHubs(e,i,r,n,o=[]){let s=pe.GetAllDebugCurves(i,e);r!=null&&s.push(z.mkDebugCurveTWCI(255,1,"red",be.mkDiamond(5,25,r.Position))),s=s.concat(o)}static GetAllDebugCurves(e,i){return pe.GraphNodes(i).concat(pe.VertexDebugCurves(e,i)).concat(pe.DebugEdges(i))}static DebugEdges(e){return e.Edges.map(i=>z.mkDebugCurveTWCI(40,.1,"gray",i.curve))}static VertexDebugCurves(e,i){return pe.DebugCircles(i).concat(pe.DebugHubBases(i)).concat(pe.DebugSegs(i)).concat(pe.BetweenHubs(e,i))}static BetweenHubs(e,i){let r=[];for(let n of i.Metrolines){let o=pe.GetInterestingSegs(i,e,n),s=pe.GetMonotoneColor(n.Polyline.start,n.Polyline.end,o);for(let a of o)r.push(z.mkDebugCurveTWCI(100,n.Width,s,S.mkPP(a[0],a[1])))}return r}static GetInterestingSegs(e,i,r){let n=new Array;if(e.Stations.length===0||e.Stations[0].BundleBases==null||e.Stations[0].BundleBases.size===0)return[];let o=pe.FindCurveStart(e,i,r),s=pe.HubSegsOfLine(e,i,r);for(let a of s)a!=null&&(n.push([o,a.start]),o=a.end);return n.push([o,pe.FindCurveEnd(e,i,r)]),n}static GetMonotoneColor(e,i,r){return"green"}static DebugHubBases(e){let i=new Array;for(let r of e.Stations)for(let n of r.BundleBases.values())i.push(z.mkDebugCurveTWCI(100,1,"red",S.mkPP(n.EndPoint,n.StartPoint)));return i}static DebugCircles(e){return e.Stations.map(i=>z.mkDebugCurveTWCI(100,.1,"blue",be.mkCircle(i.Radius,i.Position)))}static DebugSegs(e){let i=new Array;for(let r of e.VirtualStations())for(let n of r.BundleBases.values())for(let o of n.OrientedHubSegments)if(o!=null)if(o.Segment==null){let s=o.Other.BundleBase,a=o.Index,u=o.Other.Index;i.push(S.mkPP(n.Points[a],s.Points[u]))}else i.push(o.Segment);return i.map(r=>z.mkDebugCurveTWCI(100,.01,"green",r))}static GraphNodes(e){return e.Edges.map(r=>r.sourcePort.Curve).concat(e.Edges.map(r=>r.targetPort.Curve)).map(r=>z.mkDebugCurveTWCI(40,1,"black",r))}static BiArc(e,i,r,n){let o=e.sub(r);if(o.length<m.distanceEpsilon)return null;let s=o.dot(i.sub(n)),a=-i.dot(n);if(i.dot(r.sub(e))<=0&&i.dot(n)<=0)return pe.StandardBezier(e,i,r,n);let u=2*(a-1),h=2*s,d=o.dot(o),g;if(Math.abs(u)<m.distanceEpsilon)if(Math.abs(h)>m.distanceEpsilon)g=-d/h;else return null;else{let A=h*h-4*u*d;A<0&&(A=0),A=Math.sqrt(A),g=(-h+A)/(2*u),g<0&&(g=(-h-A)/(2*u))}let f=e.add(i.mul(g)),P=r.add(n.mul(g)),y=c.middle(f,P),w=c.getTriangleOrientation(e,f,y),x=c.getTriangleOrientation(y,P,r);if(w!==x)return pe.StandardBezier(e,i,r,n);let G=new p;return G.addSegs([pe.ArcOn(e,f,y),pe.ArcOn(y,P,r)]),G}static ArcOn(e,i,r){let n={center:null};if(Math.abs(c.signedDoubledTriangleArea(e,i,r))<1e-4||!pe.FindArcCenter(e,i,r,n))return S.mkPP(e,r);let o=n.center,s=te(e,o);if(te(e,i)/s<1e-4)return S.mkPP(e,r);let u=e.sub(o),h=Math.atan2(u.y,u.x),d=r.sub(o),g=Math.atan2(d.y,d.x),f=g-h;if(f<0&&(f+=2*Math.PI,g+=2*Math.PI),f<=Math.PI)return new k(h,g,new c(s,0),new c(0,s),o);for(g>2*Math.PI&&(g-=2*Math.PI),h=Math.PI-h,g=Math.PI-g,h<0&&(h+=2*Math.PI);g<h;)g+=2*Math.PI;return f=g-h,new k(h,g,new c(-s,0),new c(0,s),o)}static FindArcCenter(e,i,r,n){let o=i.sub(e).rotate90Cw(),s=i.sub(r).rotate90Cw();return n.center=c.lineLineIntersection(e,e.add(o),r,r.add(s)),n.center!=null}static StandardBezier(e,i,r,n){let o=te(e,r)/4;return ee.mkBezier([e,e.add(i.mul(o)),r.add(n.mul(o)),r])}FanBezierSegs(){let e=!0,i=5,r=0;for(;e&&r++<i;){e=!1;for(let n of this.metroGraphData.Stations)for(let o of n.BundleBases.values())e||(e=this.FanEdgesOfHubSegment(o))}}FanEdgesOfHubSegment(e){let i=!1;for(let r=0;r<e.Count-1;r++)i||(i=this.FanCouple(e,r,e.CurveCenter,e.Curve.boundingBox.diagonal/2));return i}FanCouple(e,i,r,n){let o=e.OrientedHubSegments[i],s=e.OrientedHubSegments[i+1];if(o==null||Os(o.Segment.start,o.Segment.end,s.Segment.start,s.Segment.end)||c.getTriangleOrientation(o.value(0),o.value(.5),o.value(1))!=c.getTriangleOrientation(s.value(0),s.value(.5),s.value(1)))return!1;let u=this.BaseLength(o),h=this.BaseLength(s);return Math.abs(u-h)<m.intersectionEpsilon?!1:u>h?this.AdjustLongerSeg(o,s,r,n):this.AdjustLongerSeg(s,o,r,n)}AdjustLongerSeg(e,i,r,n){let o=e.value(0).sub(i.value(0)),s=e.value(1).sub(i.value(1)),a=Math.min(o.length,s.length),u=i.value(.5),h=Math.max(o.length,s.length);return this.NicelyAligned(e.Segment,o,s,u,a,h)===0?!1:this.FitLonger(e,o,s,u,a,h,r,n)}FitLonger(e,i,r,n,o,s,a,u){let h=e.Segment,d=h.start,g=h.end,f=0,P=10,y=h.start.mul(1-pe.SqueezeBound).add(h.B(1).mul(pe.SqueezeBound)),w=h.end.mul(1-pe.SqueezeBound).add(h.B(2).mul(pe.SqueezeBound)),x=h.B(1).mul(2).sub(h.start),G=h.B(2).mul(2).sub(h.end),A={highP:x};this.PullControlPointToTheCircle(h.start,A,a,u),x=A.highP;let M=this.NicelyAligned(h,i,r,n,o,s);do{if(M===-1){let Y=c.middle(h.B(1),y),K=c.middle(h.B(2),w);x=h.B(1),G=h.B(2),h=new ee(d,Y,K,g)}else{let Y=c.middle(h.B(1),x),K=(h.B(2),G);y=h.B(1),w=h.B(2),h=new ee(d,Y,K,g)}if((M=this.NicelyAligned(h,i,r,n,o,s))===0)return e.Segment=h,e.Other.Segment=h,!0;if(f++>P)return!1}while(!0)}PullControlPointToTheCircle(e,i,r,n){let o=c.ProjectionToLine(e,i.highP,r),s=Math.sqrt(n*n-o.sub(r).lengthSquared),a=i.highP.sub(o),u=a.length;u>s&&(i.highP=o.add(a.mul(s/u)))}NicelyAligned(e,i,r,n,o,s){let u=e.value(.5).sub(n),h=u.length;return i.dot(u)<0||r.dot(u)<0||h<o-.001?1:h>s+.001?-1:0}BaseLength(e){return e.value(0).sub(e.value(1)).lengthSquared}},yn=pe;yn.SqueezeBound=.2;var di=class{constructor(t,e){this.stepsWithProgress=0;this.metroGraphData=t,this.bundlingSettings=e,this.costCalculator=new ht(this.metroGraphData,this.bundlingSettings),this.cache=new Sn(this.metroGraphData,this.bundlingSettings,this.costCalculator,this.metroGraphData.cdt)}static FixRouting(t,e){return this.FixRoutingMBP(t,e,null)}static FixRoutingMBP(t,e,i){return new di(t,e).FixRoutingP(i)}FixRoutingP(t){this.stationsForOptimizations=this.GetStationsForOptimizations(t),this.cache.InitializeCostCache();let e=di.MaxStep,i=Number.POSITIVE_INFINITY,r=this.metroGraphData.VirtualStations().map(o=>o.Position),n=0;for(;n++<di.MaxIterations;){let o=this.TryMoveStations();if(n<=1&&!o)return!1;if(!o)break;let s=i;i=ht.Cost(this.metroGraphData,this.bundlingSettings),e=this.UpdateMaxStep(e,s,i);let a=r;if(r=this.metroGraphData.VirtualStations().map(u=>u.Position),e<di.MinStep||this.Converged(e,a,r))break}return!0}static stationsArePositionedCorrectly(t){for(let e of t.VirtualEdges())if(!this.edgeIsPositionedCorrectly(e,t))return!1;return!0}static edgeIsPositionedCorrectly(t,e){let i=t[0],r=t[1],n=e.looseIntersections.ObstaclesToIgnoreForBundle(i,r),o=S.mkPP(i.Position,r.Position),s=Array.from(e.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(o.boundingBox)).filter(a=>!n.has(a)).filter(a=>p.CurvesIntersect(o,a));return s.length>0?(yn.ShowHubs(e,null,null,"./tmp/badcross.svg",[z.mkDebugCurveTWCI(200,1,"Brown",o),z.mkDebugCurveTWCI(200,1,"Red",be.mkCircle(2,i.Position)),z.mkDebugCurveTWCI(200,1,"Blue",be.mkCircle(5,r.Position)),z.mkDebugCurveTWCI(100,1,"Blue",be.mkCircle(5,r.Position))].concat(s.map(a=>z.mkDebugCurveTWCI(100,1,"Pink",a)))),!1):!0}GetStationsForOptimizations(t){if(t==null)return new Set(this.metroGraphData.VirtualStations());{let e=new Set;for(let i of t){let r=this.metroGraphData.PointToStations.get(i);r&&!r.IsReal&&e.add(r)}return e}}Converged(t,e,i){let r=0,n=0;for(let s=0;s<e.length;s++)n+=e[s].sub(i[s]).lengthSquared,r+=e[s].lengthSquared;return Math.sqrt(n/r)<di.MinRelativeChange}UpdateMaxStep(t,e,i){return i+1<e?(this.stepsWithProgress++,this.stepsWithProgress>=5&&(this.stepsWithProgress=0,t=Math.min(di.MaxStep,t/.8))):(this.stepsWithProgress=0,t*=.8),t}TryMoveStations(){let t=!1,e=new Set;for(let i of this.stationsForOptimizations)if(this.TryMoveStation(i)){t=!0,e.add(i);for(let r of i.Neighbors)r.IsReal||e.add(r)}return this.stationsForOptimizations=e,t}TryMoveStation(t){let e=this.BuildDirection(t);if(e.length===0)return!1;let i=this.BuildStepLength(t,e);if(i<di.MinStep&&(e=ld(),i=this.BuildStepLength(t,e),i<di.MinStep))return!1;let r=e.mul(i),n=t.Position.add(r);return this.metroGraphData.PointToStations.has(n)||!this.moveIsLegalForAdjacentBundles(t,n)?!1:(this.metroGraphData.MoveNode(t,n),this.cache.UpdateCostCache(t),!0)}moveIsLegalForAdjacentBundles(t,e){for(let i of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(I.mkOnPoints([e]),r=>p.PointRelativeToCurveLocation(e,r)!==0))if(t.getELP().has(i)===!1)return!1;for(let i of t.Neighbors){let r=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(i,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegal_(i.Position,e,i.cdtTriangle,r))return!1}return!0}BuildDirection(t){let e=this.BuildForceForInk(t),i=this.BuildForceForPathLengths(t),r=this.BuildForceForRadius(t),n=this.BuildForceForBundle(t),o=e.add(i.add(r.add(n)));return o.length<.1?new c(0,0):o.normalize()}BuildStepLength(t,e){let i=di.MinStep,r=this.CostGain(t,t.Position.add(e.mul(i)));if(r<.01)return 0;for(;2*i<=di.MaxStep;){let n=this.CostGain(t,t.Position.add(e.mul(i*2)));if(n<=r)break;i*=2,r=n}return i}CostGain(t,e){let r=this.costCalculator.RadiusGain(t,e);if(r<-12345678)return-12345678;let n=this.costCalculator.BundleGain(t,e);if(n<-12345678)return-12345678;let o=this.costCalculator.InkGain(t,e),s=this.costCalculator.PathLengthsGain(t,e);return r+o+s+n}BuildForceForInk(t){let e=new c(0,0);for(let r of t.Neighbors){let n=r.Position.sub(t.Position);e=e.add(n.normalize())}return e.mul(this.bundlingSettings.InkImportance)}BuildForceForPathLengths(t){let e=new c(0,0);for(let r of this.metroGraphData.MetroNodeInfosOfNode(t)){let n=r.Metroline,o=r.PolyPoint.next.point,s=r.PolyPoint.prev.point,a=o.sub(t.Position),u=s.sub(t.Position);e=e.add(a.div(a.length*n.IdealLength)),e=e.add(u.div(u.length*n.IdealLength))}return e.mul(this.bundlingSettings.PathLengthImportance)}BuildForceForRadius(t){let e=new c(0,0),i=t.cachedIdealRadius,r={touchedObstacles:[]};if(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t,t.Position,i,r))throw yn.ShowHubs(this.metroGraphData,null,t,"./tmp/hubs.svg",[z.mkDebugCurveTWCI(255,1,"Brown",At.containingPoly),z.mkDebugCurveTWCI(100,1,"Blue",be.mkCircle(i,t.Position))]),new Error;for(let s of r.touchedObstacles){let a=s[1].sub(t.Position).length,u=2*(1-a/i),h=t.Position.sub(s[1]).normalize();e=e.add(h.mul(u))}return e.mul(this.bundlingSettings.HubRepulsionImportance)}BuildForceForBundle(t){let e=new c(0,0);for(let r of t.Neighbors){let n=this.metroGraphData.GetWidthSSN(t,r,this.bundlingSettings.EdgeSeparation),o={closestDist:[]},s=this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,r,t.Position,r.Position,n/2,o);for(let a of o.closestDist){let u=a[0].sub(a[1]).length,h=2*(1-u/(n/2)),d=a[0].sub(a[1]).normalize().neg();e=e.add(d.mul(h))}}return e.mul(this.bundlingSettings.BundleRepulsionImportance)}},gi=di;gi.MaxIterations=100,gi.MaxStep=50,gi.MinStep=1,gi.MinRelativeChange=5e-4;function ld(){return new c(1+2*Qi(),1+2*Qi())}var ir=class{constructor(t,e){this.metroGraphData=t,this.bundlingSettings=e}static FixRouting(t,e){let i=new ir(t,e);i.GlueConflictingStations(),i.UnglueEdgesFromBundleToSaveInk(!0);let r=0,n=10;for(;++r<n;){let o=i.GlueConflictingStations();if(o||(o=i.RelaxConstrainedEdges()),o||(o=r<=3&&i.UnglueEdgesFromBundleToSaveInk(!1)),o||(o=i.GlueCollinearNeighbors(r)),o||(o=r===3&&i.RemoveDoublePathCrossings()),!o)break}for(t.cdtIntersections.ComputeForcesForBundles=!0,i.RemoveDoublePathCrossings(),i.UnglueEdgesFromBundleToSaveInk(!0);i.GlueConflictingStations(););t.Initialize(!0)}GlueConflictingStations(){let t=this.GetCirclesHierarchy();if(t==null)return!1;let e=new Map,i=new Set;if(Be(t,t,(n,o)=>this.TryToGlueStations(n,o,e,i)),e.size===0)return!1;for(let n=0;n<this.metroGraphData.Edges.length;n++)this.RegenerateEdge(e,n);let r=new ie;for(let n of i){r.add(n.Position);for(let o of n.Neighbors)o.IsReal||r.add(o.Position)}return this.metroGraphData.Initialize(!1),gi.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,r),!0}GetCirclesHierarchy(){for(let i of this.metroGraphData.VirtualStations())i.Radius=this.GetCurrentHubRadius(i);let t=this.metroGraphData.VirtualStations().map(e);return ge(t);function e(i){let r=i.Position,n=Math.max(i.Radius,5),o=new c(n,n),s=I.mkPP(r.add(o),r.sub(o));return Se(i,s)}}GetCurrentHubRadius(t){if(t.IsReal)return t.BoundaryCurve.boundingBox.diagonal/2;{let e=t.cachedIdealRadius,i=this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(t,t.Position,e);for(let r of t.Neighbors)i=Math.min(i,t.Position.sub(r.Position).length);return i}}TryToGlueStations(t,e,i,r){if(!vn(t.getELP(),e.getELP()))return!1;let n=t.Position.sub(e.Position).length,o=Math.max(t.Radius,5),s=Math.max(e.Radius,5);n>=o+s||this.TryGlueOrdered(t,e,r,i)||this.TryGlueOrdered(e,t,r,i)}TryGlueOrdered(t,e,i,r){return!r.has(t)&&!i.has(t)&&this.StationGluingIsAllowed(t,e,r)?(this.Map(t,e,i,r),!0):!1}Map(t,e,i,r){r.set(t,e),i.add(e)}StationGluingIsAllowed(t,e,i){for(let n of t.Neighbors){let o=ir.Glued(n,i),s=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(o,t);if(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(o,e,s))return!1}return!(this.ComputeCostDeltaAfterStationGluing(t,e,i)<0)}ComputeCostDeltaAfterStationGluing(t,e,i){let r=t.Position.sub(e.Position).length;if(t.Radius>=r||e.Radius>=r)return 1;let n=0,o=this.metroGraphData.Ink,s=this.metroGraphData.Ink-e.Position.sub(t.Position).length;for(let a of t.Neighbors){let u=ir.Glued(a,i);s-=u.Position.sub(t.Position).length,s+=this.metroGraphData.RealEdgeCount(u,e)===0?u.Position.sub(e.Position).length:0}n+=ht.InkError(o,s,this.bundlingSettings);for(let a of this.metroGraphData.MetroNodeInfosOfNode(t)){let u=a.Metroline.Length,h=a.Metroline.Length,d=a.PolyPoint,g=d.prev,f=d.next;h-=g.point.sub(t.Position).length+f.point.sub(t.Position).length,h+=g.point.sub(e.Position).length+f.point.sub(e.Position).length,n+=ht.PathLengthsError(u,h,a.Metroline.IdealLength,this.bundlingSettings)}return n}RegenerateEdge(t,e){let i=this.metroGraphData.Metrolines[e].Polyline;for(let o of i)if(!this.metroGraphData.PointToStations.has(o))return;let r=!1;for(let o of i)if(t.has(this.metroGraphData.PointToStations.get(o))){r=!0;break}if(!r)return;let n=Array.from(i).map(o=>this.metroGraphData.PointToStations.get(o));this.metroGraphData.Edges[e].curve=R.mkFromPoints(ir.GluedPolyline(n,t))}static GluedPolyline(t,e){let i,r=new wh.Stack;r.push(t[0]);let n=new Set;for(i=1;i<t.length-1;i++){let o=ir.Glued(t[i],e);if(n.has(o)){for(;r.top!==o;)n.delete(r.pop());continue}c.closeDistEps(o.Position,r.top.Position)||(n.add(o),r.push(o))}return r.push(t[i]),Array.from(r).reverse().map(o=>o.Position)}static Glued(t,e){var i;return(i=e.get(t))!=null?i:t}UnglueEdgesFromBundleToSaveInk(t){let e=new Gt;this.ink=this.metroGraphData.Ink,this.polylineLength=new Map;for(let n of this.metroGraphData.Metrolines){this.polylineLength.set(n,n.Length);for(let o=n.Polyline.startPoint;o.next!=null;o=o.next){let s=new he(o.point,o.next.point);dl(e,s,n)}}let i=new ie,r=!1;for(let n of this.metroGraphData.Metrolines){let o=Si(this.metroGraphData.PointToStations.get(n.Polyline.start).getELP(),this.metroGraphData.PointToStations.get(n.Polyline.end).getELP());this.TrySeparateOnPolyline(n,e,i,o)&&(r=!0)}return r&&this.metroGraphData.Initialize(!1),(t||r)&&gi.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t?null:i),r}TrySeparateOnPolyline(t,e,i,r){let n=!1,o=!0;for(;o;){o=!1;for(let s=t.Polyline.startPoint;s.next!=null&&s.next.next!=null;s=s.next)this.TryShortcutPolypoint(s,e,i,r)&&(o=!0);o&&(n=!0)}return n}TryShortcutPolypoint(t,e,i,r){return this.SeparationShortcutAllowed(t,e,r)?(i.add(t.point),i.add(t.next.point),i.add(t.next.next.point),this.RemoveShortcuttedPolypoint(t,e),!0):!1}SeparationShortcutAllowed(t,e,i){let r=t.point,n=t.next.point,o=t.next.next.point,s=this.metroGraphData.PointToStations.get(r),a=this.metroGraphData.PointToStations.get(n),u=this.metroGraphData.PointToStations.get(o),h=bi(s.getELP(),u.getELP()),d=cu([i,a.getELP(),h]);return!(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(s,u,d)||this.GetInkgain(t,e,r,n,o)<0)}GetInkgain(t,e,i,r,n){let[o,s,a]=this.FindPolylines(t,e),u=0,h=this.ink,d=this.ink,g=i.sub(r).length,f=r.sub(n).length,P=i.sub(n).length;o.size===a.size&&(d-=g),s.size===a.size&&(d-=f);let y=e.get(new he(i,n));(!y||y.size===0)&&(d+=P),u+=ht.InkError(h,d,this.bundlingSettings);for(let Y of a){let K=this.polylineLength.get(Y),Me=K-(g+f-P);u+=ht.PathLengthsError(K,Me,Y.IdealLength,this.bundlingSettings)}let w=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(i)),x=this.metroGraphData.GetWidthAN(Array.from(a),this.bundlingSettings.EdgeSeparation),G=this.metroGraphData.GetWidthAN(Array.from(sr(o,a)),this.bundlingSettings.EdgeSeparation),A=Ge.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(w,i,n,r,x,G,this.bundlingSettings);A>w&&(u-=ht.RError(A,w,this.bundlingSettings)),w=this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(n));let M=this.metroGraphData.GetWidthAN(Array.from(sr(s,a)),this.bundlingSettings.EdgeSeparation);return A=Ge.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(w,n,r,i,M,x,this.bundlingSettings),A>w&&(u-=ht.RError(A,w,this.bundlingSettings)),u}RemoveShortcuttedPolypoint(t,e){let i=t.point,r=t.next.point,n=t.next.next.point,[o,s,a]=this.FindPolylines(t,e),u=te(i,r),h=te(r,n),d=te(i,n);o.size===a.size&&(this.ink-=u),s.size===a.size&&(this.ink-=h);let g=e.get(new he(i,n));(!g||g.size===0)&&(this.ink+=d);for(let f of a){let P=this.polylineLength.get(f);this.polylineLength.set(f,P-(u+h-d))}for(let f of a){let P=Array.from(f.Polyline.polylinePoints()).find(y=>y.point.equal(r));this.RemovePolypoint(P),gl(e,[i,r],f),gl(e,[r,n],f),du(e,[i,n],f)}}FindPolylines(t,e){let i=t.point,r=t.next.point,n=t.next.next.point,o=e.getPP(i,r),s=e.getPP(r,n),a=Si(o,s);return[o,s,a]}RemovePolypoint(t){let e=t.prev,i=t.next;e.next=i,i.prev=e}GlueCollinearNeighbors(t){let e=new ie,i=!1;for(let r of this.metroGraphData.Stations)this.GlueCollinearNeighborsSPN(r,e,t)&&(i=!0);return i&&(this.metroGraphData.Initialize(!1),gi.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,e)),i}GlueCollinearNeighborsSPN(t,e,i){if(t.Neighbors.length<=1)return!1;let r=new Oo,n=t.Neighbors;for(let o=0;o<n.length;o++)this.TryToGlueEdges(t,n[o],n[(o+1)%n.length],r,i);if(r.isEmpty)return!1;for(let o of r)this.GlueEdge(o),e.add(o[0].Position),e.add(o[1].Position),e.add(o[2]);return!0}TryToGlueEdges(t,e,i,r,n){if(c.anglePCP(e.Position,t.Position,i.Position)<this.bundlingSettings.AngleThreshold){let s=te(e.Position,t.Position),a=te(i.Position,t.Position),u=Math.min(s,a)/Math.max(s,a);if(u<.05)return;if(s<a){if(this.EdgeGluingIsAllowedSSS(t,e,i)){this.AddEdgeToGlue(t,i,e,e.Position,r);return}}else if(this.EdgeGluingIsAllowedSSS(t,i,e)){this.AddEdgeToGlue(t,e,i,i.Position,r);return}if(n<5&&u>.5){let h=this.ConstructGluingPoint(t,e,i);this.EdgeGluingIsAllowedSSSP(t,e,i,h)&&this.AddEdgeToGlue(t,i,e,h,r)}}}ConstructGluingPoint(t,e,i){let r=Math.min(te(e.Position,t.Position),te(i.Position,t.Position)/2),n=e.Position.sub(t.Position).normalize().add(i.Position.sub(t.Position).normalize());return t.Position.add(n.mul(r/2))}EdgeGluingIsAllowedSSS(t,e,i){if(e.IsReal||i.IsReal||!vn(e.getELP(),i.getELP())||!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,i,e.Position,i.Position))return!1;let r=this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t,i);return!(re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(S.mkPP(t.Position,e.Position),this.metroGraphData.LooseTree).find(a=>!r.has(a.seg1))||re.IntersectionsOfLineAndRectangleNodeOverPolylineLR(S.mkPP(e.Position,i.Position),this.metroGraphData.LooseTree).find(a=>!r.has(a.seg1))||this.ComputeCostDeltaAfterEdgeGluing(t,e,i,e.Position)<0)}EdgeGluingIsAllowedSSSP(t,e,i,r){return!(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(r,0,Si(e.getELP(),i.getELP()))||!this.metroGraphData.cdtIntersections.EdgeIsLegal(t,null,t.Position,r)||!this.metroGraphData.cdtIntersections.EdgeIsLegal(e,null,e.Position,r)||!this.metroGraphData.cdtIntersections.EdgeIsLegal(i,null,i.Position,r)||this.ComputeCostDeltaAfterEdgeGluing(t,e,i,r)<0)}ComputeCostDeltaAfterEdgeGluing(t,e,i,r){let n=0,o=this.metroGraphData.Ink,s=this.metroGraphData.Ink-te(t.Position,i.Position)-te(t.Position,e.Position)+te(t.Position,r)+te(r,e.Position)+te(r,i.Position);n+=ht.InkError(o,s,this.bundlingSettings);for(let d of this.metroGraphData.GetIjInfo(t,i).Metrolines){let g=d.Length,f=d.Length-te(t.Position,i.Position)+te(t.Position,r)+te(r,i.Position);n+=ht.PathLengthsError(g,f,d.IdealLength,this.bundlingSettings)}for(let d of this.metroGraphData.GetIjInfo(t,e).Metrolines){let g=d.Length,f=d.Length-te(t.Position,e.Position)+te(t.Position,r)+te(r,e.Position);n+=ht.PathLengthsError(g,f,d.IdealLength,this.bundlingSettings)}let a=t.cachedIdealRadius,u=this.GetCurrentHubRadius(t),h=Ge.GetMinRadiusForTwoAdjacentBundles(u,t,t.Position,e,i,this.metroGraphData,this.bundlingSettings);return h>u&&(n+=ht.RError(h,u,this.bundlingSettings)),a>te(t.Position,r)&&!t.IsReal&&(n-=ht.RError(a,te(t.Position,r),this.bundlingSettings)),n}AddEdgeToGlue(t,e,i,r,n){n.has(i,t)||n.has(e,t)||n.has(t,i)||n.has(t,e)||(n.set(t,i,r),n.set(t,e,r))}GlueEdge(t){let e=t[0],i=t[1],r=t[2];for(let n of e.MetroNodeInfos.map(o=>o.PolyPoint))n.next!=null&&n.next.point.equal(i.Position)?this.SplitPolylinePoint(n,r):n.prev!=null&&n.prev.point.equal(i.Position)&&this.SplitPolylinePoint(n.prev,r)}SplitPolylinePoint(t,e){if(t.point===e||t.next.point===e)return;let i=Ne.mkFromPoint(e);i.polyline=t.polyline,i.next=t.next,i.prev=t,i.next.prev=i,i.prev.next=i}RelaxConstrainedEdges(){let t=new ie,e=!1;for(let i of this.metroGraphData.VirtualEdges())this.RelaxConstrainedEdge(i[0],i[1],t)&&(e=!0);return e&&(this.metroGraphData.Initialize(!1),gi.FixRoutingMBP(this.metroGraphData,this.bundlingSettings,t)),e}RelaxConstrainedEdge(t,e,i){let r=this.metroGraphData.GetWidthSSN(t,e,this.bundlingSettings.EdgeSeparation),n={closestDist:new Array};this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t,e,t.Position,e.Position,.99*r/2,n);let o=n.closestDist;if(o.length>0){let s=-1,a;for(let u of o){let h=Math.min(te(t.Position,u[1]),te(e.Position,u[1])),d=te(t.Position,e.Position);if(h/d<.1)continue;let f=te(u[0],u[1]);(s===-1||f<s)&&(s=f,a=u[1])}if(s===-1||!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(a,0,Si(t.getELP(),e.getELP())))return!1;i.add(a),i.add(t.Position),i.add(e.Position);for(let u of this.metroGraphData.GetIjInfo(t,e).Metrolines){let h=null;for(let d of u.Polyline.polylinePoints())if(d.point.equal(t.Position)){h=d;break}h.next!=null&&h.next.point.equal(e.Position)?this.SplitPolylinePoint(h,a):this.SplitPolylinePoint(h.prev,a)}return!0}return!1}RemoveDoublePathCrossings(){let t=new xr(this.metroGraphData,this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();return t&&(this.metroGraphData.Initialize(!1),gi.FixRouting(this.metroGraphData,this.bundlingSettings)),t}};var _n=class{constructor(t,e,i){this.upperBound=Number.POSITIVE_INFINITY;this._visGraph=i,i.ClearPrevEdgesTable();for(let r of i.Vertices())r.Distance=Number.POSITIVE_INFINITY;this.sources=t,this.targets=new Set(e)}GetPath(){let t=new nt;for(let e of this.sources)e.Distance=0,t.Enqueue(e,0);for(;!t.IsEmpty()&&(this._current=t.Dequeue(),!this.targets.has(this._current));){for(let e of this._current.OutEdges)this.PassableOutEdge(e)&&this.ProcessNeighbor(t,e,e.Target);for(let e of this._current.InEdges.filter(this.PassableInEdge.bind))this.ProcessNeighbor(t,e,e.Source)}return this._visGraph.PreviosVertex(this._current)==null?null:this.CalculatePath()}PassableOutEdge(t){return this.targets.has(t.Target)||!_n.IsForbidden(t)}PassableInEdge(t){return this.targets.has(t.Source)||!_n.IsForbidden(t)}static IsForbidden(t){return(t.IsPassable!=null&&!t.IsPassable()||t)instanceof Xe}ProcessNeighbor(t,e,i){let r=e.Length,n=this._current.Distance+r;n>=this.upperBound||(this.targets.has(i)&&(this.upperBound=n,this.closestTarget=i),this._visGraph.PreviosVertex(i)==null?(i.Distance=n,this._visGraph.SetPreviousEdge(i,e),t.Enqueue(i,n)):n<i.Distance&&(i.Distance=n,this._visGraph.SetPreviousEdge(i,e),t.DecreasePriority(i,n)))}CalculatePath(){if(this.closestTarget==null)return null;let t=new Array,e=this.closestTarget;do t.push(e),e=this._visGraph.PreviosVertex(e);while(e.Distance>0);return t.push(e),t.reverse()}};var Tr=class extends H{constructor(e,i,r,n,o,s,a,u,h,d){super(null);this.bundlingSettings=n,this.bundlingSettings.edgeWidthShrinkCoeff=1,this.edgesToRoute=e,this.regularEdges=e.filter(g=>g.source!==g.target),this.VisibilityGraph=r,this.shortestPathRouter=i,this.LoosePadding=o,this.LooseHierarchy=a,this.TightHierarchy=s,this.EdgeLooseEnterable=u,this.EdgeTightEnterable=h,this.loosePolylineOfPort=d,Qr(0)}ThereAreOverlaps(e){return $t(e,e,p.CurvesIntersect)}run(){if(this.ThereAreOverlaps(this.TightHierarchy)){this.Status=1;return}this.FixLocationsForHookAnywherePorts(this.edgesToRoute),this.RoutePathsWithSteinerDijkstra(),this.FixChildParentEdges(),this.bundlingSettings.StopAfterShortestPaths||this.OrderOptimizeNudgeEtc(),this.RouteSelfEdges(),this.FixArrowheads()}OrderOptimizeNudgeEtc(){let e=new za(this.regularEdges,this.LooseHierarchy,this.TightHierarchy,this.bundlingSettings,this.shortestPathRouter.cdt,this.EdgeLooseEnterable,this.EdgeTightEnterable,this.loosePolylineOfPort);ir.FixRouting(e,this.bundlingSettings),new yn(e,this.bundlingSettings).run()}FixChildParentEdges(){for(let e of this.regularEdges){let i=e.sourcePort,r=e.targetPort;if(i.Curve.boundingBox.containsRect(r.Curve.boundingBox)){let n=p.intersectionOne(i.Curve,S.mkPP(e.curve.start,e.curve.end),!1),o=e.curve;o.startPoint.point=n.x}if(r.Curve.boundingBox.containsRect(i.Curve.boundingBox)){let n=p.intersectionOne(r.Curve,S.mkPP(e.curve.start,e.curve.end),!0),o=e.curve;o.endPoint.point=n.x}}}FixLocationsForHookAnywherePorts(e){for(let i of e){let r=i.sourcePort instanceof Re;if(r){let n=i.sourcePort;n.SetLocation(this.FigureOutHookLocation(n.LoosePolyline,i.targetPort,i))}else if(r=i.targetPort instanceof Re,r){let n=i.targetPort;n.SetLocation(this.FigureOutHookLocation(n.LoosePolyline,i.sourcePort,i))}}}FigureOutHookLocation(e,i,r){return i instanceof et?this.FigureOutHookLocationForClusterOtherPort(e,i,r):this.FigureOutHookLocationForSimpleOtherPort(e,i,r)}FigureOutHookLocationForClusterOtherPort(e,i,r){let n=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(r),s=new _n(Array.from(i.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind),Array.from(e).map(this.VisibilityGraph.FindVertex.bind),this.VisibilityGraph).GetPath();for(let a of n)a.IsTransparent=!1;return s[s.length-1].point}FigureOutHookLocationForSimpleOtherPort(e,i,r){let n=i.Location,o=this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(r),a=new gr(this.VisibilityGraph.FindVertex(n),Array.from(e).map(u=>this.VisibilityGraph.FindVertex(u)),this.VisibilityGraph).GetPath();for(let u of o)u.IsTransparent=!1;return a[a.length-1].point}RoutePathsWithSteinerDijkstra(){this.shortestPathRouter.VisibilityGraph=this.VisibilityGraph,this.shortestPathRouter.BundlingSettings=this.bundlingSettings,this.shortestPathRouter.geomEdges=this.regularEdges,this.shortestPathRouter.ObstacleHierarchy=this.LooseHierarchy,this.shortestPathRouter.RouteEdges(),this.shortestPathRouter.cdt!=null&&this.AdjustEdgeSeparation()}AdjustEdgeSeparation(){let e=new Map;this.shortestPathRouter.FillCrossedCdtEdges(e);let i=this.GetPathsOnCdtEdge(e);this.bundlingSettings.edgeWidthShrinkCoeff=this.CalculateEdgeWidthShrinkCoeff(i)}GetPathsOnCdtEdge(e){let i=new Map;for(let r of e.keys())for(let n of e.get(r))xn(i,n,r);return i}CalculateEdgeWidthShrinkCoeff(e){let i=0,r=this.bundlingSettings.edgeWidthShrinkCoeff;if(this.EdgeSeparationIsOkMN(e,r))return r;let n=!1;for(;!n||Math.abs(r-i)>.01;){let o=(i+r)/2;this.EdgeSeparationIsOkMN(e,o)?(i=o,n=!0):r=o}return i}EdgeSeparationIsOkMN(e,i){for(let r of e.keys())if(!this.EdgeSeparationIsOk(r,e.get(r),i))return!1;return!0}EdgeSeparationIsOk(e,i,r){return Array.from(i).map(o=>this.bundlingSettings.ActualEdgeWidth(o,r)).reduce((o,s)=>o+s,0)<=e.Capacity}RouteSelfEdges(){for(let e of this.edgesToRoute)if(e.source===e.target){let i={smoothedPolyline:null};e.curve=Pe.RouteSelfEdge(e.source.boundaryCurve,this.LoosePadding*2,i)}}FixArrowheads(){for(let e of this.edgesToRoute)we.trimSplineAndCalculateArrowheadsII(e,e.source.boundaryCurve,e.target.boundaryCurve,e.curve,!1)}};Tr.SuperLoosePaddingCoefficient=1.1;var Ua=class{constructor(t,e,i){this.numberOfPassedPaths=0;this.VisibilityEdge=t,this.Source=e,this.Target=i}get TargetPoint(){return this.Target.Point}get SourcePoint(){return this.Source.Point}get IsOccupied(){return this.numberOfPassedPaths>0}get IsPassable(){return this.Target.IsTargetOfRouting||this.Source.IsSourceOfRouting||this.VisibilityEdge.IsPassable==null||this.VisibilityEdge.IsPassable()}AddOccupiedEdge(){this.numberOfPassedPaths++}RemoveOccupiedEdge(){this.numberOfPassedPaths--}};var Qa=class{constructor(t){this.InBoneEdges=new Array;this.OutBoneEdges=new Array;this.VisibilityVertex=t}get Prev(){return this.PrevEdge==null?null:this.PrevEdge.Source===this?this.PrevEdge.Target:this.PrevEdge.Source}get Point(){return this.VisibilityVertex.point}get Cost(){return this.IsSourceOfRouting?this.cost:this.Prev==null?Number.POSITIVE_INFINITY:this.cost}set Cost(t){this.cost=t}SetPreviousToNull(){this.PrevEdge=null}};var mi=class{constructor(t,e,i){this.EdgesToRoutes=new Map;this.EdgesToRouteSources=new Map;this.MakeTransparentShapesOfEdgeGeometry=t,this.cdt=e,this.Gates=i}CreateGraphElements(){for(let t of this.vertexArray){let e=t.VisibilityVertex;for(let i of e.InEdges){let r=new Ua(i,this.VisibilityVerticesToSdVerts.get(i.Source),this.VisibilityVerticesToSdVerts.get(i.Target)),n=this.VisibilityVerticesToSdVerts.get(i.Source);t.InBoneEdges.push(r),n.OutBoneEdges.push(r)}}}CreateRoutingGraph(){this.vertexArray=[],this.VisibilityVerticesToSdVerts=new Map;for(let t of this.VisibilityGraph.Vertices()){let e=new Qa(t);this.vertexArray.push(e),this.VisibilityVerticesToSdVerts.set(t,e)}this.CreateGraphElements()}RouteEdges(){this.Initialize(),this.RestoreCapacities();for(let t of this.geomEdges)this.EdgesToRoutes.set(t,this.RouteEdge(t));this.RerouteEdges();for(let t of this.geomEdges)this.SetEdgeGeometryCurve(t)}SetEdgeGeometryCurve(t){let e=new R,i=this.EdgesToRouteSources.get(t);e.addPoint(i.Point);for(let o of this.EdgesToRoutes.get(t))o.SourcePoint.equal(i.Point)?(e.addPoint(o.TargetPoint),i=o.Target):(e.addPoint(o.SourcePoint),i=o.Source);t.curve=e,t.sourcePort instanceof et&&mi.ExtendPolylineStartToClusterBoundary(e,t.sourcePort.Curve),t.targetPort instanceof et&&mi.ExtendPolylineEndToClusterBoundary(e,t.targetPort.Curve)}static ExtendPolylineEndToClusterBoundary(t,e){let i=e.closestParameter(t.end);t.addPoint(e.value(i))}static ExtendPolylineStartToClusterBoundary(t,e){let i=e.closestParameter(t.start);t.PrependPoint(e.value(i))}RerouteEdges(){this.RestoreCapacities();for(let t of this.geomEdges){let e=this.RerouteEdge(t);this.EdgesToRoutes.set(t,e)}}RestoreCapacities(){this.cdt!=null&&this.cdt.RestoreEdgeCapacities()}RerouteEdge(t){let e=this.EdgesToRoutes.get(t);for(let i of e)i.RemoveOccupiedEdge();return this.RouteEdge(t)}RouteEdge(t){this.CurrentEdgeGeometry=t;for(let r=0;r<this.vertexArray.length;r++){let n=this.vertexArray[r];n.SetPreviousToNull(),n.IsTargetOfRouting=n.IsSourceOfRouting=!1}let e=this.MakeTransparentShapesOfEdgeGeometry(t),i=this.RouteEdgeWithGroups();for(let r of e)r.IsTransparent=!1;return i}RouteEdgeWithGroups(){for(let t=0;t<2;t++){this.SetLengthCoefficient(),this.Queue=new nt,this.sourceLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort,!1);let e=this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(),t===0);if(e!=null)return e;for(let i=0;i<this.vertexArray.length;i++)this.vertexArray[i].SetPreviousToNull()}throw new Error}RouteOnKnownSourceTargetVertices(t,e){for(this.LowestCostToTarget=Number.POSITIVE_INFINITY,this.ClosestTargetVertex=null;this.Queue.count>0;){let i={priority:0},r=this.Queue.DequeueAndGetPriority(i);if(!(i.priority>=this.LowestCostToTarget)){for(let n=0;n<r.OutBoneEdges.length;n++){let o=r.OutBoneEdges[n];o.IsPassable&&this.ProcessOutcomingBoneEdge(r,o,t,e)}for(let n=0;n<r.InBoneEdges.length;n++){let o=r.InBoneEdges[n];o.IsPassable&&this.ProcessIncomingBoneEdge(r,o,t,e)}}}return this.GetPathAndUpdateRelatedCosts()}ProcessOutcomingBoneEdge(t,e,i,r){r&&i.dot(e.TargetPoint.sub(e.SourcePoint))<0||this.ProcessBoneEdge(t,e.Target,e)}ProcessIncomingBoneEdge(t,e,i,r){r&&i.dot(e.SourcePoint.sub(e.TargetPoint))<0||this.ProcessBoneEdge(t,e.Source,e)}ProcessBoneEdge(t,e,i){let r=this.GetEdgeAdditionalCost(i,t.Cost);if(!(e.Cost<=r))if(e.Cost=r,e.PrevEdge=i,this.Queue.ContainsElement(e))this.Queue.DecreasePriority(e,r);else{if(e.IsTargetOfRouting){let n=0;this.CurrentEdgeGeometry.targetPort instanceof et&&(n=this.LengthCoefficient*e.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length),r+n<this.LowestCostToTarget&&(this.LowestCostToTarget=r+n,this.ClosestTargetVertex=e);return}this.Enqueue(e)}}GetPathAndUpdateRelatedCosts(){let t=this.ClosestTargetVertex;if(t==null)return null;let e=new Array;for(;t.PrevEdge!=null;)e.push(t.PrevEdge),this.RegisterPathInBoneEdge(t.PrevEdge),t=t.Prev;return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry,t),e.reverse(),e}RegisterPathInBoneEdge(t){t.AddOccupiedEdge(),this.cdt!=null&&this.BundlingSettings.CapacityOverflowCoefficient!==0&&this.UpdateResidualCostsOfCrossedCdtEdges(t)}UpdateResidualCostsOfCrossedCdtEdges(t){for(let e of t.CrossedCdtEdges)this.AdjacentToSourceOrTarget(e)||(e.ResidualCapacity===e.Capacity?e.ResidualCapacity-=this.BundlingSettings.edgeWidthShrinkCoeff*this.CurrentEdgeGeometry.lineWidth:e.ResidualCapacity-=this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry))}H(t){return t.Cost+this.LengthCoefficient*t.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length}GetEdgeAdditionalCost(t,e){let i=t.TargetPoint.sub(t.SourcePoint).length;return this.LengthCoefficient*i+e+(t.IsOccupied?0:this.BundlingSettings.InkImportance*i)+this.CapacityOverflowCost(t)}CapacityOverflowCost(t){if(this.cdt==null||this.BundlingSettings.CapacityOverflowCoefficient===0)return 0;let e=0;for(let i of this.CrossedCdtEdgesOfBoneEdge(t))e+=this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier,this.BundlingSettings,this.CurrentEdgeGeometry,i);return e}CrossedCdtEdgesOfBoneEdge(t){return t.CrossedCdtEdges!=null?Array.from(t.CrossedCdtEdges):Array.from(t.CrossedCdtEdges=this.ThreadBoneEdgeThroughCdt(t))}ThreadBoneEdgeThroughCdt(t){let e=t.SourcePoint,i=t.Source.Triangle,r=new Set,n=t.TargetPoint;if(ne.PointIsInsideOfTriangle(n,i))return r;let o=new bn(i,e,n);for(;o.MoveNext();){let s=o.CurrentPiercedEdge;this.Gates.has(s)&&r.add(s)}return r}static CostOfCrossingCdtEdge(t,e,i,r){let n=i.lineWidth*e.edgeWidthShrinkCoeff;r.Capacity!==r.ResidualCapacity&&(n+=e.EdgeSeparation*e.edgeWidthShrinkCoeff);let o=r.ResidualCapacity-n;return o>=0?0:-o*t}CostOfCrossingCdtEdgeLocal(t,e,i,r){return this.AdjacentToSourceOrTarget(r)?0:mi.CostOfCrossingCdtEdge(t,e,i,r)}AdjacentToSourceOrTarget(t){return t.upperSite.Owner===this.sourceLoosePoly||t.lowerSite.Owner===this.sourceLoosePoly||t.upperSite.Owner===this.targetLoosePoly||t.lowerSite.Owner===this.targetLoosePoly}SetLengthCoefficient(){let t=this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);this.LengthCoefficient=this.BundlingSettings.PathLengthImportance/t}GetIdealDistanceBetweenSourceAndTarget(t){return t.sourcePort.Location.sub(t.targetPort.Location).length}SetPortVerticesAndObstacles(t,e){let i;if(t instanceof et){i=t.LoosePolyline;for(let n of i){let o=0;e&&(o=this.LengthCoefficient*n.sub(this.CurrentEdgeGeometry.sourcePort.Location).length),this.AddAndEnqueueVertexToEnds(n,e,o)}}else if(t instanceof Re){i=t.LoosePolyline;for(let n of i)this.AddAndEnqueueVertexToEnds(n,e,0)}else{this.AddAndEnqueueVertexToEnds(t.Location,e,0);let r=Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(t.Curve.boundingBox)),n=r[0].boundingBox.diagonal;i=r[0];for(let o=1;o<r.length;o++){let s=r[o],a=s.boundingBox.diagonal;a<n&&(n=a,i=s)}}return i}Enqueue(t){this.Queue.Enqueue(t,this.H(t))}AddAndEnqueueVertexToEnds(t,e,i){let r=this.FindVertex(t),n=this.VisibilityVerticesToSdVerts.get(r);e?(n.IsSourceOfRouting=!0,n.Cost=i,this.Enqueue(n)):n.IsTargetOfRouting=!0}FindVertex(t){return this.VisibilityGraph.FindVertex(t)}Initialize(){this.CreateRoutingGraph(),this.cdt!=null&&(this.capacityOverlowPenaltyMultiplier=mi.CapacityOverflowPenaltyMultiplier(this.BundlingSettings),this.SetVertexTriangles(),this.CalculateCapacitiesOfTrianglulation())}CalculateCapacitiesOfTrianglulation(){for(let t of this.Gates)mi.CalculateCdtEdgeCapacityForEdge(t)}static CalculateCdtEdgeCapacityForEdge(t){if(t.constrained||t.CwTriangle==null||t.CcwTriangle==null)return;let e=t.upperSite.Owner,i=t.lowerSite.Owner;if(e!==i){let r=He.DistancePoint(new He(e),t.lowerSite.point),n=He.DistancePoint(new He(i),t.upperSite.point);t.Capacity=(r+n)/2}}SetVertexTriangles(){let t=ge(Array.from(this.cdt.GetTriangles()).map(i=>Se(i,i.BoundingBox()))),e=ge(this.vertexArray.map(i=>Se(i,I.mkOnPoints([i.Point]))));it(t,e,(i,r)=>this.TryToAssigenTriangleToVertex(i,r))}TryToAssigenTriangleToVertex(t,e){e.Triangle==null&&ne.PointIsInsideOfTriangle(e.Point,t)&&(e.Triangle=t)}static CapacityOverflowPenaltyMultiplier(t){return t.CapacityOverflowCoefficient*(t.PathLengthImportance+t.InkImportance)}FillCrossedCdtEdges(t){for(let e of this.geomEdges){this.sourceLoosePoly=this.SetPortVerticesAndObstacles(e.sourcePort,!0),this.targetLoosePoly=this.SetPortVerticesAndObstacles(e.targetPort,!1);for(let i of this.EdgesToRoutes.get(e))for(let r of this.CrossedCdtEdgesOfBoneEdge(i))this.AdjacentToSourceOrTarget(r)||xn(t,e,r)}}};var Jn=class{constructor(t,e,i,r,n){this.multiEdges=t,this.interactiveEdgeRouter=e,this.bundlingSettings=r,this.bundlingSettings.edgeWidthShrinkCoeff=1,this.transparentShapeSetter=n,this.nodeTree=or(i,o=>o.boundingBox)}run(){for(let t of this.GetIndependantPreGraphs())new Tr(t.edges,new mi(this.transparentShapeSetter,null,null),this.interactiveEdgeRouter.VisibilityGraph,this.bundlingSettings,this.interactiveEdgeRouter.LoosePadding,this.interactiveEdgeRouter.TightHierarchy,this.interactiveEdgeRouter.LooseHierarchy,null,null,null).run()}GetPortCurve(t){return this.nodeTree.FirstHitNodeWithPredicate(t.Location,(i,r)=>p.PointRelativeToCurveLocation(i,r)!==0?1:0).UserData}GetIndependantPreGraphs(){let t=this.CreateInitialPregraphs();do{let e=t.length,i={preGraphs:t};if(this.UniteConnectedPreGraphs(i),e<=t.length)break}while(!0);return t}UniteConnectedPreGraphs(t){let e=Jn.GetIntersectionGraphOfPreGraphs(t.preGraphs);if(e==null)return;let i=Ti(e),r=new Array;for(let n of i){let o=null;for(let s of n)o==null?(o=t.preGraphs[s],r.push(o)):o.AddGraph(t.preGraphs[s])}t.preGraphs=r;for(let n of t.preGraphs)this.AddIntersectingNodes(n)}AddIntersectingNodes(t){let e=t.boundingBox;for(let i of this.nodeTree.GetNodeItemsIntersectingRectangle(e))t.AddNodeBoundary(i)}static GetIntersectionGraphOfPreGraphs(t){let e=Jn.EnumeratePairsOfIntersectedPreGraphs(t);return e.length?rt(e,t.length):null}static EnumeratePairsOfIntersectedPreGraphs(t){let e=Array.from(Array(t.length).keys()),i=or(e,n=>t[n].boundingBox),r=new Array;return Be(i,i,(n,o)=>r.push(new F(n,o))),r}CreateInitialPregraphs(){return this.multiEdges.map(t=>this.CreatePregraphFromSetOfEdgeGeometries(t))}CreatePregraphFromSetOfEdgeGeometries(t){let e=new Set,i=t[0],r=this.GetPortCurve(i.sourcePort),n=r.boundingBox;e.add(r),e.add(i.targetPort.Curve),n.addRec(i.targetPort.Curve.boundingBox);let o=this.nodeTree.GetNodeItemsIntersectingRectangle(n);for(let s of o)e.add(s);return Ao.constructorStatic(t,e)}};var Cs=J(Mi(),1);var Xa=class{constructor(){this.triangles=new Set;this.front=new Cs.Queue;this.passedTrs=new Set;this.visitedInThreader=new Set}setCdt(t){this.cdt=t,this.cdt.SetInEdges();let e=new Set;for(let i of t.GetTriangles())for(let r of i.Sites)r.Owner!=null&&e.add(r.Owner)}findChannelTriangles(){this.passedTrs.clear();for(let t=this.poly.startPoint;t.next!=null;t=t.next)this.addPiercedTrianglesOnSegment(t.point,t.next.point);this.addSourceTargetTriangles()}addSourceTargetTriangles(){this.addPolyTrianglesForEndStart(this.poly.start),this.addPolyTrianglesForEndStart(this.poly.end)}findSiteTriangle(t){let e=this.cdt.FindSite(t);if(e.Edges)for(let i of e.Edges){let r=i.CcwTriangle;if(r&&Lo(r)||(r=i.CwTriangle,r&&Lo(r)))return r}if(e.InEdges)for(let i of e.InEdges){let r=i.CcwTriangle;if(r&&Lo(r)||(r=i.CwTriangle,r&&Lo(r)))return r}return null}addPolyTrianglesForEndStart(t){let e=new Set,i=new Cs.Queue(this.findSiteTriangle(t));for(;i.length;){let r=i.dequeue();for(let n of r.Edges){let o=n.GetOtherTriangle_T(r);o&&!e.has(o)&&Lo(o)&&(i.enqueue(o),e.add(o))}}for(let r of e)this.triangles.add(r)}addPiercedTrianglesOnSegment(t,e){if(this.extendPassedTrsByContainingPoint(t),this.createThreader(t,e),this.passedTrs.size){this.front=new Cs.Queue;return}for(let i of this.threadThrough())this.triangles.add(i)}edgeCanBePierced(t){let e=t.lowerSite.Owner,i=t.upperSite.Owner;return e==this.sourcePoly||i==this.targetPoly||i==this.sourcePoly||e==this.targetPoly||e!=i&&e!==null&&i!==null}padTriangle(t,e){let i=t.Sites.item0.point.add(t.Sites.item1.point).add(t.Sites.item2.point).mul(.3333333333333333),r=new zn;return r.setItem(0,n(t.Sites.item0)),r.setItem(1,n(t.Sites.item1)),r.setItem(2,n(t.Sites.item2)),r;function n(o){let s=o.point.sub(i),a=s.length;return i.add(s.mul((a+e)/a))}}insideSourceOrTargetPoly(t){let e=t.Sites.item0.Owner;return(e===this.sourcePoly||e===this.targetPoly)&&e===t.Sites.item1.Owner&&e===t.Sites.item2.Owner}outsideOfObstacles(t){var i;if(t==null)return!1;let e=(i=t.Sites.item0.Owner)!=null?i:t.Sites.item1.Owner;return e===this.sourcePoly||e===this.targetPoly||!Lo(t)}run(t){if(this.triangles.clear(),this.poly=t,this.d=[],t.count<=2||this.cdt==null)return;this.sourcePoly=this.findPoly(t.start),this.targetPoly=this.findPoly(t.end),this.findChannelTriangles();let e=this.getPerimeterEdges();e=this.fillTheCollapedSites(e);let i=new ne([],[],Array.from(e).map(n=>({A:n.lowerSite.point,B:n.upperSite.point})));i.run();let r=this.getSleeve(this.findSourceTriangle(i));if(r==null){console.log("failed to create sleeve");return}if(r.length==0){this.poly=R.mkFromPoints([t.start,t.end]);return}this.initDiagonals(r),this.refineFunnel()}findPoly(t){var i;let e=this.cdt.FindSite(t);for(let r of e.Edges)return(i=r.lowerSite.Owner)!=null?i:r.upperSite.Owner}fillTheCollapedSites(t){let e=new Map;for(let n of t)r(n.lowerSite,n),r(n.upperSite,n);let i=[];for(let[n,o]of e)o.length>2&&i.push(n);if(i.length==0)return t;for(let n of i)for(let o of n.Triangles())this.outsideOfObstacles(o)&&this.triangles.add(o);return this.getPerimeterEdges();function r(n,o){let s=e.get(n);s==null&&e.set(n,s=[]),s.push(o)}}findSourceTriangle(t){let e;for(let i of t.GetTriangles())if(i.containsPoint(this.poly.start)){e=i;break}return e}refineFunnel(){let t=[],e=this.poly.start,i={point:e},r={point:e},n={point:this.d[0].left,prev:i},o={point:this.d[0].right,prev:r};i.next=n,r.next=o;let s;for(let A=1;A<this.d.length;A++)u(A,this.d);this.d.push({right:this.poly.end,left:n.point}),u(this.d.length-1,this.d);let a=R.mkFromPoints(t);for(let A=r;A!=null;A=A.next)a.addPoint(A.point);this.poly=a;function u(A,M){if(M[A-1].left!==M[A].left){s=M[A].left;let K=n;for(;!(w(K)||g(K));K=K.prev);w(K)?P():G(K)}else{s=M[A].right;let K=o;for(;!(w(K)||f(K));K=K.prev);w(K)?y():x(K)}}function h(A){return A.next==null?!0:c.pointToTheLeftOfLineOrOnLine(s,A.point,A.next.point)}function d(A){return A.next==null?!0:c.pointToTheRightOfLineOrOnLine(s,A.point,A.next.point)}function g(A){return c.pointToTheLeftOfLine(s,A.prev.point,A.point)}function f(A){return c.pointToTheRightOfLine(s,A.prev.point,A.point)}function P(){let A=r;for(;!h(A);)A=A.next;if(!w(A)){let M=r;for(;!M.point.equal(A.point);M=M.next)t.push(M.point);r.point=M.point,r.next=M.next,e=M.point,o.point.equal(r.point)&&(o.prev=o.next=null)}i.point=e,n.point=s,n.prev=i,i.next=n}function y(){let A=i;for(;!d(A);)A=A.next;if(!w(A)){let M=i;for(;!M.point.equal(A.point);M=M.next)t.push(M.point);i.point=M.point,i.next=M.next,e=M.point,n.point.equal(i.point)&&(n.prev=i.next=null)}r.point=e,o.point=s,o.prev=r,r.next=o}function w(A){return A.point==e}function x(A){A!=o?(o.point=s,o.prev=A,A.next=o):(o={point:s,prev:A},A.next=o)}function G(A){A!=n?(n.point=s,n.prev=A,A.next=n):(n={point:s,prev:A},A.next=n)}}initDiagonals(t){for(let e of t){let i=e.edge,r=e.source.OppositeSite(i);c.getTriangleOrientation(r.point,i.lowerSite.point,i.upperSite.point)==1?this.d.push({left:i.upperSite.point,right:i.lowerSite.point}):this.d.push({right:i.upperSite.point,left:i.lowerSite.point})}}getSleeve(t){let e=new Cs.Queue;e.enqueue(t);let i=new Map;for(i.set(t,void 0);e.length>0;){let r=e.dequeue(),n=i.get(r);if(r.containsPoint(this.poly.end))return this.recoverPath(t,i,r);for(let o of r.Edges){if(o.constrained||n!==void 0&&o===n)continue;let s=o.GetOtherTriangle_T(r);s!=null&&(i.has(s)||(i.set(s,o),e.enqueue(s)))}}}recoverPath(t,e,i){let r=[];for(let n=i;n!=t&&n!==t;){let o=e.get(n);n=o.GetOtherTriangle_T(n),r.push({source:n,edge:o})}return r.reverse()}getPerimeterEdges(){let t=new Set;for(let e of this.triangles)for(let i of e.Edges)this.triangles.has(i.GetOtherTriangle_T(e))||t.add(i);return t}canPierce(t,e){return t&&!this.visitedInThreader.has(e.GetOtherTriangle_T(t))&&this.edgeCanBePierced(e)}createThreader(t,e){this.start=t,this.end=e,this.visitedInThreader.clear();let i=Array.from(this.passedTrs).map(r=>r);this.passedTrs.clear();for(let r of i)this.initFront(r)}initFront(t){t.containsPoint(this.end)&&(this.passedTrs.add(t),this.triangles.add(t));let e=this.GetHyperplaneSign(t.Sites.item0),i=this.GetHyperplaneSign(t.Sites.item1);if(this.canPierce(t,t.Edges.item0)&&e!==i&&c.getTriangleOrientation(this.end,t.Sites.item0.point,t.Sites.item1.point)==0){let n={source:t,edge:t.Edges.item0,rightSign:e,leftSign:i};this.enqueueInFront(n)}let r=this.GetHyperplaneSign(t.Sites.item2);if(this.canPierce(t,t.Edges.item1)&&i!==r&&c.getTriangleOrientation(this.end,t.Sites.item1.point,t.Sites.item2.point)==0){let n={source:t,edge:t.Edges.item1,rightSign:i,leftSign:r};this.enqueueInFront(n)}if(this.canPierce(t,t.Edges.item2)&&e!==r&&c.getTriangleOrientation(this.end,t.Sites.item2.point,t.Sites.item0.point)==0){let n={source:t,edge:t.Edges.item2,rightSign:r,leftSign:e};this.enqueueInFront(n)}}enqueueInFront(t){this.front.enqueue(t)}processFrontEdge(t){let e=ud(t);if(e==null)return;if(this.visitedInThreader.add(e),e.containsPoint(this.end)){this.passedTrs.add(e);return}let i=e.Edges.index(t.edge),r=e.Sites.getItem(i+2),n=this.canPierce(e,e.Edges.getItem(i+1)),o=this.canPierce(e,e.Edges.getItem(i+2));if(!n&&!o)return;let s=this.GetHyperplaneSign(r);n&&s<t.rightSign&&this.enqueueInFront({source:e,edge:e.Edges.getItem(i+1),leftSign:s,rightSign:t.rightSign}),o&&s>t.leftSign&&this.enqueueInFront({source:e,edge:e.Edges.getItem(i+2),leftSign:t.leftSign,rightSign:s})}extendPassedTrsByContainingPoint(t){let e=this.cdt.FindSite(t);if(e)for(let i of e.Triangles())this.outsideOfObstacles(i)&&(this.passedTrs.add(i),this.triangles.add(i));else{let i=this.passedTrs.values().next().value;for(let r of i.Edges){let n=r.GetOtherTriangle_T(i);if(this.outsideOfObstacles(n)&&n.containsPoint(t)){this.passedTrs.add(n),this.triangles.add(n);break}}}}*neigborsInChannel(t){for(let e of t.Edges){if(this.edgeCanBePierced(e)===!1)continue;let i=e.GetOtherTriangle_T(t);this.visitedInThreader.has(i)||(yield i)}}GetHyperplaneSign(t){let e=c.signedDoubledTriangleArea(this.start,t.point,this.end);return e>m.distanceEpsilon?1:e<-m.distanceEpsilon?-1:0}*threadThrough(){for(;this.front.length;){let t=this.front.dequeue();this.processFrontEdge(t)}for(let t of this.visitedInThreader)yield t}};function Lo(l){return l.Sites.item0.Owner==null||l.Sites.item1.Owner==null||l.Sites.item2.Owner==null?!0:l.Sites.item0.Owner==l.Sites.item1.Owner&&l.Sites.item0.Owner==l.Sites.item2.Owner}function ud(l){return l.edge.GetOtherTriangle_T(l.source)}var $=class extends H{constructor(e,i,r=1,n=2,o=30*(Math.PI/180),s=null,a=null){super(a);this.continueOnOverlaps=!0;this.shapesToTightLooseCouples=new Map;this.multiEdgesSeparation=.5;this.routeMultiEdgesAsBundles=!0;this.UsePolylineEndShortcutting=!0;this.UseInnerPolylingShortcutting=!0;this.AllowedShootingStraightLines=!0;this._overlapsDetected=!1;this.edges=i,this.BundlingSettings=s,this.geomGraph=e,this.LoosePadding=n,this.tightPadding=r,this.coneAngle=o,this.routeMultiEdgesAsBundles=i.length<1e3&&e.deepNodeCount<1e3}get ContinueOnOverlaps(){return this.continueOnOverlaps}set ContinueOnOverlaps(e){this.continueOnOverlaps=e}get LoosePadding(){return this.loosePadding}set LoosePadding(e){this.loosePadding=e}get MultiEdgesSeparation(){return this.multiEdgesSeparation}set MultiEdgesSeparation(e){this.multiEdgesSeparation=e}static mk2(e,i){return $.mk5(e,i.Padding,i.PolylinePadding,i.ConeAngle,i.bundlingSettings)}static mk4(e,i,r,n){return new $(e,Array.from(e.deepEdges),i,r,n,null)}static mk5(e,i,r,n,o){return new $(e,Array.from(e.deepEdges),i,r,n,o)}static mk6(e,i,r,n,o,s){let a=$.mk4(e,i,r,n),u=qt.GetShapes(o,s);return a.Initialize(u,n),a}Initialize(e,i){this.rootShapes=e.filter(r=>r.Parents==null||r.Parents.length===0),this.coneAngle=i,this.coneAngle===0&&(this.coneAngle=Math.PI/6)}run(){if(this.edges.length==0||this.geomGraph.isEmpty())return;let e=ot.GetShapes(this.geomGraph,this.edges);this.BundlingSettings==null&&this.geomGraph.layoutSettings&&this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings&&this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings&&(this.BundlingSettings=this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings),this.Initialize(e,this.coneAngle),this.GetOrCreateRoot(),this.RouteOnRoot(),this.RemoveRoot()}rerouteOnSubsetOfNodes(e){this.RouteMultiEdgesAsBundles=!1,this.edges=Array.from(this.geomGraph.deepEdges).filter(r=>eo(r.edge,e));let i=ot.GetShapes(this.geomGraph,this.edges);this.rootShapes=i.filter(r=>r.Parents==null||r.Parents.length===0),this.GetOrCreateRoot(),this.CalculateShapeToBoundaries(this.root),this.calcLooseShapesToNodes(),this.CalculatePortsToShapes(),this.rerouteOnActiveNodes(e),this.RemoveRoot()}calcLooseShapesToNodes(){if(this.loosePolylinesToNodes=new Map,!this.OverlapsDetected){for(let[r,n]of this.shapesToTightLooseCouples)this.loosePolylinesToNodes.set(n.LooseShape.BoundaryCurve,new Set([r.node.node]));return}let e=or(this.geomGraph.nodesBreadthFirst,r=>r.boundingBox),i=this.GetLooseHierarchy();it(i,e,(r,n)=>{if(p.CurveIsInsideOther(n.boundaryCurve,r)){let o=this.loosePolylinesToNodes.get(r);for(let s of n.getAncestors())if(!(s instanceof de&&s.parent==null)&&s.boundaryCurve!=null&&p.CurveIsInsideOther(s.boundaryCurve,r))return;o==null&&this.loosePolylinesToNodes.set(r,o=new Set),o.add(n.node)}})}RouteOnRoot(){Qr(0),this.CalculatePortsToShapes(),this.CalculatePortsToEnterableShapes(),this.CalculateShapeToBoundaries(this.root),!(this.OverlapsDetected&&!this.ContinueOnOverlaps)&&(this.BindLooseShapes(),this.SetLoosePolylinesForAnywherePorts(),this.CalculateVisibilityGraph(),this.RouteOnVisGraph())}CalculatePortsToEnterableShapes(){this.portsToEnterableShapes=new Map;for(let[e,i]of this.portsToShapes){let r=new Set;$.EdgesAttachedToPortAvoidTheNode(e)||r.add(i),this.portsToEnterableShapes.set(e,r)}for(let e of this.rootShapes)for(let i of e.Descendants())for(let r of i.Ports){let n=this.portsToEnterableShapes.get(r);Vr(n,Array.from(i.Ancestors()).filter(o=>o.BoundaryCurve!=null))}}static EdgesAttachedToPortAvoidTheNode(e){return e instanceof tt||e instanceof et}SetLoosePolylinesForAnywherePorts(){for(let[e,i]of this.shapesToTightLooseCouples)for(let r of e.Ports){if(r instanceof Re){let o=r;o.LoosePolyline=i.LooseShape.BoundaryCurve}if(r instanceof et){let o=r;o.LoosePolyline=i.LooseShape.BoundaryCurve}}}BindLooseShapes(){this.looseRoot=new Ci;for(let e of this.root.Children){let i=this.shapesToTightLooseCouples.get(e).LooseShape;this.BindLooseShapesUnderShape(e),this.looseRoot.AddChild(i)}}BindLooseShapesUnderShape(e){let i=this.shapesToTightLooseCouples.get(e).LooseShape;for(let r of e.Children){let n=this.shapesToTightLooseCouples.get(r).LooseShape;i.AddChild(n),this.BindLooseShapesUnderShape(r)}}CalculateShapeToBoundaries(e){if(this.ProgressStep(),e.Children.length!==0){for(let i of e.Children)this.CalculateShapeToBoundaries(i);this.obstacleCalculator=new uo(e,this.tightPadding,this.AdjustedLoosePadding,this.shapesToTightLooseCouples),this.obstacleCalculator.Calculate(.01),this.OverlapsDetected||(this.OverlapsDetected=this.obstacleCalculator.OverlapsDetected)}}get OverlapsDetected(){return this._overlapsDetected}set OverlapsDetected(e){this._overlapsDetected=e}get AdjustedLoosePadding(){return this.BundlingSettings==null?this.LoosePadding:this.LoosePadding*Tr.SuperLoosePaddingCoefficient}GroupEdgesByPassport(){let e=new Array;for(let i of this.edges){let r=this.EdgePassport(i),n=e.find(o=>vn(o.passport,r));n||(n={passport:r,edges:[]},e.push(n)),n.edges.push(i)}return e}RouteOnVisGraph(){if(this.ancestorSets=$.GetAncestorSetsMap(Array.from(this.root.Descendants())),this.BundlingSettings==null){let e=this.GroupEdgesByPassport();for(let i=0;i<e.length;i++){let r=e[i],n=r.passport,o=this.GetObstaclesFromPassport(n),s=this.CreateInteractiveEdgeRouter(Array.from(o));this.RouteEdgesWithTheSamePassport(r,s,o)}}else this.RouteBundles()}rerouteOnActiveNodes(e){if(this.ancestorSets=$.GetAncestorSetsMap(Array.from(this.root.Descendants())),this.BundlingSettings==null)for(let i of this.GroupEdgesByPassport()){let r=i.passport,n=this.GetObstaclesFromPassport(r),o=new Set;for(let a of n){let u=this.LooseShapeOfOriginalShape(a);for(let h of this.loosePolylinesToNodes.get(u.BoundaryCurve))e.has(h)&&o.add(a)}let s=this.CreateInteractiveEdgeRouter(Array.from(o));this.rerouteEdgesWithTheSamePassportActiveNodes(i,s,o,e)}else this.RouteBundles()}getDebugCurvesFromEdgesAndCdt(e){let i=Array.from(this.geomGraph.deepEdges).map(r=>r.curve).filter(r=>r!=null).filter(r=>r.count>5).map(r=>z.mkDebugCurveTWCI(200,1,"Red",r));for(let r of e.PointsToSites.values())for(let n of r.Edges)i.push(z.mkDebugCurveTWCI(200,.5,n.constrained?"Blue":"Green",S.mkPP(n.lowerSite.point,n.upperSite.point)));return i}RouteEdgesWithTheSamePassport(e,i,r){let n={regularEdges:[],multiEdges:[]};try{let o=this.getCdtFromPassport(r);i.pathOptimizer.setCdt(o)}catch(o){i.pathOptimizer.setCdt(null)}if(this.RouteMultiEdgesAsBundles){if(this.SplitOnRegularAndMultiedges(e.edges,n),n.regularEdges.length>0)for(let o=0;o<n.regularEdges.length;o++)this.routeEdge(i,n.regularEdges[o]);n.multiEdges!=null&&(this.ScaleDownLooseHierarchy(i,r),this.RouteMultiEdges(n.multiEdges,i,e.passport))}else for(let o=0;o<e.edges.length;o++)this.routeEdge(i,e.edges[o])}rerouteEdgesWithTheSamePassportActiveNodes(e,i,r,n){let o={regularEdges:[],multiEdges:[]};try{let s=this.getCdtFromPassport(r);i.pathOptimizer.setCdt(s)}catch(s){console.log(s),i.pathOptimizer.setCdt(null)}if(this.RouteMultiEdgesAsBundles){if(this.SplitOnRegularAndMultiedges(e.edges,o),o.regularEdges.length>0)for(let s=0;s<o.regularEdges.length;s++){let a=o.regularEdges[s];X.assert(eo(a.edge,n)),this.rerouteEdge(i,a)}o.multiEdges!=null&&(this.ScaleDownLooseHierarchy(i,r),this.RouteMultiEdges(o.multiEdges,i,e.passport))}else for(let s=0;s<e.edges.length;s++){let a=e.edges[s];eo(a.edge,n)&&this.rerouteEdge(i,a)}}rerouteEdge(e,i){try{e.rerouteEdge(i),we.trimSplineAndCalculateArrowheadsII(i,i.sourcePort.Curve,i.targetPort.Curve,i.curve,!1)}catch(r){}}getCdtFromPassport(e){let i=new Set,r=[],n=I.mkEmpty();for(let a of e){let u=this.LoosePolyOfOriginalShape(a);if(u!=null){i.add(u);for(let h of a.Ports)r.push(h.Location);n.addRecSelf(u.boundingBox)}}n.pad(Math.max(n.diagonal/4,100));let o=Array.from(i);o.push(n.perimeter());let s=new ne(r,o,[]);return s.run(),s}get RouteMultiEdgesAsBundles(){return this.routeMultiEdgesAsBundles}set RouteMultiEdgesAsBundles(e){this.routeMultiEdgesAsBundles=e}routeEdge(e,i){let r=this.makeTransparentShapesOfEdgeAndGetTheShapes(i);this.ProgressStep(),this.RouteEdgeInternal(i,e),$.SetTransparency(r,!1)}ScaleDownLooseHierarchy(e,i){let r=new Array;for(let n of i){let o=this.shapesToTightLooseCouples.get(n);r.push(We.LoosePolylineWithFewCorners(o.TightPolyline,o.Distance/1.1,0))}e.LooseHierarchy=$.CreateLooseObstacleHierarachy(r),e.ClearActivePolygons(),e.AddActivePolygons(r.map(n=>new He(n)))}RouteMultiEdges(e,i,r){let n=[];for(let a of r)for(let u of a.Children)n.push(u.BoundaryCurve);let o=new Kt;o.InkImportance=1e-5,o.EdgeSeparation=this.MultiEdgesSeparation,new Jn(e,i,n,o,a=>this.makeTransparentShapesOfEdgeAndGetTheShapes(a)).run()}SplitOnRegularAndMultiedges(e,i){let r=new Gt;for(let n of e)$.IsEdgeToParent(n)?i.regularEdges.push(n):$.RegisterInPortLocationsToEdges(n,r);i.multiEdges=null;for(let n of r.values())n.length===1||this.OverlapsDetected?Bi(i.regularEdges,n):(i.multiEdges==null&&(i.multiEdges=new Array),i.multiEdges.push(n))}static RegisterInPortLocationsToEdges(e,i){let r,n=new he(e.sourcePort.Location,e.targetPort.Location);r=i.get(n),r||(r=new Array,i.set(n,r)),r.push(e)}static IsEdgeToParent(e){return e.sourcePort instanceof Re||e.targetPort instanceof Re}CreateInteractiveEdgeRouter(e){let i=new Set(e.map(n=>this.shapesToTightLooseCouples.get(n).LooseShape.BoundaryCurve)),r=new re(this.cancelToken);return r.pathOptimizer=new Xa,r.ObstacleCalculator=new We(e.map(n=>n.BoundaryCurve),this.tightPadding,this.loosePadding,!1),r.VisibilityGraph=this.visGraph,r.TightHierarchy=this.CreateTightObstacleHierarachy(e),r.LooseHierarchy=$.CreateLooseObstacleHierarachy(Array.from(i)),r.UseSpanner=!0,r.LookForRoundedVertices=!0,r.TightPadding=this.tightPadding,r.LoosePadding=this.LoosePadding,r.UseEdgeLengthMultiplier=this.UseEdgeLengthMultiplier,r.UsePolylineEndShortcutting=this.UsePolylineEndShortcutting,r.UseInnerPolylingShortcutting=this.UseInnerPolylingShortcutting,r.AllowedShootingStraightLines=this.AllowedShootingStraightLines,r.AddActivePolygons(Array.from(i).map(n=>new He(n))),r}GetObstaclesFromPassport(e){if(e.size===0)return new Set(this.root.Children);let i=this.GetCommonAncestorsAbovePassport(e),r=this.GetAllAncestors(e),n=new Set;for(let a of e)for(let u of a.Children)r.has(u)||n.add(u);let o=bi(new Set(e),n),s=new Oh.Queue;for(let a of e)i.has(a)||s.enqueue(a);for(;s.length>0;){let a=s.dequeue();for(let u of a.Parents){for(let h of u.Children)r.has(h)||n.add(h);!i.has(u)&&!o.has(u)&&(s.enqueue(u),o.add(u))}}return n}GetAllAncestors(e){if(e.size===0)return new Set;let i=new Set(e);for(let r of e)i=bi(i,this.ancestorSets.get(r));return i}GetCommonAncestorsAbovePassport(e){if(e.size===0)return new Set;let i=Array.from(e),r=this.ancestorSets.get(i[0]);for(let n=1;n<i.length;n++){let o=i[n];r=Si(r,this.ancestorSets.get(o))}return r}RouteBundles(){this.ScaleLooseShapesDown(),this.CalculateEdgeEnterablePolylines();let e=this.GetLooseHierarchy(),i=Ta(e),r=new mi(o=>this.makeTransparentShapesOfEdgeAndGetTheShapes(o),i,this.FindCdtGates(i));new Tr(this.edges,r,this.visGraph,this.BundlingSettings,this.LoosePadding,this.GetTightHierarchy(),e,this.enterableLoose,this.enterableTight,o=>this.LoosePolyOfOriginalShape(this.portsToShapes.get(o))).run()}CreateTheMapToParentLooseShapes(e,i){for(let r of e.Children){let o=this.shapesToTightLooseCouples.get(r).LooseShape.BoundaryCurve;i.set(o,e),this.CreateTheMapToParentLooseShapes(r,i)}}FindCdtGates(e){let i=new Map;this.CreateTheMapToParentLooseShapes(this.root,i);let r=new Set;for(let n of e.PointsToSites.values())for(let o of n.Edges){if(o.CwTriangle==null&&o.CcwTriangle==null)continue;let s=n.Owner,a=o.lowerSite.Owner;if(s===a)continue;let u=i.get(s);if(u){let h=i.get(a);u===h&&r.add(o)}}return r}CalculateEdgeEnterablePolylines(){this.enterableLoose=new Map,this.enterableTight=new Map;for(let e of this.edges){let i=new Set,r=new Set;this.GetEdgeEnterablePolylines(e,i,r),this.enterableLoose.set(e,i),this.enterableTight.set(e,r)}}GetEdgeEnterablePolylines(e,i,r){let n=this.portsToShapes.get(e.sourcePort),o=this.portsToShapes.get(e.targetPort);n!==this.root&&this.GetEnterablesForShape(n,i,r),o!==this.root&&this.GetEnterablesForShape(o,i,r)}GetEnterablesForShape(e,i,r){for(let n of this.ancestorSets.get(e)){let o=this.LoosePolyOfOriginalShape(n);o&&i.add(o);let s=this.TightPolyOfOriginalShape(n);s&&r.add(s)}}GetTightHierarchy(){return ge(Array.from(this.shapesToTightLooseCouples.values()).map(e=>Se(e.TightPolyline,e.TightPolyline.boundingBox)))}GetLooseHierarchy(){let e=new Set;for(let i of this.shapesToTightLooseCouples.values())e.add(i.LooseShape.BoundaryCurve);return ge(Array.from(e).map(i=>Se(i,i.boundingBox)))}ScaleLooseShapesDown(){for(let[,e]of this.shapesToTightLooseCouples)e.LooseShape.BoundaryCurve=We.LoosePolylineWithFewCorners(e.TightPolyline,e.Distance/Tr.SuperLoosePaddingCoefficient,0)}EdgePassport(e){let i=new Set,r=this.portsToShapes.get(e.sourcePort),n=this.portsToShapes.get(e.targetPort);return this.IsAncestor(r,n)?(Vr(i,n.Parents),i.add(r),i):this.IsAncestor(n,r)?(Vr(i,r.Parents),i.add(n),i):(r!==this.looseRoot&&Vr(i,r.Parents),n!==this.looseRoot&&Vr(i,n.Parents),i)}*AllPorts(){for(let e of this.edges)yield e.sourcePort,yield e.targetPort}CalculatePortsToShapes(){this.portsToShapes=new Map;for(let e of this.root.Descendants())for(let i of e.Ports)this.portsToShapes.set(i,e);for(let e of this.AllPorts())this.portsToShapes.has(e)||(this.root.Ports.add(e),this.portsToShapes.set(e,this.root))}RouteEdgeInternal(e,i){let r=new Array;e.sourcePort instanceof Re||Bi(r,this.AddVisibilityEdgesFromPort(e.sourcePort)),e.targetPort instanceof Re||Bi(r,this.AddVisibilityEdgesFromPort(e.targetPort));let n={smoothedPolyline:null};if(c.closeDistEps(e.sourcePort.Location,e.targetPort.Location)?e.curve=Pe.RouteSelfEdge(e.sourcePort.Curve,Math.max(this.LoosePadding*2,e.GetMaxArrowheadLength()),n):e.curve=i.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(e.sourcePort,e.targetPort,!0,n),e.smoothedPolyline=n.smoothedPolyline,e.curve==null)throw new Error;for(let o of r)se.RemoveEdge(o);we.trimSplineAndCalculateArrowheadsII(e,e.sourcePort.Curve,e.targetPort.Curve,e.curve,!1)}*AddVisibilityEdgesFromPort(e){let i,r;if(e instanceof tt||!(i=this.portsToShapes.get(e))||!(r=this.shapesToTightLooseCouples.get(i)))return;let n=r.LooseShape;for(let o of n.BoundaryCurve)this.visGraph.FindEdgePP(e.Location,o)==null&&(yield this.visGraph.AddEdgePP(e.Location,o))}makeTransparentShapesOfEdgeAndGetTheShapes(e){let i=this.portsToShapes.get(e.sourcePort),r=this.portsToShapes.get(e.targetPort),n=new Array;for(let o of this.GetTransparentShapes(e.sourcePort,e.targetPort,i,r))o!=null&&n.push(this.LooseShapeOfOriginalShape(o));for(let o of this.portsToEnterableShapes.get(e.sourcePort))n.push(this.LooseShapeOfOriginalShape(o));for(let o of this.portsToEnterableShapes.get(e.targetPort))n.push(this.LooseShapeOfOriginalShape(o));return $.SetTransparency(n,!0),n}LooseShapeOfOriginalShape(e){return e===this.root?this.looseRoot:this.shapesToTightLooseCouples.get(e).LooseShape}LoosePolyOfOriginalShape(e){return this.LooseShapeOfOriginalShape(e).BoundaryCurve}TightPolyOfOriginalShape(e){return e===this.root?null:this.shapesToTightLooseCouples.get(e).TightPolyline}*GetTransparentShapes(e,i,r,n){for(let o of this.ancestorSets.get(r))yield o;for(let o of this.ancestorSets.get(n))yield o;$.EdgesAttachedToPortAvoidTheNode(e)||(yield r),$.EdgesAttachedToPortAvoidTheNode(i)||(yield n)}static SetTransparency(e,i){for(let r of e)r.IsTransparent=i}IsAncestor(e,i){let r;return i!=null&&(r=this.ancestorSets.get(i))!=null&&r.has(e)}static CreateLooseObstacleHierarachy(e){return ge(e.map(i=>Se(i,i.boundingBox)))}CreateTightObstacleHierarachy(e){let i=e.map(r=>this.shapesToTightLooseCouples.get(r).TightPolyline);return ge(i.map(r=>Se(r,r.boundingBox)))}CalculateVisibilityGraph(){let e=this.LineSweeperPorts!=null?ie.mk(this.LineSweeperPorts):new ie;this.ProcessHookAnyWherePorts(e),this.portRTree=yi(Array.from(e.values()).map(i=>[I.rectangleOnPoint(i),i])),this.visGraph=new se,this.FillVisibilityGraphUnderShape(this.root)}static ShowVisGraph(e,i,r,n=null,o=null){let s=Array.from(i.Edges).map(a=>z.mkDebugCurveTWCI(100,1,a.IsPassable!=null&&a.IsPassable()?"green":"black",S.mkPP(a.SourcePoint,a.TargetPoint)));if(r!=null)for(let a of r){s.push(z.mkDebugCurveTWCI(100,.3,"brown",a));for(let u of a)s.push(z.mkDebugCurveTWCI(100,1,"green",be.mkCircle(1,u)))}if(n!=null)for(let a of n)s.push(z.mkDebugCurveTWCI(100,10,"navy",a));if(o!=null)for(let a of o)s.push(z.mkDebugCurveTWCI(100,10,"red",a))}ProcessHookAnyWherePorts(e){for(let i of this.edges)i.sourcePort instanceof Re||i.sourcePort instanceof et||e.add(i.sourcePort.Location),i.targetPort instanceof Re||i.targetPort instanceof et||e.add(i.targetPort.Location)}FillVisibilityGraphUnderShape(e){let i=e.Children;for(let d=0;d<i.length;d++){let g=i[d];this.FillVisibilityGraphUnderShape(g)}let r=this.shapesToTightLooseCouples.get(e),n=r?r.LooseShape.BoundaryCurve:null,o=r?r.LooseShape:this.looseRoot,s=new Set(o.Children.map(d=>d.BoundaryCurve)),a=this.RemoveInsidePortsAndSplitBoundaryIfNeeded(n),u=new se,h=Ui.mk([],u,this.coneAngle,a,n);h.run(),u=new se,h=Ui.mk(Array.from(s),u,this.coneAngle,a,n),h.run(),this.ProgressStep();for(let d of u.Edges)this.TryToCreateNewEdgeAndSetIsPassable(d,o);this.AddBoundaryEdgesToVisGraph(n)}TryToCreateNewEdgeAndSetIsPassable(e,i){let r=this.visGraph.FindEdgePP(e.SourcePoint,e.TargetPoint);r==null&&(r=this.visGraph.AddEdgePP(e.SourcePoint,e.TargetPoint),i!=null&&(r.IsPassable=()=>i.IsTransparent))}AddBoundaryEdgesToVisGraph(e){if(e==null)return;let i;for(let r=e.startPoint;i=r.nextOnPolyline,this.visGraph.AddEdgePP(r.point,i.point),i!==e.startPoint;r=i);}RemoveInsidePortsAndSplitBoundaryIfNeeded(e){let i=new ie;if(e==null){for(let o of this.portRTree.GetAllLeaves())i.add(o);return this.portRTree.clear(),i}let r=e.boundingBox,n=this.portRTree.GetAllIntersecting(r);for(let o of n)switch(p.PointRelativeToCurveLocation(o,e)){case 2:i.add(o),this.portRTree.Remove(I.rectangleOnPoint(o),o);break;case 1:this.portRTree.Remove(I.rectangleOnPoint(o),o);let s=$.FindPointOnPolylineToInsertAfter(e,o);if(s!=null)ke.InsertPointIntoPolylineAfter(e,s,o);else throw new Error;break}return i}static FindPointOnPolylineToInsertAfter(e,i){for(let r=e.startPoint;;){let n=r.nextOnPolyline;if(c.closeDistEps(i,r.point)||c.closeDistEps(i,n.point))return null;let o=c.distToLineSegment(i,r.point,n.point).dist;if(N(o,0))return r;if(r=n,r===e.startPoint)throw new Error}}GetOrCreateRoot(){if(this.rootShapes.length===1){let e=this.rootShapes[0];if(e.BoundaryCurve==null){this.root=e;return}}this.rootWasCreated=!0,this.root=new Ci(null);for(let e of this.rootShapes)this.root.AddChild(e)}RemoveRoot(){if(!!this.rootWasCreated){for(let e of this.rootShapes)e.RemoveParent(this.root);this.root=null,this.rootWasCreated=!1}}static GetAncestorSetsMap(e){let i=new Map;for(let r of e.filter(n=>!i.has(n)))i.set(r,$.GetAncestorSet(r,i));return i}static GetAncestorSet(e,i){let r=new Set(e.Parents);for(let n of e.Parents){let o=i.get(n);o||i.set(n,o=$.GetAncestorSet(n,i));for(let s of o)r.add(s)}return r}static CreatePortsIfNeeded(e){for(let i of e){if(i.sourcePort==null){let r=i;new $e(()=>r.source.boundaryCurve,()=>r.source.center,new c(0,0))}if(i.targetPort==null){let r=i;new $e(()=>r.target.boundaryCurve,()=>r.target.center,new c(0,0))}}}};function xh(l,t,e){let i=Zl(l);new $(l,t,i.Padding,i.PolylinePadding,i.coneAngle,i.bundlingSettings,e).run()}var _a=class{constructor(t,e){this.tileCapacity=500;this.levels=[];this.nodeIndexInSortedNodes=new Map;this.geomGraph=t,this.topLevelTileRect=e,this.tileSizes=[],this.tileSizes.push(e.size)}getTileData(t,e,i){let r=this.levels[i];return r?r.get(t,e):null}*getTilesOfLevel(t){let e=this.levels[t];if(e!=null)for(let[i,r]of e.keyValues())yield{x:i.x,y:i.y,data:r}}getMinTileSize(){let t=0,e=0,i=0;for(let r of this.geomGraph.nodesBreadthFirst)r instanceof de||(i==0?(t=r.width,e=r.height):(t=(i*t+r.width)/(i+1),e=(i*e+r.height)/(i+1)),i++);return new Ke(t*3,e*3)}fillTheLowestLayer(){let t=new ct(1),e=new hr(this.topLevelTileRect),i=e.arrowheads,r=e.labels;for(let o of this.geomGraph.graph.deepEdges)n(o);e.nodes=Array.from(this.geomGraph.nodesBreadthFirst),t.set(0,0,e),this.levels.push(t);function n(o){let s=Pe.getGeom(o),a=Pe.getGeom(o).curve;if(a instanceof p)for(let u of a.segs)e.addElement({edge:o,curve:u});else e.addElement({edge:o,curve:a});s.sourceArrowhead&&i.push({edge:s.edge,tip:s.sourceArrowhead.tipPosition,base:s.curve.start}),s.targetArrowhead&&i.push({edge:s.edge,tip:s.targetArrowhead.tipPosition,base:s.curve.end}),s.label&&r.push(s.label)}}buildUpToLevel(t){if(this.fillTheLowestLayer(),this.minTileSize=this.getMinTileSize(),this.pageRank=Ns(this.geomGraph.graph,.85),!this.needToSubdivide())return 1;for(let r=1;r<=t&&!this.subdivideLevel(r);r++);let e=Array.from(this.pageRank.keys()).sort(this.compareByPagerank.bind(this));for(let r=0;r<e.length;r++)this.nodeIndexInSortedNodes.set(e[r],r);for(let r=0;r<this.levels.length-1;r++)this.filterOutEntities(this.levels[r],e,r);let i=new $(this.geomGraph,[]);for(let r=this.levels.length-2;r>=0;r--){let n=this.setOfNodesOnTheLevel(r);i.rerouteOnSubsetOfNodes(n),this.regenerateCurveClipsUpToLayer(r,n)}return this.calculateNodeRank(e),this.levels.length}needToSubdivide(){let t=!1;for(let e of this.levels[0].values())if(e.entityCount>this.tileCapacity){t=!0;break}return t}setOfNodesOnTheLevel(t){let e=new Set;for(let i of this.levels[t].values())for(let r of i.nodes)e.add(r.node);return e}regenerateCurveClipsUpToLayer(t,e){this.clearCurveClipsInLevelsUpTo(t);for(let i of this.levels[0].values())this.regenerateCurveClipsUnderTileUpToLevel(i,t,e)}clearCurveClipsInLevelsUpTo(t){for(let e=0;e<=t;e++)for(let i of this.levels[e].values())i.initCurveClips()}regenerateCurveClipsUnderTileUpToLevel(t,e,i){t.arrowheads=[],t.initCurveClips();for(let r of this.geomGraph.deepEdges)!eo(r.edge,i)||(t.addElement({edge:r.edge,curve:r.curve}),r.sourceArrowhead&&t.arrowheads.push({edge:r.edge,tip:r.sourceArrowhead.tipPosition,base:r.curve.start}),r.targetArrowhead&&t.arrowheads.push({edge:r.edge,tip:r.targetArrowhead.tipPosition,base:r.curve.end}));for(let r=1;r<=e;r++)this.regenerateCurveClipsWhenPreviosLayerIsDone(r),this.removeEmptyTiles(r)}removeEmptyTiles(t){let e=this.levels[t],i=[];for(let[r,n]of e.keyValues())n.isEmpty()&&i.push(r);for(let r of i)e.delete(r.x,r.y)}regenerateCurveClipsWhenPreviosLayerIsDone(t){for(let[e,i]of this.levels[t-1].keyValues())this.subdivideTile(e,t,i,!0)}calculateNodeRank(t){this.nodeRank=new Map;let e=t.length;for(let i=0;i<e;i++)this.nodeRank.set(t[i],-Math.log10((i+1)/e))}compareByPagerank(t,e){return this.pageRank.get(e)-this.pageRank.get(t)}filterOutEntities(t,e,i){let r=this.transferDataOfLevelToMap(t),n=0;for(;n<e.length;n++){let o=e[n];if(!this.addNodeToLevel(t,o,r))break}return this.removeEmptyTiles(i),n}addNodeToLevel(t,e,i){let r=i.get(e);for(let o of r)if(o.tile.entityCount>=this.tileCapacity)return!1;for(let o of r){let s=o.tile,a=o.data;s.addElement(a)}for(let o of e.selfEdges){let s=i.get(o);for(let a of s){let u=a.tile,h=a.data;u.addElement(h)}if(o.label)for(let a of i.get(o.label)){let u=a.tile,h=a.data;u.addElement(h)}}let n=this.nodeIndexInSortedNodes.get(e);for(let o of e.inEdges){let s=o.source;if(!(this.nodeIndexInSortedNodes.get(s)>n)){for(let u of i.get(o)){let h=u.tile,d=u.data;h.addElement(d)}if(o.label)for(let u of i.get(o.label)){let h=u.tile,d=u.data;h.addElement(d)}}}for(let o of e.outEdges){let s=o.target;if(!(this.nodeIndexInSortedNodes.get(s)>n)){for(let u of i.get(o)){let h=u.tile,d=u.data;h.addElement(d)}if(o.label)for(let u of i.get(o.label)){let h=u.tile,d=u.data;h.addElement(d)}}}return!0}transferDataOfLevelToMap(t){let e=new Map;for(let r of t.values()){for(let n of r.getBundles())for(let o of n.edges)i(o).push({tile:r,data:{edge:o,curve:n.clip}});for(let n of r.labels){let o=n.parent.edge;i(o).push({tile:r,data:n})}for(let n of r.nodes){let o=n.node;i(o).push({tile:r,data:n})}for(let n of r.arrowheads){let o=n.edge;i(o).push({tile:r,data:n})}r.clear()}return e;function i(r){let n=e.get(r);return n||e.set(r,n=new Array),n}}subdivideLevel(t){let e=Math.pow(2,t);if(this.levels[t]=new ct(e),this.subdivideTilesOnLevel(t))return console.log("done subdividing at level",t,"because each tile contains less than",this.tileCapacity),!0;let{w:r,h:n}=this.getWHOnLevel(t);return r<=this.minTileSize.width&&n<=this.minTileSize.height?(console.log("done subdividing at level",t," because of the tile size = ",r,n," less than ",this.minTileSize),!0):!1}countClips(t){let e=0;for(let i of this.levels[t].values())e+=i.curveBundlesLength;return e}countCacheClips(t){let e=0;for(let i of this.levels[t].values())e+=i.cachedClipsLength;return e}getWHOnLevel(t){for(let e=this.tileSizes.length;e<=t;e++){let i=this.tileSizes[e-1];this.tileSizes.push(new Ke(i.width/2,i.height/2))}return{w:this.tileSizes[t].width,h:this.tileSizes[t].height}}subdivideTilesOnLevel(t){let e=!0;for(let[i,r]of this.levels[t-1].keyValues()){let n=this.subdivideTile(i,t,r,!1);e&&(e=n)}return this.removeEmptyTiles(t),e}subdivideTile(t,e,i,r){let{w:n,h:o}=this.getWHOnLevel(e),s=this.levels[e],a=t.x,u=t.y,h=this.topLevelTileRect.left+a*n*2,d=this.topLevelTileRect.bottom+u*o*2,g=new Array(4);for(let x=0;x<2;x++)for(let G=0;G<2;G++)g[x*2+G]=new F(a*2+x,u*2+G);r||this.generateSubtilesWithoutTileClips(h,n,d,o,g,i,e);let f=new S(h,d+o,h+2*n,d+o),P=new S(h+n,d,h+n,d+2*o);y();for(let x of s.values())if(x.entityCount>this.tileCapacity)return!1;return!0;function y(){for(let x of i.getBundles()){let G=x.clip,A=w(G);if(X.assert(A.length>=2),A.length==2){let M=(A[0][1]+A[1][1])/2,Y=G.value(M),K=Y.x<=h+n?0:1,Me=Y.y<=d+o?0:1,nr=2*K+Me,Lr=g[nr],E=s.getI(Lr);if(!E){let T=h+K*n,L=d+Me*o;E=new hr(new I({left:T,bottom:L,top:L+o,right:T+n})),s.setPair(Lr,E)}let b=E.addToBundlesOrFetchFromBundles(G.parStart,G.parEnd,G);for(let T of x.edges)b.push(T)}else for(let M=0;M<A.length-1;M++){let Y=(A[M][1]+A[M+1][1])/2,K=G.value(Y),Me=K.x<=h+n?0:1,nr=K.y<=d+o?0:1,Lr=2*Me+nr,E=g[Lr],b=s.getI(E);if(!b){let L=h+Me*n,V=d+nr*o;b=new hr(new I({left:L,bottom:V,top:V+o,right:L+n})),s.setPair(E,b)}let T=b.addToBundlesOrFetchFromBundles(A[M][1],A[M+1][1],G);for(let L of x.edges)T.push(L)}}}function w(x){let G=Array.from(p.getAllIntersections(x,f,!0)).concat(Array.from(p.getAllIntersections(x,P,!0)));G.sort((M,Y)=>M.par0-Y.par0);let A=[[x.start,x.parStart]];for(let M=0;M<G.length;M++){let Y=G[M];Y.par0>A[A.length-1][1]+m.distanceEpsilon&&A.push([Y.x,Y.par0])}return x.parEnd>A[A.length-1][1]+m.distanceEpsilon&&A.push([x.end,x.parEnd]),A}}addSubtilesToLevel(t,e,i,r,n){for(let o=0;o<2;o++)for(let s=0;s<2;s++){let a=t[o*2+s];a.isEmpty()||(e.set(2*i+o,2*r+s,a),n&&a.entityCount>this.tileCapacity&&(n=!1))}return n}generateSubtilesWithoutTileClips(t,e,i,r,n,o,s){let a=0;for(let u=0;u<2;u++)for(let h=0;h<2;h++){let d=new I({left:t+e*u,right:t+e*(u+1),bottom:i+r*h,top:i+r*(h+1)}),g=this.generateSubTileExceptEdgeClips(o,d);g&&this.levels[s].set(n[a].x,n[a].y,g),a++}}innerClips(t,e,i){let r=[],n=Array.from(p.getAllIntersections(t,i,!0)).concat(Array.from(p.getAllIntersections(t,e,!0)));n.sort((s,a)=>s.par0-a.par0);let o=[t.parStart];for(let s=0;s<n.length;s++){let a=n[s];a.par0>o[o.length-1]+m.distanceEpsilon&&o.push(a.par0)}if(t.parEnd>o[o.length-1]+m.distanceEpsilon&&o.push(t.parEnd),o.length<=2)return r.push(t),r;for(let s=0;s<o.length-1;s++)r.push(t.trim(o[s],o[s+1]));return r}generateSubTileExceptEdgeClips(t,e){let i=new hr(e);for(let r of t.nodes)r.boundingBox.intersects(e)&&i.nodes.push(r);for(let r of t.labels)r.boundingBox.intersects(e)&&i.labels.push(r);for(let r of t.arrowheads){let n=I.mkPP(r.base,r.tip),s=r.tip.sub(r.base).div(3).rotate90Cw();n.add(r.base.add(s)),n.add(r.base.sub(s)),n.intersects(e)&&i.arrowheads.push(r)}return i}};var Ja=class extends Di{toString(){return"label of "+(this.parent?this.parent.toString():"null")}constructor(t){super(),this.parent=t}};var bt=class{static CreatePortsAndRouteEdges(t,e,i,r,n,o=null){bt.FillRouter(t,e,i,r,n).run(),bt.CreateSelfEdges(Array.from(r).filter(a=>a.sourcePort.Location===a.targetPort.Location),t)}static CreatePortsAndRouteEdges_(t,e,i,r,n,o,s){bt.CreatePortsAndRouteEdges(t,e,i,r,n)}static CreatePortsAndRouteEdges__(t,e,i,r,n,o){bt.CreatePortsAndRouteEdges(t,e,i,r,n)}static FillRouter(t,e,i,r,n){let o=new Map;bt.FillNodeShapesMap(i,r,o);let s=new Ki(o.values(),e,t);for(let a of r)a.sourcePort=Lh(o.get(a.source).Ports),a.targetPort=Lh(o.get(a.target).Ports),s.AddEdgeGeometryToRoute(a);return s}static FillNodeShapesMap(t,e,i){for(let r of t){let n=bt.CreateShapeWithRelativeNodeAtCenter(r);i.set(r,n)}for(let r of e){let n=r.source;i.has(n)||i.set(n,bt.CreateShapeWithRelativeNodeAtCenter(n)),n=r.target,i.has(n)||i.set(n,bt.CreateShapeWithRelativeNodeAtCenter(n))}}static CreateSelfEdges(t,e){for(let i of t)bt.CreateSimpleEdgeCurveWithGivenFitRadius(i,e)}static CreateSimpleEdgeCurveWithGivenFitRadius(t,e){let i=t.source.center,r=t.target.center;if(t.source===t.target){let n=t.source.boundaryCurve.boundingBox.width/2,o=t.source.boundingBox.height/4;t.smoothedPolyline=bt.CreateUnderlyingPolylineForSelfEdge(i,n,o);for(let s=t.smoothedPolyline.headSite.next;s.next!=null;s=s.next)bt.CalculateCoefficiensUnderSite(s,e);t.curve=t.smoothedPolyline.createCurve()}else t.smoothedPolyline=oe.mkFromPoints([i,r]),t.curve=t.smoothedPolyline.createCurve();we.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,t.curve,!0)||we.createBigEnoughSpline(t)}static CreateSimpleEdgeCurve(t){let e=t.source.center,i=t.target.center;if(t.source===t.target){let r=t.source.boundaryCurve.boundingBox.width/2,n=t.source.boundingBox.height/4;t.smoothedPolyline=bt.CreateUnderlyingPolylineForSelfEdge(e,r,n),t.curve=t.smoothedPolyline.createCurve()}else t.smoothedPolyline=oe.mkFromPoints([e,i]),t.curve=t.smoothedPolyline.createCurve();we.trimSplineAndCalculateArrowheadsII(t,t.source.boundaryCurve,t.target.boundaryCurve,t.curve,!0)||we.createBigEnoughSpline(t)}static CreateUnderlyingPolylineForSelfEdge(t,e,i){let r=t.add(new c(0,i)),n=t.add(new c(e,i)),o=t.add(new c(e,i*-1)),s=t.add(new c(0,i*-1)),a=_.mkSiteP(t),u=new oe(a);return a=_.mkSiteSP(a,r),a=_.mkSiteSP(a,n),a=_.mkSiteSP(a,o),a=_.mkSiteSP(a,s),_.mkSiteSP(a,t),u}static CreateShapeWithRelativeNodeAtCenter(t){let e=new cr(t);return e.Ports.add(new $e(()=>t.boundaryCurve,()=>t.center,new c(0,0))),e}static CalculateCoefficiensUnderSite(t,e){let i=e/t.point.sub(t.prev.point).length;i=Math.min(.5,i),t.previouisBezierCoefficient=i,i=e/t.next.point.sub(t.point).length,i=Math.min(.5,i),t.nextBezierCoefficient=i}};function Lh(l){for(let t of l)return t}var rr=class extends _e{constructor(e,i){super();this.SetEdges(e,i)}};var Ya=class{constructor(t){this.MultipleMiddles=new Set;this.Multiedges=new ct(t)}*RegularMultiedges(){for(let[t,e]of this.Multiedges.keyValues())t.x!==t.y&&(yield e)}*AllIntEdges(){for(let t of this.Multiedges.values())for(let e of t)yield e}addFeedbackSet(t){for(let e of t){let i=new F(e.source,e.target),r=new F(e.target,e.source),n=this.Multiedges.get(i.x,i.y);for(let o of n)o.reverse();if(this.Multiedges.has(r.x,r.y)){let o=this.Multiedges.get(r.x,r.y);for(let s of n)o.push(s)}else this.Multiedges.set(r.x,r.y,n);this.Multiedges.delete(i.x,i.y)}}registerOriginalEdgeInMultiedges(t){let e=this.Multiedges.get(t.source,t.target);e==null&&this.Multiedges.set(t.source,t.target,e=[]),e.push(t)}*SkeletonEdges(){for(let[t,e]of this.Multiedges.keyValues())t.x!==t.y&&(yield e[0])}GetMultiedge(t,e){return this.GetMultiedgeI(new F(t,e))}GetMultiedgeI(t){return this.Multiedges.has(t.x,t.y)?this.Multiedges.get(t.x,t.y):new Array}};function Es(l,t){for(let e=0;e<l.length;e++)t[e]=l[e]}var Jt=class{constructor(t){this.initialize(t)}initialize(t){this.y=t,this.verticesToX=null,this.layers=null}DropEmptyLayers(){let t=new Array(this.Layers.length),e=0;for(let o=0;o<this.Layers.length;o++)t[o]=e,this.Layers[o].length===0&&e++;if(e===0)return this;let i=new Array(this.y.length);for(let o=0;o<i.length;o++)i[o]=this.y[o]-t[this.y[o]];let r=new Array(this.layers.length-e);for(let o=0;o<this.layers.length;o++)this.layers[o].length>0&&(r[o-t[o]]=Array.from(this.layers[o]));let n=new Jt(i);return n.layers=r,n}updateLayers(t){this.layers==null&&this.InitLayers();for(let e=0;e<this.layers.length;e++)Es(t[e],this.layers[e]);this.UpdateXFromLayers()}UpdateXFromLayers(){this.layers==null&&this.InitLayers(),this.verticesToX==null&&(this.verticesToX=new Array(this.y.length));for(let t of this.layers){let e=0;for(let i of t)this.verticesToX[i]=e++}}get x(){return this.verticesToX!=null?this.verticesToX:(this.verticesToX=new Array(this.y.length),this.UpdateXFromLayers(),this.verticesToX)}ReversedClone(){let t=new Array(this.y.length),e=this.Layers.length-1;for(let i=0;i<this.y.length;i++)t[i]=e-this.y[i];return new Jt(t)}get Layers(){return this.layers!=null?this.layers:(this.InitLayers(),this.layers)}set Layers(t){this.layers=t}InitLayers(){let t=0;for(let i of this.y)i+1>t&&(t=i+1);let e=new Array(t).fill(0);for(let i of this.y)e[i]++;this.layers=new Array(t);for(let i=0;i<t;i++)this.layers[i]=new Array(e[i]),e[i]=0;for(let i=0;i<this.y.length;i++){let r=this.y[i];this.layers[r][e[r]++]=i}}};var Ro=class extends H{constructor(e,i,r,n){super(n);this.jumpers=new Set;this.possibleJumperFeasibleIntervals=new Map;this.nodeCount=r,this.dag=e,this.layering=i,this.Init()}static Balance(e,i,r,n){new Ro(e,i,r,n).run()}run(){for(;this.jumpers.size>0;)this.Jump(this.ChooseJumper())}Init(){this.CalculateLayerCounts(),this.InitJumpers()}Jump(e){this.jumpers.delete(e);let i=this.possibleJumperFeasibleIntervals.get(e),r=this.CalcJumpInfo(i.x,i.y,e);if(r==null)return;this.layering[e]=r.layerToJumpTo;let n=this.nodeCount[e];this.vertsCounts[r.jumperLayer]-=n,this.vertsCounts[r.layerToJumpTo]+=n,this.UpdateRegionsForPossibleJumpersAndInsertJumpers(r.jumperLayer,e)}IsJumper(e){return this.possibleJumperFeasibleIntervals.has(e)}UpdateRegionsForPossibleJumpersAndInsertJumpers(e,i){let r=new Set;for(let o of this.dag.pred(i))this.IsJumper(o)&&(this.CalculateRegionAndInsertJumper(o),r.add(o));for(let o of this.dag.succ(i))this.IsJumper(o)&&(this.CalculateRegionAndInsertJumper(o),r.add(o));let n=new Array;for(let o of this.possibleJumperFeasibleIntervals)r.has(o[0])||o[1].x>e&&o[1].y<e&&n.push(o[0]);for(let o of n)this.CalculateRegionAndInsertJumper(o)}InitJumpers(){let e=new Array(this.dag.nodeCount).fill(0);for(let i of this.dag.edges)e[i.source]-=i.weight,e[i.target]+=i.weight;this.possibleJumperFeasibleIntervals=new Map;for(let i=0;i<this.dag.nodeCount;i++)e[i]===0&&this.CalculateRegionAndInsertJumper(i)}CalculateRegionAndInsertJumper(e){let i=new F(this.Up(e),this.Down(e));this.possibleJumperFeasibleIntervals.set(e,i),this.InsertJumper(i.x,i.y,e)}InsertJumper(e,i,r){this.CalcJumpInfo(e,i,r)!=null&&this.jumpers.add(r)}CalcJumpInfo(e,i,r){let n=this.layering[r],o=-1,s=this.vertsCounts[n]-2*this.nodeCount[r];for(let a=e-1;a>n;a--)this.vertsCounts[a]<s&&(s=this.vertsCounts[a],o=a);for(let a=n-1;a>i;a--)this.vertsCounts[a]<s&&(s=this.vertsCounts[a],o=a);if(o!==-1)return{jumperLayer:n,layerToJumpTo:o}}Up(e){let i=Number.MAX_SAFE_INTEGER;for(let r of this.dag.inEdges[e]){let n=this.layering[r.source]-r.separation+1;n<i&&(i=n)}return i===Number.MAX_SAFE_INTEGER&&(i=this.layering[e]+1),i}Down(e){let i=Number.NEGATIVE_INFINITY;for(let r of this.dag.outEdges[e]){let n=this.layering[r.target]+r.separation-1;n>i&&(i=n)}return i===Number.NEGATIVE_INFINITY&&(i=this.layering[e]-1),i}CalculateLayerCounts(){this.vertsCounts=new Array(Math.max(...this.layering)+1).fill(0);for(let e of this.layering)this.vertsCounts[e]+=this.nodeCount[e]}ChooseJumper(){for(let e of this.jumpers)return e;throw new Error("there are no jumpers to choose")}};var pi=class{constructor(t){this.Initialize(t)}Initialize(t){this.BaseGraph=t,this.totalNumberOfNodes=t.nodeCount;for(let e of this.BaseGraph.edges)if(e.LayerEdges!=null)for(let i of e.LayerEdges){let r=Math.max(i.Source,i.Target)+1;r>this.totalNumberOfNodes&&(this.totalNumberOfNodes=r)}this.firstVirtualNode=Number.POSITIVE_INFINITY;for(let e of this.BaseGraph.edges)if(e.LayerEdges!=null)for(let i=1;i<e.LayerEdges.length;i++){let r=e.LayerEdges[i];this.firstVirtualNode=Math.min(this.firstVirtualNode,r.Source)}this.firstVirtualNode===Number.POSITIVE_INFINITY&&(this.firstVirtualNode=this.BaseGraph.nodeCount,this.totalNumberOfNodes=this.BaseGraph.nodeCount),this.virtualNodesToInEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode),this.virtualNodesToOutEdges=new Array(this.totalNumberOfNodes-this.firstVirtualNode);for(let e of this.BaseGraph.edges)if(e.LayerSpan>0)for(let i of e.LayerEdges)i.Target!==e.target&&(this.virtualNodesToInEdges[i.Target-this.firstVirtualNode]=i),i.Source!==e.source&&(this.virtualNodesToOutEdges[i.Source-this.firstVirtualNode]=i)}*edges_(){for(let t of this.BaseGraph.edges)if(t.LayerSpan>0)for(let e of t.LayerEdges)yield e}get Edges(){return this.edges_()}*InEdges(t){if(t<this.BaseGraph.nodeCount)for(let e of this.BaseGraph.inEdges[t])e.source!==e.target&&e.LayerEdges!=null&&(yield pi.LastEdge(e));else t>=this.firstVirtualNode&&(yield this.InEdgeOfVirtualNode(t))}static LastEdge(t){return t.LayerEdges[t.LayerEdges.length-1]}InEdgeOfVirtualNode(t){return this.virtualNodesToInEdges[t-this.firstVirtualNode]}*OutEdges(t){if(t<this.BaseGraph.nodeCount)for(let e of this.BaseGraph.outEdges[t])e.source!==e.target&&e.LayerEdges!=null&&(yield pi.FirstEdge(e));else t>=this.firstVirtualNode&&(yield this.OutEdgeOfVirtualNode(t))}OutDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[t].length>1:!1}InDegreeIsMoreThanOne(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[t].length>1:!1}OutEdgeOfVirtualNode(t){return this.virtualNodesToOutEdges[t-this.firstVirtualNode]}static FirstEdge(t){return t.LayerEdges[0]}InEdgesCount(t){return this.RealInEdgesCount(t)}RealInEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.inEdges[t].filter(e=>e.LayerEdges!=null).length:1}OutEdgesCount(t){return this.RealOutEdgesCount(t)}RealOutEdgesCount(t){return t<this.BaseGraph.nodeCount?this.BaseGraph.outEdges[t].filter(e=>e.LayerEdges!=null).length:1}get NodeCount(){return this.totalNumberOfNodes}IsRealNode(t){return t<this.BaseGraph.nodeCount}IsVirtualNode(t){return!this.IsRealNode(t)}ReversedClone(){let t=this.CreateReversedEdges();return new pi(new rr(t,this.BaseGraph.nodeCount))}CreateReversedEdges(){let t=new Array;for(let e of this.BaseGraph.edges)e.isSelfEdge()||t.push(e.reversedClone());return t}*Succ(t){for(let e of this.OutEdges(t))yield e.Target}*Pred(t){for(let e of this.InEdges(t))yield e.Source}};var Ar=class{constructor(t,e,i,r){this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=r}static InsertLayers(t,e,i,r){let n=new Ar(t,e,i,r);return n.InsertLayers(),{layeredGraph:n.nLayeredGraph,la:n.Nla.DropEmptyLayers()}}get NLayering(){return this.Nla.y}InsertLayers(){this.EditOldLayering(),this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.FillUnsortedNewOddLayers(),this.WidenOriginalLayers(),this.SortNewOddLayers()}EditOldLayering(){let t=this.intGraph.nodeCount;for(let e of this.database.RegularMultiedges()){let i=0,r=e[0];if(i=r.LayerSpan*2,i>0){for(let n of r.LayerEdges)n.Target!==r.target&&(t++,this.UpdateOldLayer(t++,n.Target));t+=(i-1)*(e.length-1)+1}}}UpdateOldLayer(t,e){let i=this.la.x[e],r=this.la.y[e],n=this.la.Layers[r];n[i]=t}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){let e=this.Nla.Layers[t*2],i=0;for(let r of this.la.Layers[t]){let n=this.virtNodesToIntEdges[r];if(n!=null){let o=this.NLayering[n.source]-this.NLayering[r],s=this.database.Multiedges.get(n.source,n.target);for(let a of s)if(a!==n){let u=a.LayerEdges[o].Source;e[i]=u,this.Nla.x[u]=i++}else e[i]=r,this.Nla.x[r]=i++}else e[i]=r,this.Nla.x[r]=i++}}}FillUnsortedNewOddLayers(){let t=new Array(this.Nla.Layers.length).fill(0);for(let e=this.intGraph.nodeCount;e<this.nLayeredGraph.NodeCount;e++){let i=this.NLayering[e];i%2===1&&(this.Nla.Layers[i][t[i]++]=e)}}MapVirtualNodesToEdges(){this.virtNodesToIntEdges=new Array(this.NLayering.length);for(let t of this.database.AllIntEdges())if(t.source!==t.target&&t.LayerEdges!=null)for(let e of t.LayerEdges)e.Target!==t.target&&(this.virtNodesToIntEdges[e.Target]=t)}CreateFullLayeredGraph(){this.totalNodes=this.intGraph.nodeCount;for(let t of this.database.RegularMultiedges()){let e=0,i=!0;for(let r of t)if(i&&(i=!1,e=r.LayerSpan*2),e>0){r.LayerEdges=new Array(e);for(let n=0;n<e;n++){let o={currentVV:this.totalNodes},s=Ri.GetSource(o,r,n);this.totalNodes=o.currentVV;let a=Ri.GetTarget(this.totalNodes,r,n,e);r.LayerEdges[n]=new Qt(s,a,r.CrossingWeight)}Ar.RegisterDontStepOnVertex(this.database,r)}}this.nLayeredGraph=new pi(this.intGraph)}SortNewOddLayers(){for(let t=1;t<this.Nla.Layers.length;t+=2){let e=new Pr,i=this.Nla.Layers[t];for(let n of i){let o=-1;for(let u of this.nLayeredGraph.InEdges(n))o=u.Source;let s=-1;for(let u of this.nLayeredGraph.OutEdges(n))s=u.Target;let a=this.Nla.x[o]+this.Nla.x[s];if(e.has(a)){let u=e.get(a);if(typeof u=="number"){let h=new Array;h.push(u),h.push(n),e.set(a,h)}else u.push(n)}else e.set(a,n)}let r=0;for(let n of e.values())if(typeof n=="number")i[r++]=n;else for(let o of n)i[r++]=o;for(let n=0;n<i.length;n++)this.Nla.x[i[n]]=n}}InitNewLayering(){this.Nla=new Jt(new Array(this.totalNodes));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=this.la.y[i]*2;for(let[i,r]of this.database.Multiedges.keyValues())if(i.x!==i.y&&this.la.y[i.x]!==this.la.y[i.y]){let n=this.la.y[i.x]*2;for(let o of r){let s=n-1;for(let a of o.LayerEdges)a.Target!==o.target&&(this.NLayering[a.Target]=s--)}}let t=new Array(2*this.la.Layers.length-1),e=new Array(t.length).fill(0);for(let i of this.NLayering)e[i]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new Jt(this.NLayering),this.Nla.Layers=t}static RegisterDontStepOnVertex(t,e){if(t.Multiedges.get(e.source,e.target).length>1){let i=e.LayerEdges[e.LayerEdges.length/2];t.MultipleMiddles.add(i.Source)}}};var Ri=class{constructor(t,e,i,r){this.virtNodesToIntEdges=new Map;this.la=e,this.database=i,this.layeredGraph=t,this.intGraph=r}get NLayering(){return this.Nla.y}static InsertPaths(t,e,i,r){let n=new Ri(t,e,i,r);return n.InsertPaths(),{layeredGraph:n.NLayeredGraph,la:n.Nla}}InsertPaths(){this.CreateFullLayeredGraph(),this.InitNewLayering(),this.MapVirtualNodesToEdges(),this.WidenOriginalLayers()}WidenOriginalLayers(){for(let t=0;t<this.la.Layers.length;t++){let e=this.Nla.Layers[t],i=0;for(let r of this.la.Layers[t]){let n=this.virtNodesToIntEdges.get(r);if(n!=null){let o=this.NLayering[n.source]-this.NLayering[r],s=this.database.Multiedges.get(n.source,n.target);for(let a of s)if(!this.EdgeIsFlat(a))if(a!==n){let u=a.LayerEdges[o].Source;e[i]=u,this.Nla.x[u]=i++}else e[i]=r,this.Nla.x[r]=i++}else e[i]=r,this.Nla.x[r]=i++}}}EdgeIsFlat(t){return this.la.y[t.source]===this.la.y[t.target]}MapVirtualNodesToEdges(){for(let t of this.database.RegularMultiedges())for(let e of t)if(!this.EdgeIsFlat(e))for(let i of e.LayerEdges)i.Target!==e.target&&this.virtNodesToIntEdges.set(i.Target,e)}CreateFullLayeredGraph(){let t=this.layeredGraph.NodeCount;for(let[e,i]of this.database.Multiedges.keyValues())if(e.x!==e.y){let r=!0,n=0;for(let o of i){if(r)r=!1,n=o.LayerSpan;else if(o.LayerEdges=new Array(n),n===1)o.LayerEdges[0]=new Qt(o.source,o.target,o.CrossingWeight);else for(let s=0;s<n;s++){let a={currentVV:t},u=Ri.GetSource(a,o,s);t=a.currentVV;let h=Ri.GetTarget(t,o,s,n);o.LayerEdges[s]=new Qt(u,h,o.CrossingWeight)}Ar.RegisterDontStepOnVertex(this.database,o)}}this.NLayeredGraph=new pi(this.intGraph)}static GetTarget(t,e,i,r){return i<r-1?t:e.target}static GetSource(t,e,i){return i===0?e.source:t.currentVV++}InitNewLayering(){this.Nla=new Jt(new Array(this.NLayeredGraph.NodeCount));for(let i=0;i<this.layeredGraph.NodeCount;i++)this.NLayering[i]=this.la.y[i];for(let[i,r]of this.database.Multiedges.keyValues())if(i.x!==i.y&&this.la.y[i.x]!==this.la.y[i.y]){let n=0,o=!0;for(let s of r){o&&(o=!1,n=this.la.y[s.source]);let a=n-1;for(let u of s.LayerEdges)this.NLayering[u.Target]=a--}}let t=new Array(this.la.Layers.length),e=new Array(t.length).fill(0);for(let i of this.NLayering)e[i]++;for(let i=0;i<e.length;i++)t[i]=new Array(e[i]);this.Nla=new Jt(this.NLayering),this.Nla.Layers=t}};var Cn=class{constructor(t,e,i){this.numberOfCrossings=e,this.la=t,this.virtVertexStart=i}LayerGroupDisbalance(t,e,i){return e===1?this.LayerGroupDisbalanceWithOrigSeparators(t,i):this.LayerGroupDisbalanceWithVirtSeparators(t,e)}LayerGroupDisbalanceWithVirtSeparators(t,e){let i=0;for(let r=0;r<t.length;){let n=this.CurrentOrigGroupDelta(r,t,e);r=n.i,i+=n.ret}return i}CurrentOrigGroupDelta(t,e,i){let r=0,n=t;for(;n<e.length&&e[n]<this.virtVertexStart;n++)r++;return t=n+1,{ret:Math.abs(i-r),i:t}}LayerGroupDisbalanceWithOrigSeparators(t,e){let i=0;for(let r=0;r<t.length;){let n=this.CurrentVirtGroupDelta(r,t,e);i+=n.ret,r=n.i}return i}CurrentVirtGroupDelta(t,e,i){let r=0,n=t;for(;n<e.length&&e[n]>=this.virtVertexStart;n++)r++;return t=n+1,{ret:Math.abs(i-r),i:t}}static less(t,e){return t.numberOfCrossings<e.numberOfCrossings}static greater(t,e){return t.numberOfCrossings>e.numberOfCrossings}IsPerfect(){return this.numberOfCrossings===0}};var Gh=J(ai(),1);var Za=class{constructor(t){this.x=t}Compare(t,e){let i=this.x[t.Source]-this.x[e.Source];return i!==0?i:this.x[t.Target]-this.x[e.Target]}};var Ka=class{constructor(t){this.x=t}Compare(t,e){let i=this.x[t.Target]-this.x[e.Target];return i!==0?i:this.x[t.Source]-this.x[e.Source]}};function $a(){return Ur(2)===0}function hd(l,t,e){let i=e.Layers[l+1],r=e.Layers[l];return r.length<=i.length?dd(r,t,e):cd(i,r,t,e)}function cd(l,t,e,i){let r=Nh(t,e),n=new Ka(i.x);r.sort((u,h)=>n.Compare(u,h));let o=1;for(;o<l.length;)o*=2;let s=new Array(2*o-1).fill(0);o--;let a=0;for(let u of r){let h=o+i.x[u.Source],d=u.CrossingWeight;for(s[h]+=d;h>0;)h%2!==0&&(a+=d*s[h+1]),h=Math.floor((h-1)/2),s[h]+=d}return a}function dd(l,t,e){let i=Nh(l,t),r=new Za(e.x);i.sort((a,u)=>r.Compare(a,u));let n=1;for(;n<l.length;)n*=2;let o=new Array(2*n-1).fill(0);n--;let s=0;for(let a of i){let u=n+e.x[a.Target],h=a.CrossingWeight;for(o[u]+=h;u>0;)u%2!==0&&(s+=h*o[u+1]),u=Math.floor((u-1)/2),o[u]+=h}return s}function Nh(l,t){return Vi(l,e=>t.InEdges(e))}function Rh(l,t){let e=0;for(let i=0;i<t.Layers.length-1;i++)e+=hd(i,l,t);return e}var wr=class extends H{constructor(e,i,r,n,o,s,a){super(a);this.tryReverse=!0;this.MaxNumberOfAdjacentExchanges=50;this.cancelToken=a,this.tryReverse=i,this.startOfVirtNodes=n,this.layerArrays=r,this.layering=r.y,this.nOfLayers=r.Layers.length,this.layers=r.Layers,this.properLayeredGraph=e,this.hasCrossWeights=o,this.SugSettings=s}get NoGainStepsBound(){return this.SugSettings.NoGainAdjacentSwapStepsBound*this.SugSettings.NoGainStepsForOrderingMultiplier}get SeedOfRandom(){return Ur(100)}get MaxOfIterations(){return this.SugSettings.MaxNumberOfPassesInOrdering*this.SugSettings.NoGainStepsForOrderingMultiplier}static OrderLayers(e,i,r,n,o){let s=!1;for(let u of e.Edges)if(u.CrossingWeight!==1){s=!0;break}new wr(e,!0,i,r,s,n,o).run()}run(){if(this.Calculate(),this.tryReverse){let e=this.layerArrays.ReversedClone(),i=new wr(this.properLayeredGraph.ReversedClone(),!1,e,this.startOfVirtNodes,this.hasCrossWeights,this.SugSettings,this.cancelToken);if(i.run(),Cn.less(i.measure,this.measure)){for(let r=0;r<this.nOfLayers;r++)Es(e.Layers[r],this.layerArrays.Layers[this.nOfLayers-1-r]);this.layerArrays.UpdateXFromLayers()}}}Calculate(){this.Init(),this.layerArraysCopy=wr.CloneLayers(this.layers,this.layerArraysCopy);let e=0;this.measure=new Cn(this.layerArraysCopy,Rh(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);for(let i=0;i<this.MaxOfIterations&&e<this.NoGainStepsBound&&!this.measure.IsPerfect();i++){let r=i%2===0;this.LayerByLayerSweep(r),this.AdjacentExchange();let n=new Cn(this.layerArrays.Layers,Rh(this.properLayeredGraph,this.layerArrays),this.startOfVirtNodes);Cn.less(this.measure,n)?(this.Restore(),e++):(Cn.less(n,this.measure)||$a())&&(e=0,this.layerArraysCopy=wr.CloneLayers(this.layers,this.layerArraysCopy),this.measure=n)}}static CloneLayers(e,i){if(i==null){i=new Array(e.length);for(let r=0;r<e.length;r++)i[r]=e[r].map(n=>n)}else for(let r=0;r<e.length;r++)Es(e[r],i[r]);return i}Restore(){this.layerArrays.updateLayers(this.layerArraysCopy)}LayerByLayerSweep(e){if(e)for(let i=1;i<this.nOfLayers;i++)this.SweepLayer(i,!0);else for(let i=this.nOfLayers-2;i>=0;i--)this.SweepLayer(i,!1)}SweepLayer(e,i){let r=this.layers[e],n=new Array(r.length);for(let s=0;s<n.length;s++)n[s]=this.WMedian(r[s],i);this.Sort(e,n);let o=this.layerArrays.Layers[e];for(let s=0;s<o.length;s++)this.layerArrays.x[o[s]]=s}Sort(e,i){let r=new Pr,n=this.layers[e],o=0;for(let a of i){let u=n[o++];if(a!==-1)if(!r.has(a))r.set(a,u);else{let h=r.get(a);if(typeof h!="number"){let d=h;if($a())d.push(u);else{let g=Ur(d.length),f=d[g];d[g]=u,d.push(f)}}else{let d=h,g=new Array;r.set(a,g),$a()?(g.push(d),g.push(u)):(g.push(u),g.push(d))}}}let s=r.values();for(o=0;o<n.length;)if(i[o]!==-1){let a=s.next().value;if(typeof a=="number")n[o++]=a;else{let u=a;for(let h of u){for(;i[o]===-1;)o++;n[o++]=h}}}else o++}WMedian(e,i){let r,n;if(i?(r=this.properLayeredGraph.OutEdges(e),n=this.properLayeredGraph.OutEdgesCount(e)):(r=this.properLayeredGraph.InEdges(e),n=this.properLayeredGraph.InEdgesCount(e)),n===0)return-1;let o=new Array(n),s=0;if(i)for(let d of r)o[s++]=this.X[d.Target];else for(let d of r)o[s++]=this.X[d.Source];o.sort((d,g)=>d-g);let a=Math.floor(n/2);if(n%2===1)return o[a];if(n===2)return .5*(o[0]+o[1]);let u=o[a-1]-o[0],h=o[n-1]-o[a];return Math.floor((o[a-1]*u+o[a]*h)/(u+h))}Init(){let e=new Array(this.nOfLayers).fill(0),i=new Gh.Stack;for(let n=0;n<this.properLayeredGraph.NodeCount;n++)this.properLayeredGraph.InEdgesCount(n)===0&&i.push(n);let r=new Array(this.properLayeredGraph.NodeCount).fill(!1);for(;i.size>0;){let n=i.pop(),o=this.layerArrays.y[n];this.layerArrays.Layers[o][e[o]]=n,this.layerArrays.x[n]=e[o],e[o]++;for(let s of this.properLayeredGraph.Succ(n))r[s]||(r[s]=!0,i.push(s))}this.X=this.layerArrays.x}AdjacentExchange(){this.InitArrays();let e=0,i=!0;for(;i&&e++<this.MaxNumberOfAdjacentExchanges;){i=!1;for(let r=0;r<this.layers.length;r++)i=this.AdjExchangeLayer(r)||i;for(let r=this.layers.length-2;r>=0;r--)i=this.AdjExchangeLayer(r)||i}}AllocArrays(){let e=this.properLayeredGraph.NodeCount;this.predecessors=new Array(e),this.successors=new Array(e),this.pOrder=new Array(e),this.sOrder=new Array(e),this.hasCrossWeights&&(this.outCrossingCount=new Array(e),this.inCrossingCount=new Array(e));for(let i=0;i<e;i++){let r=this.properLayeredGraph.InEdgesCount(i);if(this.predecessors[i]=new Array(r),this.hasCrossWeights){let n=this.inCrossingCount[i]=new Map;for(let o of this.properLayeredGraph.InEdges(i))n.set(o.Source,o.CrossingWeight)}if(this.pOrder[i]=new Map,r=this.properLayeredGraph.OutEdgesCount(i),this.successors[i]=new Array(r),this.sOrder[i]=new Map,this.hasCrossWeights){let n=this.outCrossingCount[i]=new Map;for(let o of this.properLayeredGraph.OutEdges(i))n.set(o.Target,o.CrossingWeight)}}}InitArrays(){this.successors==null&&this.AllocArrays();for(let e=0;e<this.properLayeredGraph.NodeCount;e++)this.pOrder[e]=new Map,this.sOrder[e]=new Map;for(let e of this.layers)this.InitPsArraysForLayer(e)}CalcPair(e,i){let r=this.successors[e],n=this.successors[i],o=this.predecessors[e],s=this.predecessors[i];if(this.hasCrossWeights){let a=this.outCrossingCount[e],u=this.outCrossingCount[i],h=this.inCrossingCount[e],d=this.inCrossingCount[i];return{cuv:this.CountOnArraysUV(r,n,a,u)+this.CountOnArraysUV(o,s,h,d),cvu:this.CountOnArraysUV(n,r,u,a)+this.CountOnArraysUV(s,o,d,h)}}else return{cuv:this.CountOnArrays(r,n)+this.CountOnArrays(o,s),cvu:this.CountOnArrays(n,r)+this.CountOnArrays(s,o)}}InitPsArraysForLayer(e){for(let i of e){for(let r of this.properLayeredGraph.Pred(i)){let n=this.sOrder[r],o=n.size;this.successors[r][o]=i,n.set(i,o)}for(let r of this.properLayeredGraph.Succ(i)){let n=this.pOrder[r],o=n.size;this.predecessors[r][o]=i,n.set(i,o)}}}CountOnArrays(e,i){let r=0,n=i.length-1,o=-1,s=0;for(let a of e){let u=this.X[a];for(;o<n&&this.X[i[o+1]]<u;o++)s++;r+=s}return r}CountOnArraysUV(e,i,r,n){let o=0,s=i.length-1,a=-1,u=0;for(let h of e){let d=this.X[h],g;for(;a<s&&this.X[g=i[a+1]]<d;a++)u+=n.get(g);o+=u*r.get(h)}return o}AdjExchangeLayer(e){let i=this.layers[e];return this.ExchangeWithGainWithNoDisturbance(i)?!0:(this.DisturbLayer(i),this.ExchangeWithGainWithNoDisturbance(i))}Swap(e,i){let r=this.X[e],n=this.X[i],o=this.layering[e],s=this.layers[o];s[r]=i,s[n]=e,this.X[e]=n,this.X[i]=r,this.UpdateSsContainingUv(e,i),this.UpdatePsContainingUv(e,i)}UpdatePsContainingUv(e,i){if(this.successors[e].length<=this.successors[i].length)for(let r of this.successors[e]){let n=this.pOrder[r];if(n.has(i)){let o=n.get(i),s=this.predecessors[r];s[o-1]=i,s[o]=e,n.set(i,o-1),n.set(e,o)}}else for(let r of this.successors[i]){let n=this.pOrder[r];if(n.has(e)){let o=n.get(i),s=this.predecessors[r];s[o-1]=i,s[o]=e,n.set(i,o-1),n.set(e,o)}}}UpdateSsContainingUv(e,i){if(this.predecessors[e].length<=this.predecessors[i].length)for(let r of this.predecessors[e]){let n=this.sOrder[r];if(n.has(i)){let o=n.get(i),s=this.successors[r];s[o-1]=i,s[o]=e,n.set(i,o-1),n.set(e,o)}}else for(let r of this.predecessors[i]){let n=this.sOrder[r];if(n.has(e)){let o=n.get(i),s=this.successors[r];s[o-1]=i,s[o]=e,n.set(i,o-1),n.set(e,o)}}}DisturbLayer(e){for(let i=0;i<e.length-1;i++)this.AdjacentSwapToTheRight(e,i)}ExchangeWithGainWithNoDisturbance(e){let i=!1,r;do r=this.ExchangeWithGain(e),i=i||r;while(r);return i}ExchangeWithGain(e){for(let i=0;i<e.length-1;i++)if(this.SwapWithGain(e[i],e[i+1]))return this.SwapToTheLeft(e,i),this.SwapToTheRight(e,i+1),!0;return!1}SwapToTheLeft(e,i){for(let r=i-1;r>=0;r--)this.AdjacentSwapToTheRight(e,r)}SwapToTheRight(e,i){for(let r=i;r<e.length-1;r++)this.AdjacentSwapToTheRight(e,r)}AdjacentSwapToTheRight(e,i){let r=e[i],n=e[i+1],o=this.SwapGain(r,n);(o>0||o===0&&$a())&&this.Swap(r,n)}SwapGain(e,i){let r=this.CalcPair(e,i);return r.cuv-r.cvu}UvAreOfSameKind(e,i){return e<this.startOfVirtNodes&&i<this.startOfVirtNodes||e>=this.startOfVirtNodes&&i>=this.startOfVirtNodes}NeighborsForbidTheSwap(e,i){return this.UpperNeighborsForbidTheSwap(e,i)||this.LowerNeighborsForbidTheSwap(e,i)}LowerNeighborsForbidTheSwap(e,i){let r,n;return(r=this.properLayeredGraph.OutEdgesCount(e))===0||(n=this.properLayeredGraph.OutEdgesCount(i))===0?!1:this.X[this.successors[e][r>>1]]<this.X[this.successors[i][n>>1]]}UpperNeighborsForbidTheSwap(e,i){let r=this.properLayeredGraph.InEdgesCount(e),n=this.properLayeredGraph.InEdgesCount(i);return r===0||n===0?!1:this.X[this.predecessors[e][r>>1]]<this.X[this.predecessors[i][n>>1]]}CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(e,i,r){let n=this.GetKindDelegate(r),o=0;for(let a=i-1;a>=0&&!n(e[a]);a--)o++;let s=0;for(let a=i+1;a<e.length&&!n(e[a]);a++)s++;return o-s}IsOriginal(e){return e<this.startOfVirtNodes}IsVirtual(e){return e>=this.startOfVirtNodes}GetKindDelegate(e){return this.IsVirtual(e)?this.IsVirtual:this.IsOriginal}SwapWithGain(e,i){return this.SwapGain(e,i)>0?(this.Swap(e,i),!0):!1}};var Yn=class{constructor(t,e,i){this.properLayeredGraph=t,this.layerArrays=e,this.nodePositions=i}static UpdateLayerArrays0(t,e,i){new Yn(t,e,i).UpdateLayerArrays()}static UpdateLayerArrays1(t,e){let i=Yn.BuildInitialNodePositions(t,e);this.UpdateLayerArrays0(t,e,i)}static BuildInitialNodePositions(t,e){let i=new Map;for(let r=0;r<e.Layers.length;r++){let n=0,o=0;for(;n<e.Layers[r].length;){for(;n<e.Layers[r].length&&t.IsVirtualNode(e.Layers[r][n]);)n++;for(let s=o;s<n;s++)i.set(e.Layers[r][s],new c(r,o));n<e.Layers[r].length&&i.set(e.Layers[r][n],new c(r,n)),n++,o=n}}return i}UpdateLayerArrays(){let t=this.CreateInitialOrdering();t=this.BuildOrdering(t),this.RestoreLayerArrays(t)}CreateInitialOrdering(){let t=new ve;for(let e of this.layerArrays.Layers)for(let i of e){let r=this.nodePositions.get(i);t.hasxy(r.x,r.y)||t.setxy(r.x,r.y,[]),t.getxy(r.x,r.y).push(i)}return t}BuildOrdering(t){let e=new ve,i=new Map;for(let r of this.layerArrays.Layers)for(let n of r){let o=this.nodePositions.get(n);e.hasxy(o.x,o.y)||(this.BuildNodeOrdering(t.get(o),i),e.set(o,t.get(o)))}return e}BuildNodeOrdering(t,e){t.sort(this.Comparison(e));for(let i=0;i<t.length;i++)e.set(t[i],i)}firstSucc(t){for(let e of this.properLayeredGraph.Succ(t))return e}firstPred(t){for(let e of this.properLayeredGraph.Pred(t))return e}Comparison(t){return(e,i)=>{let r=this.firstSucc(e),n=this.firstSucc(i),o=this.firstPred(e),s=this.firstPred(i),a=this.nodePositions.get(r),u=this.nodePositions.get(n),h=this.nodePositions.get(o),d=this.nodePositions.get(s);if(!a.equal(u))return h.equal(d)?a.compareTo(u):h.compareTo(d);if(this.properLayeredGraph.IsVirtualNode(r)){if(!h.equal(d))return h.compareTo(d);let g=t.get(r),f=t.get(n);return Q(g,f)}for(;this.nodePositions.get(o).equal(this.nodePositions.get(s))&&this.properLayeredGraph.IsVirtualNode(o);)o=this.firstPred(o),s=this.firstPred(s);return this.nodePositions.get(o).equal(this.nodePositions.get(s))?Q(e,i):this.nodePositions.get(o).compareTo(this.nodePositions.get(s))}}RestoreLayerArrays(t){for(let e of this.layerArrays.Layers){let i=0,r=0;for(;i<e.length;){for(;i<e.length&&this.nodePositions.get(e[r]).equal(this.nodePositions.get(e[i]));)i++;let n=t.get(this.nodePositions.get(e[r]));for(let o=r;o<i;o++)e[o]=n[o-r];r=i}}this.layerArrays.UpdateXFromLayers()}};var Vh=J(Qe(),1);var Bh=J(ai(),1);var En=class{static getOrder(t,e){let i=rt(e.map(([r,n])=>new F(r,n)),t);return En.getOrderOnGraph(i)}static getOrderOnGraph(t){let e=new Array(t.nodeCount).fill(!1),i=new Bh.Stack,r=[],n;for(let o=0;o<t.nodeCount;o++){if(e[o])continue;let s=o;e[s]=!0;let a=0;n=t.outEdges[o];do{for(;a<n.length;a++){let u=n[a].target;e[u]||(e[u]=!0,i.push({edges:n,index:a+1,current_u:s}),s=u,n=t.outEdges[s],a=-1)}if(r.push(s),i.length>0){let u=i.pop();n=u.edges,a=u.index,s=u.current_u}else break}while(!0)}return r.reverse()}};var el=class{GetLayers(){let t=En.getOrderOnGraph(this.graph),e=new Array(this.graph.nodeCount).fill(0),i=this.graph.nodeCount;for(;i-- >0;){let r=t[i];for(let n of this.graph.inEdges[r]){let o=n.source,s=e[r]+n.separation;e[o]<s&&(e[o]=s)}}return e}checkTopoOrder(t){for(let e of this.graph.edges)if(gd(e,t))return!1;return!0}constructor(t){this.graph=t}};function gd(l,t){let e=t.findIndex(r=>r===l.source),i=t.findIndex(r=>r===l.target);return e===-1||i===-1||e>=i}var tu=class{constructor(t){this.inTree=!1;this.cut=tu.infinity;this.iedge=t}get source(){return this.iedge.source}get target(){return this.iedge.target}get separation(){return this.iedge.separation}get crossingWeight(){return this.iedge.CrossingWeight}get weight(){return this.iedge.weight}},Ht=tu;Ht.infinity=Number.MAX_SAFE_INTEGER;var In=J(ai(),1);function md(l){let t=new Array;for(let e of l.edges)t.push(new Ht(e));return rt(t,l.nodeCount)}var Is=class{constructor(t,e,i,r,n){this.v=t,this.outEnum=e,this.i=i,this.inEnum=r,this.j=n}},Go=class{constructor(t,e){this.layers=null;this.treeVertices=[];this.vertices=[];this.leaves=[];this.graph=md(t),this.networkCancelToken=e;for(let i=0;i<this.graph.nodeCount;i++)this.vertices.push({inTree:!1,lim:-1,low:-1,parent:null})}get weight(){return this.graph.edges.map(t=>t.weight*(this.layers[t.source]-this.layers[t.target])).reduce((t,e)=>t+e,0)}get nodeCount(){return this.vertices.length}setLow(t,e){this.vertices[t].low=e}setLim(t,e){this.vertices[t].lim=e}setParent(t,e){this.vertices[t].parent=e}GetLayers(){return this.layers==null&&this.run(),this.layers}shiftLayerToZero(){let t=Math.min(...this.layers);for(let e=0;e<this.layers.length;e++)this.layers[e]-=t}addVertexToTree(t){this.vertices[t].inTree=!0}vertexInTree(t){return this.vertices[t].inTree}lim(t){return this.vertices[t].lim}low(t){return this.vertices[t].low}parent(t){return this.vertices[t].parent}feasibleTree(){for(this.initLayers();this.tightTree()<this.nodeCount;){let t=this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();if(t==null)break;let e=this.slack(t);this.vertexInTree(t.source)&&(e=-e);for(let i of this.treeVertices)this.layers[i]+=e}this.initCutValues()}vertexSourceTargetVal(t,e){let i=e.source,r=e.target;return this.lim(i)>this.lim(r)?this.lim(t)<=this.lim(r)&&this.low(r)<=this.lim(t)?0:1:this.lim(t)<=this.lim(i)&&this.low(i)<=this.lim(t)?1:0}incidentEdges(t){return this.graph.incidentEdges(t)}allLowCutsHaveBeenDone(t){for(let e of this.incidentEdges(t))if(e.inTree&&e.cut===Ht.infinity&&e!==this.parent(t))return!1;return!0}edgeSourceTargetVal(t,e){return this.vertexSourceTargetVal(t.source,e)-this.vertexSourceTargetVal(t.target,e)}initCutValues(){this.initLimLowAndParent();let t=new In.Stack;for(let i of this.leaves)t.push(i);let e=new In.Stack;for(;t.length>0;){for(;t.length>0;){let r=t.pop(),n=this.parent(r);if(n==null)continue;let o=0;for(let a of this.incidentEdges(r))if(a.inTree===!1){let u=this.edgeSourceTargetVal(a,n);u!==0&&(o+=u*a.weight)}else if(a===n)o+=a.weight;else{let u=n.source===a.target||n.target===a.source?1:-1;o+=this.edgeContribution(a,r)*u}n.cut=o;let s=n.source===r?n.target:n.source;this.allLowCutsHaveBeenDone(s)&&e.push(s)}let i=t;t=e,e=i}}edgeContribution(t,e){let i=t.cut-t.weight;for(let r of this.incidentEdges(e))if(r.inTree===!1){let n=this.edgeSourceTargetVal(r,t);n===-1?i+=r.weight:n===1&&(i-=r.weight)}return i}initLimLowAndParent(){this.initLowLimParentAndLeavesOnSubtree(1,0)}initLowLimParentAndLeavesOnSubtree(t,e){let i=new In.Stack,r=this.graph.outEdges[e],n=-1,o=this.graph.inEdges[e],s=-1;for(i.push(new Is(e,r,n,o,s)),this.vertices[e].low=t;i.length>0;){let a=i.pop();e=a.v,r=a.outEnum,n=a.i,o=a.inEnum,s=a.j;let u;do{for(u=!0;++n<r.length;){let h=r[n];!h.inTree||this.vertices[h.target].low>0||(i.push(new Is(e,r,n,o,s)),e=h.target,this.setParent(e,h),this.setLow(e,t),r=this.graph.outEdges[e],n=-1,o=this.graph.inEdges[e],s=-1)}for(;++s<o.length;){let h=o[s];if(!(!h.inTree||this.vertices[h.source].low>0)){i.push(new Is(e,r,n,o,s)),e=h.source,this.setLow(e,t),this.setParent(e,h),r=this.graph.outEdges[e],n=-1,o=this.graph.inEdges[e],s=-1,u=!1;break}}}while(!u);this.setLim(e,t++),this.lim(e)===this.low(e)&&this.leaves.push(e)}}updateLimLowLeavesAndParentsUnderNode(t){let e=this.vertices[t].low,i=this.vertices[t].lim;this.leaves=[];for(let r=0;r<this.nodeCount;r++)e<=this.vertices[r].lim&&this.vertices[r].lim<=i?this.setLow(r,0):this.low(r)===this.lim(r)&&this.leaves.push(r);this.initLowLimParentAndLeavesOnSubtree(e,t)}slack(t){return this.layers[t.source]-this.layers[t.target]-t.separation}getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack(){let t=null,e=Ht.infinity;for(let i of this.treeVertices){for(let r of this.graph.outEdges[i]){if(this.vertexInTree(r.source)&&this.vertexInTree(r.target))continue;let n=this.slack(r);if(n<e&&(t=r,e=n,n===1))return r}for(let r of this.graph.inEdges[i]){if(this.vertexInTree(r.source)&&this.vertexInTree(r.target))continue;let n=this.slack(r);if(n<e&&(t=r,e=n,n===1))return r}}return t}tightTree(){this.treeVertices=[];for(let e of this.graph.edges)e.inTree=!1;for(let e=1;e<this.nodeCount;e++)this.vertices[e].inTree=!1;this.vertices[0].inTree=!0,this.treeVertices.push(0);let t=new In.Stack;for(t.push(0);t.length>0;){let e=t.pop();for(let i of this.graph.outEdges[e])this.vertexInTree(i.target)||this.layers[i.source]-this.layers[i.target]===i.separation&&(t.push(i.target),this.addVertexToTree(i.target),this.treeVertices.push(i.target),i.inTree=!0);for(let i of this.graph.inEdges[e])this.vertexInTree(i.source)||this.layers[i.source]-this.layers[i.target]===i.separation&&(t.push(i.source),this.addVertexToTree(i.source),this.treeVertices.push(i.source),i.inTree=!0)}return this.treeVertices.length}leaveEnterEdge(){let t,e,i=0;for(let o of this.graph.edges)o.inTree&&o.cut<i&&(i=o.cut,t=o);if(t==null)return null;let r=!1,n=Ht.infinity;for(let o of this.graph.edges){let s=this.slack(o);if(o.inTree===!1&&this.edgeSourceTargetVal(o,t)===-1&&(s<n||s===n&&(r=Ur(2)===1))){if(n=s,e=o,n===0&&!r)break;r=!1}}if(e==null)throw new Error;return{leaving:t,entering:e}}exchange(t,e){let i=this.commonPredecessorOfSourceAndTargetOfF(e);this.createPathForCutUpdates(t,e,i),this.updateLimLowLeavesAndParentsUnderNode(i),this.updateCuts(t),this.updateLayersUnderNode(i)}updateLayersUnderNode(t){let e=new In.Stack;e.push(t);for(let i=0;i<this.nodeCount;i++)this.low(t)<=this.lim(i)&&this.lim(i)<=this.lim(t)&&i!==t&&(this.layers[i]=Ht.infinity);for(;e.length>0;){let i=e.pop();for(let r of this.graph.outEdges[i])r.inTree&&this.layers[r.target]===Ht.infinity&&(this.layers[r.target]=this.layers[i]-r.separation,e.push(r.target));for(let r of this.graph.inEdges[i])r.inTree&&this.layers[r.source]===Ht.infinity&&(this.layers[r.source]=this.layers[i]+r.separation,e.push(r.source))}}updateCuts(t){let e=new In.Stack,i=new In.Stack;for(e.push(t.source),e.push(t.target);e.length>0;){for(;e.length>0;){let n=e.pop(),o=this.parent(n);if(o==null||o.cut!==Ht.infinity)continue;let s=0;for(let u of this.incidentEdges(n))if(u.inTree===!1)s+=this.edgeSourceTargetVal(u,o)*u.weight;else if(u===o)s+=u.weight;else{let h=o.source===u.target||o.target===u.source?1:-1;s+=this.edgeContribution(u,n)*h}o.cut=s;let a=o.source===n?o.target:o.source;this.allLowCutsHaveBeenDone(a)&&i.push(a)}let r=e;e=i,i=r}}createPathForCutUpdates(t,e,i){let r=e.target;for(;r!==i;){let n=this.parent(r);n.cut=Ht.infinity,r=n.source===r?n.target:n.source}e.cut=Ht.infinity,t.inTree=!1,e.inTree=!0}commonPredecessorOfSourceAndTargetOfF(t){let e,i;this.lim(t.source)<this.lim(t.target)?(e=this.lim(t.source),i=this.lim(t.target)):(e=this.lim(t.target),i=this.lim(t.source));let r=t.source;for(;!(this.low(r)<=e&&i<=this.lim(r));){let n=this.parent(r);n.cut=Ht.infinity,r=n.source===r?n.target:n.source}return r}checkCutValues(){for(let t of this.graph.edges)if(t.inTree){let e=0;for(let i of this.graph.edges)e+=this.edgeSourceTargetVal(i,t)*i.weight;t.cut!==e&&console.log(Vh.String.Format("cuts are wrong for {0}; should be {1} but is {2}",t,e,t.cut))}}initLayers(){let t=new el(this.graph);return this.layers=t.GetLayers()}run(){if(this.graph.edges.length===0&&this.graph.nodeCount===0)this.layers=[];else{this.feasibleTree();let t;for(;(t=this.leaveEnterEdge())!=null;)this.exchange(t.leaving,t.entering);this.shiftLayerToZero()}}};var tl=class{GetLayers(){return new Go(this.graph,this.Cancel).GetLayers()}ShrunkComponent(t){let e=[];for(let i of t){let r=i[0],n=i[1];for(let o of this.graph.outEdges[r]){let s=new pt(n,t.get(o.target),o.edge);s.separation=o.separation,s.weight=o.weight,e.push(s)}}return new rr(e,t.size)}constructor(t,e){this.graph=t,this.Cancel=e}};var wt=class{constructor(t){this.padding=0;this.alreadySitsOnASpline=!1;this.labelIsToTheLeftOfTheSpline=!1;this.labelIsToTheRightOfTheSpline=!1;this.labelCornersPreserveCoefficient=t}toString(){return"la:ra "+this.la+" "+this.ra+" ta:ba "+this.ta+" "+this.ba+" x:y "+this.x_+" "+this.y_}get leftAnchor(){return this.la}set leftAnchor(t){this.la=Math.max(t,0)}get rightAnchor(){return this.ra}set rightAnchor(t){this.ra=Math.max(t,0)}get topAnchor(){return this.ta}set topAnchor(t){this.ta=Math.max(t,0)}get bottomAnchor(){return this.ba}set bottomAnchor(t){this.ba=Math.max(t,0)}get left(){return this.x_-this.la}get right(){return this.x_+this.ra}get top(){return this.y_+this.ta}set top(t){this.y_+=t-this.ta}get bottom(){return this.y_-this.ba}set bottom(t){this.y_+=t-this.ba}get leftTop(){return new c(this.left,this.top)}get leftBottom(){return new c(this.left,this.bottom)}get rightBottom(){return new c(this.right,this.bottom)}get node(){return this.node_}set node(t){this.node_=t,this.polygonalBoundary_=null}get rightTop(){return new c(this.right,this.top)}static mkAnchor(t,e,i,r,n,o){let s=new wt(o);return s.la=t,s.ra=e,s.ta=i,s.ba=r,s.node=n,s}get x(){return this.x_}set x(t){this.polygonalBoundary_=null,this.x_=t}get y(){return this.y_}set y(t){this.polygonalBoundary_=null,this.y_=t}get origin(){return new c(this.x,this.y)}get width(){return this.la+this.ra}get height(){return this.ta+this.ba}get hasLabel(){return this.labelIsToTheLeftOfTheSpline||this.labelIsToTheLeftOfTheSpline}get LabelWidth(){if(this.labelIsToTheLeftOfTheSpline)return this.leftAnchor;if(this.labelIsToTheRightOfTheSpline)return this.rightAnchor;throw new Error}get polygonalBoundary(){return this.polygonalBoundary_!=null?this.polygonalBoundary_:this.polygonalBoundary_=wt.pad(this.creatPolygonalBoundaryWithoutPadding(),this.padding)}static pad(t,e){return e===0?t:wt.curveIsConvex(t)?wt.padConvexCurve(t,e):wt.padConvexCurve(t.boundingBox.perimeter(),e)}static padCorner(t,e,i,r,n){let o=wt.getPaddedCorner(e,i,r,n);t.addPoint(o.a),o.numberOfPoints===2&&t.addPoint(o.b)}static padConvexCurve(t,e){let i=new R;wt.padCorner(i,t.endPoint.prev,t.endPoint,t.startPoint,e),wt.padCorner(i,t.endPoint,t.startPoint,t.startPoint.next,e);for(let r=t.startPoint;r.next.next!=null;r=r.next)wt.padCorner(i,r,r.next,r.next.next,e);return i.closed=!0,i}static getPaddedCorner(t,e,i,r){let n=t.point,o=e.point,s=i.point,a=c.getTriangleOrientation(n,o,s)===1,u=o.sub(n),h=u.rotate((a?-Math.PI:Math.PI)/2).normalize(),d=u.normalize().add(o.sub(s).normalize());if(d.length<m.intersectionEpsilon)return{a:o.add(h.mul(r)),b:null,numberOfPoints:1};let g=d.normalize().mul(r),f=g.rotate(Math.PI/2),P=(r-g.dot(h))/f.dot(h);return{a:g.add(f.mul(P)).add(o),b:g.sub(f.mul(P)).add(o),numberOfPoints:2}}static*orientations(t){yield c.getTriangleOrientation(t.endPoint.point,t.startPoint.point,t.startPoint.next.point),yield c.getTriangleOrientation(t.endPoint.prev.point,t.endPoint.point,t.startPoint.point);let e=t.startPoint;for(;e.next.next!=null;)yield c.getTriangleOrientation(e.point,e.next.point,e.next.next.point),e=e.next}static curveIsConvex(t){let e=2;for(let i of wt.orientations(t))if(i!==2){if(e===2)e=i;else if(i!==e)return!1}return!0}creatPolygonalBoundaryWithoutPadding(){return this.hasLabel?this.labelIsToTheLeftOfTheSpline?this.polygonOnLeftLabel():this.polygonOnRightLabel():this.nodeBoundary==null?this.standardRectBoundary():p.polylineAroundClosedCurve(this.nodeBoundary)}get nodeBoundary(){return this.node==null?null:this.node.boundaryCurve}standardRectBoundary(){let t=new R;return t.addPoint(this.leftTop),t.addPoint(this.rightTop),t.addPoint(this.rightBottom),t.addPoint(this.leftBottom),t.closed=!0,t}polygonOnLeftLabel(){let t=this.left+(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return R.mkClosedFromPoints([new c(t,this.top),this.rightTop,this.rightBottom,new c(t,this.bottom),new c(this.left,this.y)])}polygonOnRightLabel(){let t=this.right-(1-this.labelCornersPreserveCoefficient)*this.LabelWidth;return R.mkClosedFromPoints([new c(t,this.top),new c(this.right,this.y),new c(t,this.bottom),this.leftBottom,this.leftTop])}move(t){this.x+=t.x,this.y+=t.y}};var No=class{constructor(t,e,i,r,n){this.xCoords=new Array(4);this.la=t,this.graph=e,this.nOfOriginalVertices=i,this.nOfVertices=this.graph.NodeCount,this.markedEdges=new at,this.h=this.la.Layers.length,this.root=new Array(this.nOfVertices),this.align=new Array(this.nOfVertices),this.anchors=r,this.nodeSep=n}get CurrentEnumRightUp(){return(this.LR?0:1)+2*(this.BT?0:1)}IsVirtual(t){return t>=this.nOfOriginalVertices}Source(t){return this.BT?t.Source:t.Target}Target(t){return this.BT?t.Target:t.Source}static CalculateXCoordinates(t,e,i,r,n){new No(t,e,i,r,n).Calculate()}Calculate(){this.SortInAndOutEdges(),this.RightUpSetup(),this.CalcBiasedAlignment(),this.LeftUpSetup(),this.CalcBiasedAlignment(),this.RightDownSetup(),this.CalcBiasedAlignment(),this.LeftDownSetup(),this.CalcBiasedAlignment(),this.HorizontalBalancing()}SortInAndOutEdges(){this.FillLowMedians(),this.FillUpperMedins()}FillUpperMedins(){this.upperMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillUpperMediansForNode(t)}CompareByX(t,e){return this.la.x[t]-this.la.x[e]}FillUpperMediansForNode(t){let e=this.graph.InEdgesCount(t);if(e>0){let i=new Array(e);e=0;for(let n of this.graph.InEdges(t))i[e++]=n.Source;i.sort((n,o)=>this.CompareByX(n,o));let r=Math.floor(e/2);r*2===e?this.upperMedians[t]=new F(i[r-1],i[r]):this.upperMedians[t]=i[r]}else this.upperMedians[t]=-1}FillLowMedians(){this.lowMedians=new Array(this.graph.NodeCount);for(let t=0;t<this.graph.NodeCount;t++)this.FillLowMediansForNode(t)}FillLowMediansForNode(t){let e=this.graph.OutEdgesCount(t);if(e>0){let i=new Array(e);e=0;for(let n of this.graph.OutEdges(t))i[e++]=n.Target;i.sort((n,o)=>this.CompareByX(n,o));let r=Math.floor(e/2);r*2===e?this.lowMedians[t]=new F(i[r-1],i[r]):this.lowMedians[t]=i[r]}else this.lowMedians[t]=-1}HorizontalBalancing(){let t=-1,e=new Array(4),i=new Array(4),r=Number.MAX_VALUE;for(let o=0;o<4;o++){let s={a:0,b:0};this.AssignmentBounds(o,s),e[o]=s.a,i[o]=s.b;let a=i[o]-e[o];a<r&&(t=o,r=a)}for(let o=0;o<4;o++){let s;if(No.IsLeftMostAssignment(o)?s=e[t]-e[o]:s=i[t]-i[o],this.x=this.xCoords[o],s!==0)for(let a=0;a<this.nOfVertices;a++)this.x[a]=this.x[a]+s}let n=new Array(4);for(let o=0;o<this.nOfVertices;o++)n[0]=this.xCoords[0][o],n[1]=this.xCoords[1][o],n[2]=this.xCoords[2][o],n[3]=this.xCoords[3][o],n.sort((s,a)=>s-a),this.anchors[o].x=(n[1]+n[2])/2}static IsLeftMostAssignment(t){return t===0||t===2}AssignmentBounds(t,e){if(this.nOfVertices===0)e.a=0,e.b=0;else{this.x=this.xCoords[t],e.a=e.b=this.x[0];for(let i=1;i<this.nOfVertices;i++){let r=this.x[i];r<e.a?e.a=r:r>e.b&&(e.b=r)}}}CalcBiasedAlignment(){this.ConflictElimination(),this.Align()}LeftUpSetup(){this.LR=!1,this.BT=!0}LeftDownSetup(){this.LR=!1,this.BT=!1}RightDownSetup(){this.LR=!0,this.BT=!1}RightUpSetup(){this.LR=!0,this.BT=!0}ConflictElimination(){this.RemoveMarksFromEdges(),this.MarkConflictingEdges()}*UpperEdgeMedians(t){let e=this.BT?this.upperMedians[t]:this.lowMedians[t];if(typeof e!="number"){let r=e;this.LR?(yield r.x,yield r.y):(yield r.y,yield r.x)}else{let r=e;r>=0&&(yield r)}}MarkConflictingEdges(){let t=this.LowerOf(0,this.h-1),e=t,i=this.UpperOf(0,this.h-1),r=this.NextLower(i);for(;this.IsBelow(t,i);t=this.NextUpper(t))this.IsBelow(e,t)&&this.IsBelow(t,r)&&this.ConflictsWithAtLeastOneInnerEdgeForALayer(t)}NextUpper(t){return this.BT?t+1:t-1}NextLower(t){return this.BT?t-1:t+1}UpperOf(t,e){return this.BT?Math.max(t,e):Math.min(t,e)}LowerOf(t,e){return this.BT?Math.min(t,e):Math.max(t,e)}IsBelow(t,e){return this.BT?t<e:e<t}LeftMost(t,e){return this.LR?Math.min(t,e):Math.max(t,e)}RightMost(t,e){return this.LR?Math.max(t,e):Math.min(t,e)}IsNotRightFrom(t,e){return this.LR?t<=e:e<=t}IsLeftFrom(t,e){return this.LR?t<e:e<t}NextRight(t){return this.LR?t+1:t-1}NextLeft(t){return this.LR?t-1:t+1}ConflictsWithAtLeastOneInnerEdgeForALayer(t){if(t>=0&&t<this.la.Layers.length){let e=this.la.Layers[t],i=null,r=this.LeftMost(0,e.length-1),n=this.RightMost(0,e.length-1);for(;this.IsNotRightFrom(r,n)&&i==null;r=this.NextRight(r))i=this.InnerEdgeByTarget(e[r]);if(i!=null){let o=this.Pos(this.Source(i));for(let a=this.LeftMost(0,e.length-1);this.IsLeftFrom(a,r);a=this.NextRight(a))for(let u of this.InEdges(e[a]))this.IsLeftFrom(o,this.Pos(this.Source(u)))&&this.MarkEdge(u);let s=this.Pos(this.Source(i));for(;this.IsNotRightFrom(r,n);){let a=this.AlignmentToTheRightOfInner(e,r,o);if(r=this.NextRight(r),a!=null){let u=this.Pos(this.Source(a));this.MarkEdgesBetweenInnerAndNewInnerEdges(e,i,a,s,u),i=a,s=u}}for(let a=this.NextRight(this.Pos(this.Target(i)));this.IsNotRightFrom(a,n);a=this.NextRight(a))for(let u of this.InEdges(e[a]))this.IsLeftFrom(this.Pos(this.Source(u)),this.Pos(this.Source(i)))&&this.MarkEdge(u)}}}InEdgeOfVirtualNode(t){return this.BT?this.graph.InEdgeOfVirtualNode(t):this.graph.OutEdgeOfVirtualNode(t)}InEdges(t){return this.BT?this.graph.InEdges(t):this.graph.OutEdges(t)}MarkEdgesBetweenInnerAndNewInnerEdges(t,e,i,r,n){let o=this.NextRight(this.Pos(this.Target(e)));for(;this.IsLeftFrom(o,this.Pos(this.Target(i)));o=this.NextRight(o))for(let s of this.InEdges(t[o])){let a=this.Pos(this.Source(s));this.IsLeftFrom(a,r)?this.MarkEdge(s):this.IsLeftFrom(n,a)&&this.MarkEdge(s)}}AlignmentToTheRightOfInner(t,e,i){if(this.NumberOfInEdges(t[e])===1){let n=null;for(let o of this.InEdges(t[e]))n=o;return this.IsInnerEdge(n)&&this.IsLeftFrom(i,this.Pos(n.Source))?n:null}return null}NumberOfInEdges(t){return this.BT?this.graph.InEdgesCount(t):this.graph.OutEdgesCount(t)}Pos(t){return this.la.x[t]}InnerEdgeByTarget(t){if(this.IsVirtual(t)){let e=this.InEdgeOfVirtualNode(t);if(this.IsVirtual(this.Source(e)))return e}return null}IsInnerEdge(t){return this.IsVirtual(t.Source)&&this.IsVirtual(t.Target)}RemoveMarksFromEdges(){this.markedEdges.clear()}Align(){this.CreateBlocks(),this.AssignCoordinatesByLongestPath()}AssignCoordinatesByLongestPath(){this.x=this.xCoords[this.CurrentEnumRightUp]=new Array(this.nOfVertices);let t=new Array;for(let r=0;r<this.nOfVertices;r++)if(r===this.root[r]){let n=r;do{let o={neighbor:0};this.TryToGetRightNeighbor(n,o)&&t.push(new pt(r,this.root[o.neighbor],null)),n=this.align[n]}while(n!==r)}let e=rt(t,this.nOfVertices),i=En.getOrderOnGraph(e);for(let r of i)if(r===this.root[r]){let n=0,o=!0,s=r;do{let a={neighbor:0};this.TryToGetLeftNeighbor(s,a)&&(o?(n=this.x[this.root[a.neighbor]]+this.DeltaBetweenVertices(a.neighbor,s),o=!1):n=this.RightMost(n,this.x[this.root[a.neighbor]]+this.DeltaBetweenVertices(a.neighbor,s))),s=this.align[s]}while(s!==r);this.x[r]=n}for(let r of i)if(r===this.root[r]&&e.inEdges[r].length===0){let n=r,o=this.RightMost(-No.infinity,No.infinity),s=o;do{let a={neighbor:0};this.TryToGetRightNeighbor(n,a)&&(o=this.LeftMost(o,this.x[this.root[a.neighbor]]-this.DeltaBetweenVertices(n,a.neighbor))),n=this.align[n]}while(n!==r);s!==o&&(this.x[r]=o)}for(let r=0;r<this.nOfVertices;r++)r!==this.root[r]&&(this.x[r]=this.x[this.root[r]])}TryToGetRightNeighbor(t,e){let i=this.NextRight(this.Pos(t)),r=this.la.Layers[this.la.y[t]];return i>=0&&i<r.length?(e.neighbor=r[i],!0):!1}TryToGetLeftNeighbor(t,e){let i=this.NextLeft(this.Pos(t)),r=this.la.Layers[this.la.y[t]];return i>=0&&i<r.length?(e.neighbor=r[i],!0):!1}CreateBlocks(){for(let e=0;e<this.nOfVertices;e++)this.root[e]=this.align[e]=e;let t=this.LowerOf(0,this.h-1);for(let e=this.NextLower(this.UpperOf(0,this.h-1));!this.IsBelow(e,t);e=this.NextLower(e)){let i=this.la.Layers[e],r=this.LeftMost(-1,this.la.Layers[this.NextUpper(e)].length),n=this.RightMost(0,i.length-1);for(let o=this.LeftMost(0,i.length-1);this.IsNotRightFrom(o,n);o=this.NextRight(o)){let s=i[o];for(let a of this.UpperEdgeMedians(s))if(!this.IsMarked(s,a)&&this.IsLeftFrom(r,this.Pos(a))){this.align[a]=s,this.root[s]=this.root[a],this.align[s]=this.root[a],r=this.Pos(a);break}}}}IsMarked(t,e){return this.BT?this.markedEdges.hasxy(e,t):this.markedEdges.hasxy(t,e)}MarkEdge(t){this.markedEdges.addNN(t.Source,t.Target)}DeltaBetweenVertices(t,e){let i;if(this.Pos(t)>this.Pos(e)){let r=t;t=e,e=r,i=-1}else i=1;return(this.anchors[t].rightAnchor+this.anchors[e].leftAnchor+this.nodeSep)*i}},vs=No;vs.infinity=1e7;var il=class extends _e{constructor(e,i,r,n,o){super();this.weightMultiplierOfOriginalOriginal=1;this.weightMultOfOneVirtual=3;this.weightMultiplierOfTwoVirtual=8;this.SetEdges(n,o),this.virtualVerticesStart=e.nodeCount,this.virtualVerticesEnd=i.NodeCount-1,this.layeredGraph=i,this.layerArrays=r}EdgeWeightMultiplier(e){let i=e.source,r=e.target;if(i<this.layeredGraph.NodeCount&&this.layerArrays.y[i]===this.layerArrays.y[r]&&this.layerArrays.x[i]===this.layerArrays.x[r]+1)return 0;let n=0,o=-1,s=-1;for(let u of this.outEdges[i])s===-1?s=u.target:o=u.target;return s>=this.virtualVerticesStart&&s<=this.virtualVerticesEnd&&n++,o>=this.virtualVerticesStart&&o<=this.virtualVerticesEnd&&n++,n===0?this.weightMultiplierOfOriginalOriginal:n===1?this.weightMultOfOneVirtual:this.weightMultiplierOfTwoVirtual}SetEdgeWeights(){for(let e of this.edges)e.weight=e.weight*this.EdgeWeightMultiplier(e)}};var Or=class{constructor(t,e){this.groupSplitThreshold=2;this.initialNodes=t,this.groupSplitThreshold=e}static Calculate(t,e=0){return new Or(t,e).Calculate()}Calculate(){return this.Calc(this.initialNodes)}Calc(t){if(t.length===0)return null;if(t.length===1)return t[0];let e=t[0].parallelogram,i=1,r=j.parallelogramOfTwo(e,t[i].parallelogram).area;for(let h=2;h<t.length;h++){let d=j.parallelogramOfTwo(e,t[h].parallelogram).area;d>r&&(i=h,r=d)}let n;for(let h=0;h<t.length;h++)if(h!==i){n=h;break}r=j.parallelogramOfTwo(t[i].parallelogram,t[n].parallelogram).area;for(let h=0;h<t.length;h++){if(h===i)continue;let d=j.parallelogramOfTwo(t[i].parallelogram,t[h].parallelogram).area;d>r&&(n=h,r=d)}let o=new Array,s=new Array;o.push(t[i]),s.push(t[n]);let a=t[i].parallelogram,u=t[n].parallelogram;for(let h=0;h<t.length;h++){if(h===i||h===n)continue;let d=j.parallelogramOfTwo(a,t[h].parallelogram),g=d.area-a.area,f=j.parallelogramOfTwo(u,t[h].parallelogram),P=f.area-u.area;o.length*this.groupSplitThreshold<s.length?(o.push(t[h]),a=d):s.length*this.groupSplitThreshold<o.length?(s.push(t[h]),u=f):g<P?(o.push(t[h]),a=d):(s.push(t[h]),u=f)}return{parallelogram:j.parallelogramOfTwo(a,u),node:{children:[this.Calc(o),this.Calc(s)]},seg:void 0,leafBoxesOffset:void 0}}};var Ot=class{constructor(t,e,i,r,n,o,s,a){this.topNode=t,this.bottomNode=e,this.topSite=i,this.bottomSite=i.next,this.currentTopSite=i,this.currentBottomSite=i.next,this.layerArrays=r,this.layeredGraph=n,this.originalGraph=o,this.anchors=s,this.layerSeparation=a}static Refine(t,e,i,r,n,o,s,a){new Ot(t,e,i,n,o,s,r,a).Refine()}Refine(){for(this.Init();this.InsertSites(););}FixCorner(t,e,i){if(t.equal(e))return e;let r=c.ClosestPointAtLineSegment(e,t,i),n=e.sub(r),o=Math.abs(n.y),s=this.layerSeparation/2;return o>s&&(n=n.mul(s/(o*2))),n.add(e)}InsertSites(){return Ur(2)===0?this.CalculateNewTopSite()||this.CalculateNewBottomSite():this.CalculateNewBottomSite()||this.CalculateNewTopSite()}CalculateNewBottomSite(){let t=this.currentBottomSite.point.sub(this.currentTopSite.point),e=Ot.absCotan(t),i,r=!1;for(let n of this.bottomCorners()){let o=Ot.absCotan(n.sub(this.currentBottomSite.point));o<e&&(e=o,i=n,r=!0)}return r?N(e,Ot.absCotan(t))?!1:(this.currentBottomSite=_.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,i,this.currentBottomSite.point),this.currentBottomSite),!0):!1}static absCotan(t){return Math.abs(t.x/t.y)}CalculateNewTopSite(){let t=this.currentBottomSite.point.sub(this.currentTopSite.point),e=Ot.absCotan(t),i,r=!1;for(let n of this.topCorners()){let o=Ot.absCotan(n.sub(this.currentTopSite.point));o<e&&(e=o,i=n,r=!0)}return r?N(e,Ot.absCotan(t))?!1:(this.currentTopSite=_.mkSiteSPS(this.currentTopSite,this.FixCorner(this.currentTopSite.point,i,this.currentBottomSite.point),this.currentBottomSite),!0):!1}Init(){this.IsTopToTheLeftOfBottom()?(this.topCorners=()=>this.CornersToTheRightOfTop(),this.bottomCorners=()=>this.CornersToTheLeftOfBottom()):(this.topCorners=()=>this.CornersToTheLeftOfTop(),this.bottomCorners=()=>this.CornersToTheRightOfBottom())}IsTopToTheLeftOfBottom(){return this.topSite.point.x<this.topSite.next.point.x}*NodeCorners(t){for(let e of this.anchors[t].polygonalBoundary.polylinePoints())yield e.point}*CornersToTheLeftOfBottom(){let t=this.layerArrays.x[this.bottomNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(let r of this.LeftFromTheNode(this.NodeLayer(this.bottomNode),t,2,e,i))for(let n of this.NodeCorners(r))n.y>this.currentBottomSite.point.y&&Ot.PossibleCorner(e,i,n)&&(yield n)}*CornersToTheLeftOfTop(){let t=this.layerArrays.x[this.topNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(let r of this.LeftFromTheNode(this.NodeLayer(this.topNode),t,0,e,i))for(let n of this.NodeCorners(r))n.y<this.currentTopSite.point.y&&Ot.PossibleCorner(e,i,n)&&(yield n)}*CornersToTheRightOfBottom(){let t=this.layerArrays.x[this.bottomNode],e=this.currentBottomSite.point.x,i=this.currentTopSite.point.x;for(let r of this.RightFromTheNode(this.NodeLayer(this.bottomNode),t,2,e,i))for(let n of this.NodeCorners(r))n.y>this.currentBottomSite.point.y&&Ot.PossibleCorner(e,i,n)&&(yield n)}*CornersToTheRightOfTop(){let t=this.layerArrays.x[this.topNode],e=this.currentTopSite.point.x,i=this.currentBottomSite.point.x;for(let r of this.RightFromTheNode(this.NodeLayer(this.topNode),t,0,e,i))for(let n of this.NodeCorners(r))n.y<this.currentTopSite.point.y&&Ot.PossibleCorner(e,i,n)&&(yield n)}static PossibleCorner(t,e,i){return i.x>t&&i.x<e}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return this.IsLabel(t)||this.IsLabel(e)?!1:!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.AdjacentEdgesIntersect(t,e))}AdjacentEdgesIntersect(t,e){return this.Intersect(this.IncomingEdge(t),this.IncomingEdge(e))||this.Intersect(this.OutcomingEdge(t),this.OutcomingEdge(e))}Intersect(t,e){return(this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source])*(this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target])<0}IncomingEdge(t){for(let e of this.layeredGraph.InEdges(t))return e;throw new Error}OutcomingEdge(t){for(let e of this.layeredGraph.OutEdges(t))return e;throw new Error}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}*RightFromTheNode(t,e,i,r,n){let o=0,s=0;i===2&&(o=Number.MAX_VALUE),i===0&&(s=Number.MAX_VALUE);let a=t[e];for(let u=e+1;u<t.length;u++){let h=t[u];if(this.NodeUCanBeCrossedByNodeV(h,a))continue;let d=this.anchors[h];if(d.left>=n)break;d.right>r&&(d.topAnchor>s+m.distanceEpsilon?(s=d.topAnchor,yield h):d.bottomAnchor>o+m.distanceEpsilon&&(o=d.bottomAnchor,yield h))}}*LeftFromTheNode(t,e,i,r,n){let o=0,s=0;i===2&&(o=Number.MAX_VALUE),i===0&&(s=Number.MAX_VALUE);let a=t[e];for(let u=e-1;u>-1;u--){let h=t[u];if(this.NodeUCanBeCrossedByNodeV(h,a))continue;let d=this.anchors[h];if(d.right<=r)break;d.left<n&&(d.topAnchor>s+m.distanceEpsilon?(s=d.topAnchor,yield h):d.bottomAnchor>o+m.distanceEpsilon&&(o=d.bottomAnchor,yield h))}}};var Ze=class{constructor(t,e,i,r,n,o,s){this.thinRightNodes=new Array;this.thinWestNodes=new Array;this.database=s,this.edgePath=t,this.anchors=e,this.layerArrays=n,this.originalGraph=i,this.settings=r,this.layeredGraph=o,this.eastHierarchy=this.BuildEastHierarchy(),this.westHierarchy=this.BuildWestHierarchy()}BuildEastHierarchy(){let t=this.FindEastBoundaryAnchorCurves(),e=new Array;for(let i of t)e.push(i.pNodeOverICurve());return this.thinEastHierarchy=Or.Calculate(this.thinRightNodes),Or.Calculate(e)}BuildWestHierarchy(){let t=this.FindWestBoundaryAnchorCurves(),e=new Array;for(let i of t)e.push(i.pNodeOverICurve());return this.thinWestHierarchy=Or.Calculate(this.thinWestNodes),Or.Calculate(e)}FindEastBoundaryAnchorCurves(){let t=new Array,e=0;for(let i of this.edgePath){let r=null;for(let n of this.EastBoundaryNodesOfANode(i,fi.GetNodeKind(e,this.edgePath))){let o=this.anchors[n];(r==null||r.origin.x>o.origin.x)&&(r=o),t.push(o.polygonalBoundary)}r!=null&&this.thinRightNodes.push(S.mkLinePXY(r.origin,this.originalGraph.right,r.y).pNodeOverICurve()),e++}return t}FindWestBoundaryAnchorCurves(){let t=[],e=0;for(let i of this.edgePath.nodes()){let r=-1;for(let n of this.LeftBoundaryNodesOfANode(i,fi.GetNodeKind(e,this.edgePath)))(r===-1||this.layerArrays.x[n]>this.layerArrays.x[r])&&(r=n),t.push(this.anchors[n].polygonalBoundary);if(r!==-1){let n=this.anchors[r];this.thinWestNodes.push(S.mkLinePXY(n.origin,this.originalGraph.left,n.origin.y).pNodeOverICurve())}e++}return t}*FillRightTopAndBottomVerts(t,e,i){let r=0,n=0;i===2?r=Number.MAX_VALUE:i===0&&(n=Number.MAX_VALUE);let o=t[e];for(let s=e+1;s<t.length;s++){let a=t[s],u=this.anchors[a];u.topAnchor>n?this.NodeUCanBeCrossedByNodeV(a,o)||(n=u.topAnchor,u.bottomAnchor>r&&(r=u.bottomAnchor),yield a):u.bottomAnchor>r&&(this.NodeUCanBeCrossedByNodeV(a,o)||(r=u.bottomAnchor,u.topAnchor>n&&(n=u.topAnchor),yield a))}}*FillLeftTopAndBottomVerts(t,e,i){let r=0,n=0;i===0?n=Number.MAX_VALUE:i===2&&(r=Number.MAX_VALUE);let o=t[e];for(let s=e-1;s>=0;s--){let a=t[s],u=this.anchors[a];u.topAnchor>n+m.distanceEpsilon?this.NodeUCanBeCrossedByNodeV(a,o)||(n=u.topAnchor,r=Math.max(r,u.bottomAnchor),yield a):u.bottomAnchor>r+m.distanceEpsilon&&(this.NodeUCanBeCrossedByNodeV(a,o)||(n=Math.max(n,u.topAnchor),r=u.bottomAnchor,yield a))}}IsVirtualVertex(t){return t>=this.originalGraph.shallowNodeCount}IsLabel(t){return this.anchors[t].hasLabel}NodeUCanBeCrossedByNodeV(t,e){return this.IsLabel(t)||this.IsLabel(e)?!1:!!(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e)&&this.EdgesIntersectSomewhere(t,e))}EdgesIntersectSomewhere(t,e){return this.UVAreMiddlesOfTheSameMultiEdge(t,e)?!1:this.IntersectAbove(t,e)||this.IntersectBelow(t,e)}UVAreMiddlesOfTheSameMultiEdge(t,e){return!!(this.database.MultipleMiddles.has(t)&&this.database.MultipleMiddles.has(e)&&this.SourceOfTheOriginalEdgeContainingAVirtualNode(t)===this.SourceOfTheOriginalEdgeContainingAVirtualNode(e))}SourceOfTheOriginalEdgeContainingAVirtualNode(t){for(;this.IsVirtualVertex(t);)t=this.IncomingEdge(t).Source;return t}IntersectBelow(t,e){do{let i=this.OutcomingEdge(t),r=this.OutcomingEdge(e);if(this.Intersect(i,r))return!0;t=i.Target,e=r.Target}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t===e}IntersectAbove(t,e){do{let i=this.IncomingEdge(t),r=this.IncomingEdge(e);if(this.Intersect(i,r))return!0;t=i.Source,e=r.Source}while(this.IsVirtualVertex(t)&&this.IsVirtualVertex(e));return t===e}Intersect(t,e){let i=this.layerArrays.x[t.Source]-this.layerArrays.x[e.Source],r=this.layerArrays.x[t.Target]-this.layerArrays.x[e.Target];return i>0&&r<0||i<0&&r>0}IncomingEdge(t){return this.layeredGraph.InEdgeOfVirtualNode(t)}OutcomingEdge(t){return this.layeredGraph.OutEdgeOfVirtualNode(t)}EastBoundaryNodesOfANode(t,e){return this.FillRightTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}NodeLayer(t){return this.layerArrays.Layers[this.layerArrays.y[t]]}LeftBoundaryNodesOfANode(t,e){return this.FillLeftTopAndBottomVerts(this.NodeLayer(t),this.layerArrays.x[t],e)}getSpline(t){return this.createRefinedPolyline(t),this.createSmoothedPolyline()}get GetPolyline(){return new oe(this.headSite)}LineSegIntersectBound(t,e){let i=S.mkPP(t,e);return Ze.CurveIntersectsHierarchy(i,this.westHierarchy)||Ze.CurveIntersectsHierarchy(i,this.thinWestHierarchy)||Ze.CurveIntersectsHierarchy(i,this.eastHierarchy)||Ze.CurveIntersectsHierarchy(i,this.thinEastHierarchy)}SegIntersectWestBound(t,e){return Ze.SegIntersectsBound(t,e,this.westHierarchy)||Ze.SegIntersectsBound(t,e,this.thinWestHierarchy)}SegIntersectEastBound(t,e){return Ze.SegIntersectsBound(t,e,this.eastHierarchy)||Ze.SegIntersectsBound(t,e,this.thinEastHierarchy)}TryToRemoveInflectionCorner(t){if(!t.s.next||!t.s.prev||t.s.turn===1&&this.SegIntersectEastBound(t.s.prev,t.s.next)||t.s.turn===0&&this.SegIntersectWestBound(t.s.prev,t.s.next)){t.cut=!1,t.s=t.s.next;return}let e=t.s.next;t.s.prev.next=e,e.prev=t.s.prev,t.s=e,t.cut=!0}static SegIntersectsBound(t,e,i){return Ze.CurveIntersectsHierarchy(S.mkPP(t.point,e.point),i)}static CurveIntersectsHierarchy(t,e){if(e==null||!j.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram))return!1;if(e.node.hasOwnProperty("children")){let i=e.node;return Ze.CurveIntersectsHierarchy(t,i.children[0])||Ze.CurveIntersectsHierarchy(t,i.children[1])}return p.intersectionOne(t,e.seg,!1)!=null}static Flat(t){return c.getTriangleOrientation(t.prev.point,t.point,t.next.point)===2}Reverse(){let t=new Ze(this.edgePath,this.anchors,this.originalGraph,this.settings,this.layerArrays,this.layeredGraph,this.database),e=this.headSite,i=null;for(;e!=null;)t.headSite=e.clone(),t.headSite.next=i,i!=null&&(i.prev=t.headSite),i=t.headSite,e=e.next;return t}createRefinedPolyline(t){this.CreateInitialListOfSites();let e=this.headSite,i;for(let r=0;r<this.edgePath.count;r++)i=e.next,this.RefineBeetweenNeighborLayers(e,this.EdgePathNode(r),this.EdgePathNode(r+1)),e=i;this.TryToRemoveInflections(),t&&this.OptimizeShortPath()}RefineBeetweenNeighborLayers(t,e,i){Ot.Refine(e,i,t,this.anchors,this.layerArrays,this.layeredGraph,this.originalGraph,this.settings.LayerSeparation)}CreateInitialListOfSites(){let t=this.headSite=_.mkSiteP(this.EdgePathPoint(0));for(let e=1;e<=this.edgePath.count;e++)t=_.mkSiteSP(t,this.EdgePathPoint(e))}get TailSite(){let t=this.headSite;for(;t.next!=null;)t=t.next;return t}OptimizeForThreeSites(){let t=this.EdgePathNode(0),e=this.EdgePathNode(2),i=this.anchors[t],r=this.anchors[e];if(N(i.x,r.x))return;let n={ax:i.x,bx:r.x,sign:0};if(!this.FindLegalPositions(i,r,n))return;let o=(i.y-r.y)/(i.bottom-r.top),s=.5*(n.ax+n.bx),a=n.sign*((n.ax-n.bx)*.5);n.ax=s+o*(a*n.sign),n.bx=s-o*(a*n.sign),this.headSite.point=new c(n.ax,i.y);let u=this.headSite.next,h=u.point.y;u.point=new c(this.MiddlePos(n.ax,n.bx,i,r,h),h),u.next.point=new c(n.bx,r.y);let d=this.anchors[this.EdgePathNode(1)];d.x=u.point.x}OptimizeForTwoSites(){let t=this.EdgePathNode(0),e=this.EdgePathNode(1),i=this.anchors[t],r=this.anchors[e];if(N(i.x,r.x))return;let n={ax:i.x,bx:r.x,sign:0};if(!this.FindPositions(i,r,n))return;let o=(i.y-r.y)/(i.bottom-r.top),s=.5*(n.ax+n.bx),a=n.sign*((n.ax-n.bx)*.5);n.ax=s+o*(a*n.sign),n.bx=s-o*(a*n.sign),this.headSite.point=new c(n.ax,i.y),this.headSite.next.point=new c(n.bx,r.y)}FindLegalPositions(t,e,i){return this.FindPositions(t,e,i)?this.PositionsAreLegal(i.ax,i.bx,i.sign,t,e,this.EdgePathNode(1)):!1}FindPositions(t,e,i){let r,n;if(i.ax<i.bx?(i.sign=1,n=Math.max(i.ax,e.left),r=Math.min(t.right,i.bx)):(i.sign=-1,n=Math.max(t.left,i.bx),r=Math.min(e.right,i.ax)),n<=r)i.bx=.5*(n+r),i.ax=.5*(n+r);else{if(this.OriginToOriginSegCrossesAnchorSide(t,e))return!1;i.sign===1?(i.ax=t.right-.1*t.rightAnchor,i.bx=e.left):(i.ax=t.left+.1*t.leftAnchor,i.bx=e.right)}return!0}OriginToOriginSegCrossesAnchorSide(t,e){let i=S.mkPP(t.origin,e.origin);return t.x<e.x&&p.CurvesIntersect(i,S.mkPP(t.rightBottom,t.rightTop))||p.CurvesIntersect(i,S.mkPP(e.leftBottom,t.leftTop))||t.x>e.x&&p.CurvesIntersect(i,S.mkPP(t.leftBottom,t.leftTop))||p.CurvesIntersect(i,S.mkPP(e.rightBottom,t.rightTop))}OptimizeShortPath(){this.edgePath.count>2||(this.edgePath.count===2&&this.headSite.next.next!=null&&this.headSite.next.next.next==null&&this.anchors[this.EdgePathNode(1)].node==null?this.OptimizeForThreeSites():this.edgePath.count===1&&this.OptimizeForTwoSites())}PositionsAreLegal(t,e,i,r,n,o){if(!N(t,e)&&(t-e)*i>0)return!1;let s=this.anchors[o],a=this.MiddlePos(t,e,r,n,s.y);return this.MiddleAnchorLegal(a,o,s)?!this.LineSegIntersectBound(new c(t,r.bottom),new c(e,n.top)):!1}MiddleAnchorLegal(t,e,i){let r=this.NodeLayer(e),n=this.layerArrays.x[e],o=t-i.x;return!(n>0&&this.anchors[r[n-1]].right>o+i.left||n<r.length-1&&this.anchors[r[n+1]].left<o+i.right)}MiddlePos(t,e,i,r,n){let o=i.y-n,s=n-r.y;return(t*o+e*s)/(o+s)}TryToRemoveInflections(){if(this.TurningAlwaySameDirection())return;let t=!0;for(;t;){t=!1;for(let e={s:this.headSite,cut:!1};e.s;)this.TryToRemoveInflectionCorner(e),t=e.cut||t}}TurningAlwaySameDirection(){let t=0;for(let e=this.headSite.next;e!=null&&e.next!=null;e=e.next){let i=e.turn;if(t===0)i>0?t=1:i<0&&(t=-1);else if(t*i<0)return!1}return!0}EdgePathPoint(t){return this.anchors[this.EdgePathNode(t)].origin}EdgePathNode(t){return t===this.edgePath.count?this.edgePath.LayerEdges[this.edgePath.count-1].Target:this.edgePath.LayerEdges[t].Source}createSmoothedPolyline(){this.RemoveVerticesWithNoTurns();let t=new p,e=this.headSite,i=p.findCorner(e);return i!==void 0?(this.createFilletCurve(t,{a:e,b:i.b,c:i.c}),t=this.ExtendCurveToEndpoints(t)):t.addSegment(S.mkPP(this.headSite.point,this.TailSite.point)),t}curveIsLegal(t){return!0}RemoveVerticesWithNoTurns(){for(;this.RemoveVerticesWithNoTurnsOnePass(););}RemoveVerticesWithNoTurnsOnePass(){let t=!1;for(let e=this.headSite;e.next!=null&&e.next.next!=null;e=e.next)Ze.Flat(e.next)&&(t=!0,e.next=e.next.next,e.next.prev=e);return t}ExtendCurveToEndpoints(t){let e=this.headSite.point;if(!c.closeDistEps(e,t.start)){let i=new p;i.addSegs([S.mkPP(e,t.start),t]),t=i}return e=this.TailSite.point,c.closeDistEps(e,t.end)||t.addSegment(S.mkPP(t.end,e)),t}createFilletCurve(t,e){for(;this.AddSmoothedCorner(e.a,e.b,e.c,t),e.a=e.b,e.b=e.c,e.b.next!=null;)e.c=e.b.next}AddSmoothedCorner(t,e,i,r){let n=.5,o;do o=p.createBezierSeg(n,n,t,e,i),e.previouisBezierCoefficient=n,n/=2;while(this.BezierSegIntersectsBoundary(o));if(n*=2,n<.5){n=.5*(n+n*2);let s=p.createBezierSeg(n,n,t,e,i);this.BezierSegIntersectsBoundary(s)||(e.nextBezierCoefficient=n,e.previouisBezierCoefficient=n,o=s)}r.segs.length>0&&!c.closeDistEps(r.end,o.start)&&r.addSegment(S.mkPP(r.end,o.start)),r.addSegment(o)}BezierSegIntersectsBoundary(t){return c.signedDoubledTriangleArea(t.B(0),t.B(1),t.B(2))<0?this.BezierSegIntersectsTree(t,this.thinWestHierarchy)||this.BezierSegIntersectsTree(t,this.westHierarchy):this.BezierSegIntersectsTree(t,this.thinEastHierarchy)||this.BezierSegIntersectsTree(t,this.eastHierarchy)}BezierSegIntersectsTree(t,e){if(e==null)return!1;if(j.intersect(t.pNodeOverICurve().parallelogram,e.parallelogram))if(e.node.hasOwnProperty("children")){let i=e.node;return this.BezierSegIntersectsTree(t,i.children[0])||this.BezierSegIntersectsTree(t,i.children[1])}else return Ze.BezierSegIntersectsBoundary(t,e.seg);else return!1}static BezierSegIntersectsBoundary(t,e){for(let i of p.getAllIntersections(t,e,!1))if(e instanceof p){let r=e;if(p.realCutWithClosedCurve(i,r,!1))return!0}else return!0;return!1}};var fi=class extends H{constructor(e,i,r,n,o,s){super(null);this.settings=e,this.OriginalGraph=i,this.Database=r,this.ProperLayeredGraph=o,this.LayerArrays=n,this.IntGraph=s}run(){this.createSplines()}createSplines(){this.createRegularSplines(),this.createSelfSplines(),this.IntGraph!=null&&this.RouteFlatEdges(),this.OriginalGraph.graph.parent==null&&this.RouteUnroutedEdges()}RouteUnroutedEdges(){let e=[];for(let s of this.OriginalGraph.deepEdges)s.curve||e.push(s);if(e.length==0)return;let r=(this.OriginalGraph.layoutSettings?this.OriginalGraph.layoutSettings:new Xt).commonSettings.edgeRoutingSettings;new $(this.OriginalGraph,e,r.padding,r.polylinePadding,r.coneAngle,r.bundlingSettings,this.cancelToken).run(),hi.constructorGA(this.OriginalGraph,e).run()}RouteFlatEdges(){}createRegularSplines(){for(let e of this.Database.RegularMultiedges()){if(pd(e))continue;let i=e.length,r=i===1&&this.MayOptimizeEdge(e[0]);for(let n=Math.floor(i/2);n<i;n++)this.createSplineForNonSelfEdge(e[n],r);for(let n=Math.floor(i/2)-1;n>=0;n--)this.createSplineForNonSelfEdge(e[n],r)}}MayOptimizeEdge(e){return!(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(e.source)||this.ProperLayeredGraph.InDegreeIsMoreThanOne(e.target)||Dh(e.edge.source)||Dh(e.edge.target))}createSelfSplines(){for(let[e,i]of this.Database.Multiedges.keyValues()){let r=e;if(r.x===r.y){let n=this.Database.Anchors[r.x],o=n.leftAnchor;for(let s of i){let a=this.settings.NodeSeparation+(this.settings.MinNodeWidth+o),u=n.bottomAnchor/2,h=n.origin,d=h.add(new c(0,u)),g=h.add(new c(a,u)),f=h.add(new c(a,-u)),P=h.add(new c(0,-u)),y=_.mkSiteP(h),w=new oe(y);y=_.mkSiteSP(y,d),y=_.mkSiteSP(y,g),y=_.mkSiteSP(y,f),y=_.mkSiteSP(y,P),_.mkSiteSP(y,h);let x=w.createCurve();if(s.curve=x,s.edge.smoothedPolyline=w,o=a,s.edge.label!=null){o+=s.edge.label.width;let G=x.value((x.parStart+x.parEnd)/2),A=new c(G.x+s.labelWidth/2,n.y),M=new c(s.edge.label.width/2,s.edge.label.height/2),Y=I.mkPP(A.add(M),A.sub(M));s.edge.label.width=Y.width,s.edge.label.height=Y.height,s.edge.label.positionCenter(A)}we.trimSplineAndCalculateArrowheadsII(s.edge,s.edge.source.boundaryCurve,s.edge.target.boundaryCurve,x,!1)}}}}createSplineForNonSelfEdge(e,i){e.LayerEdges!=null&&(this.drawSplineBySmothingThePolyline(e,i),e.IsVirtualEdge||(e.updateEdgeLabelPosition(this.Database.Anchors),we.trimSplineAndCalculateArrowheadsII(e.edge,e.edge.source.boundaryCurve,e.edge.target.boundaryCurve,e.curve,!0)))}drawSplineBySmothingThePolyline(e,i){let r=new Ze(e,this.Database.Anchors,this.OriginalGraph,this.settings,this.LayerArrays,this.ProperLayeredGraph,this.Database),n=r.getSpline(i);e.reversed?(e.curve=n.reverse(),e.underlyingPolyline=r.Reverse().GetPolyline):(e.curve=n,e.underlyingPolyline=r.GetPolyline)}static UpdateLabel(e,i){let r=null;i.labelIsToTheRightOfTheSpline?(e.label.positionCenter(new c(i.x+i.rightAnchor/2,i.y)),r=S.mkPP(e.label.boundingBox.leftTop,e.label.boundingBox.leftBottom)):i.labelIsToTheLeftOfTheSpline&&(e.label.positionCenter(new c(i.x-i.leftAnchor/2,i.y)),r=S.mkPP(e.label.boundingBox.rightTop,e.label.boundingBox.rightBottom));let n=fi.GetSegmentInFrontOfLabel(e.curve,e.label.center.y);if(n!=null&&p.getAllIntersections(e.curve,p.polyFromBox(e.label.boundingBox),!1).length===0){let o={curveClosestPoint:void 0,labelSideClosest:void 0};if(fi.FindClosestPoints(o,n,r))fi.ShiftLabel(e,o);else{let s=n.closestParameter(r.start),a=n.closestParameter(r.end);n.value(s).sub(r.start).length<n.value(a).sub(r.end).length?(o.curveClosestPoint=n.value(s),o.labelSideClosest=r.start):(o.curveClosestPoint=n.value(a),o.labelSideClosest=r.end),fi.ShiftLabel(e,o)}}}static ShiftLabel(e,i){let r=e.lineWidth/2,n=i.curveClosestPoint.sub(i.labelSideClosest),o=n.length;o>r&&e.label.positionCenter(e.label.center.add(n.div(o*(o-r))))}static FindClosestPoints(e,i,r){let n=p.minDistWithinIntervals(i,r,i.parStart,i.parEnd,r.parStart,r.parEnd,(i.parStart+i.parEnd)/2,(r.parStart+r.parEnd)/2);return n?(e.curveClosestPoint=n.aX,e.labelSideClosest=n.bX,!0):!1}static GetSegmentInFrontOfLabel(e,i){if(e instanceof p){let r=e;for(let n of r.segs)if((n.start.y-i)*(n.end.y-i)<=0)return n}return null}static GetNodeKind(e,i){return e===0?0:e<i.count?1:2}};function pd(l){if(l.length<4)return!1;for(let t of l)if(t.edge.label)return!1;return!0}function Dh(l){return l.node.selfEdges.size>0}function fd(l,t){new Pn(l,l.layoutSettings,t).run()}function Wh(l,t,e){let i=l.layoutSettings?l.layoutSettings:new Xt;if(ds(l,i),gn(l,t,fd,dn,to),e){let r=new Ce(1,0,-l.boundingBox.left,0,-1,l.top);l.transform(r)}}var Pn=class extends H{constructor(e,i,r){super(r);this.LayersAreDoubled=!1;if(e==null)return;this.originalGraph=e,this.sugiyamaSettings=i;let n=Array.from(e.shallowNodes);this.nodeIdToIndex=new Map;let o=0;for(let a of n)this.nodeIdToIndex.set(a.id,o++);let s=[];for(let a of this.originalGraph.shallowEdges){let u=this.nodeIdToIndex.get(a.source.id);if(u==null)continue;let h=this.nodeIdToIndex.get(a.target.id);if(h==null)continue;let d=new pt(u,h,a);s.push(d)}this.IntGraph=new rr(s,e.shallowNodeCount),this.IntGraph.nodes=n,this.database=new Ya(n.length);for(let a of this.IntGraph.edges)this.database.registerOriginalEdgeInMultiedges(a);this.cycleRemoval()}get extremeAspectRatio(){let e=this.originalGraph.boundingBox,i=e.width/e.height;return i<1/50||i>50}get verticalConstraints(){return this.sugiyamaSettings.verticalConstraints}get HorizontalConstraints(){return this.sugiyamaSettings.horizontalConstraints}run(){if(this.originalGraph.shallowNodeCount===0){this.originalGraph.boundingBox=I.mkEmpty();return}Rd(this.originalGraph,this.sugiyamaSettings.transform),this.engineLayerArrays=this.calculateLayers(),this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode===3&&this.runPostLayering(),Gd(this.originalGraph,this.sugiyamaSettings.transform)}runPostLayering(){let e=this.sugiyamaSettings.commonSettings.edgeRoutingSettings,i=this.constrainedOrdering!=null?0:e.EdgeRoutingMode;this.extremeAspectRatio?wa(this.originalGraph,Array.from(this.originalGraph.deepEdges),this.cancelToken):i===3?this.calculateEdgeSplines():dn(this.originalGraph,Array.from(this.originalGraph.deepEdges),this.cancelToken)}SetLabels(){throw new Error("not implementedt")}cycleRemoval(){let e=this.sugiyamaSettings.verticalConstraints,i=e.isEmpty?jt.getFeedbackSet(this.IntGraph):e.getFeedbackSetExternal(this.IntGraph,this.nodeIdToIndex);this.database.addFeedbackSet(i)}calculateLayers(){this.CreateGluedDagSkeletonForLayering();let e=this.CalculateLayerArrays();return this.UpdateNodePositionData(),e}UpdateNodePositionData(){for(let e=0;e<this.IntGraph.nodeCount&&e<this.database.Anchors.length;e++)this.IntGraph.nodes[e].center=this.database.Anchors[e].origin;if(this.sugiyamaSettings.GridSizeByX>0)for(let e=0;e<this.originalGraph.shallowNodeCount;e++)this.SnapLeftSidesOfTheNodeToGrid(e,this.sugiyamaSettings.GridSizeByX)}SnapLeftSidesOfTheNodeToGrid(e,i){let r=this.IntGraph.nodes[e],n=this.database.Anchors[e];n.leftAnchor-=i/2,n.rightAnchor-=i/2;let o=r.boundingBox.left,s=Math.floor(o/i),a=o-s*i;Math.abs(a)<.001||(Math.abs(a)<=i/2?r.center=r.center.add(new c(-a,0)):r.center=r.center.add(new c(i-a,0)),n.x=r.center.x)}GetCurrentHeight(){let e=new ti;for(let i of this.NodeAnchors())e.AddValue(i.top),e.AddValue(i.bottom);return e.length}*NodeAnchors(){let e=Math.min(this.IntGraph.nodeCount,this.anchors.length);for(let i=0;i<e;i++)yield this.anchors[i]}GetCurrentWidth(){let e=new ti;for(let i of this.NodeAnchors())e.AddValue(i.left),e.AddValue(i.right);return e.length}ExtendLayeringToUngluedSameLayerVertices(e){let i=this.verticalConstraints;for(let r=0;r<e.length;r++)e[r]=e[i.nodeToRepr(r)];return e}calculateEdgeSplines(){new fi(this.sugiyamaSettings,this.originalGraph,this.database,this.engineLayerArrays,this.properLayeredGraph,this.IntGraph).run()}YLayeringAndOrdering(e){let i=e.GetLayers();Ro.Balance(this.gluedDagSkeletonForLayering,i,this.GetNodeCountsOfGluedDag(),null),i=this.ExtendLayeringToUngluedSameLayerVertices(i);let r=new Jt(i);if(this.HorizontalConstraints==null||this.HorizontalConstraints.IsEmpty)return r=this.YLayeringAndOrderingWithoutHorizontalConstraints(r),r;throw new Error("not implemented")}CreateProperLayeredGraph(e){let i=e.length,r=0;for(let o of this.database.SkeletonEdges()){let s=Cd(e,o);s>0&&(o.LayerEdges=new Array(s));let a=0;if(s>1){let u=i+r++,h=new Qt(o.source,u,o.CrossingWeight,o.weight);o.LayerEdges[a++]=h;for(let d=0;d<s-2;d++)u++,r++,h=new Qt(u-1,u,o.CrossingWeight,o.weight),o.LayerEdges[a++]=h;h=new Qt(u,o.target,o.CrossingWeight,o.weight),o.LayerEdges[a]=h}else if(s===1){let u=new Qt(o.source,o.target,o.CrossingWeight,o.weight);o.LayerEdges[a]=u}}let n=new Array(this.originalGraph.shallowNodeCount+r).fill(0);for(let o of this.database.SkeletonEdges())if(o.LayerEdges!=null){let s=e[o.source];n[o.source]=s--;for(let a of o.LayerEdges)n[a.Target]=s--}else n[o.source]=e[o.source],n[o.target]=e[o.target];return this.properLayeredGraph=new pi(new rr(Array.from(this.database.SkeletonEdges()),e.length)),this.properLayeredGraph.BaseGraph.nodes=this.IntGraph.nodes,new Jt(n)}YLayeringAndOrderingWithoutHorizontalConstraints(e){let i=this.CreateProperLayeredGraph(e.y);return wr.OrderLayers(this.properLayeredGraph,i,this.originalGraph.shallowNodeCount,this.sugiyamaSettings,this.cancelToken),Yn.UpdateLayerArrays1(this.properLayeredGraph,i),i}CalculateYLayers(){let e=this.YLayeringAndOrdering(new tl(this.gluedDagSkeletonForLayering,this.cancelToken));return this.constrainedOrdering!=null?e:this.InsertLayersIfNeeded(e)}InsertLayersIfNeeded(e){this.InsertVirtualEdgesIfNeeded(e);let i=this.AnalyzeNeedToInsertLayersAndHasMultiedges(e);if(i.needToInsertLayers){let r=Ar.InsertLayers(this.properLayeredGraph,e,this.database,this.IntGraph);this.properLayeredGraph=r.layeredGraph,e=r.la,this.LayersAreDoubled=!0}else if(i.multipleEdges){let r=Ri.InsertPaths(this.properLayeredGraph,e,this.database,this.IntGraph);this.properLayeredGraph=r.layeredGraph,e=r.la}return this.RecreateIntGraphFromDataBase(),e}RecreateIntGraphFromDataBase(){let e=new Array;for(let i of this.database.Multiedges.values())e=e.concat(i);this.IntGraph.SetEdges(e,this.IntGraph.nodeCount)}InsertVirtualEdgesIfNeeded(e){if(this.constrainedOrdering==null){for(let[i,r]of this.database.Multiedges.keyValues())if(r.length%2===0&&e.y[i.x]-1===e.y[i.y]){let n=new Pe(null),o=new pt(i.x,i.y,n);o.IsVirtualEdge=!0,r.splice(r.length/2,0,o),this.IntGraph.addEdge(o)}}}AnalyzeNeedToInsertLayersAndHasMultiedges(e){let i=!1,r=!1;for(let n of this.IntGraph.edges)if(n.hasLabel&&e.y[n.source]!==e.y[n.target]){i=!0;break}if(i===!1&&this.constrainedOrdering==null){for(let[n,o]of this.database.Multiedges.keyValues())if(o.length>1&&(r=!0,e.y[n.x]-e.y[n.y]===1)){i=!0;break}}return{needToInsertLayers:i,multipleEdges:r}}UseBrandesXCalculations(e){return e.x.length>=this.sugiyamaSettings.BrandesThreshold}CalculateAnchorsAndYPositions(e){this.anchors=bd(this.database,this.properLayeredGraph,this.originalGraph,this.IntGraph,this.sugiyamaSettings),Sd(e,500,this.originalGraph,this.database,this.IntGraph,this.sugiyamaSettings,this.LayersAreDoubled)}OptimizeEdgeLabelsLocations(){for(let e=0;e<this.anchors.length;e++){let i=this.anchors[e];if(i.labelIsToTheRightOfTheSpline){let r=this.GetSuccessorAndPredecessor(e);if(!xd(i,r.predecessor,r.successor)){let n=r.predecessor.origin.sub(i.origin).length+r.successor.origin.sub(i.origin).length,o=i.right-i.leftAnchor,s=new c(o,i.y);r.predecessor.origin.sub(s).length+r.successor.origin.sub(s).length<n&&zh(i)}}}}GetSuccessorAndPredecessor(e){let i;for(let n of this.properLayeredGraph.InEdges(e))i=n.Source;let r;for(let n of this.properLayeredGraph.OutEdges(e))r=n.Target;return{predecessor:this.anchors[i],successor:this.anchors[r]}}CalculateLayerArrays(){let e=this.CalculateYLayers();return this.constrainedOrdering==null?(this.CalculateAnchorsAndYPositions(e),this.UseBrandesXCalculations(e)?this.CalculateXPositionsByBrandes(e):this.CalculateXLayersByGansnerNorth(e)):this.anchors=this.database.Anchors,this.OptimizeEdgeLabelsLocations(),this.engineLayerArrays=e,this.StraightensShortEdges(),this.CalculateOriginalGraphBox(),e}StretchToDesiredAspectRatio(e,i){e>i?this.StretchInYDirection(e/i):e<i&&this.StretchInXDirection(i/e)}StretchInYDirection(e){let i=(this.originalGraph.boundingBox.top+this.originalGraph.boundingBox.bottom)/2;for(let n of this.database.Anchors)n.bottomAnchor=n.bottomAnchor*e,n.topAnchor=n.topAnchor*e,n.y=i+e*(n.y-i);let r=this.originalGraph.height*e;this.originalGraph.boundingBox=new I({left:this.originalGraph.boundingBox.left,top:i+r/2,right:this.originalGraph.boundingBox.right,bottom:i-r/2})}StretchInXDirection(e){let i=(this.originalGraph.boundingBox.left+this.originalGraph.boundingBox.right)/2;for(let n of this.database.Anchors)n.leftAnchor=n.leftAnchor*e,n.rightAnchor=n.rightAnchor*e,n.x=i+e*(n.x-i);let r=this.originalGraph.width*e;this.originalGraph.boundingBox=new I({left:i-r/2,top:this.originalGraph.boundingBox.top,right:i+r/2,bottom:this.originalGraph.boundingBox.bottom})}CalculateOriginalGraphBox(){if(this.anchors.length===0)return;let e=new I({left:this.anchors[0].left,top:this.anchors[0].top,right:this.anchors[0].right,bottom:this.anchors[0].bottom});for(let i=1;i<this.anchors.length;i++){let r=this.anchors[i];e.add(r.leftTop),e.add(r.rightBottom)}this.originalGraph.labelSize&&this.originalGraph.addLabelToGraphBB(e),e.padEverywhere(this.originalGraph.margins),this.originalGraph.boundingBox=e}StraightensShortEdges(){for(;this.StraightenEdgePaths(););}StraightenEdgePaths(){let e=!1;for(let i of this.database.AllIntEdges())i.LayerSpan===2&&(e=this.ShiftVertexWithNeighbors(i.LayerEdges[0].Source,i.LayerEdges[0].Target,i.LayerEdges[1].Target)||e);return e}ShiftVertexWithNeighbors(e,i,r){let n=this.database.Anchors[e],o=this.database.Anchors[r],s=this.database.Anchors[i],a=(s.y-n.y)*((o.x-n.x)/(o.y-n.y))+n.x,u=1e-4;return a>s.x+u?this.TryShiftToTheRight(a,i):a<s.x-u?this.TryShiftToTheLeft(a,i):!1}TryShiftToTheLeft(e,i){let r=this.engineLayerArrays.Layers[this.engineLayerArrays.y[i]],n=this.engineLayerArrays.x[i];if(n>0){let o=this.database.Anchors[r[n-1]],s=Math.max(o.right+(this.sugiyamaSettings.NodeSeparation+this.database.Anchors[i].leftAnchor),e);return s<this.database.Anchors[i].x-1?(this.database.Anchors[i].x=s,!0):!1}return this.database.Anchors[i].x=e,!0}TryShiftToTheRight(e,i){let r=this.engineLayerArrays.Layers[this.engineLayerArrays.y[i]],n=this.engineLayerArrays.x[i];if(n<r.length-1){let o=this.database.Anchors[r[n+1]],s=Math.min(o.left-(this.sugiyamaSettings.NodeSeparation-this.database.Anchors[i].rightAnchor),e);return s>this.database.Anchors[i].x+1?(this.database.Anchors[i].x=s,!0):!1}return this.database.Anchors[i].x=e,!0}CalculateXLayersByGansnerNorth(e){this.xLayoutGraph=this.CreateXLayoutGraph(e),this.CalculateXLayersByGansnerNorthOnProperLayeredGraph()}CalculateXLayersByGansnerNorthOnProperLayeredGraph(){let e=new Go(this.xLayoutGraph,null).GetLayers();for(let i=0;i<this.database.Anchors.length;i++)this.anchors[i].x=e[i]}CreateXLayoutGraph(e){let i=this.properLayeredGraph.NodeCount,r=new Array;for(let o of this.properLayeredGraph.Edges){let s=new pt(i,o.Source,null),a=new pt(i,o.Target,null);a.weight=o.Weight,s.weight=o.Weight,s.separation=0,a.separation=0,i++,r.push(s),r.push(a)}for(let o of e.Layers)for(let s=o.length-1;s>0;s--){let a=o[s],u=o[s-1],h=new pt(a,u,null),d=this.database.Anchors[a],g=this.database.Anchors[u],f=d.leftAnchor+(g.rightAnchor+this.sugiyamaSettings.NodeSeparation);h.separation=Math.ceil(f+.5),r.push(h)}let n=new il(this.IntGraph,this.properLayeredGraph,e,r,i);return n.SetEdgeWeights(),n}CalculateXPositionsByBrandes(e){vs.CalculateXCoordinates(e,this.properLayeredGraph,this.originalGraph.shallowNodeCount,this.database.Anchors,this.sugiyamaSettings.NodeSeparation)}GluedDagSkeletonEdges(){let e=new ct(this.IntGraph.nodeCount);for(let[r,n]of this.database.Multiedges.keyValues()){if(r.isDiagonal())continue;let o=this.verticalConstraints.gluedIntEdge(n[0]);o.source!==o.target&&e.set(o.source,o.target,o)}let i=Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map(r=>yd(r,null));for(let r of i)e.set(r.source,r.target,r);return Array.from(e.values())}static CalcAnchorsForOriginalNode(e,i,r,n,o){let s={leftAnchor:0,rightAnchor:0,topAnchor:0,bottomAnchor:0};if(i.nodes!=null){let h=i.nodes[e];wd(s,h,o)}Od(e,s,n,o);let a=o.MinNodeWidth/2;s.leftAnchor<a&&(s.leftAnchor=a),s.rightAnchor<a&&(s.rightAnchor=a);let u=o.MinNodeHeight/2;s.topAnchor<u&&(s.topAnchor=u),s.bottomAnchor<u&&(s.bottomAnchor=u),r[e]=wt.mkAnchor(s.leftAnchor,s.rightAnchor,s.topAnchor,s.bottomAnchor,i.nodes[e],o.LabelCornersPreserveCoefficient),r[e].padding=i.nodes[e].padding}CreateGluedDagSkeletonForLayering(){this.gluedDagSkeletonForLayering=new rr(this.GluedDagSkeletonEdges(),this.originalGraph.shallowNodeCount),this.SetGluedEdgesWeights()}SetGluedEdgesWeights(){let e=new ct(this.IntGraph.nodeCount);for(let i of this.gluedDagSkeletonForLayering.edges)e.set(i.source,i.target,i);for(let[i,r]of this.database.Multiedges.keyValues())if(i.x!==i.y){let n=this.verticalConstraints.gluedIntPair(i);if(n.x===n.y)continue;let o=e.get(n.x,n.y);for(let s of r)o.weight+=s.weight}}GetNodeCountsOfGluedDag(){return this.verticalConstraints.isEmpty?new Array(this.IntGraph.nodeCount).fill(1):this.verticalConstraints.getGluedNodeCounts()}};function Fh(l,t){if(t===0)return 0;let e=Math.floor(l/t),i=l-e*t;return Math.abs(i)<1e-4?0:t-i}function Pd(l,t){for(let e of l)if(e<t)return!0;return!1}function bd(l,t,e,i,r){let n=l.Anchors=new Array(t.NodeCount);for(let o=0;o<n.length;o++)n[o]=new wt(r.LabelCornersPreserveCoefficient);for(let o=0;o<e.shallowNodeCount;o++)Pn.CalcAnchorsForOriginalNode(o,i,n,l,r);for(let o of l.AllIntEdges())if(o.LayerEdges!=null){for(let s of o.LayerEdges){let a=s.Target;if(a!==o.target){let u=n[a];l.MultipleMiddles.has(a)?(u.leftAnchor=u.rightAnchor=iu()*4,u.topAnchor=u.bottomAnchor=kh(r)/2):(u.leftAnchor=u.rightAnchor=iu()/2,u.topAnchor=u.bottomAnchor=kh(r)/2)}}if(o.hasLabel){let s=o.LayerEdges[o.LayerEdges.length/2].Source,a=n[s],u=o.labelWidth,h=o.labelHeight;a.rightAnchor=u,a.leftAnchor=iu()*8,a.topAnchor<h/2&&(a.topAnchor=a.bottomAnchor=h/2),a.labelIsToTheRightOfTheSpline=!0}}return n}function iu(){return 1}function kh(l){return l.MinNodeHeight*1.5/8}function Hh(l,t,e,i,r,n){let o=0;if(e>0){let s=Td(t.Layers[e-1],t.y,i);if(s.length){let a=r.LayerSeparation/3,u=n;o=Math.max(...s.map(h=>Ad(h,u,a,l)))}}return o}function Sd(l,t,e,i,r,n,o){let s=i.Anchors,a=e.margins.top+t,u=0;for(let h of l.Layers){let d=0,g=0;for(let x of h){let G=s[x];G.bottomAnchor>d&&(d=G.bottomAnchor),G.topAnchor>g&&(g=G.topAnchor)}Ed(h,d,g,e.shallowNodeCount,i.Anchors);let f=Hh(i,l,u,r,n,a),P=a+d+f,y=P+g;if(Id(n)){y+=Fh(y,n.GridSizeByY);for(let x of h)s[x].top=y}else if(vd(n)){let x=P-d;x+=Fh(x,x);for(let G of h)s[G].bottom=x,y=Math.max(s[G].top,y)}else for(let x of h)s[x].y=P;let w=n.ActualLayerSeparation(o);a=y+w,u++}Hh(i,l,u,r,n,a)}function yd(l,t){let e=new pt(l.x,l.y,t);return e.weight=0,e.separation=1,e}function Cd(l,t){return l[t.source]-l[t.target]}function Ed(l,t,e,i,r){if(Pd(l,i)){for(let n of l)if(n>=i){let o=r[n];o.bottomAnchor=t,o.topAnchor=e}}}function Id(l){return l.SnapToGridByY===1}function vd(l){return l.SnapToGridByY===2}function xd(l,t,e){if(l.labelIsToTheRightOfTheSpline){if(c.getTriangleOrientation(t.origin,l.origin,e.origin)===0)return!0;let i=l.leftAnchor,r=l.rightAnchor,n=l.x;return zh(l),c.getTriangleOrientation(t.origin,l.origin,e.origin)===1?!0:(l.x=n,l.leftAnchor=i,l.rightAnchor=r,l.labelIsToTheRightOfTheSpline=!0,l.labelIsToTheLeftOfTheSpline=!1,!1)}return!1}function zh(l){let t=l.right,e=l.leftAnchor;l.leftAnchor=l.rightAnchor,l.rightAnchor=e,l.x=t-l.rightAnchor,l.labelIsToTheLeftOfTheSpline=!0,l.labelIsToTheRightOfTheSpline=!1}function Td(l,t,e){let i=new at;for(let r of l)if(!(r>=e.nodeCount))for(let n of e.outEdges[r])t[n.source]===t[n.target]&&i.addNN(n.source,n.target);return Array.from(i.values())}function Ad(l,t,e,i){let r=0,n=i.GetMultiedgeI(l);for(let o of n){r+=e;let s=o.edge.label;s!=null&&(s.positionCenter(new c(s.center.x,t+r+s.height/2)),r+=s.height)}return r}function wd(l,t,e){l.rightAnchor=l.leftAnchor=(t.width+e.GridSizeByX)/2,l.topAnchor=l.bottomAnchor=t.height/2}function Od(l,t,e,i){let r=Ld(e,l,t,i);t.rightAnchor+=r}function Ld(l,t,e,i){let r=0,n=l.GetMultiedge(t,t);if(n.length>0){for(let o of n)o.edge.label!=null&&(e.rightAnchor+=o.edge.label.width,e.topAnchor<o.edge.label.height/2&&(e.topAnchor=e.bottomAnchor=o.edge.label.height/2));r+=(i.NodeSeparation+i.MinNodeWidth)*n.length}return r}function Rd(l,t){if(t.isIdentity())return;let e=t.inverse();for(let i of l.shallowNodes)i.transform(e);for(let i of l.shallowEdges)if(i.label!=null){let r=I.mkPP(e.multiplyPoint(new c(0,0)),e.multiplyPoint(new c(i.label.width,i.label.height)));i.label.width=r.width,i.label.height=r.height}}function Gd(l,t){if(!t.isIdentity()){for(let e of l.shallowNodes)e.transform(t);for(let e of l.shallowEdges)if(e.label!=null){let i=I.mkPP(t.multiplyPoint(new c(0,0)),t.multiplyPoint(new c(e.label.width,e.label.height)));e.label.width=i.width,e.label.height=i.height}Nd(l,t),l.graph.parent==null&&(l.boundingBox=null)}}function Nd(l,t){for(let e of l.shallowEdges)e.label&&e.label.transform(t),Bd(t,e)}function Bd(l,t){if(t.curve!=null){t.curve=t.curve.transform(l);let e=t;e.sourceArrowhead!=null&&(e.sourceArrowhead.tipPosition=l.multiplyPoint(e.sourceArrowhead.tipPosition)),e.targetArrowhead!=null&&(e.targetArrowhead.tipPosition=l.multiplyPoint(e.targetArrowhead.tipPosition)),Vd(t,l)}}function Vd(l,t){if(l.smoothedPolyline!=null)for(let e=l.smoothedPolyline.headSite;e!=null;e=e.next)e.point=t.multiplyPoint(e.point)}var rl=class{throwIfCanceled(){throw new Error("Algorithm was cancelled")}get canceled(){return this.canceled_}set canceled(t){this.canceled_=t}};globalThis.msagl=globalThis.msagl||{};Object.assign(globalThis.msagl,ru);})();
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashMap is derived from the implementation of Dictionary<T> in .NET Core.
   HashSet is derived from the implementation of HashSet<T> in .NET Core.
   "getPrime", "expandPrime", and "isPrime" are derived from the implementation
   of "HashHelpers" in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   HashSet is derived from the implementation of HashSet<T> in .NET Core.

   .NET Core is licensed under the MIT License:

   The MIT License (MIT)

   Copyright (c) .NET Foundation and Contributors

   All rights reserved.

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   LinkedList is derived from the implementation of LinkedList in
   Promise Extensions for Javascript: https://github.com/rbuckton/prex

   Promise Extensions is licensed under the Apache 2.0 License:

   Promise Extensions for JavaScript
   Copyright (c) Microsoft Corporation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2021 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*!
   Copyright 2022 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   xxHash Library
   Copyright (c) 2012-2021 Yann Collet
   All rights reserved.

   BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without modification,
   are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.

   * Redistributions in binary form must reproduce the above copyright notice, this
     list of conditions and the following disclaimer in the documentation and/or
     other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*!
   Copyright 2022 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*! The following comments were added due to code inlined from "@esfx/internal-binarysearch": */
/*! The following comments were added due to code inlined from "@esfx/internal-collections-hash": */
