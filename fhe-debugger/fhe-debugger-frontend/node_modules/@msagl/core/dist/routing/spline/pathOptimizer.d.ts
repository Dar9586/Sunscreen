import { Queue } from 'queue-typescript';
import { Point, Polyline } from '../../math/geometry';
import { Cdt } from '../ConstrainedDelaunayTriangulation/Cdt';
import { CdtEdge, CdtEdge as Ed } from '../ConstrainedDelaunayTriangulation/CdtEdge';
import { CdtTriangle as Tr } from '../ConstrainedDelaunayTriangulation/CdtTriangle';
import { ThreeArray } from '../ConstrainedDelaunayTriangulation/ThreeArray';
/** Optimize path locally, without changing its topology.
 * The obstacles are represented by constrained edges of cdd, the Delaunay triangulation.
 * It is not assumed that the polyline passes only through the sites of the cdt.
//  */
/** the target of s would be otherTriange:  s.edge.getOtherTriangle_T(s.source) */
declare type FrontEdge = {
    source: Tr;
    edge: Ed;
    leftSign?: number;
    rightSign?: number;
};
export declare class PathOptimizer {
    private cdt;
    poly: Polyline;
    private sourcePoly;
    private targetPoly;
    private d;
    setCdt(cdt: Cdt): void;
    triangles: Set<Tr>;
    private findChannelTriangles;
    addSourceTargetTriangles(): void;
    private findSiteTriangle;
    private addPolyTrianglesForEndStart;
    /** this.passedTriangles is an array of triangles containing 'end' on the function exit,
     * but on entering the end becomes start of the next segment
     */
    addPiercedTrianglesOnSegment(start: Point, end: Point): void;
    edgeCanBePierced(e: CdtEdge): boolean;
    padTriangle(t: Tr, eps: number): ThreeArray<Point>;
    insideSourceOrTargetPoly(t: Tr): boolean;
    private outsideOfObstacles;
    /** following "https://page.mi.fu-berlin.de/mulzer/notes/alggeo/polySP.pdf" */
    run(poly: Polyline): void;
    findPoly(p: Point): Polyline;
    /** Because of the floating point operations we might miss some triangles and get a polygon collapsing to a point somewhere inside of the polyline.
     * This point will correspond to a site adjacent to more than two edges from 'perimeter'.
     * We add to the polygon all the 'legal' triangles adjacent to this cite.
     */
    fillTheCollapedSites(perimeter: Set<Ed>): Set<Ed>;
    private findSourceTriangle;
    private refineFunnel;
    private initDiagonals;
    private getSleeve;
    private recoverPath;
    private getPerimeterEdges;
    start: Point;
    end: Point;
    front: Queue<FrontEdge>;
    passedTrs: Set<Tr>;
    canPierce(tr: Tr, e: Ed): boolean;
    visitedInThreader: Set<Tr>;
    createThreader(start: Point, end: Point): void;
    /**This method finds the edges of the current triangle that
     * is pierced by a segment (start,end). It assumes that the start
     * point is inside or on the boundary of the current triangle,
     *  and the end point is outside.
     * The function works by computing the sign of each vertex
     *  of the current triangle with respect to the segment.
     *  The sign is zero if the vertex is on the segment,
     * positive if it is to the right of the segment  (when looking from the start point to the end point),
     * and negative if it is to the left.
     * The function then checks if there are two consecutive
     * vertices with different signs. If so, it means that the edge between them is pierced by the segment. The function returns that edge as the result.
  
  The function also sets the positiveSign and negativeSign fields to store the signs of the vertices on either side of the pierced edge. This is useful for finding the next triangle in the path of the segment. */
    initFront(tr: Tr): void;
    enqueueInFront(frontEdge: FrontEdge): void;
    /** returns true if arrived into the triangle containing end */
    private processFrontEdge;
    extendPassedTrsByContainingPoint(p: Point): void;
    neigborsInChannel(t: Tr): IterableIterator<Tr>;
    private GetHyperplaneSign;
    threadThrough(): IterableIterator<Tr>;
}
export {};
