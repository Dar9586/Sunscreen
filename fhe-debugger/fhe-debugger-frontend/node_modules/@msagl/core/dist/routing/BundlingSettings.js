export class BundlingSettings {
    constructor() {
        this.capacityOverflowCoefficient = BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier;
        this.RotateBundles = false;
        // the upper bound of the virtual node radius
        this.MaxHubRadius = 50;
        // the lower bound of the virtual node radius
        this.MinHubRadius = 0.1;
        this.CreateUnderlyingPolyline = false;
        this.pathLengthImportance = BundlingSettings.DefaultPathLengthImportance;
        this.inkImportance = BundlingSettings.DefaultInkImportance;
        this.edgeSeparation = BundlingSettings.DefaultEdgeSeparation;
        /** this could be different from bundlingSetting.EdgeSeparation
         *    and could be a negative number
         */
        this._edgeWidthShrinkCoeff = 1;
        this.useCubicBezierSegmentsInsideOfHubs = false;
        this.angleThreshold = (Math.PI / 180) * 45;
        this.hubRepulsionImportance = 100;
        this.bundleRepulsionImportance = 100;
        this.minimalRatioOfGoodCdtEdges = 0.9;
        this.highestQuality = true;
        // if set to true then the edges will be routed one on top of each other with no gap inside of a bundle
        this.KeepOverlaps = false;
        // calculates the routes that just follow the visibility graph
        this.StopAfterShortestPaths = false;
    }
    toJSON() {
        const ret = {};
        if (this.capacityOverflowCoefficient != BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier)
            ret.capacityOverflowCoefficient = this.capacityOverflowCoefficient;
        if (this.RotateBundles)
            ret.RotateBundles = this.RotateBundles;
        if (this.MaxHubRadius != 50)
            ret.MaxHubRadius = this.MaxHubRadius;
        if (this.MinHubRadius != 0.1)
            ret.MinHubRadius = this.MinHubRadius;
        if (this.CreateUnderlyingPolyline)
            ret.CreateUnderlyingPolyline = this.CreateUnderlyingPolyline;
        if (this.pathLengthImportance != BundlingSettings.DefaultPathLengthImportance)
            ret.pathLengthImportance = this.pathLengthImportance;
        if (this.inkImportance != BundlingSettings.DefaultInkImportance)
            ret.inkImportance = this.inkImportance;
        if (this.edgeSeparation != BundlingSettings.DefaultEdgeSeparation)
            ret.edgeSeparation = this.edgeSeparation;
        if (this._edgeWidthShrinkCoeff != 1)
            ret._edgeWidthShrinkCoeff = this._edgeWidthShrinkCoeff;
        if (this.useCubicBezierSegmentsInsideOfHubs)
            ret.useCubicBezierSegmentsInsideOfHubs = this.useCubicBezierSegmentsInsideOfHubs;
        if (this.angleThreshold != (Math.PI / 180) * 45)
            ret.angleThreshold = this.angleThreshold;
        if (this.hubRepulsionImportance != 100)
            ret.hubRepulsionImportance = this.hubRepulsionImportance;
        if (this.bundleRepulsionImportance != 100)
            ret.bundleRepulsionImportance = this.bundleRepulsionImportance;
        if (this.minimalRatioOfGoodCdtEdges != 0.9)
            ret.minimalRatioOfGoodCdtEdges = this.minimalRatioOfGoodCdtEdges;
        if (!this.highestQuality)
            ret.highestQuality = this.highestQuality;
        if (this.KeepOverlaps)
            ret.KeepOverlaps = this.KeepOverlaps;
        if (this.StopAfterShortestPaths)
            ret.StopAfterShortestPaths = this.StopAfterShortestPaths;
        return ret;
    }
    static createFromJSON(s) {
        const r = new BundlingSettings();
        if (s.capacityOverflowCoefficient)
            r.capacityOverflowCoefficient = s.capacityOverflowCoefficient;
        if (s.RotateBundles)
            r.RotateBundles = s.RotateBundles;
        if (s.MaxHubRadius)
            r.MaxHubRadius = s.MaxHubRadius;
        if (s.MinHubRadius)
            r.MinHubRadius = s.MinHubRadius;
        if (s.CreateUnderlyingPolyline)
            r.CreateUnderlyingPolyline = s.CreateUnderlyingPolyline;
        if (s.pathLengthImportance)
            r.pathLengthImportance = s.pathLengthImportance;
        if (s.inkImportance)
            r.inkImportance = s.inkImportance;
        if (s.edgeSeparation)
            r.edgeSeparation = s.edgeSeparation;
        if (s._edgeWidthShrinkCoeff)
            r._edgeWidthShrinkCoeff = s._edgeWidthShrinkCoeff;
        if (s.useCubicBezierSegmentsInsideOfHubs)
            r.useCubicBezierSegmentsInsideOfHubs = s.useCubicBezierSegmentsInsideOfHubs;
        if (s.angleThreshold)
            r.angleThreshold = s.angleThreshold;
        if (s.hubRepulsionImportance)
            r.hubRepulsionImportance = s.hubRepulsionImportance;
        if (s.bundleRepulsionImportance)
            r.bundleRepulsionImportance = s.bundleRepulsionImportance;
        if (s.minimalRatioOfGoodCdtEdges)
            r.minimalRatioOfGoodCdtEdges = s.minimalRatioOfGoodCdtEdges;
        if (s.highestQuality)
            r.HighestQuality = s.highestQuality;
        if (s.KeepOverlaps)
            r.KeepOverlaps = s.KeepOverlaps;
        if (s.StopAfterShortestPaths)
            r.StopAfterShortestPaths = s.StopAfterShortestPaths;
        return r;
    }
    // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient
    // and InkImportanceCoefficient, and added to the routing price
    get CapacityOverflowCoefficient() {
        return this.capacityOverflowCoefficient;
    }
    set CapacityOverflowCoefficient(value) {
        this.capacityOverflowCoefficient = value;
    }
    // the importance of path lengths coefficient
    get PathLengthImportance() {
        return this.pathLengthImportance;
    }
    set PathLengthImportance(value) {
        this.pathLengthImportance = value;
    }
    get InkImportance() {
        return this.inkImportance;
    }
    set InkImportance(value) {
        this.inkImportance = value;
    }
    /** Separation between the neighbor edges within a bundle */
    get EdgeSeparation() {
        return this.edgeSeparation;
    }
    set EdgeSeparation(value) {
        this.edgeSeparation = value;
    }
    get edgeWidthShrinkCoeff() {
        return this._edgeWidthShrinkCoeff;
    }
    set edgeWidthShrinkCoeff(value) {
        this._edgeWidthShrinkCoeff = value;
    }
    ActualEdgeWidth(e, coeff = this.edgeWidthShrinkCoeff) {
        return coeff * (this.edgeSeparation + e.lineWidth);
    }
    // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
    get UseCubicBezierSegmentsInsideOfHubs() {
        return this.useCubicBezierSegmentsInsideOfHubs;
    }
    set UseCubicBezierSegmentsInsideOfHubs(value) {
        this.useCubicBezierSegmentsInsideOfHubs = value;
    }
    // 45 degrees;
    // min angle for gluing edges
    get AngleThreshold() {
        return this.angleThreshold;
    }
    set AngleThreshold(value) {
        this.angleThreshold = value;
    }
    // the importance of hub repulsion coefficient
    get HubRepulsionImportance() {
        return this.hubRepulsionImportance;
    }
    set HubRepulsionImportance(value) {
        this.hubRepulsionImportance = value;
    }
    // the importance of bundle repulsion coefficient
    get BundleRepulsionImportance() {
        return this.bundleRepulsionImportance;
    }
    set BundleRepulsionImportance(value) {
        this.bundleRepulsionImportance = value;
    }
    // minimal ration of cdt edges with satisfied capacity needed to perform bundling
    // (otherwise bundling will not be executed)
    get MinimalRatioOfGoodCdtEdges() {
        return this.minimalRatioOfGoodCdtEdges;
    }
    set MinimalRatioOfGoodCdtEdges(value) {
        this.minimalRatioOfGoodCdtEdges = value;
    }
    // speed vs quality of the drawing
    get HighestQuality() {
        return this.highestQuality;
    }
    set HighestQuality(value) {
        this.highestQuality = value;
    }
}
// the default value of CapacityOverflowCoefficient
BundlingSettings.DefaultCapacityOverflowCoefficientMultiplier = 1000;
// the default path lenght importance coefficient
BundlingSettings.DefaultPathLengthImportance = 500;
// the default ink importance
BundlingSettings.DefaultInkImportance = 0.01;
/** default edge separation */
BundlingSettings.DefaultEdgeSeparation = 0.5;
//# sourceMappingURL=BundlingSettings.js.map