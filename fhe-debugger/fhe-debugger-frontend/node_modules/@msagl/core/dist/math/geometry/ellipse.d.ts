import { ICurve, ICurveJSON } from './icurve';
import { Rectangle } from './rectangle';
import { PN } from './parallelogramNode';
import { Point, PointJSON } from './point';
import { PlaneTransformation } from './planeTransformation';
/** ellipse: also represents a circle and an arc.
 * The point on the ellipse corresponding to the parameter t is calculated by
 * the formula center + cos(t)*aAxis + sin(t) * bAxis.
 * To get an ellipse rotating clockwise use, for example,
 * aAxis = (-1,0) and bAxis=(0,1) */
export declare type EllipseJSON = {
    parStart: number;
    parEnd: number;
    axis0: PointJSON;
    axis1: PointJSON;
    center: PointJSON;
};
export declare class Ellipse implements ICurve {
    isFullEllipse(): boolean;
    static fromJSON(eData: EllipseJSON): Ellipse;
    toJSON(): ICurveJSON;
    box: Rectangle;
    pNode: PN;
    /** the aAxis of the ellips*/
    aAxis: Point;
    /** the bAxis of the ellipse */
    bAxis: Point;
    center: Point;
    parStart: number;
    parEnd: number;
    /** offsets the curve in the given direction */
    offsetCurve(offset: number, dir: Point): ICurve;
    /** Reverse the ellipe: not implemented. */
    reverse(): ICurve;
    static mkEllipsePPP(a: Point, b: Point, center: Point): Ellipse;
    constructor(parStart: number, parEnd: number, axis0: Point, axis1: Point, center: Point);
    get start(): Point;
    get end(): Point;
    /** Trims the curve */
    trim(start: number, end: number): ICurve;
    trimWithWrap(start: number, end: number): ICurve;
    /** The bounding box of the ellipse */
    get boundingBox(): Rectangle;
    /** Returns the point on the curve corresponding to parameter t */
    value(t: number): Point;
    /** first derivative */
    derivative(t: number): Point;
    /** second derivative */
    secondDerivative(t: number): Point;
    /** third derivative */
    thirdDerivative(t: number): Point;
    /** a tree of ParallelogramNodes covering the edge */
    pNodeOverICurve(): PN;
    private setBoundingBox;
    static mkEllipse(parStart: number, parEnd: number, axis0: Point, axis1: Point, centerX: number, centerY: number): Ellipse;
    /** Construct a full ellipse by two axes */
    static mkFullEllipsePPP(axis0: Point, axis1: Point, center: Point): Ellipse;
    /** Constructs a full ellipse with axes aligned to X and Y directions */
    static mkFullEllipseNNP(axisA: number, axisB: number, center: Point): Ellipse;
    /** creates a circle by a given radius and the center */
    static mkCircle(radius: number, center: Point): Ellipse;
    /** Moves the ellipse to the delta vector */
    translate(delta: Point): void;
    /** Scales the ellipse by x and by y */
    scaleFromOrigin(xScale: number, yScale: number): Ellipse;
    getParameterAtLength(length: number): number;
    /** Transforms the ellipse */
    transform(transformation: PlaneTransformation): ICurve;
    /** returns a parameter t such that the distance between curve[t] and targetPoint is minimal
     * and t belongs to the closed segment [low,high] */
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    lengthPartial(start: number, end: number): number;
    get length(): number;
    /** clones the ellipse . */
    clone(): Ellipse;
    /** returns a parameter t such that the distance between curve[t] and a is minimal */
    closestParameter(targetPoint: Point): number;
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    curvature(t: number): number;
    curvatureDerivative(t: number): number;
    curvatureSecondDerivative(t: number): number;
    orientedCounterclockwise(): boolean;
    fullBox(): Rectangle;
    /**is it a proper arc? meaning that it just a part of a circle */
    isArc(): boolean;
}
