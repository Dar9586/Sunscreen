import { ICurve } from './icurve';
import { Point, PointJSON } from './point';
import { PlaneTransformation } from './planeTransformation';
import { Rectangle } from './rectangle';
import { PN } from './parallelogramNode';
export declare type LineSegmentJSON = {
    start: PointJSON;
    end: PointJSON;
};
export declare class LineSegment implements ICurve {
    static fromJSON(lineData: LineSegmentJSON): LineSegment;
    toJSON(): LineSegmentJSON;
    start: Point;
    end: Point;
    readonly parStart = 0;
    readonly parEnd = 1;
    offsetCurve(offset: number, dir: Point): ICurve;
    constructor(x: number, y: number, x1: number, y1: number);
    trim(start: number, end: number): ICurve;
    value(t: number): Point;
    trimWithWrap(start: number, end: number): ICurve;
    pNodeOverICurve(): PN;
    normal(): Point;
    static mkPP(start: Point, end: Point): LineSegment;
    static mkLinePXY(p: Point, x: number, y: number): LineSegment;
    derivative(t: number): Point;
    secondDerivative(t: number): Point;
    thirdDerivative(t: number): Point;
    reverse(): LineSegment;
    translate(delta: Point): void;
    scaleFromOrigin(xScale: number, yScale: number): LineSegment;
    getParameterAtLength(length: number): number;
    transform(transformation: PlaneTransformation): ICurve;
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    lengthPartial(start: number, end: number): number;
    get length(): number;
    get boundingBox(): Rectangle;
    clone(): LineSegment;
    static closestParameterOnLineSegment(point: Point, segmentStart: Point, segmentEnd: Point): number;
    closestParameter(targetPoint: Point): number;
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    static IntersectPPPP(a: Point, b: Point, c: Point, d: Point): Point | undefined;
    curvature(t: number): number;
    curvatureDerivative(t: number): number;
    curvatureSecondDerivative(_: number): number;
    static minDistBetweenLineSegments(a: Point, b: Point, c: Point, d: Point): {
        dist: number;
        parab: number;
        parcd: number;
    };
}
/** a - is the point to test
 * [c,b] - is the segment
 * The function actually checks that a is inside of the bounding box of [c,b].
 * ! Use it only when a,b,c are collinear !
 */
export declare function pointIsOnSegment(a: Point, b: Point, c: Point): boolean;
/** returns true if segments intersect */
export declare function segmentsIntersect(a: Point, b: Point, c: Point, d: Point): boolean;
