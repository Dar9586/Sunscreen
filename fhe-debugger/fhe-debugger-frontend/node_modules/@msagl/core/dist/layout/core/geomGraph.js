import { Graph } from '../../structs/graph';
import { Rectangle, Size } from '../../math/geometry/rectangle';
import { GeomObject } from './geomObject';
import { GeomNode } from './geomNode';
import { GeomEdge } from './geomEdge';
import { PlaneTransformation } from '../../math/geometry/planeTransformation';
import { Point } from '../../math/geometry/point';
import { OptimalRectanglePacking } from '../../math/geometry/rectanglePacking/OptimalRectanglePacking';
import { mkRTree } from '../../math/geometry/RTree/rTree';
import { Curve, interpolateICurve, PointLocation } from '../../math/geometry';
import { RRect } from './RRect';
import { AttributeRegistry } from '../../structs/attributeRegistry';
import { Edge } from '../../structs/edge';
import { Node } from '../../structs/node';
import { PointPair } from '../../math/geometry/pointPair';
// packs the subgraphs and set the bounding box of the parent graph
export function optimalPackingRunner(geomGraph, subGraphs) {
    const subgraphsRects = subGraphs.map((g) => [g, g.boundingBox]); // g.boundingBox is a clone of the graph rectangle
    const rectangles = subgraphsRects.map((t) => t[1]);
    const packing = new OptimalRectanglePacking(rectangles, 1.5);
    packing.run();
    for (const [g, rect] of subgraphsRects) {
        const delta = rect.leftBottom.sub(g.boundingBox.leftBottom);
        g.translate(delta);
    }
    geomGraph.boundingBox = new Rectangle({
        left: 0,
        bottom: 0,
        right: packing.PackedWidth,
        top: packing.PackedHeight,
    });
}
/** GeomGraph is an attribute on a Graph. The underlying Graph keeps all structural information but GeomGraph holds the geometry data, and the layout settings */
export class GeomGraph extends GeomNode {
    constructor(graph) {
        super(graph);
        /** The empty space between the graph inner entities and its boundary */
        this.margins = { left: 10, top: 10, bottom: 10, right: 10 };
        /** The X radius of the rounded rectangle border */
        this.radX = 10;
        /** The Y radius of the rounded rectangle border */
        this.radY = 10;
        this.rrect = new RRect({ left: 0, right: -1, top: 20, bottom: 0, radX: this.radX, radY: this.radY });
    }
    isAncestor(source) {
        return this.graph.isAncestor(source.node);
    }
    deepTranslate(delta) {
        for (const n of this.nodesBreadthFirst) {
            if (n instanceof GeomGraph) {
                n.boundingBox = n.boundingBox.translate(delta);
            }
            else {
                n.translate(delta);
            }
            for (const e of n.selfEdges()) {
                e.translate(delta);
            }
            for (const e of n.outEdges()) {
                if (this.graph.isAncestor(e.target.node))
                    e.translate(delta);
            }
        }
        this.boundingBox = this.boundingBox.translate(delta);
    }
    /** it is a rather shallow clone */
    clone() {
        const gg = new GeomGraph(null);
        gg.boundingBox = this.boundingBox.clone();
        gg.layoutSettings = this.layoutSettings;
        gg.margins = this.margins;
        gg.radX = this.radX;
        gg.radY = this.radY;
        return gg;
    }
    /** Calculate bounding box from children, not updating the bounding boxes recursively. */
    calculateBoundsFromChildren() {
        const bb = Rectangle.mkEmpty();
        for (const n of this.shallowNodes) {
            bb.addRecSelf(n.boundingBoxWithPadding);
        }
        bb.padEverywhere(this.margins);
        return bb;
    }
    *allSuccessorsWidthFirst() {
        for (const n of this.graph.allSuccessorsWidthFirst()) {
            yield GeomNode.getGeom(n);
        }
    }
    static getGeom(attrCont) {
        return GeomObject.getGeom(attrCont);
    }
    edgeCurveOrArrowheadsIntersectRect(geomEdge, rect) {
        for (const p of geomEdge.sourceArrowheadPoints(25)) {
            if (rect.contains(p))
                return true;
        }
        for (const p of geomEdge.targetArrowheadPoints(25)) {
            if (rect.contains(p))
                return true;
        }
        const curveUnderTest = geomEdge.curve;
        const perimeter = rect.perimeter();
        return (Curve.intersectionOne(curveUnderTest, perimeter, false) != null ||
            Curve.PointRelativeToCurveLocation(curveUnderTest.start, perimeter) === PointLocation.Inside);
    }
    isEmpty() {
        return this.graph.isEmpty();
    }
    setSettingsRecursively(ls) {
        this.layoutSettings = ls;
        for (const n of this.nodesBreadthFirst) {
            const gg = n;
            gg.layoutSettings = ls;
        }
    }
    get layoutSettings() {
        return this._layoutSettings;
    }
    // recursively sets the same settings for subgraphs
    set layoutSettings(value) {
        this._layoutSettings = value;
    }
    get labelSize() {
        return this._labelSize;
    }
    set labelSize(value) {
        this._labelSize = value;
    }
    get boundingBox() {
        if (this.rrect)
            return this.rrect.clone();
        else
            return null;
    }
    set boundingBox(value) {
        if (value) {
            this.rrect.setRect(value);
        }
        else {
            this.rrect.roundedRect_ = null;
        }
        // Assert.assert(this.bbIsCorrect())
    }
    transform(matrix) {
        if (matrix.isIdentity())
            return;
        for (const n of this.shallowNodes) {
            n.transform(matrix);
        }
        for (const e of this.shallowEdges) {
            e.transform(matrix);
            if (e.label)
                e.label.transform(matrix);
        }
        this.boundingBox =
            this.rrect == null || this.rrect.isEmpty() ? this.pumpTheBoxToTheGraphWithMargins() : this.boundingBox.transform(matrix);
    }
    /** Contrary to the deepTranslate() it also translates edges leading out of the graph */
    translate(delta) {
        if (delta.x === 0 && delta.y === 0)
            return;
        this.deepTranslate(delta);
    }
    get nodesBreadthFirst() {
        return this.nodesBreadthFirstIter();
    }
    *nodesBreadthFirstIter() {
        for (const n of this.graph.nodesBreadthFirst) {
            yield GeomObject.getGeom(n);
        }
    }
    setEdge(s, t) {
        const structEdge = this.graph.setEdge(s, t);
        return new GeomEdge(structEdge);
    }
    /** this does not change the graph bounding box */
    getPumpedGraphWithMarginsBox() {
        const t = { b: Rectangle.mkEmpty() };
        pumpTheBoxToTheGraph(this, t);
        t.b.padEverywhere(this.margins);
        return t.b;
    }
    /** sets the bounding box and the boundary curve as well */
    pumpTheBoxToTheGraphWithMargins() {
        return (this.boundingBox = this.getPumpedGraphWithMarginsBox());
    }
    // Fields which are set by Msagl
    // return the center of the curve bounding box
    get center() {
        return this.boundingBox || this.boundingBox.isEmpty ? this.boundingBox.center : new Point(0, 0);
    }
    set center(value) {
        // Assert.assert(this.bbIsCorrect())
        const del = value.sub(this.center);
        const t = new PlaneTransformation(1, 0, del.x, 0, 1, del.y);
        this.transform(t);
    }
    get left() {
        return this.boundingBox.left;
    }
    get right() {
        return this.boundingBox.right;
    }
    get top() {
        return this.boundingBox.top;
    }
    get bottom() {
        return this.boundingBox.bottom;
    }
    CheckClusterConsistency() {
        throw new Error('Method not implemented.');
    }
    get edgeCount() {
        return this.graph.edgeCount;
    }
    get boundaryCurve() {
        // Assert.assert(this.rrect.isOk())
        return this.rrect.roundedRect_;
    }
    set boundaryCurve(value) {
        throw new Error();
    }
    get shallowNodes() {
        return this.shallowNodes_();
    }
    *shallowNodes_() {
        for (const n of this.graph.shallowNodes)
            yield GeomObject.getGeom(n);
    }
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges() {
        return this.deepEdgesIt();
    }
    *deepEdgesIt() {
        for (const e of this.graph.deepEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    get shallowEdges() {
        return this.shallowEdgesIt();
    }
    *shallowEdgesIt() {
        for (const e of this.graph.shallowEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    static mk(id, labelSize = new Size(0, 0)) {
        const g = new GeomGraph(new Graph(id));
        g.labelSize = labelSize;
        return g;
    }
    get Clusters() {
        return this.subgraphs();
    }
    /** iterates over all subgraphs  */
    *subgraphs() {
        for (const g of this.graph.subgraphsBreadthFirst()) {
            yield GeomObject.getGeom(g);
        }
    }
    static mkWithGraphAndLabel(graph, labelSize) {
        const g = new GeomGraph(graph);
        g.labelSize = labelSize;
        return g;
    }
    get deepNodeCount() {
        let n = 0;
        for (const v of this.graph.nodesBreadthFirst)
            n++;
        return n;
    }
    get subgraphsDepthFirst() {
        return this.getSubgraphsDepthFirst();
    }
    *getSubgraphsDepthFirst() {
        for (const n of this.graph.allSuccessorsDepthFirst()) {
            if (n instanceof Graph)
                yield GeomGraph.getGeom(n);
        }
    }
    get uniformMargins() {
        return Math.max(this.margins.left, this.margins.right, this.margins.right, this.margins.bottom);
    }
    set uniformMargins(value) {
        this.margins.left = this.margins.right = this.margins.right = this.margins.bottom = value;
    }
    get height() {
        return this.boundingBox.height;
    }
    get width() {
        return this.boundingBox.width;
    }
    get shallowNodeCount() {
        return this.graph.shallowNodeCount;
    }
    get graph() {
        return this.entity;
    }
    liftNode(n) {
        const liftedNode = this.graph.liftNode(n.node);
        return liftedNode ? GeomObject.getGeom(liftedNode) : null;
    }
    findNode(id) {
        const n = this.graph.findNode(id);
        if (!n)
            return null;
        return GeomObject.getGeom(n);
    }
    addNode(gn) {
        this.graph.addNode(gn.node);
        return gn;
    }
    addLabelToGraphBB(rect) {
        if (this.labelSize) {
            rect.top += this.labelSize.height + 2; // 2 for label margin
            if (rect.width < this.labelSize.width) {
                rect.width = this.labelSize.width;
            }
        }
    }
}
export function pumpTheBoxToTheGraph(igraph, t) {
    for (const e of igraph.shallowEdges) {
        if (!isProperEdge(e))
            continue;
        const cb = e.curve.boundingBox;
        // cb.pad(e.lineWidth)
        t.b.addRecSelf(cb);
        if (e.edge.label != null) {
            const labelGeom = GeomObject.getGeom(e.edge.label);
            if (labelGeom) {
                t.b.addRecSelf(labelGeom.boundingBox);
            }
        }
    }
    for (const n of igraph.shallowNodes) {
        if ('shallowEdges' in n) {
            pumpTheBoxToTheGraph(n, t);
        }
        if (n.underCollapsedGraph() || !n.boundingBox)
            continue;
        t.b.addRecSelf(n.boundingBox);
    }
    if (igraph instanceof GeomGraph) {
        igraph.addLabelToGraphBB(t.b);
    }
    function isProperEdge(geomEdge) {
        if (geomEdge == null)
            return false;
        if (geomEdge.curve == null)
            return false;
        if (geomEdge.underCollapsedGraph())
            return false;
        if (igraph instanceof GeomGraph) {
            const graph = igraph.entity;
            return graph.isAncestor(geomEdge.source.entity) && graph.isAncestor(geomEdge.target.entity);
        }
        else {
            return true;
        }
    }
}
/** iterate over the graph objects intersected by a rectangle: by default, return only the intersected nodes */
export function* intersectedObjects(rtree, rect, onlyNodes = true) {
    const result = rtree.GetAllIntersecting(rect);
    if (onlyNodes) {
        for (const r of result) {
            if (r instanceof Node)
                yield r;
        }
    }
    else {
        // nodes and edges
        for (const r of result) {
            if (r instanceof Node || r instanceof Edge)
                yield r;
        }
    }
}
export function buildRTree(graph) {
    const data = Array.from(graph.nodesBreadthFirst)
        .concat(Array.from(graph.deepEdges))
        .map((o) => [GeomObject.getGeom(o).boundingBox, o]);
    return mkRTree(data);
}
export function* getGeomIntersectedObjects(tree, slack, point) {
    if (!tree)
        return;
    const rect = Rectangle.mkSizeCenter(new Size(slack * 2), point);
    for (const t of tree.RootNode.AllHitItems(rect, null)) {
        if ('edge' in t) {
            if (dist(point, t.pp._first, t.pp._second) < slack) {
                yield GeomObject.getGeom(t.edge);
            }
        }
        else {
            yield GeomObject.getGeom(t);
        }
    }
    function dist(p, s, e) {
        const l = e.sub(s);
        const len = l.length;
        if (len < 1.0 / 10) {
            return p.sub(Point.middle(s, e)).length;
        }
        const perp = l.rotate90Cw();
        return Math.abs(p.sub(s).dot(perp)) / len;
    }
}
export function buildRTreeWithInterpolatedEdges(graph, slack) {
    if (graph == null)
        return null;
    const nodes = Array.from(graph.nodesBreadthFirst).map((n) => [GeomNode.getGeom(n).boundingBox, n]);
    const edgesPlusEdgeLabels = [];
    for (const e of graph.deepEdges) {
        const ge = e.getAttr(AttributeRegistry.GeomObjectIndex);
        if (!ge)
            continue;
        if (ge.label) {
            edgesPlusEdgeLabels.push([ge.label.boundingBox, e.label]);
        }
        if (!ge.curve)
            continue;
        const poly = interpolateICurve(ge.curve, slack / 2);
        if (ge.sourceArrowhead) {
            edgesPlusEdgeLabels.push([
                Rectangle.mkPP(ge.sourceArrowhead.tipPosition, ge.curve.start),
                { edge: e, pp: new PointPair(ge.sourceArrowhead.tipPosition, ge.curve.start) },
            ]);
        }
        for (let i = 0; i < poly.length - 1; i++) {
            edgesPlusEdgeLabels.push([Rectangle.mkPP(poly[i], poly[i + 1]), { edge: e, pp: new PointPair(poly[i], poly[i + 1]) }]);
        }
        if (ge.targetArrowhead) {
            edgesPlusEdgeLabels.push([
                Rectangle.mkPP(ge.curve.end, ge.targetArrowhead.tipPosition),
                { edge: e, pp: new PointPair(ge.curve.end, ge.targetArrowhead.tipPosition) },
            ]);
        }
    }
    const t = nodes.concat(edgesPlusEdgeLabels);
    return mkRTree(t);
}
//# sourceMappingURL=geomGraph.js.map