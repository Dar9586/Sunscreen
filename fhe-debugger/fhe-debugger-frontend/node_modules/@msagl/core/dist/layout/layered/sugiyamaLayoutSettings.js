import { VerticalConstraintsForSugiyama } from './verticalConstraintsForSugiyama';
import { HorizontalConstraintsForSugiyama } from './HorizontalConstraintsForSugiyama';
import { LayerDirectionEnum } from './layerDirectionEnum';
import { PlaneTransformation } from '../../math/geometry/planeTransformation';
import { closeDistEps } from '../../utils/compare';
import { EdgeRoutingMode } from '../../routing/EdgeRoutingMode';
import { CommonLayoutSettings } from '../commonLayoutSettings';
export var SnapToGridByY;
(function (SnapToGridByY) {
    SnapToGridByY[SnapToGridByY["None"] = 0] = "None";
    SnapToGridByY[SnapToGridByY["Top"] = 1] = "Top";
    SnapToGridByY[SnapToGridByY["Bottom"] = 2] = "Bottom";
})(SnapToGridByY || (SnapToGridByY = {}));
/** Settings for layered layout: it specifies if the direction of the layers, distance between the layers, etc*/
export class SugiyamaLayoutSettings {
    constructor() {
        this.commonSettings = new CommonLayoutSettings();
        this.verticalConstraints = new VerticalConstraintsForSugiyama();
        this.horizontalConstraints = new HorizontalConstraintsForSugiyama();
        this.NoGainAdjacentSwapStepsBound = 5;
        /** the adjacent swaps will proceed by NoGainAdjacentSwapStepsBound*NoGainStepsForOrderingMultiplier  */
        this.NoGainStepsForOrderingMultiplier = 1;
        /**  Aspect ratio of the layout. Ignored it zero.*/
        this.AspectRatio = 0;
        /** the maximum number of going up and down through the layers to untangle the edges */
        this.MaxNumberOfPassesInOrdering = 24;
        /**  When the number of vertices in the proper layered graph
         is at least threshold  we switch to a fast, but not so accurate,
         method for x-coordinates calculations. */
        this.BrandesThreshold = 600;
        /**  The coefficient for the label corners preserve heuristic,
         * that allows for an edge to pass through the bounding box of a label, close to its corner*/
        this.LabelCornersPreserveCoefficient = 0.1;
        /** the minimal node size */
        this.MinNodeHeight = (72 * 0.5) / 4;
        this.MinNodeWidth = (72 * 0.75) / 4;
        /**  The grid snapping mode: snap up, down on neither */
        this.SnapToGridByY = SnapToGridByY.None;
        /** the minimum distance between two layer horizontal lines passing througt the node centers */
        this.yLayerSep = 10 * 3;
        /** the transform can be an identity, or rotation on Pi/2, -Pi/2, or Pi */
        this.transform = PlaneTransformation.getIdentity();
        this.GridSizeByY = 0;
        this.GridSizeByX = 0;
        this.commonSettings.edgeRoutingSettings.EdgeRoutingMode = EdgeRoutingMode.SugiyamaSplines;
    }
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    toJSON() {
        const r = {};
        if (this.sameRanks)
            r.sameRanks = this.sameRanks;
        if (this.verticalConstraints)
            r.verticalConstraints = this.verticalConstraints;
        if (this.horizontalConstraints)
            r.horizontalConstraints = this.horizontalConstraints;
        if (this.NoGainAdjacentSwapStepsBound != 5)
            r.horizontalConstraints = this.horizontalConstraints;
        if (this.NoGainStepsForOrderingMultiplier != 1)
            r.RepetitionCoefficientForOrdering = this.NoGainStepsForOrderingMultiplier;
        if (this.AspectRatio)
            r.AspectRatio = this.AspectRatio;
        if (this.MaxNumberOfPassesInOrdering != 24)
            r.MaxNumberOfPassesInOrdering = this.MaxNumberOfPassesInOrdering;
        if (this.BrandesThreshold != 600)
            r.BrandesThreshold = this.BrandesThreshold;
        if (this.LabelCornersPreserveCoefficient != 0.1)
            r.LabelCornersPreserveCoefficient = this.LabelCornersPreserveCoefficient;
        if (this.MinNodeHeight != (72 * 0.5) / 4)
            r.MinNodeHeight = this.MinNodeHeight;
        if (this.MinNodeWidth != (72 * 0.75) / 4)
            r.MinNodeWidth = this.MinNodeWidth;
        if (this.SnapToGridByY != SnapToGridByY.None)
            r.SnapToGridByY = this.SnapToGridByY;
        if (this.yLayerSep != 10 * 3)
            r.yLayerSep = this.yLayerSep;
        if (this.transform)
            r.transform = this.transform.elements;
        if (this.GridSizeByY)
            r.GridSizeByY = this.GridSizeByY;
        if (this.GridSizeByX)
            r.GridSizeByX = this.GridSizeByX;
        r.commonLayoutSettings = this.commonSettings.toJSON();
        return r;
    }
    static fromJSON(s) {
        const r = new SugiyamaLayoutSettings();
        if (s.sameRanks)
            r.sameRanks = s.sameRanks;
        if (s.verticalConstraints)
            r.verticalConstraints = s.verticalConstraints;
        if (s.horizontalConstraints)
            r.horizontalConstraints = s.horizontalConstraints;
        if (s.NoGainAdjacentSwapStepsBound)
            r.horizontalConstraints = s.horizontalConstraints;
        if (s.RepetitionCoefficientForOrdering)
            r.NoGainStepsForOrderingMultiplier = s.RepetitionCoefficientForOrdering;
        if (s.AspectRatio)
            r.AspectRatio = s.AspectRatio;
        if (s.MaxNumberOfPassesInOrdering)
            r.MaxNumberOfPassesInOrdering = s.MaxNumberOfPassesInOrdering;
        if (s.BrandesThreshold)
            r.BrandesThreshold = s.BrandesThreshold;
        if (s.LabelCornersPreserveCoefficient)
            r.LabelCornersPreserveCoefficient = s.LabelCornersPreserveCoefficient;
        if (s.MinNodeHeight)
            r.MinNodeHeight = s.MinNodeHeight;
        if (s.MinNodeWidth)
            r.MinNodeWidth = r.MinNodeWidth;
        if (s.SnapToGridByY)
            r.SnapToGridByY = s.SnapToGridByY;
        if (s.yLayerSep)
            r.yLayerSep = s.yLayerSep;
        if (s.transform)
            r.transform = new PlaneTransformation(s.transform[0][0], s.transform[0][1], s.transform[0][2], s.transform[1][0], s.transform[1][1], s.transform[1][2]);
        if (s.GridSizeByY)
            r.GridSizeByY = s.GridSizeByY;
        if (s.GridSizeByX)
            r.GridSizeByX = s.GridSizeByX;
        if (s.commonLayoutSettings)
            r.commonSettings = CommonLayoutSettings.fromJSON(s.commonLayoutSettings);
        return r;
    }
    /** the minimum distance between two layer horizontal lines passing througt the node centers */
    get LayerSeparation() {
        return this.yLayerSep;
    }
    set LayerSeparation(value) {
        this.yLayerSep = Math.max(10 * 3, value);
    }
    ActualLayerSeparation(layersAreDoubled) {
        return layersAreDoubled ? this.LayerSeparation / 2.0 : this.LayerSeparation;
    }
    transformIsRotation(ang) {
        const p = PlaneTransformation.rotation(ang);
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 3; j++)
                if (!closeDistEps(p.elements[i][j], this.transform.elements[i][j]))
                    return false;
        }
        return true;
    }
    get layerDirection() {
        if (this.transformIsRotation(0))
            return LayerDirectionEnum.TB;
        if (this.transformIsRotation(Math.PI / 2))
            return LayerDirectionEnum.LR;
        if (this.transformIsRotation(-Math.PI / 2))
            return LayerDirectionEnum.RL;
        if (this.transformIsRotation(Math.PI))
            return LayerDirectionEnum.BT;
        throw new Error('unexpected layout direction');
    }
    set layerDirection(value) {
        switch (value) {
            case LayerDirectionEnum.TB:
                this.transform = PlaneTransformation.getIdentity();
                break;
            case LayerDirectionEnum.LR:
                this.transform = PlaneTransformation.rotation(Math.PI / 2);
                break;
            case LayerDirectionEnum.RL:
                this.transform = PlaneTransformation.rotation(-Math.PI / 2);
                break;
            case LayerDirectionEnum.BT:
                this.transform = PlaneTransformation.rotation(Math.PI);
                break;
            default:
                throw new Error('unexpected layout direction');
        }
    }
}
//# sourceMappingURL=sugiyamaLayoutSettings.js.map