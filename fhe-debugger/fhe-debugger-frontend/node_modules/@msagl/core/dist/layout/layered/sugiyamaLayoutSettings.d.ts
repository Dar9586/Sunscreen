import { VerticalConstraintsForSugiyama } from './verticalConstraintsForSugiyama';
import { HorizontalConstraintsForSugiyama } from './HorizontalConstraintsForSugiyama';
import { LayerDirectionEnum } from './layerDirectionEnum';
import { PlaneTransformation } from '../../math/geometry/planeTransformation';
import { CommonLayoutSettings, CommonLayoutSettingsJSON } from '../commonLayoutSettings';
import { EdgeRoutingSettings } from '../../routing/EdgeRoutingSettings';
import { ILayoutSettings } from '../iLayoutSettings';
export declare enum SnapToGridByY {
    None = 0,
    Top = 1,
    Bottom = 2
}
export declare type SugiyamaLayoutSettingsJSON = {
    sameRanks?: Array<string[]>;
    verticalConstraints?: VerticalConstraintsForSugiyama;
    horizontalConstraints?: HorizontalConstraintsForSugiyama;
    NoGainAdjacentSwapStepsBound?: number;
    RepetitionCoefficientForOrdering?: number;
    AspectRatio?: number;
    MaxNumberOfPassesInOrdering?: number;
    BrandesThreshold?: number;
    LabelCornersPreserveCoefficient?: number;
    MinNodeHeight?: number;
    MinNodeWidth?: number;
    SnapToGridByY?: SnapToGridByY;
    yLayerSep?: number;
    transform?: Array<Array<number>>;
    GridSizeByY?: number;
    GridSizeByX?: number;
    commonLayoutSettings?: CommonLayoutSettingsJSON;
};
/** Settings for layered layout: it specifies if the direction of the layers, distance between the layers, etc*/
export declare class SugiyamaLayoutSettings implements ILayoutSettings {
    commonSettings: CommonLayoutSettings;
    get NodeSeparation(): number;
    get edgeRoutingSettings(): EdgeRoutingSettings;
    set edgeRoutingSettings(value: EdgeRoutingSettings);
    toJSON(): SugiyamaLayoutSettingsJSON;
    static fromJSON(s: SugiyamaLayoutSettingsJSON): SugiyamaLayoutSettings;
    sameRanks: Array<string[]>;
    verticalConstraints: VerticalConstraintsForSugiyama;
    horizontalConstraints: HorizontalConstraintsForSugiyama;
    NoGainAdjacentSwapStepsBound: number;
    /** the adjacent swaps will proceed by NoGainAdjacentSwapStepsBound*NoGainStepsForOrderingMultiplier  */
    NoGainStepsForOrderingMultiplier: number;
    /**  Aspect ratio of the layout. Ignored it zero.*/
    AspectRatio: number;
    /** the maximum number of going up and down through the layers to untangle the edges */
    MaxNumberOfPassesInOrdering: number;
    /**  When the number of vertices in the proper layered graph
     is at least threshold  we switch to a fast, but not so accurate,
     method for x-coordinates calculations. */
    BrandesThreshold: number;
    /**  The coefficient for the label corners preserve heuristic,
     * that allows for an edge to pass through the bounding box of a label, close to its corner*/
    LabelCornersPreserveCoefficient: number;
    /** the minimal node size */
    MinNodeHeight: number;
    MinNodeWidth: number;
    /**  The grid snapping mode: snap up, down on neither */
    SnapToGridByY: SnapToGridByY;
    /** the minimum distance between two layer horizontal lines passing througt the node centers */
    private yLayerSep;
    /** the transform can be an identity, or rotation on Pi/2, -Pi/2, or Pi */
    transform: PlaneTransformation;
    GridSizeByY: number;
    GridSizeByX: number;
    /** the minimum distance between two layer horizontal lines passing througt the node centers */
    get LayerSeparation(): number;
    set LayerSeparation(value: number);
    ActualLayerSeparation(layersAreDoubled: boolean): number;
    constructor();
    transformIsRotation(ang: number): boolean;
    get layerDirection(): LayerDirectionEnum;
    set layerDirection(value: LayerDirectionEnum);
}
