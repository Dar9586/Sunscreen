import { Queue } from 'queue-typescript';
import { Point } from '../../../math/geometry';
import { MinimumEnclosingDisc } from './minimumEnclosingDisc';
import { MultipoleCoefficients } from './multipoleCoefficients';
var Dim;
(function (Dim) {
    Dim[Dim["Horizontal"] = 0] = "Horizontal";
    Dim[Dim["Vertical"] = 1] = "Vertical";
})(Dim || (Dim = {}));
class KdNode {
    intersects(v) {
        const d = v.med.Center.sub(this.med.Center);
        const l = d.length;
        return l < v.med.Radius + this.med.Radius;
    }
}
class InternalKdNode extends KdNode {
    constructor(med, left, right) {
        super();
        this.med = med;
        this.parent = left.parent;
        if (this.parent != null) {
            if (this.parent.leftChild == left) {
                this.parent.leftChild = this;
            }
            else {
                //Assert.assert(this.parent.rightChild == left)
                this.parent.rightChild = this;
            }
        }
        this.leftChild = left;
        this.rightChild = right;
        left.parent = this;
        right.parent = this;
    }
    computeMultipoleCoefficients(precision) {
        this.leftChild.computeMultipoleCoefficients(precision);
        this.rightChild.computeMultipoleCoefficients(precision);
        this.multipoleCoefficients = MultipoleCoefficients.constructorPMM(this.med.Center, this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);
    }
}
class LeafKdNode extends KdNode {
    constructor(particles) {
        super();
        //Assert.assert(particles[0].length == particles[1].length)
        this.particles = particles;
        this.ComputeMinimumEnclosingDisc();
    }
    computeMultipoleCoefficients(precision) {
        this.multipoleCoefficients = MultipoleCoefficients.constructorNPA(precision, this.med.Center, this.ps);
    }
    ComputeMinimumEnclosingDisc() {
        const n = this.Size();
        this.ps = new Array(n);
        for (let i = 0; i < n; i++) {
            this.ps[i] = this.particles[0][i].point;
        }
        return (this.med = MinimumEnclosingDisc.LinearComputation(this.ps));
    }
    Min(d) {
        return this.particles[d][0].pos(d);
    }
    Size() {
        return this.particles[0].length;
    }
    Max(d) {
        return this.particles[d][this.Size() - 1].pos(d);
    }
    Dimension(d) {
        return this.Max(d) - this.Min(d);
    }
    Split(t) {
        const splitDirection = this.Dimension(Dim.Horizontal) > this.Dimension(Dim.Vertical) ? Dim.Horizontal : Dim.Vertical;
        const nonSplitDirection = splitDirection == Dim.Horizontal ? Dim.Vertical : Dim.Horizontal;
        const n = this.Size();
        const nLeft = n >> 1;
        const nRight = n - nLeft;
        const leftParticles = [new Array(nLeft), new Array(nLeft)];
        const rightParticles = [new Array(nRight), new Array(nRight)];
        let rCtr = 0;
        let lCtr = 0;
        for (let i = 0; i < n; i++) {
            const p = this.particles[splitDirection][i];
            if (i < nLeft) {
                leftParticles[splitDirection][i] = p;
                p.splitLeft = true;
            }
            else {
                rightParticles[splitDirection][i - nLeft] = p;
                p.splitLeft = false;
            }
        }
        for (let i = 0; i < n; i++) {
            const p = this.particles[nonSplitDirection][i];
            if (p.splitLeft) {
                leftParticles[nonSplitDirection][lCtr++] = p;
            }
            else {
                rightParticles[nonSplitDirection][rCtr++] = p;
            }
        }
        // Assert.assert(lCtr == nLeft)
        // Assert.assert(rCtr == nRight)
        const parentMED = this.med;
        this.particles = leftParticles;
        this.ComputeMinimumEnclosingDisc();
        t.rightSibling = new LeafKdNode(rightParticles);
        return new InternalKdNode(parentMED, this, t.rightSibling);
    }
    ComputeForces() {
        for (const u of this.particles[0]) {
            for (const v of this.particles[0]) {
                if (u != v) {
                    u.force = u.force.add(MultipoleCoefficients.Force(u.point, v.point));
                }
            }
        }
    }
}
export class Particle {
    //  Create particle at point
    constructor(point) {
        this.point = point;
        this.force = new Point(0, 0);
    }
    pos(d) {
        return d == Dim.Horizontal ? this.point.x : this.point.y;
    }
}
//  A KDTree recursively divides particles of a 2D space into a balanced tree structure by doing horizontal splits for wide bounding boxes and vertical splits for tall bounding boxes.
export class KDTree {
    //  Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.
    constructor(particles, bucketSize) {
        this.particles = particles;
        const ps = new Array();
        ps.push(this.particlesBy(Dim.Horizontal));
        ps.push(this.particlesBy(Dim.Vertical));
        this.leaves = new Array();
        let l = new LeafKdNode(ps);
        this.leaves.push(l);
        const t = { rightSibling: null };
        this.root = l.Split(t);
        this.leaves.push(t.rightSibling);
        const splitQueue = new SplitQueue(bucketSize);
        splitQueue.EnqueueLL(l, t.rightSibling);
        while (splitQueue.length > 0) {
            l = splitQueue.dequeue();
            l.Split(t);
            this.leaves.push(t.rightSibling);
            splitQueue.EnqueueLL(l, t.rightSibling);
        }
    }
    particlesBy(d) {
        return this.particles.map((t) => t).sort((a, b) => a.pos(d) - b.pos(d));
    }
    //  Compute forces between particles using multipole approximations.
    ComputeForces(precision) {
        this.root.computeMultipoleCoefficients(precision);
        for (const l of this.leaves) {
            l.ComputeForces();
            const stack = new Array();
            stack.push(this.root);
            while (stack.length > 0) {
                const v = stack.pop();
                if (!l.intersects(v)) {
                    for (const p of l.particles[0]) {
                        p.force = p.force.sub(v.multipoleCoefficients.ApproximateForce(p.point));
                    }
                }
                else {
                    if (v instanceof LeafKdNode) {
                        for (const p of l.particles[0]) {
                            for (const q of v.particles[0]) {
                                if (p != q) {
                                    p.force = p.force.add(MultipoleCoefficients.Force(p.point, q.point));
                                }
                            }
                        }
                    }
                    else {
                        const n = v;
                        stack.push(n.leftChild);
                        stack.push(n.rightChild);
                    }
                }
            }
        }
    }
}
class SplitQueue extends Queue {
    constructor(B) {
        super();
        this.B = B;
    }
    EnqueueLL(l, r) {
        if (l.Size() > this.B) {
            this.enqueue(l);
        }
        if (r.Size() > this.B) {
            this.enqueue(r);
        }
    }
}
//# sourceMappingURL=kdTree.js.map