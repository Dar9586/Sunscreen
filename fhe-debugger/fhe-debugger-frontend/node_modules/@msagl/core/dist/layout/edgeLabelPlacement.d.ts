import { LinkedList } from '@esfx/collections';
import { ICurve, Point, Rectangle, Size } from '../math/geometry';
import { RTree } from '../math/geometry/RTree/rTree';
import { Algorithm } from '../utils/algorithm';
import { CancelToken } from '../utils/cancelToken';
import { GeomEdge } from './core/geomEdge';
import { GeomGraph } from './core/geomGraph';
import { GeomLabel } from './core/geomLabel';
import { GeomNode } from './core/geomNode';
export declare enum LabelPlacementResult {
    /**
       Placement result meaning that another label was overlapped
      */
    OverlapsOtherLabels = 0,
    /**
      Placement result meaning that the label overlaps a node, but not a label
      */
    OverlapsNodes = 1,
    /**
      Placement result meaning that the label overlaps an edge, but not a node or label.
      */
    OverlapsEdges = 2,
    /**
      Placement result meaning that the label overlaps nothing.
      */
    OverlapsNothing
}
export declare enum PlacementSide {
    /**
      //Places the label on any side
      */
    Any = 0,
    /**
      //Places the label on the port side of the edge.
      //Port is the left side of the edge if you were facing away from the source and towards the target.
      */
    Port = 1,
    /**
      //Places the label on the starboard side of the edge.
      //Starboard is the right side of the edge if you were facing away from the source and towards the target.
      */
    Starboard = 2,
    /**
      //Places the label on the top side of the line.
      //If the line is vertical, the label is placed on the left.
      */
    Top = 3,
    /**
      //Places the label on the bottom side of the line.
      //If the line is vertical, the label is placed on the right.
      */
    Bottom = 4,
    /**
      //Places the label on the left side of the line.
      //If the line is horizontal, the label is placed on the top.
      */
    Left = 5,
    /**
      //Places the label on the right side of the line.
      //If the line is horizontal, the label is placed on the bottom.
      */
    Right = 6
}
declare class PointSet {
    Center: Point;
    Inner: Point;
    Key: number;
    Outer: Point;
}
declare class PointSetList {
    points: LinkedList<PointSet>;
    coveredLength: number;
    AddFirst(p: PointSet): number;
    AddLast(p: PointSet): number;
}
declare enum PlacementStrategy {
    AlongCurve = 0,
    Horizontal = 1
}
interface IObstacle {
    boundingBox: Rectangle;
}
declare class LabelInfo {
    innerPoints: Point[];
    outerPoints: Point[];
    edgePoints: Array<[number, Point]>;
    placementSide: PlacementSide;
    placementOffset: number;
    placementResult: LabelPlacementResult;
    constructor(edgePoints: Array<[number, Point]>);
}
/** The class to place labels */
export declare class EdgeLabelPlacement extends Algorithm {
    placementStrategy: PlacementStrategy[];
    edges: GeomEdge[];
    obstacleMaps: RTree<IObstacle, Point>[];
    labelObstacleMap: RTree<IObstacle, Point>;
    edgeInfos: Map<GeomEdge, LabelInfo>;
    /**       The default and minimum granularity for breaking up a curve into many points.*/
    static MinGranularity: number;
    /**       The maximum granulairty for breaking up a curve into many points.*/
    static MaxGranularity: number;
    /**       The number of edges at which to start increasing the granularity.*/
    static LowerEdgeBound: number;
    /**       The number of edges at which to stop increasing the granularity.*/
    static UpperEdgeBound: number;
    granularity: number;
    get CollisionGranularity(): number;
    set CollisionGranularity(value: number);
    /**      True if the edge collision granularity should be degraded as the number of edges increases. */
    ScaleCollisionGranularity: boolean;
    static constructorG(graph: GeomGraph): EdgeLabelPlacement;
    static constructorGA(graph: GeomGraph, edges: GeomEdge[]): EdgeLabelPlacement;
    constructor(nodes: GeomNode[], edges: GeomEdge[]);
    interpolateGranularity(edgeCount: number): number;
    InitializeObstacles(nodes: GeomNode[], edgeList: GeomEdge[]): void;
    static CurvePoints(curve: ICurve, granularity: number): [number, Point][];
    static compareByArgument(x: [number, Point], y: [number, Point]): number;
    static SubdivideCurveSegment(list: Array<[number, Point]>, curve: ICurve, delta2: number, start: number, end: number): void;
    static PlaceLabelsAtDefaultPositions(cancelToken: CancelToken, edges: GeomEdge[]): void;
    GetEdgeObstacles(edges: Array<GeomEdge>): Array<IObstacle>;
    /**       Adds the label to the label obstacle map.*/
    AddLabelObstacle(label: IObstacle): void;
    run(): void;
    PlaceLabel(edge: GeomEdge): void;
    getLabelInfo(label: GeomLabel): LabelInfo;
    PlaceLabelAtFirstPosition(label: GeomLabel): void;
    StartIndex(label: GeomLabel, points: any[]): number;
    CalculateCenterLabelInfoCenter(label: GeomLabel): void;
    PlaceEdgeLabelHorizontally(edge: GeomEdge): boolean;
    static GetLabelBounds(point: Point, derivative: Point, size: Size, side: number): Rectangle;
    SetLabelBounds(labelInfo: LabelInfo, bounds: Rectangle): void;
    static GetPossibleSides(side: PlacementSide, derivative: Point): number[];
    static ExpandingSearch(start: number, min: number, max: number): IterableIterator<number>;
    static PointSetLength(ps: Array<PointSet>): number;
    PlaceEdgeLabelOnCurve(label: GeomLabel): boolean;
    CaseOfCoveredLengthGreaterThanLabelLength(label: GeomLabel, placedPoints: PointSetList, coveredLength: number, labelLength: number, wh: Size): void;
    GoOverOrderedPointsAndAddLabelObstacels(orderedPoints: Array<PointSet>, innerPoints: Array<Point>, outerPoints: Array<Point>, wh: Size): void;
    ProcessExpandingSearchOnSide(index: number, curvePoints: Array<[number, Point]>, curve: ICurve, side: number, radius: number, distanceFromCurve: number, wh: Size, t: {
        coveredLength: number;
    }, placedPoints: PointSetList, labelLength: number): void;
    GetSidesAndEdgeCurve(label: GeomLabel, e: GeomEdge, curvePoints: Array<[number, Point]>, index: number): number[];
    Conflict(labelPos: Point, radius: number, wh: Size): boolean;
    ConflictIndexRL(queryRect: Rectangle, label: GeomLabel): number;
    /**   Determines the index of the first obstacle map that the point intersects.
      Returns the index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.*/
    ConflictIndex(labelPos: Point, radius: number, wh: Size): number;
}
export {};
