import { CommonLayoutSettings } from '../commonLayoutSettings';
/** Settings for multi-dimensional scaling */
export class MdsLayoutSettings {
    constructor() {
        this.commonSettings = new CommonLayoutSettings();
        // the setting of Multi-Dimensional Scaling layout
        // private double epsilon = Math.Pow(10,-8);
        this.pivotNumber = 50;
        this.iterationsWithMajorization = 30;
        this.scaleX = 100;
        this.scaleY = 100;
        this.exponent = -2;
        this.rotationAngle = 0;
        this._removeOverlaps = true;
        /** do not call iterations with majorization, the local layout improvement heuristic, for graph with at least 2000 nodes */
        this._callIterationsWithMajorizationThreshold = 2000;
        this.adjustScale = false;
    }
    static fromJSON(s) {
        const ret = new MdsLayoutSettings();
        if (s.pivotNumber)
            ret.pivotNumber = s.pivotNumber;
        if (s.iterationsWithMajorization)
            ret.iterationsWithMajorization = s.iterationsWithMajorization;
        if (s.scaleX)
            ret.scaleX = s.scaleX;
        if (s.scaleY)
            ret.scaleY = s.scaleY;
        if (s.exponent)
            ret.exponent = s.exponent;
        if (s.rotationAngle)
            ret.rotationAngle = s.rotationAngle;
        if (s.removeOverlaps != undefined)
            ret._removeOverlaps = s.removeOverlaps;
        if (s._callIterationsWithMajorizationThreshold)
            ret._callIterationsWithMajorizationThreshold = s._callIterationsWithMajorizationThreshold;
        return ret;
    }
    toJSON() {
        const ret = {};
        if (this.pivotNumber != 50)
            ret.pivotNumber = this.pivotNumber;
        if (this.iterationsWithMajorization != 30)
            ret.iterationsWithMajorization = this.iterationsWithMajorization;
        if (this.scaleX != 200)
            ret.scaleX = this.scaleX;
        if (this.scaleY != 200)
            ret.scaleY = this.scaleY;
        if (this.exponent != -2)
            ret.exponent = this.exponent;
        if (this.rotationAngle != 0)
            ret.rotationAngle = this.rotationAngle;
        if (!this._removeOverlaps)
            ret.removeOverlaps = this._removeOverlaps;
        if (this._callIterationsWithMajorizationThreshold != 3000)
            ret._callIterationsWithMajorizationThreshold = this._callIterationsWithMajorizationThreshold;
        return ret;
    }
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    set NodeSeparation(value) {
        this.commonSettings.NodeSeparation = value;
    }
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    // remove overlaps between node boundaries
    get removeOverlaps() {
        return this._removeOverlaps;
    }
    set removeOverlaps(value) {
        this._removeOverlaps = value;
    }
    // Number of pivots in Landmark Scaling (between 3 and number of objects).
    get PivotNumber() {
        return this.pivotNumber;
    }
    set PivotNumber(value) {
        this.pivotNumber = value;
    }
    /** Number of iterations in distance scaling: these iterations beautify the layout locally. This heuristic is optional , and the property has to be set to zero for a large graph, because each iteration has O(n*n) time, where n is the number of nodes in the graph */
    get IterationsWithMajorization() {
        return this.iterationsWithMajorization;
    }
    set IterationsWithMajorization(value) {
        this.iterationsWithMajorization = value;
    }
    // X Scaling Factor.
    get ScaleX() {
        return this.scaleX;
    }
    set ScaleX(value) {
        this.scaleX = value;
    }
    // Y Scaling Factor.
    get ScaleY() {
        return this.scaleY;
    }
    set ScaleY(value) {
        /*Assert.assert(!isNaN(value))*/
        this.scaleY = value;
    }
    // Weight matrix exponent.
    get Exponent() {
        return this.exponent;
    }
    set Exponent(value) {
        this.exponent = value;
    }
    // rotation angle
    get RotationAngle() {
        return this.rotationAngle;
    }
    set RotationAngle(value) {
        this.rotationAngle = value % 360;
    }
    // Adjust the scale of the graph if there is not enough whitespace between nodes
    get AdjustScale() {
        return this.adjustScale;
    }
    set AdjustScale(value) {
        this.adjustScale = value;
    }
    GetNumberOfIterationsWithMajorization(nodeCount) {
        if (nodeCount > this.CallIterationsWithMajorizationThreshold) {
            return 0;
        }
        return this.IterationsWithMajorization;
    }
    get CallIterationsWithMajorizationThreshold() {
        return this._callIterationsWithMajorizationThreshold;
    }
    set CallIterationsWithMajorizationThreshold(value) {
        this._callIterationsWithMajorizationThreshold = value;
    }
}
//# sourceMappingURL=mDSLayoutSettings.js.map