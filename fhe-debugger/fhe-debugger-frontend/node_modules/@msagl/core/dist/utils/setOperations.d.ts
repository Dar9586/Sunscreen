import { Point } from '..';
import { PointPair } from '../math/geometry/pointPair';
import { PointPairMap } from './pointPairMap';
import { PointSet } from './PointSet';
export declare function substractSets<T>(a: Set<T>, b: Set<T>): Set<T>;
export declare function substractPointSets(a: PointSet, b: PointSet): PointSet;
export declare function uniteSets<T>(a: Set<T>, b: Set<T>): Set<T>;
export declare function addRange<T>(array: Array<T>, addedIterable: Iterable<T>): void;
export declare function setIntersection<T>(a: Set<T>, b: Set<T>): Set<T>;
export declare function setIntersectionOfArray<T>(arr: Set<T>[]): Set<T>;
export declare function insertRange<T>(collection: Set<T>, addedArray: Iterable<T>): void;
export declare function setsAreEqual<T>(a: Set<T>, b: Set<T>): boolean;
/** return the concatenated array of items */
export declare function flattenArray<U, T>(arr: ReadonlyArray<T>, callback: (elem: T) => Iterable<U>): U[];
/** adds val to map.get(key) if the key exists, otherwise creates the key pair and
 * executes the former instruction
 */
export declare function addToMapOfSets<K, V>(map: Map<K, Set<V>>, key: K, val: V): void;
export declare function addToMapOfArrays<K, V>(map: Map<K, Array<V>>, key: K, val: V): void;
export declare function addToPointPairMap<V>(map: PointPairMap<Set<V>>, key: PointPair, val: V): void;
export declare function addToPointMapTuple<V>(map: PointPairMap<Set<V>>, key: [Point, Point], val: V): void;
export declare function removeFromPointPairMap<V>(map: PointPairMap<Set<V>>, key: PointPair, val: V): void;
export declare function removeFromPointPairMapTuple<V>(map: PointPairMap<Set<V>>, key: [Point, Point], val: V): void;
export declare function removeFromArray<T>(arr: T[], OverlapRemovalNode: T): void;
