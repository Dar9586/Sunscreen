import { Graph } from './graph';
export class NodeCollection {
    constructor() {
        this.nodeMap = new Map();
    }
    remove(node) {
        this.nodeMap.delete(node.id);
    }
    get size() {
        return this.nodeMap.size;
    }
    *nodes_() {
        for (const p of this.nodeMap.values())
            yield p;
    }
    *graphs_() {
        for (const n of this.nodes_()) {
            if (n instanceof Graph) {
                yield n;
            }
        }
    }
    findShallow(id) {
        return this.nodeMap.get(id);
    }
    get nodesShallow() {
        return this.nodes_();
    }
    get graphs() {
        return this.graphs_();
    }
    *_edges() {
        // if we go over node.inEdges too then not self edges will be reported twice
        for (const node of this.nodeMap.values()) {
            for (const e of node.outEdges) {
                yield e;
            }
            for (const e of node.selfEdges) {
                yield e;
            }
        }
    }
    interGraphEdges() {
        throw new Error('not implemented');
    }
    get nodeShallowCount() {
        return this.nodeMap.size;
    }
    // caution: it is a linear by the number of nodes method
    get edgeCount() {
        let count = 0;
        for (const p of this.nodeMap.values()) {
            count += p.outDegree + p.selfDegree;
        }
        return count;
    }
    /**  returns the edges of shallow nodes */
    get edges() {
        return this._edges();
    }
    addNode(node) {
        this.nodeMap.set(node.id, node);
    }
    nodeIsConsistent(n) {
        for (const e of n.outEdges) {
            if (e.source !== n) {
                return false;
            }
            if (e.source === e.target) {
                return false;
            }
        }
        for (const e of n.inEdges) {
            if (e.target !== n) {
                return false;
            }
            if (e.source === e.target) {
                return false;
            }
        }
        for (const e of n.selfEdges) {
            if (e.target !== e.source) {
                return false;
            }
            if (e.source !== n) {
                return false;
            }
        }
        return true;
    }
    isConsistent() {
        for (const node of this.nodeMap.values()) {
            if (!this.nodeIsConsistent(node)) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=nodeCollection.js.map