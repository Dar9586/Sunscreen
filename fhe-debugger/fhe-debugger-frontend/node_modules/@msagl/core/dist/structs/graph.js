import { Queue } from 'queue-typescript';
import { Assert } from '../utils/assert';
// import {Assert} from '../utils/assert'
import { Edge } from './edge';
import { Node } from './node';
import { NodeCollection } from './nodeCollection';
/** This class keeps the connection between the nodes and the edges of the graph. The nodes of a Graph can also be Graphs.  */
export class Graph extends Node {
    constructor(id = '__graph__') {
        super(id);
        this.nodeCollection = new NodeCollection();
    }
    remove(node) {
        this.nodeCollection.remove(node);
    }
    /** Removes itself from under the parent.
     *  Also removes all the edges leading out of the graph.
     */
    removeSubgraph() {
        const parent = this.parent;
        if (parent)
            parent.removeNode(this);
        for (const c of this.outGoingEdges()) {
            if (c.attachedAtSource) {
                c.node.removeOutEdge(c.edge);
            }
            else {
                c.node.removeInEdge(c.edge);
            }
        }
    }
    /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
    *outGoingEdges() {
        for (const e of this.outEdges) {
            const t = e.target;
            if (!this.isAncestor(t)) {
                yield { edge: e, node: t, attachedAtSource: false };
            }
        }
        for (const e of this.inEdges) {
            const s = e.source;
            if (!this.isAncestor(s)) {
                yield { edge: e, node: s, attachedAtSource: true };
            }
        }
        for (const n of this.nodesBreadthFirst) {
            for (const e of n.outEdges) {
                const t = e.target;
                if (t === this)
                    continue;
                if (!this.isAncestor(t)) {
                    yield { edge: e, node: t, attachedAtSource: false };
                }
            }
            for (const e of n.inEdges) {
                const s = e.source;
                if (s === this)
                    continue;
                if (!this.isAncestor(s)) {
                    yield { edge: e, node: s, attachedAtSource: true };
                }
            }
        }
    }
    isAncestor(entity) {
        for (const ant of entity.getAncestors()) {
            if (ant === this) {
                return true;
            }
        }
        return false;
    }
    /**  Iterates over all connected components of the graph and for each component
     * returns all its nodes with "this" as the parent
     */
    *getClusteredConnectedComponents() {
        const processed = new Set();
        const q = new Queue();
        for (const v of this.nodesBreadthFirst) {
            if (processed.has(v))
                continue;
            processed.add(v);
            q.enqueue(v);
            const component = new Set();
            do {
                const u = q.dequeue();
                if (u.parent === this) {
                    component.add(u);
                }
                for (const w of this.reachableFrom(u)) {
                    if (!processed.has(w)) {
                        processed.add(w);
                        q.enqueue(w);
                    }
                }
            } while (q.length > 0);
            yield Array.from(component);
        }
    }
    *reachableFrom(u) {
        for (const e of u.outEdges) {
            yield e.target;
        }
        for (const e of u.inEdges) {
            yield e.source;
        }
        if (u instanceof Graph) {
            yield* u.shallowNodes;
        }
        if (u.parent != this) {
            yield u.parent;
        }
    }
    hasSomeAttrOnIndex(index) {
        for (const n of this.nodesBreadthFirst) {
            if (n.getAttr(index))
                return true;
        }
        for (const n of this.deepEdges) {
            if (n.getAttr(index))
                return true;
        }
        return false;
    }
    *graphs() {
        for (const g of this.nodeCollection.graphs) {
            yield g;
        }
    }
    noEmptySubgraphs() {
        for (const g of this.subgraphsBreadthFirst()) {
            if (g.shallowNodeCount === 0)
                return false;
        }
        return true;
    }
    hasSubgraphs() {
        for (const n of this.shallowNodes)
            if (n instanceof Graph)
                return true;
        return false;
    }
    /** iterates breadth first  */
    *subgraphsBreadthFirst() {
        for (const n of this.nodesBreadthFirst) {
            if (n instanceof Graph)
                yield n;
        }
    }
    isEmpty() {
        return this.shallowNodeCount === 0;
    }
    setEdge(sourceId, targetId) {
        const s = this.nodeCollection.findShallow(sourceId);
        if (s == null)
            return;
        const t = this.nodeCollection.findShallow(targetId);
        if (t == null)
            return;
        return new Edge(s, t);
    }
    /** Iterates over the nodes of the current graph but not entering the subgraphs.
     *  Yields the top subgraphs among the nodes as well
     */
    get shallowNodes() {
        return this.nodeCollection.nodesShallow;
    }
    /** Iterates over all the nodes of including the subgraphs.
     * The iteration happens in the breadth first pattern.
     */
    get nodesBreadthFirst() {
        return this.nodesBreadthFirst_();
    }
    /** iterates breadth first  */
    *nodesBreadthFirst_() {
        for (const n of this.nodeCollection.nodesShallow) {
            yield n;
            if (n instanceof Graph) {
                yield* n.nodesBreadthFirst;
            }
        }
    }
    /**
     * Finds the node with the givin id belonging to a graph or one of its subgraphs.
     */
    findNodeRecursive(id) {
        const n = this.nodeCollection.findShallow(id);
        if (n) {
            return n;
        }
        for (const g of this.shallowNodes) {
            if (g instanceof Graph) {
                const nn = g.findNodeRecursive(id);
                if (nn)
                    return nn;
            }
        }
        return null;
    }
    /** Returns a node belonging to this graph having the same id.
     * If a node with the given id belongs to a subgraph than it would no be returned.
     * To find such a deeper nested node use findNodeRecursive
     */
    findNode(id) {
        return this.nodeCollection.findShallow(id);
    }
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    get shallowEdges() {
        return this.nodeCollection.edges;
    }
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges() {
        return this.deepEdgesIt();
    }
    *deepEdgesIt() {
        for (const node of this.nodesBreadthFirst) {
            for (const e of node.outEdges) {
                yield e;
            }
            for (const e of node.selfEdges) {
                yield e;
            }
            for (const e of node.inEdges) {
                if (!this.isAncestor(e.source))
                    yield e;
            }
        }
    }
    isConsistent() {
        if (this.parent)
            return this.parent.isConsistent();
        return this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
    }
    nodeIsConsistent(n) {
        return this.nodeCollection.nodeIsConsistent(n);
    }
    /** Detouches all the node's edges and removes the node from the graph.
     * This method does not change the parent of the node.
     */
    removeNode(node) {
        for (const e of node.outEdges) {
            e.target.inEdges.delete(e);
        }
        for (const e of node.inEdges) {
            e.source.outEdges.delete(e);
        }
        this.nodeCollection.remove(node);
        for (const p of this.subgraphsBreadthFirst()) {
            p.removeNode(node);
        }
    }
    /** adds a node to the graph */
    addNode(n) {
        Assert.assert(this.findNodeRecursive(n.id) == null);
        /*Assert.assert(n.parent == null  || n.parent === this)*/
        n.parent = this;
        this.nodeCollection.addNode(n);
        // Assert.assert(this.isConsistent())
        return n;
    }
    get shallowNodeCount() {
        return this.nodeCollection.nodeShallowCount;
    }
    get nodeCountDeep() {
        let count = this.nodeCollection.size;
        for (const p of this.shallowNodes) {
            if (p instanceof Graph) {
                count += p.nodeCountDeep;
            }
        }
        return count;
    }
    get edgeCount() {
        return this.nodeCollection.edgeCount;
    }
    // If n has an ancestor which is the graph child then return it.
    // Otherwise return null
    liftNode(n) {
        while (n != null && n.parent !== this) {
            n = n.parent;
        }
        return n;
    }
    /** return the number of all edges in the graph, including the subgraphs */
    get deepEdgesCount() {
        let count = 0;
        for (const p of this.nodesBreadthFirst) {
            count += p.outDegree + p.selfDegree;
        }
        return count;
    }
    eachNodeIdIsUnique() {
        const ids = new Set();
        for (const n of this.nodesBreadthFirst) {
            if (ids.has(n.id)) {
                return false;
            }
            ids.add(n.id);
        }
        return true;
    }
    /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
    *allElements() {
        for (const n of this.allSuccessorsWidthFirst()) {
            yield n;
            for (const e of n.selfEdges) {
                yield e;
            }
            for (const e of n.outEdges) {
                yield e;
            }
            for (const e of n.inEdges) {
                if (!this.isAncestor(e.source)) {
                    yield e;
                }
            }
        }
        yield* this.edges; // uses get edges() of Node
    }
    *allSuccessorsWidthFirst() {
        for (const n of this.shallowNodes) {
            yield n;
        }
        for (const n of this.shallowNodes) {
            if (n instanceof Graph) {
                yield* n.allSuccessorsWidthFirst();
            }
        }
    }
    *allSuccessorsDepthFirst() {
        for (const n of this.shallowNodes) {
            if (n instanceof Graph) {
                yield* n.allSuccessorsDepthFirst();
            }
            yield n;
        }
    }
}
export function* shallowConnectedComponents(graph) {
    const enqueueed = new Set();
    const queue = new Queue();
    for (const n of graph.shallowNodes) {
        if (enqueueed.has(n))
            continue;
        const nodes = new Array();
        enqueue(n, queue, enqueueed);
        while (queue.length > 0) {
            const s = queue.dequeue();
            nodes.push(s);
            for (const neighbor of neighbors(s)) {
                enqueue(neighbor, queue, enqueueed);
            }
        }
        yield nodes;
    }
    function* neighbors(n) {
        for (const e of n.outEdges)
            yield e.target;
        for (const e of n.inEdges)
            yield e.source;
    }
    function enqueue(n, queue, enqueueed) {
        if (!enqueueed.has(n)) {
            queue.enqueue(n);
            enqueueed.add(n);
        }
    }
}
/** sets a new Graph as the parent of the node */
export function setNewParent(newParent, node) {
    if (node.parent) {
        const oldParent = node.parent;
        oldParent.remove(node);
    }
    newParent.addNode(node);
    // let p = newParent
    // while (p.parent) p = p.parent as Graph
    // Assert.assert(p.isConsistent())
}
/** implements the google PageRank.
 * omega is the probability of following a link
 * */
export function pagerank(graph, omega) {
    let p = new Map();
    const n = graph.nodeCountDeep;
    let initialVal = 1 / n;
    for (const v of graph.nodesBreadthFirst) {
        p.set(v, initialVal);
    }
    // repeat 50 times
    for (let c = 0; c < 50; c++) {
        initialVal = (1 - omega) / n;
        const q = new Map();
        for (const v of graph.nodesBreadthFirst) {
            q.set(v, initialVal);
        }
        //  forward propagation
        for (const v of graph.nodesBreadthFirst) {
            let qv = q.get(v);
            for (const edge of v.inEdges) {
                const u = edge.source;
                qv += omega * (p.get(u) / u.outDegree);
            }
            q.set(v, qv);
        }
        p = q;
    }
    return p;
}
export function edgeNodesBelongToSet(e, s) {
    return s.has(e.source) && s.has(e.target);
}
//# sourceMappingURL=graph.js.map