import { SortedMap } from '@esfx/collections-sortedmap';
import { IncrementalDragger } from './incrementalDragger';
import { IViewerNode } from './iViewerNode';
import { Point, Entity, GeomEdge, GeomGraph, GeomObject, ILayoutSettings, EdgeRoutingMode, GeomLabel, GeomNode, ICurve, SmoothedPolyline, CornerSite } from '@msagl/core';
export declare enum DraggingMode {
    Incremental = 0,
    Default = 1
}
export declare class GeometryGraphEditor {
    updateDeltaForDragUndo(delta: Point): void;
    registerDelete(entity: Entity): void;
    registerAdd(entity: Entity): void;
    entitiesToBeChangedByRedo(): IterableIterator<Entity>;
    entitiesToBeChangedByUndo(): IterableIterator<Entity>;
    createUndoPoint(): void;
    private edgesToReroute;
    graph: () => GeomGraph;
    private objectsToDrag;
    private undoList;
    incrementalDragger: IncrementalDragger;
    /**      return the current undo action*/
    get LayoutSettings(): ILayoutSettings;
    protected get EdgeRoutingMode(): EdgeRoutingMode;
    geomEdgeWithSmoothedPolylineExposed: GeomEdge;
    /**  returns true if "undo" is available */
    get canUndo(): boolean;
    /**  returns true if "redo" is available*/
    get canRedo(): boolean;
    static calculateAttachmentSegment(label: GeomLabel): void;
    static CalculateAttachedSegmentEnd(label: GeomLabel, edge: GeomEdge): void;
    /** drags elements by the delta,
     * and return the array of entities with the changed geometry
     *
     */
    drag(delta: Point, draggingMode: DraggingMode, lastMousePosition: Point): void;
    registerForUndoDrag(entity: Entity): void;
    DragObjectsForRectilinearCase(delta: Point): Array<Entity>;
    dragObjectsForNonRectilinearCase(delta: Point, draggingMode: DraggingMode): void;
    dragWithStraightLines(delta: Point): void;
    propagateChangesToClusterParents(): void;
    addToEdgesToReroute(e: GeomEdge): void;
    DragWithSplinesOrBundles(delta: Point): void;
    RunSplineRouterAndPutLabels(): void;
    registerForUndo(e: Entity): void;
    routeEdgesAsStraightLines(): void;
    DragIncrementally(delta: Point): void;
    dragPolylineCorner(lastMousePosition: Point, delta: Point): void;
    static dragEdgeWithSite(delta: Point, e: GeomEdge, site: CornerSite): void;
    static createCurveOnChangedPolyline(e: GeomEdge): void;
    prepareForObjectDragging(markedObjects: Iterable<GeomObject>, dragMode: DraggingMode): void;
    PrepareForClusterCollapseChange(changedClusters: Iterable<IViewerNode>): void;
    InitIncrementalDragger(): void;
    clearDraggedSets(): void;
    private addToObjectsToDrag;
    /** fills the fields objectsToDrag, edgesToDrag */
    calculateObjectToDragAndEdgesToReroute(markedObjects: Iterable<GeomObject>): void;
    removeClusterSuccessorsFromObjectsToDrag(): void;
    calculateDragSetsForEdges(): void;
    private addNodeEdgesToRerouteOrDrag;
    private addGeomGraphEdgesToRerouteOrDrag;
    /** returns true iff the edge is under a cluster belonging to this.objectsToDrag */
    private hasSelfOrAncestorInObjectsToDrag;
    private hasAncestorInObjectsToDrag;
    static CalculateMiddleOffsetsForMultiedge(multiedge: Array<GeomEdge>, node: GeomNode, offsetsInsideOfMultiedge: Map<GeomEdge, number>, nodeSeparation: number): void;
    static GetMiddleAnglesOfMultiedge(multiedge: Array<GeomEdge>, node: GeomNode): SortedMap<number, GeomEdge>;
    static Middle(iCurve: ICurve): Point;
    static GetMultiEdges(node: GeomNode): IterableIterator<Array<GeomEdge>>;
    static GetOrCreateListOfMultiedge(nodeToMultiEdge: Map<GeomNode, Array<GeomEdge>>, node: GeomNode): Array<GeomEdge>;
    prepareForGeomEdgeChange(geometryEdge: GeomEdge): void;
    undo(): void;
    redo(): void;
    clear(): void;
    static getPreviousCornerSite(edge: GeomEdge, point: Point): CornerSite;
    static betweenSites(prevSite: CornerSite, nextSite: CornerSite, point: Point): boolean;
    insertSite(edge: GeomEdge, point: Point, siteBeforeInsertion: CornerSite): void;
    deleteSite(edge: GeomEdge, site: CornerSite): void;
    static findClosestCornerForEdit(sp: SmoothedPolyline, mousePoint: Point, minDist?: number): CornerSite;
    ReactOnViewChange(): void;
    ForgetDragging(): void;
}
