import { DrawingObject, ShapeEnum } from '@msagl/drawing';
import { scaleLinear } from 'd3-scale';
import { rgb } from 'd3-color';
export function parseGraphStyle(style) {
    const parsedLayers = style.layers.map(parseLayerStyle);
    const ids = new Set();
    for (const layer of parsedLayers) {
        if (ids.has(layer.id)) {
            throw new Error(`Duplicate layer id: ${layer.id}`);
        }
        ids.add(layer.id);
    }
    return {
        layers: parsedLayers,
    };
}
function parseLayerStyle(layer, layerIndex) {
    var _a;
    const { type, id = `layer-${layerIndex}`, filter, visible = true, minZoom = -Infinity, maxZoom = Infinity } = layer;
    let interpolators;
    if (type === 'node') {
        interpolators = {
            opacity: parseInterpolation(layer.opacity),
            size: parseInterpolation(layer.size),
            fillColor: parseInterpolation(layer.fillColor, colorToRGB),
            strokeWidth: parseInterpolation(layer.strokeWidth),
            strokeColor: parseInterpolation(layer.strokeColor, colorToRGB),
            labelSize: parseInterpolation((_a = layer.labelSize) !== null && _a !== void 0 ? _a : layer.size),
            labelColor: parseInterpolation(layer.labelColor, colorToRGB),
        };
    }
    else if (layer.type === 'edge') {
        interpolators = {
            opacity: parseInterpolation(layer.opacity),
            strokeWidth: parseInterpolation(layer.strokeWidth),
            strokeColor: parseInterpolation(layer.strokeColor, colorToRGB),
            arrowSize: parseInterpolation(layer.arrowSize),
            arrowColor: parseInterpolation(layer.arrowColor, colorToRGB),
            labelSize: parseInterpolation(layer.labelSize),
            labelColor: parseInterpolation(layer.labelColor, colorToRGB),
        };
    }
    else {
        throw new Error(`Unknown layer type: ${type}`);
    }
    return {
        type,
        id,
        filter: parseFilter(filter),
        visible,
        minZoom,
        maxZoom,
        ...interpolators,
    };
}
function parseInterpolation(valueOrInterpolation, transform) {
    if (!valueOrInterpolation) {
        return null;
    }
    // @ts-ignore
    if (valueOrInterpolation.interpolation) {
        const { interpolation, interpolationParameters = [], input, inputStops, outputStops } = valueOrInterpolation;
        switch (interpolation) {
            case 'linear': {
                const scale = scaleLinear(inputStops, outputStops);
                scale.clamp(true);
                return (context) => {
                    const inputValue = context[input];
                    const value = scale(inputValue);
                    return (transform ? transform(value) : value);
                };
            }
            case 'power': {
                const base = interpolationParameters[0] || 2;
                const scale = scaleLinear(inputStops.map((x) => Math.pow(base, x)), outputStops);
                scale.clamp(true);
                return (context) => {
                    const inputValue = context[input];
                    const value = scale(Math.pow(base, inputValue));
                    return (transform ? transform(value) : value);
                };
            }
            case 'step': {
                return (context) => {
                    const inputValue = context[input];
                    const i = inputStops.findIndex((x) => x > inputValue);
                    let value;
                    if (i < 0) {
                        value = outputStops[outputStops.length - 1];
                    }
                    else {
                        value = outputStops[i];
                    }
                    return (transform ? transform(value) : value);
                };
            }
            default:
                throw new Error(`Unknown interpolation ${interpolation}`);
        }
    }
    if (transform) {
        return transform(valueOrInterpolation);
    }
    return valueOrInterpolation;
}
function colorToRGB(input) {
    const color = rgb(input);
    return [color.r, color.g, color.b, color.opacity * 255];
}
function parseFilter(filter) {
    if (!filter) {
        return null;
    }
    if (Array.isArray(filter)) {
        const testFuncs = filter.map(parseFilter);
        return (e, context) => {
            for (const f of testFuncs) {
                if (!f(e, context))
                    return false;
            }
            return true;
        };
    }
    let getProperty;
    switch (filter.property) {
        case 'id':
            getProperty = (e) => e.id;
            break;
        case 'source-id':
            getProperty = (e) => e.source.id;
            break;
        case 'target-id':
            getProperty = (e) => e.target.id;
            break;
        case 'shape':
            getProperty = (e) => ShapeEnum[getDrawingObj(e).shape];
            break;
        case 'label':
            getProperty = (e) => getDrawingObj(e).labelText;
            break;
        case 'rank':
            getProperty = (e, context) => {
                var _a, _b, _c;
                if ('source' in e) {
                    // is edge
                    return Math.min((_a = context.tileMap) === null || _a === void 0 ? void 0 : _a.nodeRank.get(e.source), (_b = context.tileMap) === null || _b === void 0 ? void 0 : _b.nodeRank.get(e.target));
                }
                return (_c = context.tileMap) === null || _c === void 0 ? void 0 : _c.nodeRank.get(e);
            };
            break;
        default:
            throw new Error(`Unknown filter property ${filter.property}`);
    }
    switch (filter.operator) {
        case '=':
            return (e, context) => getProperty(e, context) === filter.value;
        case '<':
            return (e, context) => getProperty(e, context) < filter.value;
        case '>':
            return (e, context) => getProperty(e, context) > filter.value;
        case '<=':
            return (e, context) => getProperty(e, context) <= filter.value;
        case '>=':
            return (e, context) => getProperty(e, context) >= filter.value;
        case '!=':
            return (e, context) => getProperty(e, context) != filter.value;
        case '*=':
            return (e, context) => String(getProperty(e, context)).includes(String(filter.value));
        case '^=':
            return (e, context) => String(getProperty(e, context)).startsWith(String(filter.value));
        case '$=':
            return (e, context) => String(getProperty(e, context)).endsWith(String(filter.value));
        default:
            throw new Error(`Unknown filter operator ${filter.operator}`);
    }
}
function getDrawingObj(e) {
    return DrawingObject.getDrawingObj(e);
}
//# sourceMappingURL=graph-style-evaluator.js.map