import { TextMeasurer } from '@msagl/renderer-common';
import { Edge, GeomEdge, GeomGraph, Graph, Point, Node, EventHandler, PlaneTransformation, Attribute, Entity } from '@msagl/core';
import { IViewerGraph, IViewerNode, IViewerEdge, IViewerObject } from '@msagl/drawing';
export declare class SvgViewerObject extends Attribute implements IViewerObject {
    clone(): Attribute;
    rebind(e: Entity): void;
    /**  This is the field from the Graph. It is used to keep the connection with the underlying graph */
    constructor(attrCont: Entity, svgData: SVGElement);
    svgData: SVGElement;
    isVisible: boolean;
    markedForDragging: boolean;
    /**  raised when the entity is unmarked for dragging*/
    unmarkedForDraggingCallback: () => void;
}
export declare class SvgViewerGraph extends SvgViewerObject implements IViewerGraph {
    get graph(): Graph;
}
export declare class SvgViewerNode extends SvgViewerObject implements IViewerNode {
    get node(): Node;
    IsCollapsedChanged: EventHandler;
}
export declare class SvgViewerEdge extends SvgViewerObject implements IViewerEdge {
    radiusOfPolylineCorner: number;
    selectedForEditing: boolean;
    get edge(): Edge;
    IsCollapsedChanged: (node: IViewerNode) => void;
}
/** this class creates SVG content for a given Graph */
export declare class SvgCreator {
    getShowRect(): DOMRect;
    removeRubberEdge(): void;
    rubberEdge: SVGElement;
    drawRubberEdge(edgeGeometry: GeomEdge): void;
    /** changes color and shape depending on inside parameter */
    positionEdgeInsertionElement(cursorPosition: Point, inside: boolean): void;
    nodeInsertionCircle: SVGElement;
    edgeInsertionPortElem: SVGElement;
    prepareToEdgeInsertion(cursorPosition: Point, insideOfANode: boolean): void;
    positionNodeInsertionCircle(cursorPosition: Point): void;
    stopNodeInsertion(): void;
    stopEdgeInsertion(): void;
    prepareToNodeInsertion(cursorPosition: Point): void;
    invalidate(objectToInvalidate: IViewerObject): void;
    getSvgString(): string;
    static arrowAngle: number;
    svg: SVGElement;
    superTransGroup: SVGElement;
    transformGroup: SVGElement;
    graph: Graph;
    get geomGraph(): GeomGraph;
    _textMeasurer: TextMeasurer;
    private container;
    constructor(container: HTMLElement);
    private clearContainer;
    /** It cleans the current SVG content
     * and creates the new one corresponding to the graph
     * */
    setGraph(graph: Graph): void;
    private setTransformForTranformGroup;
    /** gets transform from svg to the client window coordinates */
    getTransform(): PlaneTransformation;
    getScale(): number;
    drawEdge(edge: Edge): SVGElement;
    /** This method can create the SVG child for the smoothed polyline,
     * and also remove it*/
    private drawSelectedForEdit;
    addCornerCirclesGroup(edge: Edge, edgeGroup: SVGElement, cornersGroupId: string): void;
    addCornerCircle(p: Point, cornerGroup: SVGElement, i: number, edge: Edge): void;
    getSmoothedPolylineRadius: () => number;
    drawSmoothPolyline(edge: Edge, edgeGroup: SVGElement, smoothPolyId: string): void;
    private createOrGetWithId;
    private drawEdgeLabel;
    private removeLabelAttachmentPrompt;
    private addLabelAttachmentPrompt;
    private addArrows;
    private AddArrowhead;
    private setStroke;
    private attachStyleToPath;
    drawNode(node: Node): void;
    private drawNodeOnCurve;
    private makePathOnCurve;
    private drawLabel;
    private writeLabelText;
    private drawLabelAtXY;
    private createTspans;
    getViewBoxString(bbox: DOMRect): string;
    private createAndBindWithGraph;
}
