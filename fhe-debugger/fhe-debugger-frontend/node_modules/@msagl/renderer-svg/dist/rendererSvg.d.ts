import { IViewerEdge, IViewerGraph, IViewerNode, IViewerObject, ModifierKeysEnum } from '@msagl/drawing';
import { Edge, EventHandler, GeomEdge, Graph, PlaneTransformation, Point, Node } from '@msagl/core';
import { IViewer, LayoutEditor, InsertionMode } from '@msagl/drawing';
import { PanZoom } from 'panzoom';
import { LayoutOptions } from '@msagl/renderer-common';
/**
 * This class renders an MSAGL graph with SVG and enables the graph editing.
 */
export declare class RendererSvg implements IViewer {
    /** debug feature : TODO - redesign */
    rubberEdgeStart: Point;
    sourcePortLocatiton: Point;
    targetPortLocatiton: Point;
    keyDownListener: (e: KeyboardEvent) => void;
    container: HTMLElement;
    addKeyDownListener(callback: (e: KeyboardEvent) => void): void;
    mousePosition: Point;
    entitiesIter(): Iterable<IViewerObject>;
    panZoom: PanZoom;
    get smoothedPolylineRadiusWithNoScale(): number;
    getInterpolationSlack(): number;
    /** the distance in inches */
    private mouseHitDistance;
    get Dpi(): number;
    getHitSlack(): number;
    layoutEditor: LayoutEditor;
    /** The default is true and the value is reset to true after each call to setGraph */
    needCreateGeometry: boolean;
    /** The default is true and the value is reset to true after each call to setGraph */
    needCalculateLayout: boolean;
    getSvgString(): string;
    getJSONString(): string;
    private _graph?;
    private _layoutOptions;
    private _textMeasurer;
    private _svgCreator;
    private _objectTree;
    private processMouseMove;
    setObjectUnderCursorFromEvent(e: PointerEvent): void;
    constructor(container?: HTMLElement);
    private _insertionMode;
    get insertionMode(): InsertionMode;
    set insertionMode(value: InsertionMode);
    createUndoPoint(): void;
    selectedEntities(): IViewerObject[];
    createIViewerNodeNPA(drawingNode: Node, center: Point, visualElement: any): IViewerNode;
    createIViewerNodeN(node: Node, center: Point): IViewerNode;
    undo(): void;
    redo(): void;
    viewChangeEvent: EventHandler;
    /** when the graph is set : the geometry for it is created and the layout is done */
    setGraph(graph: Graph, options?: LayoutOptions): void;
    setOptions(options: LayoutOptions): void;
    private _update;
    /** maps the screen coordinates to the graph coordinates */
    screenToSource(e: PointerEvent): Point;
    /** maps the screen coordinates to the graph coordinates */
    private ScreenToSourceP;
    IncrementalDraggingModeAlways: boolean;
    get CurrentScale(): number;
    needToCalculateLayout: boolean;
    GraphChanged: EventHandler;
    _objectUnderMouse: IViewerObject;
    objectUnderMouseCursorChanged: EventHandler;
    get objectUnderMouseCursor(): IViewerObject;
    set objectUnderMouseCursor(value: IViewerObject);
    invalidate(objectToInvalidate: IViewerObject): void;
    invalidateAll(): void;
    modifierKeys: ModifierKeysEnum;
    get entities(): Iterable<IViewerObject>;
    get DpiX(): number;
    get DpiY(): number;
    LineThicknessForEditing: number;
    /** controls if the layout can be changed by mouse or touch interactions */
    layoutEditingEnabled: boolean;
    private get insertingNode();
    private get insertingEdge();
    PopupMenus(menuItems: [string, () => void][]): void;
    get smoothedPolylineCircleRadius(): number;
    addEdge(edge: IViewerEdge, registerForUndo: boolean): void;
    createEdgeWithGivenGeometry(edge: Edge): IViewerEdge;
    addNode(node: IViewerNode, registerForUndo: boolean): void;
    remove(viewerObj: IViewerObject, registerForUndo: boolean): void;
    private removeForNonSubgraph;
    private removeSubgraph;
    RouteEdge(drawingEdge: Edge): IViewerEdge;
    ViewerGraph: IViewerGraph;
    ArrowheadLength: number;
    SetSourcePortForEdgeRouting(portLocation: Point): void;
    setTargetPortForEdgeRouting(portLocation: Point): void;
    RemoveSourcePortEdgeRouting(): void;
    RemoveTargetPortEdgeRouting(): void;
    drawRubberEdge(edgeGeometry: GeomEdge): void;
    stopDrawingRubberEdge(): void;
    get graph(): Graph;
    get Transform(): PlaneTransformation;
}
