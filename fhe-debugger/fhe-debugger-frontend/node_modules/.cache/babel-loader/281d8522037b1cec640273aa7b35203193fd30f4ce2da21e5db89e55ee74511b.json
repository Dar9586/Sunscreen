{"ast":null,"code":"import { jsx as e, jsxs as t } from \"react/jsx-runtime\";\nimport n, { useEffect as i, Children as r, isValidElement as a, cloneElement as o, useReducer as g, useRef as d } from \"react\";\nimport { isFragment as s } from \"react-is\";\nfunction c(e, t) {\n  const n = getComputedStyle(t);\n  if (!n) return;\n  let i = e === z.Horizontal ? t.clientWidth : t.clientHeight;\n  return 0 !== i ? (e === z.Horizontal ? i -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight) : i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), i) : void 0;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction l(e, t, n = [], r = {\n  condition: !0\n}) {\n  const {\n      condition: a\n    } = r,\n    o = function (e, t) {\n      var n = {};\n      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);\n      if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n        var r = 0;\n        for (i = Object.getOwnPropertySymbols(e); r < i.length; r++) t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);\n      }\n      return n;\n    }(r, [\"condition\"]);\n  i(() => (a && window.addEventListener(e, t, o), () => {\n    a && window.removeEventListener(e, t);\n  }), [e, t, a, ...n]);\n}\n!function (e, t) {\n  void 0 === t && (t = {});\n  var n = t.insertAt;\n  if (e && \"undefined\" != typeof document) {\n    var i = document.head || document.getElementsByTagName(\"head\")[0],\n      r = document.createElement(\"style\");\n    r.type = \"text/css\", \"top\" === n && i.firstChild ? i.insertBefore(r, i.firstChild) : i.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e));\n  }\n}(\"/* === Main Container === */\\n.__dbk__container {\\n  height: 100%;\\n  width: 100%;\\n\\n  display: flex;\\n  overflow: hidden;\\n}\\n\\n.__dbk__container.Horizontal {\\n  flex-direction: row;\\n}\\n\\n.__dbk__container.Vertical {\\n  flex-direction: column;\\n}\\n/* ====== */\\n\\n/* === Wrapper for each child element === */\\n.__dbk__child-wrapper {\\n  height: 100%;\\n  width: 100%;\\n}\\n/* ====== */\\n\\n/* === Gutter === */\\n.__dbk__gutter {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n/* .__dbk__gutter > div {\\n  background: red;\\n} */\\n.__dbk__gutter.Horizontal {\\n  height: 100%;\\n  padding: 0 2px;\\n  flex-direction: column;\\n}\\n.__dbk__gutter.Horizontal:hover {\\n  cursor: col-resize;\\n}\\n\\n.__dbk__gutter.Vertical {\\n  width: 100%;\\n  padding: 2px 0;\\n  flex-direction: row;\\n}\\n.__dbk__gutter.Vertical:hover {\\n  cursor: row-resize;\\n}\\n\\n.__dbk__gutter.Light {\\n  background: #EDF0EF;\\n}\\n.__dbk__gutter.Light:hover > .__dbk__dragger {\\n  background: #76747B;\\n}\\n\\n.__dbk__gutter.Dark {\\n  background: #020203;\\n}\\n.__dbk__gutter.Dark:hover > .__dbk__dragger {\\n  background: #9995A3;\\n}\\n/* ====== */\\n\\n/* === Gutter's Dragger === */\\n.__dbk__dragger {\\n  border-radius: 2px;\\n}\\n\\n.__dbk__dragger.Horizontal {\\n  width: 4px;\\n  height: 24px;  \\n}\\n\\n.__dbk__dragger.Vertical {\\n  width: 24px;\\n  height: 4px;  \\n}\\n\\n.__dbk__dragger.Light {\\n  background: #A6ACB5;\\n}\\n\\n.__dbk__dragger.Dark {\\n  background: #434252;\\n}\\n/* ====== */\");\nconst u = n.forwardRef(({\n  className: t,\n  theme: n,\n  draggerClassName: i,\n  direction: r = z.Vertical,\n  onDragging: a\n}, o) => {\n  const g = `__dbk__gutter ${r} ${t || n}`,\n    d = `__dbk__dragger ${r} ${i || n}`;\n  return e(\"div\", Object.assign({\n    className: g,\n    ref: o,\n    dir: r,\n    onMouseDown: a,\n    onTouchStart: C ? a : void 0\n  }, {\n    children: e(\"div\", {\n      className: d\n    }, void 0)\n  }), void 0);\n});\nvar h;\nfunction p(e, t, n) {\n  let i, r;\n  return t ? (i = e / 2, r = e) : n ? (i = e, r = e / 2) : (i = e, r = e), {\n    aGutterSize: i,\n    bGutterSize: r\n  };\n}\nfunction f(e, t) {\n  switch (t.type) {\n    case h.SetIsReadyToCompute:\n      return Object.assign(Object.assign({}, e), {\n        isReady: t.payload.isReady\n      });\n    case h.CreatePairs:\n      {\n        const {\n            direction: n,\n            children: i,\n            gutters: r\n          } = t.payload,\n          a = i[0].parentNode;\n        if (!a) throw new Error(\"Cannot create pairs - parent is undefined.\");\n        const o = c(n, a);\n        if (void 0 === o) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${o}.`);\n        const g = [];\n        return i.forEach((e, t) => {\n          if (t > 0) {\n            const e = i[t - 1],\n              o = i[t],\n              d = r[t - 1],\n              s = n === z.Horizontal ? e.getBoundingClientRect().left : e.getBoundingClientRect().top,\n              c = n === z.Horizontal ? o.getBoundingClientRect().right : o.getBoundingClientRect().bottom,\n              l = n === z.Horizontal ? e.getBoundingClientRect().width + d.getBoundingClientRect().width + o.getBoundingClientRect().width : e.getBoundingClientRect().height + d.getBoundingClientRect().height + o.getBoundingClientRect().height,\n              u = n === z.Horizontal ? d.getBoundingClientRect().width : d.getBoundingClientRect().height,\n              h = {\n                idx: t - 1,\n                a: e,\n                b: o,\n                gutter: d,\n                parent: a,\n                start: s,\n                end: c,\n                size: l,\n                gutterSize: u,\n                aSizePct: 100 / i.length,\n                bSizePct: 100 / i.length\n              };\n            g.push(h);\n          }\n        }), Object.assign(Object.assign({}, e), {\n          pairs: g\n        });\n      }\n    case h.StartDragging:\n      {\n        const {\n          gutterIdx: n\n        } = t.payload;\n        return Object.assign(Object.assign({}, e), {\n          isDragging: !0,\n          draggingIdx: n\n        });\n      }\n    case h.StopDragging:\n      return Object.assign(Object.assign({}, e), {\n        isDragging: !1\n      });\n    case h.CalculateSizes:\n      {\n        const {\n            direction: n,\n            gutterIdx: i\n          } = t.payload,\n          r = e.pairs[i],\n          a = c(n, r.parent);\n        if (!a) throw new Error(\"Cannot calculate sizes - 'pair.parent' has undefined or zero size.\");\n        const o = r.gutter[n === z.Horizontal ? \"clientWidth\" : \"clientHeight\"],\n          g = 0 === i,\n          d = i === e.pairs.length - 1,\n          {\n            aGutterSize: s,\n            bGutterSize: l\n          } = p(o, g, d);\n        let u, h, f, _, b;\n        return n === z.Horizontal ? (u = r.a.getBoundingClientRect().left, h = r.b.getBoundingClientRect().right, _ = (r.a.getBoundingClientRect().width + s) / a * 100, b = (r.b.getBoundingClientRect().width + l) / a * 100, f = r.a.getBoundingClientRect().width + s + l + r.b.getBoundingClientRect().width) : (u = r.a.getBoundingClientRect().top, h = r.b.getBoundingClientRect().bottom, _ = (r.a.getBoundingClientRect().height + s) / a * 100, b = (r.b.getBoundingClientRect().height + l) / a * 100, f = r.a.getBoundingClientRect().height + s + l + r.b.getBoundingClientRect().height), e.pairs[i] = Object.assign(Object.assign({}, r), {\n          start: u,\n          end: h,\n          size: f,\n          aSizePct: _,\n          bSizePct: b,\n          gutterSize: o\n        }), Object.assign({}, e);\n      }\n    default:\n      return e;\n  }\n}\nfunction _(e, t = 0, n = []) {\n  return r.toArray(e).reduce((e, i, r) => (s(i) ? e.push.apply(e, _(i.props.children, t + 1, n.concat(i.key || r))) : a(i) ? e.push(o(i, {\n    key: n.concat(String(i.key)).join(\".\")\n  })) : \"string\" != typeof i && \"number\" != typeof i || e.push(i), e), []);\n}\n!function (e) {\n  e[e.SetIsReadyToCompute = 0] = \"SetIsReadyToCompute\", e[e.CreatePairs = 1] = \"CreatePairs\", e[e.CalculateSizes = 2] = \"CalculateSizes\", e[e.StartDragging = 3] = \"StartDragging\", e[e.StopDragging = 4] = \"StopDragging\";\n}(h || (h = {}));\nconst b = e => \"changedTouches\" in e;\nvar z, w;\n!function (e) {\n  e.Horizontal = \"Horizontal\", e.Vertical = \"Vertical\";\n}(z || (z = {})), function (e) {\n  e.Light = \"Light\", e.Dark = \"Dark\";\n}(w || (w = {}));\nconst C = \"undefined\" != typeof window && \"ontouchstart\" in window;\nfunction y(e) {\n  return e === z.Horizontal ? \"col-resize\" : \"row-resize\";\n}\nconst S = {\n  isReady: !1,\n  isDragging: !1,\n  pairs: []\n};\nfunction m({\n  direction: r = z.Horizontal,\n  minWidths: a = [],\n  minHeights: o = [],\n  initialSizes: s,\n  gutterTheme: m = w.Dark,\n  gutterClassName: x,\n  draggerClassName: k,\n  children: v,\n  onResizeStarted: R,\n  onResizeFinished: B,\n  classes: D = []\n}) {\n  const I = _(v),\n    [E, H] = g(f, S),\n    j = d(null),\n    O = d([]),\n    N = d([]);\n  O.current = [], N.current = [];\n  const P = n.useCallback(e => {\n      H({\n        type: h.SetIsReadyToCompute,\n        payload: {\n          isReady: e\n        }\n      });\n    }, []),\n    T = n.useCallback((e, t) => {\n      H({\n        type: h.StartDragging,\n        payload: {\n          gutterIdx: t\n        }\n      });\n      const n = E.pairs[t];\n      null == R || R(n.idx), n.a.style.userSelect = \"none\", n.b.style.userSelect = \"none\", n.gutter.style.cursor = y(e), n.parent.style.cursor = y(e), document.body.style.cursor = y(e);\n    }, [E.pairs]),\n    $ = n.useCallback(() => {\n      H({\n        type: h.StopDragging\n      });\n      const e = [];\n      for (let t = 0; t < E.pairs.length; t++) {\n        const n = E.pairs[t],\n          i = c(r, n.parent);\n        if (void 0 === i) throw new Error(\"Cannot call the 'onResizeFinished' callback - parentSize is undefined\");\n        if (void 0 === n.gutterSize) throw new Error(\"Cannot call 'onResizeFinished' callback - gutterSize is undefined\");\n        const a = 0 === t,\n          o = t === E.pairs.length - 1,\n          g = n.a.getBoundingClientRect()[r === z.Horizontal ? \"width\" : \"height\"],\n          {\n            aGutterSize: d,\n            bGutterSize: s\n          } = p(n.gutterSize, a, o),\n          l = (g + d) / i * 100;\n        if (e.push(l), o) {\n          const t = (n.b.getBoundingClientRect()[r === z.Horizontal ? \"width\" : \"height\"] + s) / i * 100;\n          e.push(t);\n        }\n      }\n      if (void 0 === E.draggingIdx) throw new Error(\"Could not reset cursor and user-select because 'state.draggingIdx' is undefined\");\n      const t = E.pairs[E.draggingIdx];\n      null == B || B(t.idx, e), t.a.style.userSelect = \"\", t.b.style.userSelect = \"\", t.gutter.style.cursor = \"\", t.parent.style.cursor = \"\", document.body.style.cursor = \"\";\n    }, [E.draggingIdx, E.pairs, r]),\n    F = n.useCallback((e, t) => {\n      H({\n        type: h.CalculateSizes,\n        payload: {\n          direction: e,\n          gutterIdx: t\n        }\n      });\n    }, []),\n    G = n.useCallback((e, t, n) => {\n      H({\n        type: h.CreatePairs,\n        payload: {\n          direction: e,\n          children: t,\n          gutters: n\n        }\n      });\n    }, []),\n    L = n.useCallback((e, t, n, i) => {\n      const r = t[0].parentNode;\n      if (!r) throw new Error(\"Cannot set initial sizes - parent is undefined\");\n      if (void 0 === c(e, r)) throw new Error(\"Cannot set initial sizes - parent has undefined size\");\n      t.forEach((r, a) => {\n        const o = a === t.length - 1;\n        let g;\n        if (t.length > 1) {\n          n[o ? a - 1 : a].getBoundingClientRect()[e === z.Horizontal ? \"width\" : \"height\"];\n        }\n        g = i && a < i.length ? `calc(${i[a]}% - 0px)` : `calc(${100 / t.length}% - 0px)`, e === z.Horizontal ? (r.style.width = g, r.style.height = \"100%\") : (r.style.height = g, r.style.width = \"100%\");\n      });\n    }, []),\n    V = n.useCallback((e, t) => {\n      if (void 0 === E.draggingIdx) throw new Error(\"Cannot adjust size - 'draggingIdx' is undefined\");\n      const n = E.pairs[E.draggingIdx];\n      if (void 0 === n.size) throw new Error(\"Cannot adjust size - 'pair.size' is undefined\");\n      if (void 0 === n.gutterSize) throw new Error(\"Cannot adjust size - 'pair.gutterSize' is undefined\");\n      const i = n.aSizePct + n.bSizePct,\n        r = t / n.size * i,\n        a = i - t / n.size * i,\n        o = 0 === E.draggingIdx,\n        g = E.draggingIdx === E.pairs.length - 1,\n        {\n          aGutterSize: d,\n          bGutterSize: s\n        } = p(n.gutterSize, o, g),\n        c = `calc(${r}% - ${d}px)`,\n        l = `calc(${a}% - ${s}px)`;\n      e === z.Horizontal ? (n.a.style.width = c, n.b.style.width = l) : (n.a.style.height = c, n.b.style.height = l);\n    }, [E.draggingIdx, E.pairs, r]),\n    A = n.useCallback((e, t, n) => {\n      if (!E.isDragging) return;\n      if (void 0 === E.draggingIdx) throw new Error(\"Cannot drag - 'draggingIdx' is undefined\");\n      const i = E.pairs[E.draggingIdx];\n      if (void 0 === i.start) throw new Error(\"Cannot drag - 'pair.start' is undefined\");\n      if (void 0 === i.size) throw new Error(\"Cannot drag - 'pair.size' is undefined\");\n      if (void 0 === i.gutterSize) throw new Error(\"Cannot drag - 'pair.gutterSize' is undefined\");\n      let r = function (e, t) {\n          const n = b(t) ? t.changedTouches[0] : t;\n          return e === z.Horizontal ? n.clientX : n.clientY;\n        }(t, e) - i.start,\n        a = 16,\n        o = 16;\n      n.length > E.draggingIdx && (a = n[E.draggingIdx]), n.length >= E.draggingIdx + 1 && (o = n[E.draggingIdx + 1]), r < i.gutterSize + a && (r = i.gutterSize + a), r >= i.size - (i.gutterSize + o) && (r = i.size - (i.gutterSize + o)), V(t, r);\n    }, [E.isDragging, E.draggingIdx, E.pairs, V]);\n  const W = () => {\n      if (E.isDragging) {\n        if (void 0 === E.draggingIdx) throw new Error(\"Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined\");\n        F(r, E.draggingIdx), $();\n      }\n    },\n    M = e => {\n      E.isDragging && (b(e) && e.preventDefault(), A(e, r, r === z.Horizontal ? a : o));\n    };\n  function X(e, t) {\n    if (!e.current) throw new Error(\"Can't add element to ref object - ref isn't initialized\");\n    t && !e.current.includes(t) && e.current.push(t);\n  }\n  return l(\"mouseup\", W, [E.isDragging, $]), l(\"mousemove\", M, [r, E.isDragging, A, a, o]), l(\"touchend\", W, [E.isDragging, $], {\n    condition: C\n  }), l(\"touchmove\", M, [r, E.isDragging, A, a, o], {\n    condition: C,\n    passive: !C\n  }), i(function () {\n    if (!j.current) return;\n    const e = j.current.parentElement;\n    if (!e) return;\n    const t = new ResizeObserver(() => {\n      const t = getComputedStyle(e),\n        n = r === z.Horizontal ? e.clientWidth : e.clientHeight;\n      P(!!t && !!n);\n    });\n    return t.observe(e), () => {\n      t.disconnect();\n    };\n  }, [j.current, r]), i(function () {\n    if (E.isReady) {\n      if (!O.current || !N.current) throw new Error(\"Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined\");\n      I.length <= 1 ? L(r, O.current, N.current, s) : (L(r, O.current, N.current, s), G(r, O.current, N.current));\n    }\n  }, [v, E.isReady, r, L, G, s]), e(\"div\", Object.assign({\n    className: `__dbk__container ${r}`,\n    ref: j\n  }, {\n    children: E.isReady && I.map((i, a) => t(n.Fragment, {\n      children: [e(\"div\", Object.assign({\n        ref: e => X(O, e),\n        className: \"__dbk__child-wrapper \" + (a < D.length ? D[a] : \"\")\n      }, {\n        children: i\n      }), void 0), a < I.length - 1 && e(u, {\n        ref: e => X(N, e),\n        className: x,\n        theme: m,\n        draggerClassName: k,\n        direction: r,\n        onDragging: () => {\n          return F(r, e = a), void T(r, e);\n          var e;\n        }\n      }, void 0)]\n    }, a))\n  }), void 0);\n}\nexport { w as GutterTheme, z as SplitDirection, m as default, C as isTouchDevice };","map":{"version":3,"names":["c","e","t","n","getComputedStyle","i","z","Horizontal","clientWidth","clientHeight","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","l","r","condition","a","o","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","length","propertyIsEnumerable","window","addEventListener","removeEventListener","insertAt","document","head","getElementsByTagName","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","u","forwardRef","className","theme","draggerClassName","direction","Vertical","onDragging","g","d","assign","ref","dir","onMouseDown","onTouchStart","C","children","h","p","aGutterSize","bGutterSize","f","SetIsReadyToCompute","isReady","payload","CreatePairs","gutters","parentNode","Error","forEach","s","getBoundingClientRect","left","top","right","bottom","width","height","idx","b","gutter","parent","start","end","size","gutterSize","aSizePct","bSizePct","push","pairs","StartDragging","gutterIdx","isDragging","draggingIdx","StopDragging","CalculateSizes","_","toArray","reduce","apply","props","concat","key","String","join","w","Light","Dark","y","S","m","minWidths","minHeights","initialSizes","gutterTheme","gutterClassName","x","k","v","onResizeStarted","R","onResizeFinished","B","classes","D","I","E","H","j","O","N","current","P","useCallback","T","style","userSelect","cursor","body","$","F","G","L","V","A","changedTouches","clientX","clientY","W","onStopDragging","M","preventDefault","X","includes","passive","parentElement","ResizeObserver","observe","disconnect","map","Fragment","GutterTheme","SplitDirection","default","isTouchDevice"],"sources":["/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/utils/getInnerSize.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/useEventListener.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/node_modules/style-inject/dist/style-inject.es.js","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/Gutter.tsx","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/state/reducer.actions.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/utils/getGutterSize.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/state/reducer.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/utils/flattenChildren.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/utils/isTouchEvent.ts","/home/bryanli/Sunscreen/Sunscreen/fhe-debugger/fhe-debugger-frontend/node_modules/@devbookhq/splitter/src/index.tsx"],"sourcesContent":["import { SplitDirection } from '../index';\n\nexport default function getInnerSize(direction: SplitDirection, element: HTMLElement) {\n  // Returns undefined if parent element has no layout yet.\n  // Or if the parent has no size.\n\n  const computedStyle = getComputedStyle(element);\n  if (!computedStyle) return;\n\n  let size = direction === SplitDirection.Horizontal ? element.clientWidth : element.clientHeight;\n\n  if (size === 0) return;\n\n  if (direction === SplitDirection.Horizontal) {\n    size -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  } else {\n    size -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  }\n\n  return size;\n}\n","import { useEffect } from 'react';\n\ninterface UseAddEventListenerOptions extends AddEventListenerOptions {\n  condition: boolean;\n}\n\nfunction useEventListener(event: string, handler: (event: any) => void, deps: any[] = [], useAddEventListenerOptions: UseAddEventListenerOptions = { condition: true }) {\n  const { condition, ...addEventListenerOptions } = useAddEventListenerOptions\n  useEffect(() => {\n    if (condition) {\n      window.addEventListener(event, handler, addEventListenerOptions);\n    }\n    return () => {\n      if (condition) {\n        window.removeEventListener(event, handler)\n      }\n    };\n\n// eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [event, handler, condition, ...deps]);\n}\n\nexport default useEventListener;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React from 'react';\nimport type { MouseEvent, TouchEvent } from 'react';\nimport { SplitDirection, GutterTheme, isTouchDevice } from './index';\n\ninterface GutterProps {\n  className?: string;\n  theme: GutterTheme;\n  draggerClassName?: string;\n  direction?: SplitDirection;\n  onDragging?: (e: MouseEvent | TouchEvent) => void;\n}\n\nconst Gutter = React.forwardRef<HTMLDivElement, GutterProps>((\n  {\n    className,\n    theme,\n    draggerClassName,\n    direction = SplitDirection.Vertical,\n    onDragging,\n  },\n  ref,\n) => {\n  const containerClass = `__dbk__gutter ${direction} ${className || theme}`;\n  const draggerClass = `__dbk__dragger ${direction} ${draggerClassName || theme}`;\n\n  return (\n    <div\n      className={containerClass}\n      ref={ref}\n      dir={direction}\n      onMouseDown={onDragging}\n      onTouchStart={isTouchDevice ? onDragging : undefined}\n    >\n      <div className={draggerClass}/>\n    </div>\n  );\n});\n\nexport default Gutter;\n\n","import type { SplitDirection } from 'index';\n\nexport enum ActionType {\n  SetIsReadyToCompute,\n  CreatePairs,\n  CalculateSizes,\n  StartDragging,\n  StopDragging,\n}\n\nexport interface SetIsReadyToCompute {\n  type: ActionType.SetIsReadyToCompute;\n  payload: {\n    isReady: boolean,\n  };\n}\n\nexport interface CreatePairs {\n  type: ActionType.CreatePairs;\n  payload: {\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n  };\n}\n\nexport interface CalculateSizes {\n  type: ActionType.CalculateSizes;\n  payload: {\n    direction: SplitDirection,\n    gutterIdx: number;\n  };\n}\n\nexport interface StartDragging {\n  type: ActionType.StartDragging;\n  payload: {\n    gutterIdx: number;\n  };\n}\n\ninterface StopDragging {\n  type: ActionType.StopDragging;\n}\n\nexport type Action = SetIsReadyToCompute\n  | CreatePairs\n  | CalculateSizes\n  | StartDragging\n  | StopDragging;\n\n\n","export default function getGutterSizes(gutterSize: number, isFirst: boolean, isLast: boolean) {\n  let aGutterSize: number;\n  let bGutterSize: number;\n\n  if (isFirst) {\n    aGutterSize = gutterSize / 2;\n    bGutterSize = gutterSize;\n  } else if (isLast) {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize / 2;\n  } else {\n    aGutterSize = gutterSize;\n    bGutterSize = gutterSize;\n  }\n\n  return { aGutterSize, bGutterSize };\n};\n","import { SplitDirection } from '../index';\nimport { Action, ActionType } from './reducer.actions';\nimport Pair from '../pair';\n\nimport getInnerSize from '../utils/getInnerSize';\nimport getGutterSizes from '../utils/getGutterSize';\n\nexport interface State {\n  isReady: boolean;\n\n  isDragging: boolean;\n  draggingIdx?: number; // Index of a gutter that is being dragged.\n\n  pairs: Pair[];\n}\n\nexport default function reducer(state: State, action: Action) {\n  switch (action.type) {\n    case ActionType.SetIsReadyToCompute: {\n      return {\n        ...state,\n        isReady: action.payload.isReady,\n      }\n    }\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    case ActionType.CreatePairs: {\n      const { direction, children, gutters } = action.payload;\n\n      // All children must have common parent.\n      const parent = children[0].parentNode;\n      if (!parent) throw new Error(`Cannot create pairs - parent is undefined.`);\n      const parentSize = getInnerSize(direction, parent as HTMLElement);\n      if (parentSize === undefined) throw new Error(`Cannot create pairs - parent has undefined or zero size: ${parentSize}.`);\n\n      const pairs: Pair[] = [];\n      children.forEach((_, idx) => {\n        if (idx > 0) {\n          const a = children[idx-1];\n          const b = children[idx];\n          const gutter = gutters[idx-1];\n\n          const start = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().left\n            : a.getBoundingClientRect().top;\n\n          const end = direction === SplitDirection.Horizontal\n            ? b.getBoundingClientRect().right\n            : b.getBoundingClientRect().bottom;\n\n          const size = direction === SplitDirection.Horizontal\n            ? a.getBoundingClientRect().width + gutter.getBoundingClientRect().width + b.getBoundingClientRect().width\n            : a.getBoundingClientRect().height + gutter.getBoundingClientRect().height + b.getBoundingClientRect().height\n\n          const gutterSize = direction === SplitDirection.Horizontal\n            ? gutter.getBoundingClientRect().width\n            : gutter.getBoundingClientRect().height;\n\n          const pair: Pair = {\n            idx: idx-1,\n            // TODO: Do we need to have a reference to the whole elements? Aren't indexes enough?\n            a,\n            b,\n            gutter,\n            parent: parent as HTMLElement,\n            start,\n            end,\n            size,\n            gutterSize,\n            // At the start, all elements has the same width.\n            aSizePct: 100 / children.length,\n            bSizePct: 100 / children.length,\n          };\n\n          pairs.push(pair);\n        }\n      });\n\n      return {\n        ...state,\n        pairs,\n      };\n    }\n    case ActionType.StartDragging: {\n      const { gutterIdx } = action.payload;\n      return {\n        ...state,\n        isDragging: true,\n        draggingIdx: gutterIdx,\n      };\n    }\n    case ActionType.StopDragging: {\n      return {\n        ...state,\n        isDragging: false,\n      };\n    }\n    // Recalculates the stored sizes based on the actual elements' sizes.\n    case ActionType.CalculateSizes: {\n      // We need to calculate sizes only for the pair\n      // that has the moved gutter.\n      const { direction, gutterIdx } = action.payload;\n      const pair = state.pairs[gutterIdx];\n\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (!parentSize) throw new Error(`Cannot calculate sizes - 'pair.parent' has undefined or zero size.`);\n\n      const gutterSize = pair.gutter[direction === SplitDirection.Horizontal ? 'clientWidth' : 'clientHeight'];\n\n      const isFirst = gutterIdx === 0;\n      const isLast = gutterIdx === state.pairs.length - 1;\n      const { aGutterSize, bGutterSize } = getGutterSizes(gutterSize, isFirst, isLast);\n\n      let start: number;\n      let end: number;\n      let size: number;\n      let aSizePct: number;\n      let bSizePct: number;\n\n      if (direction === SplitDirection.Horizontal) {\n        start = pair.a.getBoundingClientRect().left;\n\n        end = pair.b.getBoundingClientRect().right;\n\n        aSizePct = ((pair.a.getBoundingClientRect().width + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().width + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().width +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().width;\n      } else {\n        start = pair.a.getBoundingClientRect().top;\n\n        end = pair.b.getBoundingClientRect().bottom;\n\n        aSizePct = ((pair.a.getBoundingClientRect().height + aGutterSize) / parentSize) * 100;\n        bSizePct = ((pair.b.getBoundingClientRect().height + bGutterSize) / parentSize) * 100;\n\n        size =\n          pair.a.getBoundingClientRect().height +\n          aGutterSize +\n          bGutterSize +\n          pair.b.getBoundingClientRect().height;\n      }\n\n      state.pairs[gutterIdx] = {\n        ...pair,\n        start,\n        end,\n        size,\n        aSizePct,\n        bSizePct,\n        gutterSize,\n      };\n\n      return {\n        ...state\n      };\n    }\n    default:\n      return state;\n  }\n}\n\n","// Taken from https://github.com/grrowl/react-keyed-flatten-children\n\n/* Returns React children into an array, flattening fragments. */\nimport {\n  ReactNode,\n  ReactChild,\n  Children,\n  isValidElement,\n  cloneElement\n} from 'react';\nimport { isFragment } from 'react-is';\n\nexport default function flattenChildren(\n  children: ReactNode,\n  depth: number = 0,\n  keys: (string | number)[] = []\n): ReactChild[] {\n  return Children.toArray(children).reduce(\n    (acc: ReactChild[], node, nodeIndex) => {\n      if (isFragment(node)) {\n        acc.push.apply(\n          acc,\n          flattenChildren(\n            node.props.children,\n            depth + 1,\n            keys.concat(node.key || nodeIndex)\n          )\n        );\n      } else {\n        if (isValidElement(node)) {\n          acc.push(\n            cloneElement(node, {\n              key: keys.concat(String(node.key)).join('.')\n            })\n          );\n        } else if (typeof node === 'string' || typeof node === 'number') {\n          acc.push(node);\n        }\n      }\n      return acc;\n    },\n    []\n  );\n}\n","import type { MouseEvent, TouchEvent } from 'react';\n\nexport const isTouchEvent = (e: MouseEvent | TouchEvent): e is TouchEvent => {\n  return 'changedTouches' in e\n}\n","import React, {\n  useEffect,\n  useReducer,\n  useRef,\n} from 'react';\nimport type { MouseEvent, TouchEvent } from 'react';\n\nimport './index.css';\nimport getInnerSize from './utils/getInnerSize';\nimport useEventListener from './useEventListener';\nimport Gutter from './Gutter';\nimport { ActionType } from './state/reducer.actions';\nimport reducer, { State } from './state/reducer';\nimport getGutterSizes from './utils/getGutterSize';\nimport flattenChildren from './utils/flattenChildren';\nimport { isTouchEvent } from 'utils/isTouchEvent';\n\nexport enum SplitDirection {\n  Horizontal = 'Horizontal',\n  Vertical = 'Vertical',\n}\n\nexport enum GutterTheme {\n  Light = 'Light',\n  Dark = 'Dark',\n}\n\nconst DefaultMinSize = 16;\n\nexport const isTouchDevice = typeof window !== 'undefined' && 'ontouchstart' in window;\n\n// users touch or mouse position\nfunction getPosition(dir: SplitDirection, e: MouseEvent | TouchEvent) {\n  const targetsValueRef = isTouchEvent(e) ? e.changedTouches[0] : e;\n  if (dir === SplitDirection.Horizontal) return targetsValueRef.clientX;\n  return targetsValueRef.clientY;\n}\n\nfunction getCursorIcon(dir: SplitDirection) {\n  if (dir === SplitDirection.Horizontal) return 'col-resize';\n  return 'row-resize';\n}\n\n/*\nconst stateInit: State = (direction: SplitDirection = SplitDirection.Horizontal) => ({\n  direction,\n  isDragging: false,\n  pairs: [],\n});\n*/\n\nconst initialState: State = {\n  isReady: false,\n  isDragging: false,\n  pairs: [],\n}\n\ninterface SplitProps {\n  direction?: SplitDirection;\n  minWidths?: number[]; // In pixels.\n  minHeights?: number[]; // In pixels.\n  initialSizes?: number[]; // In percentage.\n  gutterTheme?: GutterTheme;\n  gutterClassName?: string;\n  draggerClassName?: string;\n  children?: React.ReactNode;\n  onResizeStarted?: (pairIdx: number) => void;\n  onResizeFinished?: (pairIdx: number, newSizes: number[]) => void;\n  classes?: string[];\n}\n\nfunction Split({\n  direction = SplitDirection.Horizontal,\n  minWidths = [],\n  minHeights = [],\n  initialSizes,\n  gutterTheme = GutterTheme.Dark,\n  gutterClassName,\n  draggerClassName,\n  children: reactChildren,\n  onResizeStarted,\n  onResizeFinished,\n  classes = [],\n}: SplitProps) {\n  const children = flattenChildren(reactChildren)\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const containerRef = useRef<HTMLDivElement>(null)\n  const childRefs = useRef<HTMLElement[]>([]);\n  const gutterRefs = useRef<HTMLElement[]>([]);\n  // We want to reset refs on each re-render so they don't contain old references.\n  childRefs.current = [];\n  gutterRefs.current = [];\n\n  // Helper dispatch functions.\n  const setIsReadyToCompute = React.useCallback((isReady: boolean) => {\n    dispatch({\n      type: ActionType.SetIsReadyToCompute,\n      payload: { isReady },\n    })\n  }, [])\n\n  const startDragging = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.StartDragging,\n      payload: { gutterIdx },\n    });\n\n    const pair = state.pairs[gutterIdx];\n    onResizeStarted?.(pair.idx)\n\n    // Disable selection.\n    pair.a.style.userSelect = 'none';\n    pair.b.style.userSelect = 'none';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, nut just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = getCursorIcon(direction);\n    pair.parent.style.cursor = getCursorIcon(direction);\n    document.body.style.cursor = getCursorIcon(direction);\n  }, [state.pairs]);\n\n  const stopDragging = React.useCallback(() => {\n    dispatch({\n      type: ActionType.StopDragging,\n    });\n\n    // The callback receives an index of the resized pair and new sizes of all child elements.\n    const allSizes: number[] = [];\n    for (let idx = 0; idx < state.pairs.length; idx++) {\n      const pair = state.pairs[idx];\n      const parentSize = getInnerSize(direction, pair.parent);\n      if (parentSize === undefined) throw new Error(`Cannot call the 'onResizeFinished' callback - parentSize is undefined`);\n      if (pair.gutterSize === undefined) throw new Error(`Cannot call 'onResizeFinished' callback - gutterSize is undefined`);\n\n      const isFirst = idx === 0;\n      const isLast = idx === state.pairs.length - 1;\n\n      const aSize = pair.a.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n      const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n      const aSizePct = ((aSize + aGutterSize) / parentSize) * 100;\n      allSizes.push(aSizePct);\n\n      if (isLast) {\n        const bSize = pair.b.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        const bSizePct = ((bSize + bGutterSize) / parentSize) * 100;\n        allSizes.push(bSizePct);\n      }\n    }\n\n    if (state.draggingIdx === undefined) throw new Error(`Could not reset cursor and user-select because 'state.draggingIdx' is undefined`);\n    const pair = state.pairs[state.draggingIdx];\n    onResizeFinished?.(pair.idx, allSizes);\n\n    // Disable selection.\n    pair.a.style.userSelect = '';\n    pair.b.style.userSelect = '';\n\n    // Set the mouse cursor.\n    // Must be done at multiple levels, not just for a gutter.\n    // The mouse cursor might move outside of the gutter element.\n    pair.gutter.style.cursor = '';\n    pair.parent.style.cursor = '';\n    document.body.style.cursor = '';\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const calculateSizes = React.useCallback((direction: SplitDirection, gutterIdx: number) => {\n    dispatch({\n      type: ActionType.CalculateSizes,\n      payload: { direction, gutterIdx },\n    });\n  }, []);\n\n  const createPairs = React.useCallback((direction: SplitDirection, children: HTMLElement[], gutters: HTMLElement[]) => {\n    dispatch({\n      type: ActionType.CreatePairs,\n      payload: { direction, children, gutters },\n    });\n  }, []);\n  /////////\n\n  // This method is called on the initial render.\n  // It iterates through the all children sets their initial sizes.\n  const setInitialSizes = React.useCallback((\n    direction: SplitDirection,\n    children: HTMLElement[],\n    gutters: HTMLElement[],\n    initialSizes?: number[],\n  ) => {\n    // All children must have common parent.\n    const parent = children[0].parentNode;\n    if (!parent) throw new Error(`Cannot set initial sizes - parent is undefined`);\n    const parentSize = getInnerSize(direction, parent as HTMLElement);\n    if (parentSize === undefined) throw new Error(`Cannot set initial sizes - parent has undefined size`);\n\n    children.forEach((c, idx) => {\n      const isFirst = idx === 0;\n      const isLast = idx === children.length - 1;\n\n      let gutterSize = 0\n      if (children.length > 1) {\n        const gutter = gutters[isLast ? idx-1 : idx];\n        let gutterSize = gutter.getBoundingClientRect()[direction === SplitDirection.Horizontal ? 'width' : 'height'];\n        gutterSize = isFirst || isLast ? gutterSize / 2 : gutterSize;\n      }\n\n      let calc: string;\n      if (initialSizes && idx < initialSizes.length)  {\n        calc = `calc(${initialSizes[idx]}% - ${gutterSize}px)`;\n      } else {\n        // '100 / children.length' makes all the children same wide.\n        calc = `calc(${100 / children.length}% - ${gutterSize}px)`;\n      }\n\n      if (direction === SplitDirection.Horizontal) {\n        c.style.width = calc;\n        // Reset the child wrapper's height because the direction could have changed.\n        c.style.height = '100%';\n      } else {\n        c.style.height = calc;\n        // Reset the child wrapper's width because the direction could have changed.\n        c.style.width = '100%';\n      }\n    });\n  }, []);\n\n  // Here we actually change the width of children.\n  // We convert the element's sizes into percentage\n  // and let the CSS 'calc' function do the heavy lifting.\n  // Size of 'pair.a' is same as 'offset'.\n  //\n  // For just 2 children total, the percentage adds up always to 100.\n  // For >2 children total, the percentage adds to less than 100.\n  // That's because a single gutter changes sizes of only the given pair of children.\n  // Each gutter changes size only of the two adjacent elements.\n  // -----------------------------------------------------------------------\n  // |                     |||                     |||                     |\n  // |       33.3%         |||        33.3%        |||       33.3%         |\n  // |                     |||                     |||                     |\n  // |                     |||                     |||                     |\n  // -----------------------------------------------------------------------\n  const adjustSize = React.useCallback((direction: SplitDirection, offset: number) => {\n    if (state.draggingIdx === undefined) throw new Error(`Cannot adjust size - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.size === undefined) throw new Error(`Cannot adjust size - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot adjust size - 'pair.gutterSize' is undefined`);\n    const percentage = pair.aSizePct + pair.bSizePct;\n\n    const aSizePct = (offset / pair.size) * percentage;\n    const bSizePct = percentage - (offset / pair.size) * percentage;\n\n    const isFirst = state.draggingIdx === 0;\n    const isLast = state.draggingIdx === state.pairs.length - 1;\n    const { aGutterSize, bGutterSize } = getGutterSizes(pair.gutterSize, isFirst, isLast);\n\n    const aCalc = `calc(${aSizePct}% - ${aGutterSize}px)`;\n    const bCalc = `calc(${bSizePct}% - ${bGutterSize}px)`;\n    if (direction === SplitDirection.Horizontal) {\n      pair.a.style.width = aCalc;\n      pair.b.style.width = bCalc;\n    } else {\n      pair.a.style.height = aCalc;\n      pair.b.style.height = bCalc;\n    }\n  }, [state.draggingIdx, state.pairs, direction]);\n\n  const drag = React.useCallback((e: MouseEvent | TouchEvent, direction: SplitDirection, minSizes: number[]) => {\n    if (!state.isDragging) return\n    if (state.draggingIdx === undefined) throw new Error(`Cannot drag - 'draggingIdx' is undefined`);\n\n    const pair = state.pairs[state.draggingIdx];\n    if (pair.start === undefined) throw new Error(`Cannot drag - 'pair.start' is undefined`);\n    if (pair.size === undefined) throw new Error(`Cannot drag - 'pair.size' is undefined`);\n    if (pair.gutterSize === undefined) throw new Error(`Cannot drag - 'pair.gutterSize' is undefined`);\n\n    // 'offset' is the width of the 'a' element in a pair.\n    let offset = getPosition(direction, e) - pair.start;\n\n    // Limit the maximum size and the minimum size of resized children.\n\n    let aMinSize = DefaultMinSize;\n    let bMinSize = DefaultMinSize;\n    if (minSizes.length > state.draggingIdx) {\n      aMinSize = minSizes[state.draggingIdx];\n    }\n    if (minSizes.length >= state.draggingIdx + 1) {\n      bMinSize = minSizes[state.draggingIdx + 1];\n    }\n\n    // TODO: We should check whether the parent is big enough\n    // to support these min sizes.\n    if (offset < pair.gutterSize + aMinSize) {\n      offset = pair.gutterSize + aMinSize;\n    }\n\n    if (offset >= pair.size - (pair.gutterSize + bMinSize)) {\n      offset = pair.size - (pair.gutterSize + bMinSize);\n    }\n\n    adjustSize(direction, offset);\n  }, [state.isDragging, state.draggingIdx, state.pairs, adjustSize]);\n\n  function handleStartDragging(gutterIdx: number) {\n    calculateSizes(direction, gutterIdx);\n    startDragging(direction, gutterIdx);\n  }\n\n  const onStopDragging = () => {\n    if (!state.isDragging) return;\n    if (state.draggingIdx === undefined)\n      throw new Error(`Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined`);\n    calculateSizes(direction, state.draggingIdx);\n    stopDragging();\n  };\n\n  const onMove = (e: MouseEvent | TouchEvent) => {\n    if (!state.isDragging) return;\n    if (isTouchEvent(e)) {\n      // touch event also scrolls the page, so we need to prevent that\n      e.preventDefault();\n    }\n    drag(e, direction, direction === SplitDirection.Horizontal ? minWidths : minHeights);\n  };\n\n  useEventListener(\"mouseup\", onStopDragging, [state.isDragging, stopDragging]);\n  useEventListener(\"mousemove\", onMove, [direction, state.isDragging, drag, minWidths, minHeights]);\n\n  useEventListener(\"touchend\", onStopDragging, [state.isDragging, stopDragging], { condition: isTouchDevice });\n  useEventListener(\"touchmove\", onMove, [direction, state.isDragging, drag, minWidths, minHeights], { condition: isTouchDevice, passive: !isTouchDevice });\n\n  // This makes sure that Splitter properly re-renders if parent's size changes dynamically.\n  useEffect(function watchParentSize() {\n    if (!containerRef.current) return\n    const el = containerRef.current.parentElement\n\n    // Splitter must have a parent element. In the most trivial example it's either <body> or <html>.\n    if (!el) return\n\n    // TODO: Potential performance issue!\n    // When nesting Splitters the `observer` is registered for each nesting \"level\".\n    // Splitter's parent element is another Splitter in the nesting use case.\n    const observer = new ResizeObserver(() => {\n      const style = getComputedStyle(el)\n      const size = direction === SplitDirection.Horizontal ? el.clientWidth : el.clientHeight\n      const isReady = !!style && !!size\n      setIsReadyToCompute(isReady)\n    })\n    observer.observe(el)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [\n    containerRef.current,\n    direction,\n  ])\n\n  // Initial setup, runs every time the child views change.\n  useEffect(function initialSetup() {\n    if (!state.isReady) return\n    // By the time first useEffect runs refs should be already set, unless something really bad happened.\n    if (!childRefs.current || !gutterRefs.current) {\n      throw new Error(`Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined`);\n    }\n\n    // Don't create pairs if there's only one child.\n    if (children.length <= 1) {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n    } else {\n      setInitialSizes(direction, childRefs.current, gutterRefs.current, initialSizes);\n      createPairs(direction, childRefs.current, gutterRefs.current);\n    }\n\n  }, [\n    reactChildren,\n    state.isReady,\n    direction,\n    setInitialSizes,\n    createPairs,\n    initialSizes,\n  ]);\n\n  function addRef(refs: typeof childRefs | typeof gutterRefs, el: any) {\n    if (!refs.current) throw new Error(`Can't add element to ref object - ref isn't initialized`);\n    if (el && !refs.current.includes(el)) {\n      refs.current.push(el);\n    }\n  }\n\n  return (\n    <div\n      className={'__dbk__container ' + `${direction}`}\n      ref={containerRef}\n    >\n      {state.isReady && children.map((c, idx) => (\n        <React.Fragment key={idx}>\n          <div\n            ref={el => addRef(childRefs, el)}\n            className={'__dbk__child-wrapper ' + (idx < classes.length ? classes[idx] : '')}\n          >{c}\n          </div>\n\n          {/* Gutter is between each two child views. */}\n          {idx < (children as React.ReactNodeArray).length - 1 &&\n            <Gutter\n              ref={el => addRef(gutterRefs, el)}\n              className={gutterClassName}\n              theme={gutterTheme}\n              draggerClassName={draggerClassName}\n              direction={direction}\n              onDragging={() => handleStartDragging(idx)}\n            />\n          }\n        </React.Fragment>\n      ))}\n    </div>\n  );\n}\n\nexport type {\n  SplitProps\n}\nexport default Split;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}