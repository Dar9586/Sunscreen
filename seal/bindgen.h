#define uint64_t unsigned long long
# 1 "__bindgen.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 450 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "__bindgen.cpp" 2
# 1 "./bindgen_wrapper.h" 1
# 1 "SEAL/native/src/seal/c/batchencoder.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////


# 1 "SEAL/native/src/seal/c/defines.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



// STD

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstddef" 1
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cstddef synopsis

Macros:

    offsetof(type,member-designator)
    NULL

namespace std
{

Types:

    ptrdiff_t
    size_t
    max_align_t // C++11
    nullptr_t
    byte // C++17

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 24 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3






// The _GNUC_VER_NEW macro better represents the new GCC versioning scheme
// introduced in GCC 5.0.
# 120 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Enable compiling copies of now inline methods into the dylib to support
// applications compiled against older libraries. This is unnecessary with
// COFF dllexport semantics, since dllexport forces a non-inline definition
// of inline functions to be emitted anyway. Our own non-inline copy would
// conflict with the dllexport-emitted copy, so we disable it.


// Feature macros for disabling pre ABI v1 features. All of these options
// are deprecated.
# 172 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// '__is_identifier' returns '0' if '__x' is a reserved identifier provided by
// the compiler and '1' otherwise.
# 205 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// FIXME: ABI detection should be done via compiler builtin macros. This
// is just a placeholder until Clang implements such macros. For now assume
// that Windows compilers pretending to be MSVC++ target the Microsoft ABI,
// and allow the user to explicitly specify the ABI to handle cases where this
// heuristic falls short.
# 228 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Need to detect which libc we're using if we're on Linux.
# 395 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
     // timespec_get and aligned_alloc were introduced in macOS 10.15 and
     // aligned releases
# 462 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Objective-C++ features (opt-in)
# 495 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Allow for build-time disabling of unsigned integer sanitization
# 514 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Literal operators ""d and ""y are supported starting with LLVM Clang 8 and AppleClang 10.0.1
# 661 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// The inline should be removed once PR32114 is resolved
# 777 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Just so we can migrate to the new macros gradually.


// Inline namespaces are available in Clang/GCC/MSVC regardless of C++ dialect.



namespace std { inline namespace __1 { } }
# 877 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// _LIBCPP_DEBUG potential values:
//  - undefined: No assertions. This is the default.
//  - 0:         Basic assertions
//  - 1:         Basic assertions + iterator validity checks.
# 891 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// _LIBCPP_DEBUG_LEVEL is always defined to one of [0, 1, 2] at this point
# 905 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// When the Debug mode is enabled, we disable extern declarations because we
// don't want to use the functions compiled in the library, which might not
// have had the debug mode enabled when built. However, some extern declarations
// need to be used, because code correctness depends on it (several instances
// in the <locale>). Those special declarations are declared with
// _LIBCPP_EXTERN_TEMPLATE_EVEN_IN_DEBUG_MODE, which is enabled even
// when the debug mode is enabled.
# 926 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Most unix variants have catopen.  These are the specific ones that don't.
# 936 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// If we are getting operator new from the MSVC CRT, then allocation overloads
// for align_val_t were added in 19.12, aka VS 2017 version 15.3.
# 973 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Deprecation macros.
//
// Deprecations warnings are always enabled, except when users explicitly opt-out
// by defining _LIBCPP_DISABLE_DEPRECATION_WARNINGS.
# 1019 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Macros to enter and leave a state where deprecation warnings are suppressed.
# 1057 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// The _LIBCPP_NODISCARD_ATTRIBUTE should only be used to define other
// NODISCARD macros to the correct attribute.
# 1070 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// _LIBCPP_NODISCARD_EXT may be used to apply [[nodiscard]] to entities not
// specified as such as an extension.
# 1110 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Try to find out if RTTI is disabled.
# 1123 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Thread API
# 1181 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// The glibc and Bionic implementation of pthreads implements
// pthread_mutex_destroy as nop for regular mutexes. Additionally, Win32
// mutexes have no destroy mechanism.
//
// This optimization can't be performed on Apple platforms, where
// pthread_mutex_destroy can allow the kernel to release resources.
// See https://llvm.org/D64298 for details.
//
// TODO(EricWF): Enable this optimization on Bionic after speaking to their
//               respective stakeholders.






// Destroying a condvar is a nop on Windows.
//
// This optimization can't be performed on Apple platforms, where
// pthread_cond_destroy can allow the kernel to release resources.
// See https://llvm.org/D64298 for details.
//
// TODO(EricWF): This is potentially true for some pthread implementations
// as well.





// Systems that use capability-based security (FreeBSD with Capsicum,
// Nuxi CloudABI) may only provide local filesystem access (using *at()).
// Functions like open(), rename(), unlink() and stat() should not be
// used, as they attempt to access the global filesystem namespace.




// CloudABI is intended for running networked services. Processes do not
// have standard input and output channels.





// Some systems do not provide gets() in their C library, for security reasons.
# 1240 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Thread-unsafe functions such as strtok() and localtime()
// are not available.
# 1319 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Use a function like macro to imply that it must be followed by a semicolon
# 1389 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
  // Don't warn about macro conflicts when we can restore them at the
  // end of the header.
# 1423 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Configures the fopen close-on-exec mode character, if any. This string will
// be appended to any mode string used by fstream for fopen/fdopen.
//
// Not all platforms support this, but it helps avoid fd-leaks on platforms that
// do.
# 1440 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 3
// Support for _FILE_OFFSET_BITS=64 landed gradually in Android, so the full set
// of functions used in cstdio may not be available for low API levels when
// using 64-bit file offsets on LP32.
# 37 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstddef" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 1
// -*- C++ -*-
//===--------------------------- version ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
  version synopsis

Macro name                                              Value   Headers
__cpp_lib_addressof_constexpr                           201603L <memory>
__cpp_lib_allocator_traits_is_always_equal              201411L <deque> <forward_list> <list>
                                                                <map> <memory> <scoped_allocator>
                                                                <set> <string> <unordered_map>
                                                                <unordered_set> <vector>
__cpp_lib_any                                           201606L <any>
__cpp_lib_apply                                         201603L <tuple>
__cpp_lib_array_constexpr                               201811L <array> <iterator>
                                                        201603L // C++17
__cpp_lib_as_const                                      201510L <utility>
__cpp_lib_assume_aligned                                201811L <memory>
__cpp_lib_atomic_flag_test                              201907L <atomic>
__cpp_lib_atomic_float                                  201711L <atomic>
__cpp_lib_atomic_is_always_lock_free                    201603L <atomic>
__cpp_lib_atomic_lock_free_type_aliases                 201907L <atomic>
__cpp_lib_atomic_ref                                    201806L <atomic>
__cpp_lib_atomic_shared_ptr                             201711L <atomic>
__cpp_lib_atomic_value_initialization                   201911L <atomic> <memory>
__cpp_lib_atomic_wait                                   201907L <atomic>
__cpp_lib_barrier                                       201907L <barrier>
__cpp_lib_bind_front                                    201907L <functional>
__cpp_lib_bit_cast                                      201806L <bit>
__cpp_lib_bitops                                        201907L <bit>
__cpp_lib_bool_constant                                 201505L <type_traits>
__cpp_lib_bounded_array_traits                          201902L <type_traits>
__cpp_lib_boyer_moore_searcher                          201603L <functional>
__cpp_lib_byte                                          201603L <cstddef>
__cpp_lib_char8_t                                       201811L <atomic> <filesystem> <istream>
                                                                <limits> <locale> <ostream>
                                                                <string> <string_view>
__cpp_lib_chrono                                        201611L <chrono>
__cpp_lib_chrono_udls                                   201304L <chrono>
__cpp_lib_clamp                                         201603L <algorithm>
__cpp_lib_complex_udls                                  201309L <complex>
__cpp_lib_concepts                                      202002L <concepts>
__cpp_lib_constexpr_algorithms                          201806L <algorithm>
__cpp_lib_constexpr_complex                             201711L <complex>
__cpp_lib_constexpr_dynamic_alloc                       201907L <memory>
__cpp_lib_constexpr_functional                          201907L <functional>
__cpp_lib_constexpr_iterator                            201811L <iterator>
__cpp_lib_constexpr_memory                              201811L <memory>
__cpp_lib_constexpr_numeric                             201911L <numeric>
__cpp_lib_constexpr_string                              201907L <string>
__cpp_lib_constexpr_string_view                         201811L <string_view>
__cpp_lib_constexpr_tuple                               201811L <tuple>
__cpp_lib_constexpr_utility                             201811L <utility>
__cpp_lib_constexpr_vector                              201907L <vector>
__cpp_lib_coroutine                                     201902L <coroutine>
__cpp_lib_destroying_delete                             201806L <new>
__cpp_lib_enable_shared_from_this                       201603L <memory>
__cpp_lib_endian                                        201907L <bit>
__cpp_lib_erase_if                                      202002L <deque> <forward_list> <list>
                                                                <map> <set> <string>
                                                                <unordered_map> <unordered_set> <vector>
__cpp_lib_exchange_function                             201304L <utility>
__cpp_lib_execution                                     201902L <execution>
                                                        201603L // C++17
__cpp_lib_filesystem                                    201703L <filesystem>
__cpp_lib_gcd_lcm                                       201606L <numeric>
__cpp_lib_generic_associative_lookup                    201304L <map> <set>
__cpp_lib_generic_unordered_lookup                      201811L <unordered_map> <unordered_set>
__cpp_lib_hardware_interference_size                    201703L <new>
__cpp_lib_has_unique_object_representations             201606L <type_traits>
__cpp_lib_hypot                                         201603L <cmath>
__cpp_lib_incomplete_container_elements                 201505L <forward_list> <list> <vector>
__cpp_lib_int_pow2                                      202002L <bit>
__cpp_lib_integer_comparison_functions                  202002L <utility>
__cpp_lib_integer_sequence                              201304L <utility>
__cpp_lib_integral_constant_callable                    201304L <type_traits>
__cpp_lib_interpolate                                   201902L <cmath> <numeric>
__cpp_lib_invoke                                        201411L <functional>
__cpp_lib_is_aggregate                                  201703L <type_traits>
__cpp_lib_is_constant_evaluated                         201811L <type_traits>
__cpp_lib_is_final                                      201402L <type_traits>
__cpp_lib_is_invocable                                  201703L <type_traits>
__cpp_lib_is_layout_compatible                          201907L <type_traits>
__cpp_lib_is_nothrow_convertible                        201806L <type_traits>
__cpp_lib_is_null_pointer                               201309L <type_traits>
__cpp_lib_is_pointer_interconvertible                   201907L <type_traits>
__cpp_lib_is_scoped_enum                                202011L <type_traits>
__cpp_lib_is_swappable                                  201603L <type_traits>
__cpp_lib_jthread                                       201911L <stop_token> <thread>
__cpp_lib_latch                                         201907L <latch>
__cpp_lib_launder                                       201606L <new>
__cpp_lib_list_remove_return_type                       201806L <forward_list> <list>
__cpp_lib_logical_traits                                201510L <type_traits>
__cpp_lib_make_from_tuple                               201606L <tuple>
__cpp_lib_make_reverse_iterator                         201402L <iterator>
__cpp_lib_make_unique                                   201304L <memory>
__cpp_lib_map_try_emplace                               201411L <map>
__cpp_lib_math_constants                                201907L <numbers>
__cpp_lib_math_special_functions                        201603L <cmath>
__cpp_lib_memory_resource                               201603L <memory_resource>
__cpp_lib_node_extract                                  201606L <map> <set> <unordered_map>
                                                                <unordered_set>
__cpp_lib_nonmember_container_access                    201411L <array> <deque> <forward_list>
                                                                <iterator> <list> <map>
                                                                <regex> <set> <string>
                                                                <unordered_map> <unordered_set> <vector>
__cpp_lib_not_fn                                        201603L <functional>
__cpp_lib_null_iterators                                201304L <iterator>
__cpp_lib_optional                                      201606L <optional>
__cpp_lib_parallel_algorithm                            201603L <algorithm> <numeric>
__cpp_lib_polymorphic_allocator                         201902L <memory>
__cpp_lib_quoted_string_io                              201304L <iomanip>
__cpp_lib_ranges                                        201811L <algorithm> <functional> <iterator>
                                                                <memory> <ranges>
__cpp_lib_raw_memory_algorithms                         201606L <memory>
__cpp_lib_remove_cvref                                  201711L <type_traits>
__cpp_lib_result_of_sfinae                              201210L <functional> <type_traits>
__cpp_lib_robust_nonmodifying_seq_ops                   201304L <algorithm>
__cpp_lib_sample                                        201603L <algorithm>
__cpp_lib_scoped_lock                                   201703L <mutex>
__cpp_lib_semaphore                                     201907L <semaphore>
__cpp_lib_shared_mutex                                  201505L <shared_mutex>
__cpp_lib_shared_ptr_arrays                             201611L <memory>
__cpp_lib_shared_ptr_weak_type                          201606L <memory>
__cpp_lib_shared_timed_mutex                            201402L <shared_mutex>
__cpp_lib_shift                                         201806L <algorithm>
__cpp_lib_smart_ptr_for_overwrite                       202002L <memory>
__cpp_lib_source_location                               201907L <source_location>
__cpp_lib_span                                          202002L <span>
__cpp_lib_ssize                                         201902L <iterator>
__cpp_lib_stacktrace                                    202011L <stacktrace>
__cpp_lib_starts_ends_with                              201711L <string> <string_view>
__cpp_lib_stdatomic_h                                   202011L <stdatomic.h>
__cpp_lib_string_contains                               202011L <string> <string_view>
__cpp_lib_string_udls                                   201304L <string>
__cpp_lib_string_view                                   201803L <string> <string_view>
                                                        201606L // C++17
__cpp_lib_syncbuf                                       201803L <syncstream>
__cpp_lib_three_way_comparison                          201907L <compare>
__cpp_lib_to_address                                    201711L <memory>
__cpp_lib_to_array                                      201907L <array>
__cpp_lib_to_chars                                      201611L <utility>
__cpp_lib_transformation_trait_aliases                  201304L <type_traits>
__cpp_lib_transparent_operators                         201510L <functional> <memory>
                                                        201210L // C++14
__cpp_lib_tuple_element_t                               201402L <tuple>
__cpp_lib_tuples_by_type                                201304L <tuple> <utility>
__cpp_lib_type_trait_variable_templates                 201510L <type_traits>
__cpp_lib_uncaught_exceptions                           201411L <exception>
__cpp_lib_unordered_map_try_emplace                     201411L <unordered_map>
__cpp_lib_unwrap_ref                                    201811L <functional>
__cpp_lib_variant                                       201606L <variant>
__cpp_lib_void_t                                        201411L <type_traits>

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 167 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 2
# 170 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 3
# 210 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 3
// # define __cpp_lib_boyer_moore_searcher                 201603L




// # define __cpp_lib_execution                            201603L


// # define __cpp_lib_hardware_interference_size           201703L
# 234 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 3
// # define __cpp_lib_math_special_functions               201603L
// # define __cpp_lib_memory_resource                      201603L




// # define __cpp_lib_parallel_algorithm                   201603L
# 250 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/version" 3
// # define __cpp_lib_to_chars                             201611L
# 38 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstddef" 2
# 41 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstddef" 3


// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
// -*- C++ -*-
//===--------------------------- stddef.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3
/*
    stddef.h synopsis

Macros:

    offsetof(type,member-designator)
    NULL

Types:

    ptrdiff_t
    size_t
    max_align_t // C++11
    nullptr_t

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1 3
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3


# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/stddef.h" 1 3
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */
# 17 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/stddef.h" 3
/* Always define miscellaneous pieces when modules are available. */
# 26 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/stddef.h" 3
/* __need_wint_t is intentionally not defined here. */




/* Always define ptrdiff_t when modules are available. */



typedef long int ptrdiff_t;






/* Always define size_t when modules are available. */



typedef long unsigned int size_t;





/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
# 102 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/__stddef_max_align_t.h" 1 3
/*===---- __stddef_max_align_t.h - Definition of max_align_t for modules ---===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */







typedef long double max_align_t;
# 103 "/Library/Developer/CommandLineTools/usr/lib/clang/13.0.0/include/stddef.h" 2 3





/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3



extern "C++" {

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__nullptr" 1 3
// -*- C++ -*-
//===--------------------------- __nullptr --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1 3
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__nullptr" 2 3
# 17 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__nullptr" 3
# 54 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__nullptr" 3
namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
using std::nullptr_t;
}
# 45 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstddef" 2 3


namespace std { inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;


using ::max_align_t;


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };




template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };


} }


namespace std // purposefully not versioned
{
enum class byte : unsigned char {};


template <bool> struct __enable_if_integral_imp {};
template <> struct __enable_if_integral_imp<true> { using type = byte; };
template <class _Tp> using _EnableByteOverload = typename __enable_if_integral_imp<__libcpp_is_integral<_Tp>::value>::type;

constexpr byte operator| (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs | __rhs; }

constexpr byte operator& (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs & __rhs; }

constexpr byte operator^ (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)
    ));
}

constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs ^ __rhs; }

constexpr byte operator~ (byte __b) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
        ~static_cast<unsigned int>(__b)
    ));
}
template <class _Integer>
  constexpr _EnableByteOverload<_Integer> &
  operator<<=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs << __shift; }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer>
  operator<< (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer> &
  operator>>=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs >> __shift; }

template <class _Integer>
  constexpr _EnableByteOverload<_Integer>
  operator>> (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }

template <class _Integer, class = _EnableByteOverload<_Integer> >
  constexpr _Integer
  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }
}
# 8 "SEAL/native/src/seal/c/defines.h" 2

// SEALNet

# 1 "SEAL/native/src/seal/c/stdafx.h" 1
   // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//
# 11 "SEAL/native/src/seal/c/defines.h" 2

// Check that std::size_t is 64 bits
# 14 "SEAL/native/src/seal/c/batchencoder.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdint.h" 1
// -*- C++ -*-
//===---------------------------- stdint.h --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//


// AIX system headers need stdint.h to be re-enterable while _STD_TYPES_T
// is defined until an inclusion of it without _STD_TYPES_T occurs, in which
// case the header guard macro is defined.




/*
    stdint.h synopsis

Macros:

    INT8_MIN
    INT16_MIN
    INT32_MIN
    INT64_MIN

    INT8_MAX
    INT16_MAX
    INT32_MAX
    INT64_MAX

    UINT8_MAX
    UINT16_MAX
    UINT32_MAX
    UINT64_MAX

    INT_LEAST8_MIN
    INT_LEAST16_MIN
    INT_LEAST32_MIN
    INT_LEAST64_MIN

    INT_LEAST8_MAX
    INT_LEAST16_MAX
    INT_LEAST32_MAX
    INT_LEAST64_MAX

    UINT_LEAST8_MAX
    UINT_LEAST16_MAX
    UINT_LEAST32_MAX
    UINT_LEAST64_MAX

    INT_FAST8_MIN
    INT_FAST16_MIN
    INT_FAST32_MIN
    INT_FAST64_MIN

    INT_FAST8_MAX
    INT_FAST16_MAX
    INT_FAST32_MAX
    INT_FAST64_MAX

    UINT_FAST8_MAX
    UINT_FAST16_MAX
    UINT_FAST32_MAX
    UINT_FAST64_MAX

    INTPTR_MIN
    INTPTR_MAX
    UINTPTR_MAX

    INTMAX_MIN
    INTMAX_MAX

    UINTMAX_MAX

    PTRDIFF_MIN
    PTRDIFF_MAX

    SIG_ATOMIC_MIN
    SIG_ATOMIC_MAX

    SIZE_MAX

    WCHAR_MIN
    WCHAR_MAX

    WINT_MIN
    WINT_MAX

    INT8_C(value)
    INT16_C(value)
    INT32_C(value)
    INT64_C(value)

    UINT8_C(value)
    UINT16_C(value)
    UINT32_C(value)
    UINT64_C(value)

    INTMAX_C(value)
    UINTMAX_C(value)

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 107 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdint.h" 2
# 110 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdint.h" 3


/* C99 stdlib (e.g. glibc < 2.18) does not provide macros needed
   for C++11 unless __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS
   are defined
*/








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 1 3
// -*- C++ -*-
//===---------------------------- stdint.h --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 124 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdint.h" 2 3
# 15 "SEAL/native/src/seal/c/batchencoder.h" 2

extern "C" long BatchEncoder_Create(void *context, void **batch_encoder);

extern "C" long BatchEncoder_Destroy(void *thisptr);

extern "C" long BatchEncoder_Encode1(void *thisptr, uint64_t count, uint64_t *values, void *destination);

extern "C" long BatchEncoder_Encode2(void *thisptr, uint64_t count, int64_t *values, void *destination);

extern "C" long BatchEncoder_Decode1(void *thisptr, void *plain, uint64_t *count, uint64_t *destination, void *pool);

extern "C" long BatchEncoder_Decode2(void *thisptr, void *plain, uint64_t *count, int64_t *destination, void *pool);

extern "C" long BatchEncoder_GetSlotCount(void *thisptr, uint64_t *slot_count);
# 2 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/ciphertext.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Ciphertext_Create1(void *pool, void **cipher);

extern "C" long Ciphertext_Create2(void *copy, void **cipher);

extern "C" long Ciphertext_Create3(void *context, void *pool, void **cipher);

extern "C" long Ciphertext_Create4(void *context, uint64_t *parms_id, void *pool, void **cipher);

extern "C" long Ciphertext_Create5(void *context, uint64_t *parms_id, uint64_t capacity, void *pool, void **ciphertext);

extern "C" long Ciphertext_Reserve1(void *thisptr, void *context, uint64_t *parms_id, uint64_t size_capacity);

extern "C" long Ciphertext_Reserve2(void *thisptr, void *context, uint64_t size_capacity);

extern "C" long Ciphertext_Reserve3(void *thisptr, uint64_t size_capacity);

extern "C" long Ciphertext_Set(void *thisptr, void *assign);

extern "C" long Ciphertext_Destroy(void *thisptr);

extern "C" long Ciphertext_Size(void *thisptr, uint64_t *size);

extern "C" long Ciphertext_SizeCapacity(void *thisptr, uint64_t *size_capacity);

extern "C" long Ciphertext_PolyModulusDegree(void *thisptr, uint64_t *poly_modulus_degree);

extern "C" long Ciphertext_CoeffModulusSize(void *thisptr, uint64_t *coeff_modulus_size);

extern "C" long Ciphertext_ParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long Ciphertext_SetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long Ciphertext_Resize1(void *thisptr, void *context, uint64_t *parms_id, uint64_t size);

extern "C" long Ciphertext_Resize2(void *thisptr, void *context, uint64_t size);

extern "C" long Ciphertext_Resize3(void *thisptr, uint64_t size);

extern "C" long Ciphertext_Resize4(void *thisptr, uint64_t size, uint64_t polyModulusDegree, uint64_t coeffModCount);

extern "C" long Ciphertext_GetDataAt1(void *thisptr, uint64_t index, uint64_t *data);

extern "C" long Ciphertext_GetDataAt2(void *thisptr, uint64_t poly_index, uint64_t coeff_index, uint64_t *data);

extern "C" long Ciphertext_SetDataAt(void *thisptr, uint64_t index, uint64_t value);

extern "C" long Ciphertext_IsNTTForm(void *thisptr, bool *is_ntt_form);

extern "C" long Ciphertext_SetIsNTTForm(void *thisptr, bool is_ntt_form);

extern "C" long Ciphertext_Scale(void *thisptr, double *scale);

extern "C" long Ciphertext_SetScale(void *thisptr, double scale);

extern "C" long Ciphertext_Release(void *thisptr);

extern "C" long Ciphertext_IsTransparent(void *thisptr, bool *result);

extern "C" long Ciphertext_Pool(void *thisptr, void **pool);

extern "C" long Ciphertext_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long Ciphertext_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long Ciphertext_UnsafeLoad(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long Ciphertext_Load(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 3 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/ckksencoder.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long CKKSEncoder_Create(void *context, void **ckks_encoder);

extern "C" long CKKSEncoder_Destroy(void *thisptr);

// Array of doubles
extern "C" long CKKSEncoder_Encode1(
    void *thisptr, uint64_t value_count, double *values, uint64_t *parms_id, double scale, void *destination,
    void *pool);

// Array of complex numbers (two doubles per value)
extern "C" long CKKSEncoder_Encode2(
    void *thisptr, uint64_t value_count, double *complex_values, uint64_t *parms_id, double scale, void *destination,
    void *pool);

// Single double value
extern "C" long CKKSEncoder_Encode3(
    void *thisptr, double value, uint64_t *parms_id, double scale, void *destination, void *pool);

// Single complex value
extern "C" long CKKSEncoder_Encode4(
    void *thisptr, double value_re, double value_im, uint64_t *parms_id, double scale, void *destination, void *pool);

// Single Int64 value
extern "C" long CKKSEncoder_Encode5(void *thisptr, int64_t value, uint64_t *parms_id, void *destination);

// Array of doubles
extern "C" long CKKSEncoder_Decode1(void *thisptr, void *plain, uint64_t *value_count, double *values, void *pool);

// Array of complex numbers
extern "C" long CKKSEncoder_Decode2(void *thisptr, void *plain, uint64_t *value_count, double *values, void *pool);

extern "C" long CKKSEncoder_SlotCount(void *thisptr, uint64_t *slot_count);
# 4 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/contextdata.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long ContextData_Destroy(void *thisptr);

extern "C" long ContextData_TotalCoeffModulus(void *thisptr, uint64_t *count, uint64_t *total_coeff_modulus);

extern "C" long ContextData_TotalCoeffModulusBitCount(void *thisptr, int *bit_count);

extern "C" long ContextData_Parms(void *thisptr, void **parms);

extern "C" long ContextData_Qualifiers(void *thisptr, void **epq);

extern "C" long ContextData_CoeffDivPlainModulus(void *thisptr, uint64_t *count, uint64_t *coeff_div);

extern "C" long ContextData_PlainUpperHalfThreshold(void *thisptr, uint64_t *puht);

extern "C" long ContextData_PlainUpperHalfIncrement(void *thisptr, uint64_t *count, uint64_t *puhi);

extern "C" long ContextData_UpperHalfThreshold(void *thisptr, uint64_t *count, uint64_t *uht);

extern "C" long ContextData_UpperHalfIncrement(void *thisptr, uint64_t *count, uint64_t *uhi);

extern "C" long ContextData_PrevContextData(void *thisptr, void **prev_data);

extern "C" long ContextData_NextContextData(void *thisptr, void **next_data);

extern "C" long ContextData_ChainIndex(void *thisptr, uint64_t *index);
# 5 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/decryptor.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Decryptor_Create(void *context, void *secret_key, void **decryptor);

extern "C" long Decryptor_Destroy(void *thisptr);

extern "C" long Decryptor_Decrypt(void *thisptr, void *encrypted, void *destination);

extern "C" long Decryptor_InvariantNoiseBudget(void *thisptr, void *encrypted, int *invariant_noise_budget);
# 6 "./bindgen_wrapper.h" 2

# 1 "SEAL/native/src/seal/c/encryptionparameterqualifiers.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long EPQ_Create(void *copy, void **epq);

extern "C" long EPQ_Destroy(void *thisptr);

extern "C" long EPQ_ParametersSet(void *thisptr, bool *parameters_set);

extern "C" long EPQ_UsingFFT(void *thisptr, bool *using_fft);

extern "C" long EPQ_UsingNTT(void *thisptr, bool *using_ntt);

extern "C" long EPQ_UsingBatching(void *thisptr, bool *using_batching);

extern "C" long EPQ_UsingFastPlainLift(void *thisptr, bool *using_fast_plain_lift);

extern "C" long EPQ_UsingDescendingModulusChain(void *thisptr, bool *using_descending_modulus_chain);

extern "C" long EPQ_SecLevel(void *thisptr, int *sec_level);

extern "C" long EPQ_ParameterErrorName(void *thisptr, char *outstr, uint64_t *length);

extern "C" long EPQ_ParameterErrorMessage(void *thisptr, char *outstr, uint64_t *length);
# 8 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/encryptionparameters.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long EncParams_Create1(uint8_t scheme, void **enc_params);

extern "C" long EncParams_Create2(void *copy, void **enc_params);

extern "C" long EncParams_Destroy(void *thisptr);

extern "C" long EncParams_Set(void *thisptr, void *assign);

extern "C" long EncParams_GetPolyModulusDegree(void *thisptr, uint64_t *degree);

extern "C" long EncParams_SetPolyModulusDegree(void *thisptr, uint64_t degree);

extern "C" long EncParams_GetCoeffModulus(void *thisptr, uint64_t *length, void **coeffs);

extern "C" long EncParams_SetCoeffModulus(void *thisptr, uint64_t length, void **coeffs);

extern "C" long EncParams_GetScheme(void *thisptr, uint8_t *scheme);

extern "C" long EncParams_GetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long EncParams_GetPlainModulus(void *thisptr, void **plain_modulus);

extern "C" long EncParams_SetPlainModulus1(void *thisptr, void *modulus);

extern "C" long EncParams_SetPlainModulus2(void *thisptr, uint64_t plain_modulus);

extern "C" long EncParams_Equals(void *thisptr, void *otherptr, bool *result);

extern "C" long EncParams_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long EncParams_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long EncParams_Load(void *thisptr, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 9 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/encryptor.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Encryptor_Create(void *context, void *public_key, void *secret_key, void **encryptor);

extern "C" long Encryptor_SetPublicKey(void *thisptr, void *public_key);

extern "C" long Encryptor_SetSecretKey(void *thisptr, void *secret_key);

extern "C" long Encryptor_Encrypt(void *thisptr, void *plaintext, void *destination, void *pool_handle);

extern "C" long Encryptor_EncryptZero1(void *thisptr, uint64_t *parms_id, void *destination, void *pool_handle);

extern "C" long Encryptor_EncryptZero2(void *thisptr, void *destination, void *pool_handle);

extern "C" long Encryptor_EncryptSymmetric(
    void *thisptr, void *plaintext, bool save_seed, void *destination, void *pool_handle);

extern "C" long Encryptor_EncryptZeroSymmetric1(
    void *thisptr, uint64_t *parms_id, bool save_seed, void *destination, void *pool_handle);

extern "C" long Encryptor_EncryptZeroSymmetric2(void *thisptr, bool save_seed, void *destination, void *pool_handle);

extern "C" long Encryptor_Destroy(void *thisptr);
# 10 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/evaluator.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Evaluator_Create(void *context, void **evaluator);

extern "C" long Evaluator_Destroy(void *thisptr);

extern "C" long Evaluator_Negate(void *thisptr, void *encrypted, void *destination);

extern "C" long Evaluator_Add(void *thisptr, void *encrypted1, void *encrypted2, void *destination);

extern "C" long Evaluator_AddMany(void *thisptr, uint64_t count, void **encrypteds, void *destination);

extern "C" long Evaluator_AddPlain(void *thisptr, void *encrypted, void *plain, void *destination);

extern "C" long Evaluator_Sub(void *thisptr, void *encrypted1, void *encrypted2, void *destination);

extern "C" long Evaluator_SubPlain(void *thisptr, void *encrypted, void *plain, void *destination);

extern "C" long Evaluator_Multiply(void *thisptr, void *encrypted1, void *encrypted2, void *destination, void *pool);

extern "C" long Evaluator_MultiplyMany(
    void *thisptr, uint64_t count, void **encrypteds, void *relin_keys, void *destination, void *pool);

extern "C" long Evaluator_MultiplyPlain(void *thisptr, void *encrypted, void *plain, void *destination, void *pool);

extern "C" long Evaluator_Square(void *thisptr, void *encrypted, void *destination, void *pool);

extern "C" long Evaluator_Relinearize(void *thisptr, void *encrypted, void *relinKeys, void *destination, void *pool);

extern "C" long Evaluator_ModSwitchToNext1(void *thisptr, void *encrypted, void *destination, void *pool);

extern "C" long Evaluator_ModSwitchToNext2(void *thisptr, void *plain, void *destination);

extern "C" long Evaluator_ModSwitchTo1(void *thisptr, void *encrypted, uint64_t *parms_id, void *destination, void *pool);

extern "C" long Evaluator_ModSwitchTo2(void *thisptr, void *plain, uint64_t *parms_id, void *destination);

extern "C" long Evaluator_RescaleToNext(void *thisptr, void *encrypted, void *destination, void *pool);

extern "C" long Evaluator_RescaleTo(void *thisptr, void *encrypted, uint64_t *parms_id, void *destination, void *pool);

extern "C" long Evaluator_Exponentiate(
    void *thisptr, void *encrypted, uint64_t exponent, void *relin_keys, void *destination, void *pool);

extern "C" long Evaluator_TransformToNTT1(
    void *thisptr, void *plain, uint64_t *parms_id, void *destination_ntt, void *pool);

extern "C" long Evaluator_TransformToNTT2(void *thisptr, void *encrypted, void *destination_ntt);

extern "C" long Evaluator_TransformFromNTT(void *thisptr, void *encrypted_ntt, void *destination);

extern "C" long Evaluator_ApplyGalois(
    void *thisptr, void *encrypted, uint32_t galois_elt, void *galois_keys, void *destination, void *pool);

extern "C" long Evaluator_RotateRows(
    void *thisptr, void *encrypted, int steps, void *galoisKeys, void *destination, void *pool);

extern "C" long Evaluator_RotateColumns(void *thisptr, void *encrypted, void *galois_keys, void *destination, void *pool);

extern "C" long Evaluator_RotateVector(
    void *thisptr, void *encrypted, int steps, void *galois_keys, void *destination, void *pool);

extern "C" long Evaluator_ComplexConjugate(
    void *thisptr, void *encrypted, void *galois_keys, void *destination, void *pool);

extern "C" long Evaluator_ContextUsingKeyswitching(void *thisptr, bool *using_keyswitching);
# 11 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/galoiskeys.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long GaloisKeys_GetIndex(uint32_t galois_elt, uint64_t *index);
# 12 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/keygenerator.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long KeyGenerator_Create1(void *context, void **key_generator);

extern "C" long KeyGenerator_Create2(void *context, void *secret_key, void **key_generator);

extern "C" long KeyGenerator_Destroy(void *thisptr);

extern "C" long KeyGenerator_CreateRelinKeys(void *thisptr, bool save_seed, void **relin_keys);

extern "C" long KeyGenerator_CreateGaloisKeysFromElts(
    void *thisptr, uint64_t count, uint32_t *galois_elts, bool save_seed, void **galois_keys);

extern "C" long KeyGenerator_CreateGaloisKeysFromSteps(
    void *thisptr, uint64_t count, int *steps, bool save_seed, void **galois_keys);

extern "C" long KeyGenerator_CreateGaloisKeysAll(void *thisptr, bool save_seed, void **galois_keys);

extern "C" long KeyGenerator_CreatePublicKey(void *thisptr, bool save_seed, void **public_key);

extern "C" long KeyGenerator_SecretKey(void *thisptr, void **secret_key);

extern "C" long KeyGenerator_ContextUsingKeyswitching(void *thisptr, bool *using_keyswitching);
# 13 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/kswitchkeys.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long KSwitchKeys_Create1(void **kswitch_keys);

extern "C" long KSwitchKeys_Create2(void *copy, void **kswitch_keys);

extern "C" long KSwitchKeys_Destroy(void *thisptr);

extern "C" long KSwitchKeys_Set(void *thisptr, void *assign);

extern "C" long KSwitchKeys_Size(void *thisptr, uint64_t *size);

extern "C" long KSwitchKeys_RawSize(void *thisptr, uint64_t *key_count);

extern "C" long KSwitchKeys_GetKeyList(void *thisptr, uint64_t index, uint64_t *count, void **key_list);

extern "C" long KSwitchKeys_ClearDataAndReserve(void *thisptr, uint64_t size);

extern "C" long KSwitchKeys_AddKeyList(void *thisptr, uint64_t count, void **key_list);

extern "C" long KSwitchKeys_GetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long KSwitchKeys_SetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long KSwitchKeys_Pool(void *thisptr, void **pool);

extern "C" long KSwitchKeys_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long KSwitchKeys_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long KSwitchKeys_UnsafeLoad(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long KSwitchKeys_Load(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 14 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/memorymanager.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long MemoryManager_GetPool1(int prof_opt, bool clear_on_destruction, void **pool_handle);

extern "C" long MemoryManager_GetPool2(void **pool_handle);

extern "C" long MemoryManager_SwitchProfile(void *new_profile);

extern "C" long MMProf_CreateGlobal(void **profile);

extern "C" long MMProf_CreateFixed(void *pool, void **profile);

extern "C" long MMProf_CreateNew(void **profile);

extern "C" long MMProf_CreateThreadLocal(void **profile);

extern "C" long MMProf_GetPool(void *thisptr, void **pool_handle);

extern "C" long MMProf_Destroy(void *thisptr);
# 15 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/memorypoolhandle.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long MemoryPoolHandle_Create1(void **handle);

extern "C" long MemoryPoolHandle_Create2(void *otherptr, void **handle);

extern "C" long MemoryPoolHandle_Destroy(void *thisptr);

extern "C" long MemoryPoolHandle_Set(void *thisptr, void *assignptr);

extern "C" long MemoryPoolHandle_Global(void **handle);

extern "C" long MemoryPoolHandle_ThreadLocal(void **handle);

extern "C" long MemoryPoolHandle_New(bool clear_on_destruction, void **handle);

extern "C" long MemoryPoolHandle_PoolCount(void *thisptr, uint64_t *count);

extern "C" long MemoryPoolHandle_AllocByteCount(void *thisptr, uint64_t *count);

extern "C" long MemoryPoolHandle_UseCount(void *thisptr, long *count);

extern "C" long MemoryPoolHandle_IsInitialized(void *thisptr, bool *result);

extern "C" long MemoryPoolHandle_Equals(void *thisptr, void *otherptr, bool *result);
# 16 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/modulus.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Modulus_Create1(uint64_t value, void **small_modulus);

extern "C" long Modulus_Create2(void *copy, void **small_modulus);

extern "C" long Modulus_Destroy(void *thisptr);

extern "C" long Modulus_IsZero(void *thisptr, bool *is_zero);

extern "C" long Modulus_IsPrime(void *thisptr, bool *is_prime);

extern "C" long Modulus_Value(void *thisptr, uint64_t *value);

extern "C" long Modulus_BitCount(void *thisptr, int *bit_count);

extern "C" long Modulus_UInt64Count(void *thisptr, uint64_t *uint64_count);

extern "C" long Modulus_Set1(void *thisptr, void *assign);

extern "C" long Modulus_Set2(void *thisptr, uint64_t value);

extern "C" long Modulus_ConstRatio(void *thisptr, uint64_t length, uint64_t ratio[]);

extern "C" long Modulus_Equals1(void *thisptr, void *other, bool *result);

extern "C" long Modulus_Equals2(void *thisptr, uint64_t other, bool *result);

extern "C" long Modulus_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long Modulus_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long Modulus_Load(void *thisptr, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long Modulus_Reduce(void *thisptr, uint64_t value, uint64_t *result);

extern "C" long CoeffModulus_MaxBitCount(uint64_t poly_modulus_degree, int sec_level, int *bit_count);

extern "C" long CoeffModulus_BFVDefault(uint64_t poly_modulus_degree, int sec_level, uint64_t *length, void **coeffs);

extern "C" long CoeffModulus_Create(uint64_t poly_modulus_degree, uint64_t length, int *bit_sizes, void **coeffs);
# 17 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/plaintext.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Plaintext_Create1(void *memoryPoolHandle, void **plaintext);

extern "C" long Plaintext_Create2(uint64_t coeffCount, void *memoryPoolHandle, void **plaintext);

extern "C" long Plaintext_Create3(uint64_t capacity, uint64_t coeffCount, void *memoryPoolHandle, void **plaintext);

extern "C" long Plaintext_Create4(char *hex_poly, void *memoryPoolHandle, void **plaintext);

extern "C" long Plaintext_Create5(void *copy, void **plaintext);

extern "C" long Plaintext_Set1(void *thisptr, void *assign);

extern "C" long Plaintext_Set2(void *thisptr, char *hex_poly);

extern "C" long Plaintext_Set3(void *thisptr, uint64_t const_coeff);

extern "C" long Plaintext_Set4(void *thisptr, uint64_t count, uint64_t *coeffs);

extern "C" long Plaintext_Destroy(void *thisptr);

extern "C" long Plaintext_CoeffCount(void *thisptr, uint64_t *coeff_count);

extern "C" long Plaintext_CoeffAt(void *thisptr, uint64_t index, uint64_t *coeff);

extern "C" long Plaintext_SetCoeffAt(void *thisptr, uint64_t index, uint64_t value);

extern "C" long Plaintext_ToString(void *thispt, char *outstr, uint64_t *length);

extern "C" long Plaintext_IsNTTForm(void *thisptr, bool *is_ntt_form);

extern "C" long Plaintext_IsZero(void *thisptr, bool *is_zero);

extern "C" long Plaintext_SetZero1(void *thisptr);

extern "C" long Plaintext_SetZero2(void *thisptr, uint64_t start_coeff);

extern "C" long Plaintext_SetZero3(void *thisptr, uint64_t start_coeff, uint64_t length);

extern "C" long Plaintext_GetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long Plaintext_SetParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long Plaintext_Reserve(void *thisptr, uint64_t capacity);

extern "C" long Plaintext_Resize(void *thisptr, uint64_t coeff_count);

extern "C" long Plaintext_ShrinkToFit(void *thisptr);

extern "C" long Plaintext_Release(void *thisptr);

extern "C" long Plaintext_Capacity(void *thisptr, uint64_t *capacity);

extern "C" long Plaintext_SignificantCoeffCount(void *thisptr, uint64_t *significant_coeff_count);

extern "C" long Plaintext_NonZeroCoeffCount(void *thisptr, uint64_t *nonzero_coeff_count);

extern "C" long Plaintext_Scale(void *thisptr, double *scale);

extern "C" long Plaintext_SetScale(void *thisptr, double scale);

extern "C" long Plaintext_Equals(void *thisptr, void *other, bool *result);

extern "C" long Plaintext_SwapData(void *thisptr, uint64_t count, uint64_t *new_data);

extern "C" long Plaintext_Pool(void *thisptr, void **pool);

extern "C" long Plaintext_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long Plaintext_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long Plaintext_UnsafeLoad(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long Plaintext_Load(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 18 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/publickey.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long PublicKey_Create1(void **public_key);

extern "C" long PublicKey_Create2(void *copy, void **public_key);

extern "C" long PublicKey_Set(void *thisptr, void *assign);

extern "C" long PublicKey_Data(void *thisptr, void **data);

extern "C" long PublicKey_ParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long PublicKey_Pool(void *thisptr, void **pool);

extern "C" long PublicKey_Destroy(void *thisptr);

extern "C" long PublicKey_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long PublicKey_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long PublicKey_UnsafeLoad(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long PublicKey_Load(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 19 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/relinkeys.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long RelinKeys_GetIndex(uint64_t key_power, uint64_t *index);
# 20 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/sealcontext.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long SEALContext_Create(void *encryptionParams, bool expand_mod_chain, int sec_level, void **context);

extern "C" long SEALContext_Destroy(void *thisptr);

extern "C" long SEALContext_KeyParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long SEALContext_FirstParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long SEALContext_LastParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long SEALContext_ParametersSet(void *thisptr, bool *params_set);

extern "C" long SEALContext_KeyContextData(void *thisptr, void **context_data);

extern "C" long SEALContext_FirstContextData(void *thisptr, void **context_data);

extern "C" long SEALContext_LastContextData(void *thisptr, void **context_data);

extern "C" long SEALContext_GetContextData(void *thisptr, uint64_t *parms_id, void **context_data);

extern "C" long SEALContext_UsingKeyswitching(void *thisptr, bool *using_keyswitching);

extern "C" long SEALContext_ParameterErrorName(void *thisptr, char *outstr, uint64_t *length);

extern "C" long SEALContext_ParameterErrorMessage(void *thisptr, char *outstr, uint64_t *length);
# 21 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/secretkey.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long SecretKey_Create1(void **secret_key);

extern "C" long SecretKey_Create2(void *copy, void **secret_key);

extern "C" long SecretKey_Set(void *thisptr, void *assign);

extern "C" long SecretKey_Data(void *thisptr, void **data);

extern "C" long SecretKey_Destroy(void *thisptr);

extern "C" long SecretKey_ParmsId(void *thisptr, uint64_t *parms_id);

extern "C" long SecretKey_Pool(void *thisptr, void **pool);

extern "C" long SecretKey_SaveSize(void *thisptr, uint8_t compr_mode, int64_t *result);

extern "C" long SecretKey_Save(void *thisptr, uint8_t *outptr, uint64_t size, uint8_t compr_mode, int64_t *out_bytes);

extern "C" long SecretKey_UnsafeLoad(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);

extern "C" long SecretKey_Load(void *thisptr, void *context, uint8_t *inptr, uint64_t size, int64_t *in_bytes);
# 22 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/serialization.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long Serialization_SEALMagic(uint16_t *result);

extern "C" long Serialization_SEALHeaderSize(uint8_t *result);

extern "C" long Serialization_IsSupportedComprMode(uint8_t compr_mode, bool *result);

extern "C" long Serialization_ComprModeDefault(uint8_t *result);

extern "C" long Serialization_IsCompatibleVersion(uint8_t *headerptr, uint64_t size, bool *result);

extern "C" long Serialization_IsValidHeader(uint8_t *headerptr, uint64_t size, bool *result);
# 23 "./bindgen_wrapper.h" 2

# 1 "SEAL/native/src/seal/c/utilities.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



// STD

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 1
// -*- C++ -*-
//===-------------------------- algorithm ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    algorithm synopsis

#include <initializer_list>

namespace std
{

template <class InputIterator, class Predicate>
    constexpr bool     // constexpr in C++20
    all_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>
    constexpr bool     // constexpr in C++20
    any_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Predicate>
    constexpr bool     // constexpr in C++20
    none_of(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator, class Function>
    constexpr Function          // constexpr in C++20
    for_each(InputIterator first, InputIterator last, Function f);

template<class InputIterator, class Size, class Function>
    constexpr InputIterator     // constexpr in C++20
    for_each_n(InputIterator first, Size n, Function f); // C++17

template <class InputIterator, class T>
    constexpr InputIterator     // constexpr in C++20
    find(InputIterator first, InputIterator last, const T& value);

template <class InputIterator, class Predicate>
    constexpr InputIterator     // constexpr in C++20
    find_if(InputIterator first, InputIterator last, Predicate pred);

template<class InputIterator, class Predicate>
    constexpr InputIterator     // constexpr in C++20
    find_if_not(InputIterator first, InputIterator last, Predicate pred);

template <class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1  // constexpr in C++20
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1  // constexpr in C++20
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1  // constexpr in C++20
    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1  // constexpr in C++20
    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator>
    constexpr ForwardIterator   // constexpr in C++20
    adjacent_find(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator   // constexpr in C++20
    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template <class InputIterator, class T>
    constexpr typename iterator_traits<InputIterator>::difference_type  // constexpr in C++20
    count(InputIterator first, InputIterator last, const T& value);

template <class InputIterator, class Predicate>
    constexpr typename iterator_traits<InputIterator>::difference_type // constexpr in C++20
    count_if(InputIterator first, InputIterator last, Predicate pred);

template <class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template <class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2); // **C++14**

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>   // constexpr in C++20
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred); // **C++14**

template <class InputIterator1, class InputIterator2>
    constexpr bool      // constexpr in C++20
    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template <class InputIterator1, class InputIterator2>
    constexpr bool      // constexpr in C++20
    equal(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2); // **C++14**

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool      // constexpr in C++20
    equal(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, BinaryPredicate pred);

template <class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool      // constexpr in C++20
    equal(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          BinaryPredicate pred); // **C++14**

template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool      // constexpr in C++20
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2);

template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool      // constexpr in C++20
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**

template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool      // constexpr in C++20
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, BinaryPredicate pred);

template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool      // constexpr in C++20
    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   BinaryPredicate pred);  // **C++14**

template <class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1      // constexpr in C++20
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2);

template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1      // constexpr in C++20
    search(ForwardIterator1 first1, ForwardIterator1 last1,
           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template <class ForwardIterator, class Size, class T>
    constexpr ForwardIterator       // constexpr in C++20
    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);

template <class ForwardIterator, class Size, class T, class BinaryPredicate>
    constexpr ForwardIterator       // constexpr in C++20
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value, BinaryPredicate pred);

template <class InputIterator, class OutputIterator>
    constexpr OutputIterator      // constexpr in C++20
    copy(InputIterator first, InputIterator last, OutputIterator result);

template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator      // constexpr in C++20
    copy_if(InputIterator first, InputIterator last,
            OutputIterator result, Predicate pred);

template<class InputIterator, class Size, class OutputIterator>
    constexpr OutputIterator      // constexpr in C++20
    copy_n(InputIterator first, Size n, OutputIterator result);

template <class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2      // constexpr in C++20
    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                  BidirectionalIterator2 result);

template <class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator2    // constexpr in C++20
    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);

template <class ForwardIterator1, class ForwardIterator2>
    constexpr void                // constexpr in C++20
    iter_swap(ForwardIterator1 a, ForwardIterator2 b);

template <class InputIterator, class OutputIterator, class UnaryOperation>
    constexpr OutputIterator      // constexpr in C++20
    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);

template <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator      // constexpr in C++20
    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
              OutputIterator result, BinaryOperation binary_op);

template <class ForwardIterator, class T>
    constexpr void      // constexpr in C++20
    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);

template <class ForwardIterator, class Predicate, class T>
    constexpr void      // constexpr in C++20
    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);

template <class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator      // constexpr in C++20
    replace_copy(InputIterator first, InputIterator last, OutputIterator result,
                 const T& old_value, const T& new_value);

template <class InputIterator, class OutputIterator, class Predicate, class T>
    constexpr OutputIterator      // constexpr in C++20
    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);

template <class ForwardIterator, class T>
    constexpr void      // constexpr in C++20
    fill(ForwardIterator first, ForwardIterator last, const T& value);

template <class OutputIterator, class Size, class T>
    constexpr OutputIterator      // constexpr in C++20
    fill_n(OutputIterator first, Size n, const T& value);

template <class ForwardIterator, class Generator>
    constexpr void      // constexpr in C++20
    generate(ForwardIterator first, ForwardIterator last, Generator gen);

template <class OutputIterator, class Size, class Generator>
    constexpr OutputIterator      // constexpr in C++20
    generate_n(OutputIterator first, Size n, Generator gen);

template <class ForwardIterator, class T>
    constexpr ForwardIterator     // constexpr in C++20
    remove(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class Predicate>
    constexpr ForwardIterator     // constexpr in C++20
    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator     // constexpr in C++20
    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);

template <class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator     // constexpr in C++20
    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);

template <class ForwardIterator>
    constexpr ForwardIterator    // constexpr in C++20
    unique(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator    // constexpr in C++20
    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template <class InputIterator, class OutputIterator>
    constexpr OutputIterator     // constexpr in C++20
    unique_copy(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryPredicate>
    constexpr OutputIterator     // constexpr in C++20
    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);

template <class BidirectionalIterator>
    constexpr void               // constexpr in C++20
    reverse(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class OutputIterator>
    constexpr OutputIterator       // constexpr in C++20
    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);

template <class ForwardIterator>
    constexpr ForwardIterator      // constexpr in C++20
    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);

template <class ForwardIterator, class OutputIterator>
    constexpr OutputIterator       // constexpr in C++20
    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);

template <class RandomAccessIterator>
    void
    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14, removed in C++17

template <class RandomAccessIterator, class RandomNumberGenerator>
    void
    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                   RandomNumberGenerator& rand);  // deprecated in C++14, removed in C++17

template<class PopulationIterator, class SampleIterator,
         class Distance, class UniformRandomBitGenerator>
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&& g); // C++17

template<class RandomAccessIterator, class UniformRandomNumberGenerator>
    void shuffle(RandomAccessIterator first, RandomAccessIterator last,
                 UniformRandomNumberGenerator&& g);

template<class ForwardIterator>
  constexpr ForwardIterator
    shift_left(ForwardIterator first, ForwardIterator last,
               typename iterator_traits<ForwardIterator>::difference_type n); // C++20

template<class ForwardIterator>
  constexpr ForwardIterator
    shift_right(ForwardIterator first, ForwardIterator last,
                typename iterator_traits<ForwardIterator>::difference_type n); // C++20

template <class InputIterator, class Predicate>
    constexpr bool  // constexpr in C++20
    is_partitioned(InputIterator first, InputIterator last, Predicate pred);

template <class ForwardIterator, class Predicate>
    constexpr ForwardIterator  // constexpr in C++20
    partition(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate>
    constexpr pair<OutputIterator1, OutputIterator2>   // constexpr in C++20
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false,
                   Predicate pred);

template <class ForwardIterator, class Predicate>
    ForwardIterator
    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);

template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator  // constexpr in C++20
    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);

template <class ForwardIterator>
    constexpr bool  // constexpr in C++20
    is_sorted(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    constexpr bool  // constexpr in C++20
    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);

template<class ForwardIterator>
    constexpr ForwardIterator    // constexpr in C++20
    is_sorted_until(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    constexpr ForwardIterator    // constexpr in C++20
    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    sort(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    stable_sort(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);

template <class InputIterator, class RandomAccessIterator>
    RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first, RandomAccessIterator result_last);

template <class InputIterator, class RandomAccessIterator, class Compare>
    RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);

template <class RandomAccessIterator>
    void
    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);

template <class ForwardIterator, class T>
    constexpr ForwardIterator                         // constexpr in C++20
    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator                         // constexpr in C++20
    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    constexpr ForwardIterator                         // constexpr in C++20
    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator                         // constexpr in C++20
    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++20
    equal_range(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++20
    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class ForwardIterator, class T>
    constexpr bool                                    // constexpr in C++20
    binary_search(ForwardIterator first, ForwardIterator last, const T& value);

template <class ForwardIterator, class T, class Compare>
    constexpr bool                                    // constexpr in C++20
    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator                          // constexpr in C++20
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator                          // constexpr in C++20
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class BidirectionalIterator>
    void
    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    void
    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);

template <class InputIterator1, class InputIterator2>
    constexpr bool                                    // constexpr in C++20
    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template <class InputIterator1, class InputIterator2, class Compare>
    constexpr bool                                    // constexpr in C++20
    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator                          // constexpr in C++20
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator                          // constexpr in C++20
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator                         // constexpr in C++20
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator                         // constexpr in C++20
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator                         // constexpr in C++20
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator                         // constexpr in C++20
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator                         // constexpr in C++20
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator                         // constexpr in C++20
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template <class RandomAccessIterator>
    void
    push_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    make_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    void
    sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template <class RandomAccessIterator, class Compare>
    void
    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template <class RandomAccessIterator>
    constexpr bool   // constexpr in C++20
    is_heap(RandomAccessIterator first, RandomAccessiterator last);

template <class RandomAccessIterator, class Compare>
    constexpr bool   // constexpr in C++20
    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);

template <class RandomAccessIterator>
    constexpr RandomAccessIterator   // constexpr in C++20
    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);

template <class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator   // constexpr in C++20
    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);

template <class ForwardIterator>
    constexpr ForwardIterator        // constexpr in C++14
    min_element(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    constexpr ForwardIterator        // constexpr in C++14
    min_element(ForwardIterator first, ForwardIterator last, Compare comp);

template <class T>
    constexpr const T&               // constexpr in C++14
    min(const T& a, const T& b);

template <class T, class Compare>
    constexpr const T&               // constexpr in C++14
    min(const T& a, const T& b, Compare comp);

template<class T>
    constexpr T                      // constexpr in C++14
    min(initializer_list<T> t);

template<class T, class Compare>
    constexpr T                      // constexpr in C++14
    min(initializer_list<T> t, Compare comp);

template<class T>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi);               // C++17

template<class T, class Compare>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp); // C++17

template <class ForwardIterator>
    constexpr ForwardIterator        // constexpr in C++14
    max_element(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Compare>
    constexpr ForwardIterator        // constexpr in C++14
    max_element(ForwardIterator first, ForwardIterator last, Compare comp);

template <class T>
    constexpr const T&               // constexpr in C++14
    max(const T& a, const T& b);

template <class T, class Compare>
    constexpr const T&               // constexpr in C++14
    max(const T& a, const T& b, Compare comp);

template<class T>
    constexpr T                      // constexpr in C++14
    max(initializer_list<T> t);

template<class T, class Compare>
    constexpr T                      // constexpr in C++14
    max(initializer_list<T> t, Compare comp);

template<class ForwardIterator>
    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++14
    minmax_element(ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>  // constexpr in C++14
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);

template<class T>
    constexpr pair<const T&, const T&>  // constexpr in C++14
    minmax(const T& a, const T& b);

template<class T, class Compare>
    constexpr pair<const T&, const T&>  // constexpr in C++14
    minmax(const T& a, const T& b, Compare comp);

template<class T>
    constexpr pair<T, T>                // constexpr in C++14
    minmax(initializer_list<T> t);

template<class T, class Compare>
    constexpr pair<T, T>                // constexpr in C++14
    minmax(initializer_list<T> t, Compare comp);

template <class InputIterator1, class InputIterator2>
    constexpr bool     // constexpr in C++20
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template <class InputIterator1, class InputIterator2, class Compare>
    constexpr bool     // constexpr in C++20
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2, Compare comp);

template <class BidirectionalIterator>
    constexpr bool     // constexpr in C++20
    next_permutation(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    constexpr bool     // constexpr in C++20
    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

template <class BidirectionalIterator>
    constexpr bool     // constexpr in C++20
    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);

template <class BidirectionalIterator, class Compare>
    constexpr bool     // constexpr in C++20
    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 649 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/initializer_list" 1
// -*- C++ -*-
//===----------------------- initializer_list -----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    initializer_list synopsis

namespace std
{

template<class E>
class initializer_list
{
public:
    typedef E        value_type;
    typedef const E& reference;
    typedef const E& const_reference;
    typedef size_t   size_type;

    typedef const E* iterator;
    typedef const E* const_iterator;

    initializer_list() noexcept; // constexpr in C++14

    size_t   size()  const noexcept; // constexpr in C++14
    const E* begin() const noexcept; // constexpr in C++14
    const E* end()   const noexcept; // constexpr in C++14
};

template<class E> const E* begin(initializer_list<E> il) noexcept; // constexpr in C++14
template<class E> const E* end(initializer_list<E> il) noexcept; // constexpr in C++14

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 46 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/initializer_list" 2
# 50 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/initializer_list" 3


namespace std // purposefully not versioned
{



template<class _Ep>
class __attribute__ ((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    size_t size() const noexcept {return __size_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}



} // std
# 650 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 1
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    type_traits synopsis

namespace std
{

    // helper class:
    template <class T, T v> struct integral_constant;
    typedef integral_constant<bool, true>  true_type;   // C++11
    typedef integral_constant<bool, false> false_type;  // C++11

    template <bool B>                                   // C++14
    using bool_constant = integral_constant<bool, B>;   // C++14
    typedef bool_constant<true> true_type;              // C++14
    typedef bool_constant<false> false_type;            // C++14

    // helper traits
    template <bool, class T = void> struct enable_if;
    template <bool, class T, class F> struct conditional;

    // Primary classification traits:
    template <class T> struct is_void;
    template <class T> struct is_null_pointer;  // C++14
    template <class T> struct is_integral;
    template <class T> struct is_floating_point;
    template <class T> struct is_array;
    template <class T> struct is_pointer;
    template <class T> struct is_lvalue_reference;
    template <class T> struct is_rvalue_reference;
    template <class T> struct is_member_object_pointer;
    template <class T> struct is_member_function_pointer;
    template <class T> struct is_enum;
    template <class T> struct is_union;
    template <class T> struct is_class;
    template <class T> struct is_function;

    // Secondary classification traits:
    template <class T> struct is_reference;
    template <class T> struct is_arithmetic;
    template <class T> struct is_fundamental;
    template <class T> struct is_member_pointer;
    template <class T> struct is_scoped_enum; // C++2b
    template <class T> struct is_scalar;
    template <class T> struct is_object;
    template <class T> struct is_compound;

    // Const-volatile properties and transformations:
    template <class T> struct is_const;
    template <class T> struct is_volatile;
    template <class T> struct remove_const;
    template <class T> struct remove_volatile;
    template <class T> struct remove_cv;
    template <class T> struct add_const;
    template <class T> struct add_volatile;
    template <class T> struct add_cv;

    // Reference transformations:
    template <class T> struct remove_reference;
    template <class T> struct add_lvalue_reference;
    template <class T> struct add_rvalue_reference;

    // Pointer transformations:
    template <class T> struct remove_pointer;
    template <class T> struct add_pointer;

    template<class T> struct type_identity;                     // C++20
    template<class T>
      using type_identity_t = typename type_identity<T>::type;  // C++20

    // Integral properties:
    template <class T> struct is_signed;
    template <class T> struct is_unsigned;
    template <class T> struct make_signed;
    template <class T> struct make_unsigned;

    // Array properties and transformations:
    template <class T> struct rank;
    template <class T, unsigned I = 0> struct extent;
    template <class T> struct remove_extent;
    template <class T> struct remove_all_extents;

    template <class T> struct is_bounded_array;                 // C++20
    template <class T> struct is_unbounded_array;               // C++20

    // Member introspection:
    template <class T> struct is_pod;
    template <class T> struct is_trivial;
    template <class T> struct is_trivially_copyable;
    template <class T> struct is_standard_layout;
    template <class T> struct is_literal_type;
    template <class T> struct is_empty;
    template <class T> struct is_polymorphic;
    template <class T> struct is_abstract;
    template <class T> struct is_final; // C++14
    template <class T> struct is_aggregate; // C++17

    template <class T, class... Args> struct is_constructible;
    template <class T>                struct is_default_constructible;
    template <class T>                struct is_copy_constructible;
    template <class T>                struct is_move_constructible;
    template <class T, class U>       struct is_assignable;
    template <class T>                struct is_copy_assignable;
    template <class T>                struct is_move_assignable;
    template <class T, class U>       struct is_swappable_with;       // C++17
    template <class T>                struct is_swappable;            // C++17
    template <class T>                struct is_destructible;

    template <class T, class... Args> struct is_trivially_constructible;
    template <class T>                struct is_trivially_default_constructible;
    template <class T>                struct is_trivially_copy_constructible;
    template <class T>                struct is_trivially_move_constructible;
    template <class T, class U>       struct is_trivially_assignable;
    template <class T>                struct is_trivially_copy_assignable;
    template <class T>                struct is_trivially_move_assignable;
    template <class T>                struct is_trivially_destructible;

    template <class T, class... Args> struct is_nothrow_constructible;
    template <class T>                struct is_nothrow_default_constructible;
    template <class T>                struct is_nothrow_copy_constructible;
    template <class T>                struct is_nothrow_move_constructible;
    template <class T, class U>       struct is_nothrow_assignable;
    template <class T>                struct is_nothrow_copy_assignable;
    template <class T>                struct is_nothrow_move_assignable;
    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
    template <class T>                struct is_nothrow_swappable;      // C++17
    template <class T>                struct is_nothrow_destructible;

    template <class T> struct has_virtual_destructor;

    template<class T> struct has_unique_object_representations;         // C++17

    // Relationships between types:
    template <class T, class U> struct is_same;
    template <class Base, class Derived> struct is_base_of;

    template <class From, class To> struct is_convertible;
    template <typename From, typename To> struct is_nothrow_convertible;                  // C++20
    template <typename From, typename To> inline constexpr bool is_nothrow_convertible_v; // C++20

    template <class Fn, class... ArgTypes> struct is_invocable;
    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;

    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;

    // Alignment properties and transformations:
    template <class T> struct alignment_of;
    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        struct aligned_storage;
    template <size_t Len, class... Types> struct aligned_union;
    template <class T> struct remove_cvref; // C++20

    template <class T> struct decay;
    template <class... T> struct common_type;
    template <class T> struct underlying_type;
    template <class> class result_of; // undefined
    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17

    // const-volatile modifications:
    template <class T>
      using remove_const_t    = typename remove_const<T>::type;  // C++14
    template <class T>
      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
    template <class T>
      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
    template <class T>
      using add_const_t       = typename add_const<T>::type;  // C++14
    template <class T>
      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
    template <class T>
      using add_cv_t          = typename add_cv<T>::type;  // C++14

    // reference modifications:
    template <class T>
      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
    template <class T>
      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
    template <class T>
      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14

    // sign modifications:
    template <class T>
      using make_signed_t   = typename make_signed<T>::type;  // C++14
    template <class T>
      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14

    // array modifications:
    template <class T>
      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
    template <class T>
      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14

    template <class T>
      inline constexpr bool is_bounded_array_v
        = is_bounded_array<T>::value;                                     // C++20
      inline constexpr bool is_unbounded_array_v
        = is_unbounded_array<T>::value;                                   // C++20

    // pointer modifications:
    template <class T>
      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
    template <class T>
      using add_pointer_t    = typename add_pointer<T>::type;  // C++14

    // other transformations:
    template <size_t Len, std::size_t Align=default-alignment>
      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
    template <std::size_t Len, class... Types>
      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
    template <class T>
      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20
    template <class T>
      using decay_t           = typename decay<T>::type;  // C++14
    template <bool b, class T=void>
      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
    template <bool b, class T, class F>
      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
    template <class... T>
      using common_type_t     = typename common_type<T...>::type;  // C++14
    template <class T>
      using underlying_type_t = typename underlying_type<T>::type;  // C++14
    template <class T>
      using result_of_t       = typename result_of<T>::type;  // C++14
    template <class Fn, class... ArgTypes>
      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17

    template <class...>
      using void_t = void;   // C++17

      // See C++14 20.10.4.1, primary type categories
      template <class T> inline constexpr bool is_void_v
        = is_void<T>::value;                                             // C++17
      template <class T> inline constexpr bool is_null_pointer_v
        = is_null_pointer<T>::value;                                     // C++17
      template <class T> inline constexpr bool is_integral_v
        = is_integral<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_floating_point_v
        = is_floating_point<T>::value;                                   // C++17
      template <class T> inline constexpr bool is_array_v
        = is_array<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_pointer_v
        = is_pointer<T>::value;                                          // C++17
      template <class T> inline constexpr bool is_lvalue_reference_v
        = is_lvalue_reference<T>::value;                                 // C++17
      template <class T> inline constexpr bool is_rvalue_reference_v
        = is_rvalue_reference<T>::value;                                 // C++17
      template <class T> inline constexpr bool is_member_object_pointer_v
        = is_member_object_pointer<T>::value;                            // C++17
      template <class T> inline constexpr bool is_member_function_pointer_v
        = is_member_function_pointer<T>::value;                          // C++17
      template <class T> inline constexpr bool is_enum_v
        = is_enum<T>::value;                                             // C++17
      template <class T> inline constexpr bool is_union_v
        = is_union<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_class_v
        = is_class<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_function_v
        = is_function<T>::value;                                         // C++17

      // See C++14 20.10.4.2, composite type categories
      template <class T> inline constexpr bool is_reference_v
        = is_reference<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_arithmetic_v
        = is_arithmetic<T>::value;                                       // C++17
      template <class T> inline constexpr bool is_fundamental_v
        = is_fundamental<T>::value;                                      // C++17
      template <class T> inline constexpr bool is_object_v
        = is_object<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_scalar_v
        = is_scalar<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_compound_v
        = is_compound<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_member_pointer_v
        = is_member_pointer<T>::value;                                   // C++17
      template <class T> inline constexpr bool is_scoped_enum_v
        = is_scoped_enum<T>::value;                                      // C++2b

      // See C++14 20.10.4.3, type properties
      template <class T> inline constexpr bool is_const_v
        = is_const<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_volatile_v
        = is_volatile<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_trivial_v
        = is_trivial<T>::value;                                          // C++17
      template <class T> inline constexpr bool is_trivially_copyable_v
        = is_trivially_copyable<T>::value;                               // C++17
      template <class T> inline constexpr bool is_standard_layout_v
        = is_standard_layout<T>::value;                                  // C++17
      template <class T> inline constexpr bool is_pod_v
        = is_pod<T>::value;                                              // C++17
      template <class T> inline constexpr bool is_literal_type_v
        = is_literal_type<T>::value;                                     // C++17
      template <class T> inline constexpr bool is_empty_v
        = is_empty<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_polymorphic_v
        = is_polymorphic<T>::value;                                      // C++17
      template <class T> inline constexpr bool is_abstract_v
        = is_abstract<T>::value;                                         // C++17
      template <class T> inline constexpr bool is_final_v
        = is_final<T>::value;                                            // C++17
      template <class T> inline constexpr bool is_aggregate_v
        = is_aggregate<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_signed_v
        = is_signed<T>::value;                                           // C++17
      template <class T> inline constexpr bool is_unsigned_v
        = is_unsigned<T>::value;                                         // C++17
      template <class T, class... Args> inline constexpr bool is_constructible_v
        = is_constructible<T, Args...>::value;                           // C++17
      template <class T> inline constexpr bool is_default_constructible_v
        = is_default_constructible<T>::value;                            // C++17
      template <class T> inline constexpr bool is_copy_constructible_v
        = is_copy_constructible<T>::value;                               // C++17
      template <class T> inline constexpr bool is_move_constructible_v
        = is_move_constructible<T>::value;                               // C++17
      template <class T, class U> inline constexpr bool is_assignable_v
        = is_assignable<T, U>::value;                                    // C++17
      template <class T> inline constexpr bool is_copy_assignable_v
        = is_copy_assignable<T>::value;                                  // C++17
      template <class T> inline constexpr bool is_move_assignable_v
        = is_move_assignable<T>::value;                                  // C++17
      template <class T, class U> inline constexpr bool is_swappable_with_v
        = is_swappable_with<T, U>::value;                                // C++17
      template <class T> inline constexpr bool is_swappable_v
        = is_swappable<T>::value;                                        // C++17
      template <class T> inline constexpr bool is_destructible_v
        = is_destructible<T>::value;                                     // C++17
      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
        = is_trivially_constructible<T, Args...>::value;                 // C++17
      template <class T> inline constexpr bool is_trivially_default_constructible_v
        = is_trivially_default_constructible<T>::value;                  // C++17
      template <class T> inline constexpr bool is_trivially_copy_constructible_v
        = is_trivially_copy_constructible<T>::value;                     // C++17
      template <class T> inline constexpr bool is_trivially_move_constructible_v
        = is_trivially_move_constructible<T>::value;                     // C++17
      template <class T, class U> inline constexpr bool is_trivially_assignable_v
        = is_trivially_assignable<T, U>::value;                          // C++17
      template <class T> inline constexpr bool is_trivially_copy_assignable_v
        = is_trivially_copy_assignable<T>::value;                        // C++17
      template <class T> inline constexpr bool is_trivially_move_assignable_v
        = is_trivially_move_assignable<T>::value;                        // C++17
      template <class T> inline constexpr bool is_trivially_destructible_v
        = is_trivially_destructible<T>::value;                           // C++17
      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
        = is_nothrow_constructible<T, Args...>::value;                   // C++17
      template <class T> inline constexpr bool is_nothrow_default_constructible_v
        = is_nothrow_default_constructible<T>::value;                    // C++17
      template <class T> inline constexpr bool is_nothrow_copy_constructible_v
        = is_nothrow_copy_constructible<T>::value;                       // C++17
      template <class T> inline constexpr bool is_nothrow_move_constructible_v
        = is_nothrow_move_constructible<T>::value;                       // C++17
      template <class T, class U> inline constexpr bool is_nothrow_assignable_v
        = is_nothrow_assignable<T, U>::value;                            // C++17
      template <class T> inline constexpr bool is_nothrow_copy_assignable_v
        = is_nothrow_copy_assignable<T>::value;                          // C++17
      template <class T> inline constexpr bool is_nothrow_move_assignable_v
        = is_nothrow_move_assignable<T>::value;                          // C++17
      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
        = is_nothrow_swappable_with<T, U>::value;                       // C++17
      template <class T> inline constexpr bool is_nothrow_swappable_v
        = is_nothrow_swappable<T>::value;                               // C++17
      template <class T> inline constexpr bool is_nothrow_destructible_v
        = is_nothrow_destructible<T>::value;                             // C++17
      template <class T> inline constexpr bool has_virtual_destructor_v
        = has_virtual_destructor<T>::value;                              // C++17
      template<class T> inline constexpr bool has_unique_object_representations_v // C++17
        = has_unique_object_representations<T>::value;

      // See C++14 20.10.5, type property queries
      template <class T> inline constexpr size_t alignment_of_v
        = alignment_of<T>::value;                                        // C++17
      template <class T> inline constexpr size_t rank_v
        = rank<T>::value;                                                // C++17
      template <class T, unsigned I = 0> inline constexpr size_t extent_v
        = extent<T, I>::value;                                           // C++17

      // See C++14 20.10.6, type relations
      template <class T, class U> inline constexpr bool is_same_v
        = is_same<T, U>::value;                                          // C++17
      template <class Base, class Derived> inline constexpr bool is_base_of_v
        = is_base_of<Base, Derived>::value;                              // C++17
      template <class From, class To> inline constexpr bool is_convertible_v
        = is_convertible<From, To>::value;                               // C++17
      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v
        = is_invocable<Fn, ArgTypes...>::value;                          // C++17
      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v
        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17
      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v
        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17
      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v
        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17

      // [meta.logical], logical operator traits:
      template<class... B> struct conjunction;                           // C++17
      template<class... B>
        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17
      template<class... B> struct disjunction;                           // C++17
      template<class... B>
        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17
      template<class B> struct negation;                                 // C++17
      template<class B>
        inline constexpr bool negation_v = negation<B>::value;           // C++17

}

*/

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 420 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 2
# 425 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3


namespace std { inline namespace __1 {

template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) pair;
template <class _Tp> class __attribute__ ((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) hash;

template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr operator value_type() const noexcept {return value;}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr value_type operator ()() const noexcept {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;


template <bool __b>
using bool_constant = integral_constant<bool, __b>;





typedef bool_constant<(true)> true_type;
typedef bool_constant<(false)> false_type;

template <bool _Val>
using _BoolConstant = integral_constant<bool, _Val>;

template <bool> struct _MetaBase;
template <>
struct _MetaBase<true> {
  template <class _Tp, class _Up>
  using _SelectImpl = _Tp;
  template <template <class...> class _FirstFn, template <class...> class, class ..._Args>
  using _SelectApplyImpl = _FirstFn<_Args...>;
  template <class _First, class...>
  using _FirstImpl = _First;
  template <class, class _Second, class...>
  using _SecondImpl = _Second;
  template <class _Tp = void>
  using _EnableIfImpl = _Tp;
  template <class _Result, class _First, class ..._Rest>
  using _OrImpl = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::template _OrImpl<_First, _Rest...>;
  template <class _Result, class _First, class ..._Rest>
  using _AndImpl = typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::template _AndImpl<_First, _Rest...>;
};

template <>
struct _MetaBase<false> {
  template <class _Tp, class _Up>
  using _SelectImpl = _Up;
  template <template <class...> class, template <class...> class _SecondFn, class ..._Args>
  using _SelectApplyImpl = _SecondFn<_Args...>;
  template <class _Result, class ...>
  using _OrImpl = _Result;
  template <class _Result, class ...>
  using _AndImpl = _Result;
};
template <bool _Cond, class _Ret = void>
using _EnableIf = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
template <bool _Cond, class _IfRes, class _ElseRes>
using _If = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
template <class ..._Rest>
using _Or = typename _MetaBase< sizeof...(_Rest) != 0 >::template _OrImpl<false_type, _Rest...>;
template <class ..._Rest>
using _And = typename _MetaBase< sizeof...(_Rest) != 0 >::template _AndImpl<true_type, _Rest...>;
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
template <class ..._Args>
using _FirstType = typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
template <class ..._Args>
using _SecondType = typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;

template <template <class...> class _Func, class ..._Args>
struct _Lazy : _Func<_Args...> {};

// Member detector base

template <template <class...> class _Templ, class ..._Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class ...>
false_type __sfinae_test_impl(...);

template <template <class ...> class _Templ, class ..._Args>
using _IsValidExpansion = decltype(__sfinae_test_impl<_Templ, _Args...>(0));

template <class>
struct __void_t { typedef void type; };

template <class _Tp>
struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__ ((__type_visibility__("default"))) __dependent_type : public _Tp {};


template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;


// is_same



template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_same : _BoolConstant<__is_same(_Tp, _Up)> { };


template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
# 573 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<

    __is_same(_Tp, _Up)



>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<

    !__is_same(_Tp, _Up)



>;


template <class _Tp>
using __test_for_primary_template = _EnableIf<
    _IsSame<_Tp, typename _Tp::__primary_template>::value
  >;
template <class _Tp>
using __is_primary_template = _IsValidExpansion<
    __test_for_primary_template, _Tp
  >;

struct __two {char __lx[2];};

// helper class:

// is_const



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_const : _BoolConstant<__is_const(_Tp)> { };


template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
# 630 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_volatile



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_volatile : _BoolConstant<__is_volatile(_Tp)> { };


template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
# 655 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// remove_const
# 668 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;




// remove_volatile
# 689 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;




// remove_cv
# 710 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;




// is_void



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_void : _BoolConstant<__is_void(_Tp)> { };


template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
# 743 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// __is_nullptr_t

template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_null_pointer_v
    = is_null_pointer<_Tp>::value;



// is_integral



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_integral : _BoolConstant<__is_integral(_Tp)> { };


template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
# 787 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_floating_point

template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_floating_point_v
    = is_floating_point<_Tp>::value;


// is_array



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_array : _BoolConstant<__is_array(_Tp)> { };


template <class _Tp>
inline constexpr bool is_array_v = __is_array(_Tp);
# 832 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_pointer

// In clang 10.0.0 and earlier __is_pointer didn't work with Objective-C types.
# 847 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __libcpp_remove_objc_qualifiers { typedef _Tp type; };







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_pointer_v
    = is_pointer<_Tp>::value;




// is_reference





template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> { };

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_reference : _BoolConstant<__is_reference(_Tp)> { };


template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);

template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);

template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
# 923 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_union



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 939 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_union_v
    = is_union<_Tp>::value;


// is_class



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 965 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_class_v
    = is_class<_Tp>::value;


// is_function

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public _BoolConstant<

    __is_function(_Tp)



    > {};



template <class _Tp>
inline constexpr bool is_function_v
    = is_function<_Tp>::value;


template <class _Tp> struct __libcpp_is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : _BoolConstant<__is_member_function_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_function_pointer_v
    = __is_member_function_pointer(_Tp);
# 1028 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_member_pointer



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
# 1053 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_member_object_pointer



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : _BoolConstant<__is_member_object_pointer(_Tp)> { };


template <class _Tp>
inline constexpr bool is_member_object_pointer_v
    = __is_member_object_pointer(_Tp);
# 1080 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_enum



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};


template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);
# 1114 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_arithmetic


template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_arithmetic_v
    = is_arithmetic<_Tp>::value;


// is_fundamental

// In clang 9 and lower, this builtin did not work for nullptr_t. Additionally, in C++03 mode,
// nullptr isn't defined by the compiler so, this builtin won't work.
# 1143 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};


template <class _Tp>
inline constexpr bool is_fundamental_v
    = is_fundamental<_Tp>::value;




// is_scalar

// >= 11 because in C++03 nullptr isn't actually nullptr


template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_scalar : _BoolConstant<__is_scalar(_Tp)> { };


template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
# 1194 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_object



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_object : _BoolConstant<__is_object(_Tp)> { };


template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
# 1222 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_compound

// >= 11 because in C++03 nullptr isn't actually nullptr


template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_compound : _BoolConstant<__is_compound(_Tp)> { };


template <class _Tp>
inline constexpr bool is_compound_v = __is_compound(_Tp);
# 1248 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// __is_referenceable  [defns.referenceable]

struct __is_referenceable_impl {
    template <class _Tp> static _Tp& __test(int);
    template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable : integral_constant<bool,
    _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};


// add_const

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const {
  typedef const _Tp type;
};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;


// add_volatile

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile {
  typedef volatile _Tp type;
};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;


// add_cv
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv {
  typedef const volatile _Tp type;
};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;


// remove_reference
# 1298 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};


template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;




// add_lvalue_reference

template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference
{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl { typedef _Tp type; };
template <class _Tp > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_rvalue_reference
{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;


// Suppress deprecation notice for volatile-qualified return type resulting
// from volatile-qualified types _Tp.
#pragma GCC diagnostic push
# 1332 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _Tp> _Tp&& __declval(int);
template <class _Tp> _Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
decltype(std::__1::__declval<_Tp>(0))
declval() noexcept;

// __uncvref

template <class _Tp>
struct __uncvref {
    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp>
struct __unconstref {
    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp>
using __uncvref_t = typename __uncvref<_Tp>::type;


// __is_same_uncvref

template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type,
                                   typename __uncvref<_Up>::type> {};
# 1373 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
struct __any
{
    __any(...);
};

// remove_pointer

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;


// add_pointer

template <class _Tp,
        bool = __is_referenceable<_Tp>::value ||
                _IsSame<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl
    {typedef typename remove_reference<_Tp>::type* type;};
template <class _Tp> struct __add_pointer_impl<_Tp, false>
    {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename __add_pointer_impl<_Tp>::type type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;


// type_identity





// is_signed

// In clang 9 and earlier, this builtin did not work for floating points or enums
# 1428 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public bool_constant<(_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {}; // floating point

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};


template <class _Tp>
inline constexpr bool is_signed_v
    = is_signed<_Tp>::value;




// is_unsigned



template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_unsigned : _BoolConstant<__is_unsigned(_Tp)> { };


template <class _Tp>
inline constexpr bool is_unsigned_v = __is_unsigned(_Tp);
# 1484 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// rank

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};


template <class _Tp>
inline constexpr size_t rank_v
    = rank<_Tp>::value;


// extent



template<class _Tp, size_t _Dim = 0>
struct __attribute__ ((__type_visibility__("default"))) extent
    : integral_constant<size_t, __array_extent(_Tp, _Dim)> { };


template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
# 1533 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// remove_extent

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;


// remove_all_extents

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
# 1579 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// decay

template <class _Up, bool>
struct __decay {
    typedef typename remove_cv<_Up>::type type;
};

template <class _Up>
struct __decay<_Up, true> {
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;


// is_abstract

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};


template <class _Tp>
inline constexpr bool is_abstract_v
    = is_abstract<_Tp>::value;


// is_final

template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};


template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};



template <class _Tp>
inline constexpr bool is_final_v
    = is_final<_Tp>::value;


// is_aggregate


template <class _Tp> struct __attribute__ ((__type_visibility__("default")))
is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};


template <class _Tp>
inline constexpr bool is_aggregate_v
    = is_aggregate<_Tp>::value;




// is_base_of

template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};


template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v
    = is_base_of<_Bp, _Dp>::value;


// __is_core_convertible

// [conv.general]/3 says "E is convertible to T" whenever "T t=E;" is well-formed.
// We can't test for that, but we can test implicit convertibility by passing it
// to a function. Notice that __is_core_convertible<void,void> is false,
// and __is_core_convertible<immovable-type,immovable-type> is true in C++17 and later.

template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(
    static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )
)> : public true_type {};

// is_convertible



template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
# 1760 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _From, class _To>
inline constexpr bool is_convertible_v
    = is_convertible<_From, _To>::value;


// is_nothrow_convertible
# 1791 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_empty



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1823 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_empty_v
    = is_empty<_Tp>::value;


// is_polymorphic



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1849 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_polymorphic_v
    = is_polymorphic<_Tp>::value;


// has_virtual_destructor



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1869 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool has_virtual_destructor_v
    = has_virtual_destructor<_Tp>::value;


// has_unique_object_representations



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_unique_object_representations
    : public integral_constant<bool,
       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};


template <class _Tp>
inline constexpr bool has_unique_object_representations_v
    = has_unique_object_representations<_Tp>::value;




// alignment_of

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};


template <class _Tp>
inline constexpr size_t alignment_of_v
    = alignment_of<_Tp>::value;


// aligned_storage

template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             __fallback_overaligned<_Align>
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 2014 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};
// PE/COFF does not support alignment beyond 8192 (=0x2000)

template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};





// aligned_union

template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};

// __promote

template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};

// make_signed / make_unsigned

typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;



template <class...> using void_t = void;
# 2322 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};


// sub-bullet 3 - "if decay_t<decltype(false ? declval<D1>() : declval<D2>())> ..."
template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up,
                          typename __void_t<decltype(
                                            true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
                                            )>::type>
{
  typedef typename decay<decltype(
                         true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>()
                         )>::type type;
};

template <class, class = void>
struct __common_type_impl {};

// Clang provides variadic templates in C++03 as an extension.


template <class... Tp>
struct __common_types;
template <class... _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type;
# 2361 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
{
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp , _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp , _Rest...> > {
};

// bullet 1 - sizeof...(Tp) == 0

template <>
struct __attribute__ ((__type_visibility__("default"))) common_type<> {};

// bullet 2 - sizeof...(Tp) == 1

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};

// bullet 3 - sizeof...(Tp) == 2

// sub-bullet 1 - "If is_same_v<T1, D1> is false or ..."
template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<
        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        __common_type2_imp<_Tp, _Up>,
        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
    >::type
{};

// bullet 4 - sizeof...(Tp) > 2

template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __attribute__ ((__type_visibility__("default")))
    common_type<_Tp, _Up, _Vp , _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp , _Rest...> > {};




template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;


// is_assignable

template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };



template<class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> { };


template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);
# 2460 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
// is_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_copy_assignable_v
    = is_copy_assignable<_Tp>::value;


// is_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};


template <class _Tp>
inline constexpr bool is_move_assignable_v
    = is_move_assignable<_Tp>::value;


// is_destructible
# 2498 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
//  if it's a reference, return true
//  if it's a function, return false
//  if it's   void,     return false
//  if it's an array of unknown bound, return false
//  Otherwise, return "declval<_Up&>().~_Up()" is well-formed
//    where _Up is remove_all_extents<_Tp>::type

template <class>
struct __is_destructible_apply { typedef int type; };

template <typename _Tp>
struct __is_destructor_wellformed {
    template <typename _Tp1>
    static char __test (
        typename __is_destructible_apply<decltype(std::__1::declval<_Tp1&>().~_Tp1())>::type
    );

    template <typename _Tp1>
    static __two __test (...);

    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool>
struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
   : public std::__1::integral_constant<bool,
        __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public std::__1::true_type {};

template <class _Tp, bool>
struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public std::__1::false_type {};

template <>
struct is_destructible<void>
    : public std::__1::false_type {};


template <class _Tp>
inline constexpr bool is_destructible_v
    = is_destructible<_Tp>::value;




// move

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type& __t) noexcept
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
forward(typename remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!is_lvalue_reference<_Tp>::value,
                  "can not forward an rvalue as an lvalue");
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__1::forward<_Tp>(__t);
}

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};



template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};




template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{
//     typedef ... _ClassType;
//     typedef ... _ReturnType;
//     typedef ... _FnType;
};


template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

// template <class T, class... Args> struct is_constructible;
# 2950 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
    {};







template <class _Tp, class ..._Args>
inline constexpr bool is_constructible_v
    = is_constructible<_Tp, _Args...>::value;


// is_default_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_default_constructible_v
    = is_default_constructible<_Tp>::value;



// First of all, we can't implement this check in C++03 mode because the {}
// default initialization syntax isn't valid.
// Second, we implement the trait in a funny manner with two defaulted template
// arguments to workaround Clang's PR43454.
template <class _Tp>
void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, bool = is_default_constructible<_Tp>::value>
struct __is_implicitly_default_constructible
    : false_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), true>
    : true_type
{ };

template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), false>
    : false_type
{ };


// is_copy_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_copy_constructible_v
    = is_copy_constructible<_Tp>::value;


// is_move_constructible

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_move_constructible_v
    = is_move_constructible<_Tp>::value;


// is_trivially_constructible



template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
# 3079 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
inline constexpr bool is_trivially_constructible_v
    = is_trivially_constructible<_Tp, _Args...>::value;


// is_trivially_default_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_trivially_default_constructible_v
    = is_trivially_default_constructible<_Tp>::value;


// is_trivially_copy_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_copy_constructible_v
    = is_trivially_copy_constructible<_Tp>::value;


// is_trivially_move_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_move_constructible_v
    = is_trivially_move_constructible<_Tp>::value;


// is_trivially_assignable



template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 3155 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
inline constexpr bool is_trivially_assignable_v
    = is_trivially_assignable<_Tp, _Arg>::value;


// is_trivially_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_trivially_copy_assignable_v
    = is_trivially_copy_assignable<_Tp>::value;


// is_trivially_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_trivially_move_assignable_v
    = is_trivially_move_assignable<_Tp>::value;


// is_trivially_destructible



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 3212 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_trivially_destructible_v
    = is_trivially_destructible<_Tp>::value;


// is_nothrow_constructible



template <class _Tp, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 3266 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class ..._Args>
inline constexpr bool is_nothrow_constructible_v
    = is_nothrow_constructible<_Tp, _Args...>::value;


// is_nothrow_default_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v
    = is_nothrow_default_constructible<_Tp>::value;


// is_nothrow_copy_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v
    = is_nothrow_copy_constructible<_Tp>::value;


// is_nothrow_move_constructible

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v
    = is_nothrow_move_constructible<_Tp>::value;


// is_nothrow_assignable



template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
# 3340 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v
    = is_nothrow_assignable<_Tp, _Arg>::value;


// is_nothrow_copy_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};


template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v
    = is_nothrow_copy_assignable<_Tp>::value;


// is_nothrow_move_assignable

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type>
    {};


template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v
    = is_nothrow_move_assignable<_Tp>::value;


// is_nothrow_destructible



template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 3428 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v
    = is_nothrow_destructible<_Tp>::value;


// is_pod



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3451 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp>
inline constexpr bool is_pod_v
    = is_pod<_Tp>::value;


// is_literal_type;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {};


template <class _Tp>
inline constexpr bool is_literal_type_v
    = is_literal_type<_Tp>::value;


// is_standard_layout;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};


template <class _Tp>
inline constexpr bool is_standard_layout_v
    = is_standard_layout<_Tp>::value;


// is_trivially_copyable;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>





    {};


template <class _Tp>
inline constexpr bool is_trivially_copyable_v
    = is_trivially_copyable<_Tp>::value;


// is_trivial;

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};


template <class _Tp>
inline constexpr bool is_trivial_v
    = is_trivial<_Tp>::value;


template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};



template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;

template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;

// __invoke forward declarations

// fall back - none of the bullets





template <class ..._Args>
auto __invoke(__any, _Args&& ...__args) -> __nat;

template <class ..._Args>
auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;

// bullets 1, 2 and 3

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...))) -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...))) -> decltype(((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...); }

// bullets 4, 5 and 6

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f)) -> decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept(__a0.get().*__f)) -> decltype(__a0.get().*__f) { return __a0.get().*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }

template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _A0&& __a0)
noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f)) -> decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }

// bullet 7

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              auto
__invoke(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }

template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto
__invoke_constexpr(_Fp&& __f, _Args&& ...__args)
noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...))) -> decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }



// __invokable
template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
  template <class _XFp, class ..._XArgs>
  static auto __try_call(int) -> decltype(
    std::__1::__invoke(std::__1::declval<_XFp>(), std::__1::declval<_XArgs>()...));
  template <class _XFp, class ..._XArgs>
  static __nat __try_call(...);

  // FIXME: Check that _Ret, _Fp, and _Args... are all complete types, cv void,
  // or incomplete array types as required by the standard.
  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type =
  typename conditional<
      _IsNotSame<_Result, __nat>::value,
      typename conditional<
          is_void<_Ret>::value,
          true_type,
          is_convertible<_Result, _Ret>
      >::type,
      false_type
  >::type;
  static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;

    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;

    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;

template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};



// result_of

template <class _Callable> class result_of;



template <class _Fp, class ..._Args>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};
# 3872 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class _Tp> using result_of_t = typename result_of<_Tp>::type;




// invoke_result

template <class _Fn, class... _Args>
struct __attribute__ ((__type_visibility__("default"))) invoke_result
    : __invoke_of<_Fn, _Args...>
{
};

template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;

// is_invocable

template <class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_invocable
    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_invocable_r
    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class ..._Args>
inline constexpr bool is_invocable_v
    = is_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;

// is_nothrow_invocable

template <class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_invocable
    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};

template <class _Ret, class _Fn, class ..._Args>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};

template <class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;

template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;



template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

// swap, swap_ranges

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type




swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value)
{
    std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

// iter_swap

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
               noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>())))

{
    swap(*__a, *__b);
}

// __swappable

namespace __detail
{
// ALL generic swap overloads MUST already have a declaration available at this point.

template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);

    // Extra parens are needed for the C++03 definition of decltype.
    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

    static const bool value = _IsNotSame<__swap1, __nat>::value
                           && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
  && noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

} // __detail

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};



template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_swappable
    : public conditional<
        __is_referenceable<_Tp>::value,
        is_nothrow_swappable_with<
            typename add_lvalue_reference<_Tp>::type,
            typename add_lvalue_reference<_Tp>::type>,
        false_type
    >::type
{
};

template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v
    = is_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_swappable_v
    = is_swappable<_Tp>::value;

template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v
    = is_nothrow_swappable_with<_Tp, _Up>::value;

template <class _Tp>
inline constexpr bool is_nothrow_swappable_v
    = is_nothrow_swappable<_Tp>::value;



template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __convert_to_integral(int __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
long __convert_to_integral(long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }

template<typename _Fp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) { return __val; }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }



template <class _Tp>
struct __has_operator_addressof_member_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof_free_imp
{
    template <class _Up>
        static auto __test(int)
            -> typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())), true_type>::type;
    template <class>
        static auto __test(long) -> false_type;

    static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value
                                  || __has_operator_addressof_free_imp<_Tp>::value>
{};



// is_scoped_enum [meta.unary.prop]
# 4219 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
template <class... _Args>
struct conjunction : _And<_Args...> {};
template<class... _Args>
inline constexpr bool conjunction_v
    = conjunction<_Args...>::value;

template <class... _Args>
struct disjunction : _Or<_Args...> {};
template<class... _Args>
inline constexpr bool disjunction_v
    = disjunction<_Args...>::value;

template <class _Tp>
struct negation : _Not<_Tp> {};
template<class _Tp>
inline constexpr bool negation_v
    = negation<_Tp>::value;


// These traits are used in __tree and __hash_table
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};

// __can_extract_map_key uses true_type/false_type instead of the tags.
// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
// and _ValTy == _Key.
template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};

// This specialization returns __extract_key_fail_tag for non-map containers
// because _Key == _ContainerValueTy
template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
# 4276 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/type_traits" 3
inline constexpr
bool __libcpp_is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }





template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

} }


// std::byte
namespace std // purposefully not versioned
{


}
# 651 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstring" 1
// -*- C++ -*-
//===--------------------------- cstring ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cstring synopsis

Macros:

    NULL

namespace std
{

Types:

    size_t

void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
void* memmove(void* s1, const void* s2, size_t n);
char* strcpy (char* restrict s1, const char* restrict s2);
char* strncpy(char* restrict s1, const char* restrict s2, size_t n);
char* strcat (char* restrict s1, const char* restrict s2);
char* strncat(char* restrict s1, const char* restrict s2, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
int strcmp (const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n);
int strcoll(const char* s1, const char* s2);
size_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);
const void* memchr(const void* s, int c, size_t n);
      void* memchr(      void* s, int c, size_t n);
const char* strchr(const char* s, int c);
      char* strchr(      char* s, int c);
size_t strcspn(const char* s1, const char* s2);
const char* strpbrk(const char* s1, const char* s2);
      char* strpbrk(      char* s1, const char* s2);
const char* strrchr(const char* s, int c);
      char* strrchr(      char* s, int c);
size_t strspn(const char* s1, const char* s2);
const char* strstr(const char* s1, const char* s2);
      char* strstr(      char* s1, const char* s2);
char* strtok(char* restrict s1, const char* restrict s2);
void* memset(void* s, int c, size_t n);
char* strerror(int errnum);
size_t strlen(const char* s);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 60 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstring" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string.h" 1
// -*- C++ -*-
//===--------------------------- string.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    string.h synopsis

Macros:

    NULL

Types:

    size_t

void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
void* memmove(void* s1, const void* s2, size_t n);
char* strcpy (char* restrict s1, const char* restrict s2);
char* strncpy(char* restrict s1, const char* restrict s2, size_t n);
char* strcat (char* restrict s1, const char* restrict s2);
char* strncat(char* restrict s1, const char* restrict s2, size_t n);
int memcmp(const void* s1, const void* s2, size_t n);
int strcmp (const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n);
int strcoll(const char* s1, const char* s2);
size_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);
const void* memchr(const void* s, int c, size_t n);
      void* memchr(      void* s, int c, size_t n);
const char* strchr(const char* s, int c);
      char* strchr(      char* s, int c);
size_t strcspn(const char* s1, const char* s2);
const char* strpbrk(const char* s1, const char* s2);
      char* strpbrk(      char* s1, const char* s2);
const char* strrchr(const char* s, int c);
      char* strrchr(      char* s, int c);
size_t strspn(const char* s1, const char* s2);
const char* strstr(const char* s1, const char* s2);
      char* strstr(      char* s1, const char* s2);
char* strtok(char* restrict s1, const char* restrict s2);
void* memset(void* s, int c, size_t n);
char* strerror(int errnum);
size_t strlen(const char* s);

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 55 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string.h" 2
# 58 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 1 3
// -*- C++ -*-
//===--------------------------- string.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 61 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string.h" 2 3

// MSVCRT, GNU libc and its derivates may already have the correct prototype in
// <string.h>. This macro can be defined by users if their C library provides
// the right signature.






extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strchr( char* __s, int __c) {return __libcpp_strchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strpbrk( char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strrchr( char* __s, int __c) {return __libcpp_strrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      void* memchr( void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      char* strstr( char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}
}
# 61 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstring" 2
# 64 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstring" 3


namespace std { inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }
# 652 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 1
// -*- C++ -*-
//===-------------------------- utility -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    utility synopsis

#include <initializer_list>

namespace std
{

template <class T>
    void
    swap(T& a, T& b);

namespace rel_ops
{
    template<class T> bool operator!=(const T&, const T&);
    template<class T> bool operator> (const T&, const T&);
    template<class T> bool operator<=(const T&, const T&);
    template<class T> bool operator>=(const T&, const T&);
}

template<class T>
void
swap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&
                          is_nothrow_move_assignable<T>::value);

template <class T, size_t N>
void
swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14
template <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14

template <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14

template <class T>
    typename conditional
    <
        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,
        const T&,
        T&&
    >::type
    move_if_noexcept(T& x) noexcept; // constexpr in C++14

template <class T> constexpr add_const_t<T>& as_const(T& t) noexcept;      // C++17
template <class T>                      void as_const(const T&&) = delete; // C++17

template <class T> typename add_rvalue_reference<T>::type declval() noexcept;

template <class T1, class T2>
struct pair
{
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;

    pair(const pair&) = default;
    pair(pair&&) = default;
    explicit(see-below) constexpr pair();
    explicit(see-below) pair(const T1& x, const T2& y);                          // constexpr in C++14
    template <class U, class V> explicit(see-below) pair(U&& x, V&& y);          // constexpr in C++14
    template <class U, class V> explicit(see-below) pair(const pair<U, V>& p);   // constexpr in C++14
    template <class U, class V> explicit(see-below) pair(pair<U, V>&& p);        // constexpr in C++14
    template <class... Args1, class... Args2>
        pair(piecewise_construct_t, tuple<Args1...> first_args,
             tuple<Args2...> second_args);

    template <class U, class V> pair& operator=(const pair<U, V>& p);
    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&
                                       is_nothrow_move_assignable<T2>::value);
    template <class U, class V> pair& operator=(pair<U, V>&& p);

    void swap(pair& p) noexcept(is_nothrow_swappable_v<T1> &&
                                is_nothrow_swappable_v<T2>);
};

template <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14
template <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14

template <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14
template <class T1, class T2>
void
swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));

struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
inline constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();

template <class T> struct tuple_size;
template <size_t I, class T> struct tuple_element;

template <class T1, class T2> struct tuple_size<pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;
template <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;

template<size_t I, class T1, class T2>
    typename tuple_element<I, pair<T1, T2> >::type&
    get(pair<T1, T2>&) noexcept; // constexpr in C++14

template<size_t I, class T1, class T2>
    const typename tuple_element<I, pair<T1, T2> >::type&
    get(const pair<T1, T2>&) noexcept; // constexpr in C++14

template<size_t I, class T1, class T2>
    typename tuple_element<I, pair<T1, T2> >::type&&
    get(pair<T1, T2>&&) noexcept; // constexpr in C++14

template<size_t I, class T1, class T2>
    const typename tuple_element<I, pair<T1, T2> >::type&&
    get(const pair<T1, T2>&&) noexcept; // constexpr in C++14

template<class T1, class T2>
    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14

template<class T1, class T2>
    constexpr const T1& get(const pair<T1, T2>&) noexcept; // C++14

template<class T1, class T2>
    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14

template<class T1, class T2>
    constexpr const T1&& get(const pair<T1, T2>&&) noexcept; // C++14

template<class T1, class T2>
    constexpr T1& get(pair<T2, T1>&) noexcept; // C++14

template<class T1, class T2>
    constexpr const T1& get(const pair<T2, T1>&) noexcept; // C++14

template<class T1, class T2>
    constexpr T1&& get(pair<T2, T1>&&) noexcept; // C++14

template<class T1, class T2>
    constexpr const T1&& get(const pair<T2, T1>&&) noexcept; // C++14

// C++14

template<class T, T... I>
struct integer_sequence
{
    typedef T value_type;

    static constexpr size_t size() noexcept;
};

template<size_t... I>
  using index_sequence = integer_sequence<size_t, I...>;

template<class T, T N>
  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;
template<size_t N>
  using make_index_sequence = make_integer_sequence<size_t, N>;

template<class... T>
  using index_sequence_for = make_index_sequence<sizeof...(T)>;

template<class T, class U=T>
    T exchange(T& obj, U&& new_value);

// 20.2.7, in-place construction // C++17
struct in_place_t {
  explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};
template <class T>
  struct in_place_type_t {
    explicit in_place_type_t() = default;
  };
template <class T>
  inline constexpr in_place_type_t<T> in_place_type{};
template <size_t I>
  struct in_place_index_t {
    explicit in_place_index_t() = default;
  };
template <size_t I>
  inline constexpr in_place_index_t<I> in_place_index{};

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 199 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tuple" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tuple" 2
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tuple" 3



namespace std { inline namespace __1 {

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_size;


template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};







template <size_t _Ip, class _Tp> struct __attribute__ ((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};

// tuple specializations



template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 140 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;







template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};


template <class ..._Tp> class __attribute__ ((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};

template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;



// pair specializations

template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;


// array specializations

template <class _Tp, size_t _Size> struct __attribute__ ((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;




// __tuple_types

template <class ..._Tp> struct __tuple_types {};
# 280 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tuple" 3
template <size_t _Ip, class ..._Types>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>>
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __type_pack_element<_Ip, _Types...> type;
};


template <class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp&;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;

// __make_tuple_types

// __make_tuple_types<_Tuple<_Types...>, _Ep, _Sp>::type is a
// __tuple_types<_Types...> using only those _Types in the range [_Sp, _Ep).
// _Sp defaults to 0 and _Ep defaults to tuple_size<_Tuple>.  If _Tuple is a
// lvalue_reference type, then __tuple_types<_Types&...> is the result.

template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {
  // Specialization for pair, tuple, and __tuple_types
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};

template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool ..._Preds>
struct __all_dummy;

template <bool ..._Pred>
using __all = _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};

// __tuple_convertible

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};

// __tuple_constructible

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};

// __tuple_assignable

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};


template <size_t _Ip, class ..._Tp>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;


template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size = __tuple_like_with_size_imp<
                                   __tuple_like<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;

struct __attribute__ ((__visibility__("default"))) __check_tuple_constructor_fail {

    static constexpr bool __enable_explicit_default() { return false; }
    static constexpr bool __enable_implicit_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};




template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};

template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};


} }
# 200 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 2




# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdint" 1
// -*- C++ -*-
//===--------------------------- cstdint ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cstdint synopsis

Macros:

    INT8_MIN
    INT16_MIN
    INT32_MIN
    INT64_MIN

    INT8_MAX
    INT16_MAX
    INT32_MAX
    INT64_MAX

    UINT8_MAX
    UINT16_MAX
    UINT32_MAX
    UINT64_MAX

    INT_LEAST8_MIN
    INT_LEAST16_MIN
    INT_LEAST32_MIN
    INT_LEAST64_MIN

    INT_LEAST8_MAX
    INT_LEAST16_MAX
    INT_LEAST32_MAX
    INT_LEAST64_MAX

    UINT_LEAST8_MAX
    UINT_LEAST16_MAX
    UINT_LEAST32_MAX
    UINT_LEAST64_MAX

    INT_FAST8_MIN
    INT_FAST16_MIN
    INT_FAST32_MIN
    INT_FAST64_MIN

    INT_FAST8_MAX
    INT_FAST16_MAX
    INT_FAST32_MAX
    INT_FAST64_MAX

    UINT_FAST8_MAX
    UINT_FAST16_MAX
    UINT_FAST32_MAX
    UINT_FAST64_MAX

    INTPTR_MIN
    INTPTR_MAX
    UINTPTR_MAX

    INTMAX_MIN
    INTMAX_MAX

    UINTMAX_MAX

    PTRDIFF_MIN
    PTRDIFF_MAX

    SIG_ATOMIC_MIN
    SIG_ATOMIC_MAX

    SIZE_MAX

    WCHAR_MIN
    WCHAR_MAX

    WINT_MIN
    WINT_MAX

    INT8_C(value)
    INT16_C(value)
    INT32_C(value)
    INT64_C(value)

    UINT8_C(value)
    UINT16_C(value)
    UINT32_C(value)
    UINT64_C(value)

    INTMAX_C(value)
    UINTMAX_C(value)

namespace std
{

Types:

    int8_t
    int16_t
    int32_t
    int64_t

    uint8_t
    uint16_t
    uint32_t
    uint64_t

    int_least8_t
    int_least16_t
    int_least32_t
    int_least64_t

    uint_least8_t
    uint_least16_t
    uint_least32_t
    uint_least64_t

    int_fast8_t
    int_fast16_t
    int_fast32_t
    int_fast64_t

    uint_fast8_t
    uint_fast16_t
    uint_fast32_t
    uint_fast64_t

    intptr_t
    uintptr_t

    intmax_t
    uintmax_t

}  // std
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 144 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdint" 2
# 148 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdint" 3


namespace std { inline namespace __1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 205 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 1
// -*- C++ -*-
//===--------------------------- __debug ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iosfwd" 1
// -*- C++ -*-
//===--------------------------- iosfwd -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    iosfwd synopsis

namespace std
{

template<class charT> struct char_traits;
template<>            struct char_traits<char>;
template<>            struct char_traits<char8_t>;  // C++20
template<>            struct char_traits<char16_t>;
template<>            struct char_traits<char32_t>;
template<>            struct char_traits<wchar_t>;

template<class T>     class allocator;

class ios_base;
template <class charT, class traits = char_traits<charT> > class basic_ios;

template <class charT, class traits = char_traits<charT> > class basic_streambuf;
template <class charT, class traits = char_traits<charT> > class basic_istream;
template <class charT, class traits = char_traits<charT> > class basic_ostream;
template <class charT, class traits = char_traits<charT> > class basic_iostream;

template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_stringbuf;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_istringstream;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_ostringstream;
template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
    class basic_stringstream;

template <class charT, class traits = char_traits<charT> > class basic_filebuf;
template <class charT, class traits = char_traits<charT> > class basic_ifstream;
template <class charT, class traits = char_traits<charT> > class basic_ofstream;
template <class charT, class traits = char_traits<charT> > class basic_fstream;

template <class charT, class traits = char_traits<charT> > class istreambuf_iterator;
template <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;

typedef basic_ios<char>              ios;
typedef basic_ios<wchar_t>           wios;

typedef basic_streambuf<char>        streambuf;
typedef basic_istream<char>          istream;
typedef basic_ostream<char>          ostream;
typedef basic_iostream<char>         iostream;

typedef basic_stringbuf<char>        stringbuf;
typedef basic_istringstream<char>    istringstream;
typedef basic_ostringstream<char>    ostringstream;
typedef basic_stringstream<char>     stringstream;

typedef basic_filebuf<char>          filebuf;
typedef basic_ifstream<char>         ifstream;
typedef basic_ofstream<char>         ofstream;
typedef basic_fstream<char>          fstream;

typedef basic_streambuf<wchar_t>     wstreambuf;
typedef basic_istream<wchar_t>       wistream;
typedef basic_ostream<wchar_t>       wostream;
typedef basic_iostream<wchar_t>      wiostream;

typedef basic_stringbuf<wchar_t>     wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t>  wstringstream;

typedef basic_filebuf<wchar_t>       wfilebuf;
typedef basic_ifstream<wchar_t>      wifstream;
typedef basic_ofstream<wchar_t>      wofstream;
typedef basic_fstream<wchar_t>       wfstream;

template <class state> class fpos;
typedef fpos<char_traits<char>::state_type>    streampos;
typedef fpos<char_traits<wchar_t>::state_type> wstreampos;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 95 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iosfwd" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 1
// -*- C++ -*-
//===--------------------------- wchar.h ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 21 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h"
/*
    wchar.h synopsis

Macros:

    NULL
    WCHAR_MAX
    WCHAR_MIN
    WEOF

Types:

    mbstate_t
    size_t
    tm
    wint_t

int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
int vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
int vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
int vwprintf(const wchar_t* restrict format, va_list arg);
int vwscanf(const wchar_t* restrict format, va_list arg);  // C99
int wprintf(const wchar_t* restrict format, ...);
int wscanf(const wchar_t* restrict format, ...);
wint_t fgetwc(FILE* stream);
wchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
wint_t fputwc(wchar_t c, FILE* stream);
int fputws(const wchar_t* restrict s, FILE* restrict stream);
int fwide(FILE* stream, int mode);
wint_t getwc(FILE* stream);
wint_t getwchar();
wint_t putwc(wchar_t c, FILE* stream);
wint_t putwchar(wchar_t c);
wint_t ungetwc(wint_t c, FILE* stream);
double wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
float wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
long double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
long wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
long long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
unsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
unsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
wchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
int wcscmp(const wchar_t* s1, const wchar_t* s2);
int wcscoll(const wchar_t* s1, const wchar_t* s2);
int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
size_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
      wchar_t* wcschr(      wchar_t* s, wchar_t c);
size_t wcscspn(const wchar_t* s1, const wchar_t* s2);
size_t wcslen(const wchar_t* s);
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
size_t wcsspn(const wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
wchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
int wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
size_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
                const tm* restrict timeptr);
wint_t btowc(int c);
int wctob(wint_t c);
int mbsinit(const mbstate_t* ps);
size_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
size_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
                 mbstate_t* restrict ps);
size_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
                 mbstate_t* restrict ps);

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 109 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stddef.h" 1
// -*- C++ -*-
//===--------------------------- stddef.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 110 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 2
# 113 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 1 3
// -*- C++ -*-
//===--------------------------- wchar.h ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 120 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 2 3

// Determine whether we have const-correct overloads for wcschr and friends.
# 135 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
# 96 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iosfwd" 2
# 99 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iosfwd" 3


namespace std { inline namespace __1 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__type_visibility__("default"))) char_traits;
template<> struct char_traits<char>;



template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(istringstream))) __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(ostringstream))) __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringstream))) __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

template <class _State> class __attribute__ ((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff; // for char_traits in <string>


template <class _CharT, // for <stdexcept>
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(string))) __attribute__((__preferred_name__(wstring))) basic_string;

// Include other forward declarations here
template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__ ((__type_visibility__("default"))) vector;

template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;

    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;

    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};

} }
# 15 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 2
# 18 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 3
# 47 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 3
namespace std { inline namespace __1 {

struct __attribute__ ((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)
    : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  __attribute__ ((__visibility__("default"))) string what() const;

  const char* __file_;
  int __line_;
  const char* __pred_;
  const char* __msg_;
};

/// __libcpp_debug_function_type - The type of the assertion failure handler.
typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);

/// __libcpp_debug_function - The handler function called when a _LIBCPP_ASSERT
///    fails.
extern __attribute__((__visibility__("default"))) __libcpp_debug_function_type __libcpp_debug_function;

/// __libcpp_abort_debug_function - A debug handler that aborts when called.
[[noreturn]] __attribute__ ((__visibility__("default")))
void __libcpp_abort_debug_function(__libcpp_debug_info const&);

/// __libcpp_set_debug_function - Set the debug handler to the specified
///    function.
__attribute__ ((__visibility__("default")))
bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 271 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__debug" 3
} }
# 207 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 2
# 210 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3


namespace std { inline namespace __1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

} // rel_ops

// swap_ranges is defined in <type_traits>`

// swap is defined in <type_traits>

// move_if_noexcept

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) noexcept
{
    return std::__1::move(__x);
}


template <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }
template <class _Tp> void as_const(const _Tp&&) = delete;


struct __attribute__ ((__type_visibility__("default"))) piecewise_construct_t { explicit piecewise_construct_t() = default; };



/* _LIBCPP_INLINE_VAR */ constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 296 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) pair



{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;


    pair(pair const&) = default;
    pair(pair&&) = default;
# 333 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
    template <bool _Val>
    using _EnableB = typename enable_if<_Val, bool>::type;

    struct _CheckArgs {
      template <int&...>
      static constexpr bool __enable_explicit_default() {
          return is_default_constructible<_T1>::value
              && is_default_constructible<_T2>::value
              && !__enable_implicit_default<>();
      }

      template <int&...>
      static constexpr bool __enable_implicit_default() {
          return __is_implicitly_default_constructible<_T1>::value
              && __is_implicitly_default_constructible<_T2>::value;
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && (!is_convertible<_U1, first_type>::value
                  || !is_convertible<_U2, second_type>::value);
      }

      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value
              && is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
    };

    template <bool _MaybeEnable>
    using _CheckArgsDep = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;

    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };

    template <class _Tuple>
    using _CheckTLC = typename conditional<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >::type;

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_explicit_default()
    > = false>
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::__enable_implicit_default()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)

        : first(), second() {}

    template <bool _Dummy = true, _EnableB<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<bool _Dummy = true, _EnableB<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)

        : first(__t1), second(__t2) {}

    template<class _U1, class _U2, _EnableB<
             _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))

        : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))

        : first(__p.first), second(__p.second) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _U1, class _U2, _EnableB<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))

        : first(std::__1::forward<_U1>(__p.first)), second(std::__1::forward<_U2>(__p.second)) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template<class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pair(_Tuple&& __p)
        : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
          second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

    template <class... _Args1, class... _Args2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))

        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(typename conditional<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat>::type const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(typename conditional<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>::type&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)

    {
        first = std::__1::forward<first_type>(__p.first);
        second = std::__1::forward<second_type>(__p.second);
        return *this;
    }

    template <class _Tuple, _EnableB<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     > = false>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair& operator=(_Tuple&& __p) {
        first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
        second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
        return *this;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)

    {
        using std::__1::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair(piecewise_construct_t,
         tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
         __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};


template<class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;


template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))

{
    __x.swap(__y);
}

template <class _Tp>
struct __unwrap_reference { typedef _Tp type; };

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef _Tp& type; };
# 650 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
template <class _Tp>
struct __unwrap_ref_decay



    : __unwrap_reference<typename decay<_Tp>::type>

{ };



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
# 682 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
template <class _T1, class _T2>
  struct __attribute__ ((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
    typedef _T1 type;
};

template <class _T1, class _T2>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
    typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T1>(__p.first);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T1>(__p.first);}

};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}


    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<_T2>(__p.second);}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::__1::forward<const _T2>(__p.second);}

};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}


template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::__1::move(__p));
}



template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::__1::move(__p));
}





template<class _Tp, _Tp... _Ip>
struct __attribute__ ((__type_visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;



template <class _Tp, _Tp _Ep>
using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 903 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;




template<class _T1, class _T2 = _T1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__1::move(__obj);
    __obj = std::__1::forward<_T2>(__new_value);
    return __old_value;
}




struct __attribute__ ((__visibility__("default"))) in_place_t {
    explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) in_place_type_t {
    explicit in_place_type_t() = default;
};
template <class _Tp>
inline constexpr in_place_type_t<_Tp> in_place_type{};

template <size_t _Idx>
struct __attribute__ ((__visibility__("default"))) in_place_index_t {
    explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};

template <class _Tp> struct __is_inplace_type_imp : false_type {};
template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};

template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;

template <class _Tp> struct __is_inplace_index_imp : false_type {};
template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};

template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;



template <class _Arg, class _Result>
struct __attribute__ ((__type_visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::__1::memcpy(&__r, __p, sizeof(__r));
    return __r;
}

// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t
// is 64 bits.  This is because cityhash64 uses 64bit x 64bit
// multiplication, which can be very slow on 32-bit systems.
template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};

// murmur2
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
        [[fallthrough]];
    case 2:
        __h ^= __data[1] << 8;
        [[fallthrough]];
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));

 private:
  // Some primes between 2^63 and 2^64.
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }

  // Return a 16-byte hash for 48 bytes.  Quick and dirty.
  // Callers do best to use "random-looking" values for a and b.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }

  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }

  // Return an 8-byte hash for 33 to 64 bytes.
  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

// cityhash64
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }

  // For strings over 64 bytes we hash the end first, and then as we
  // loop we keep 56 bytes of state: v, w, x, y, and z.
  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);

  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.
  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::__1::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};


template <>
struct __attribute__ ((__type_visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};
# 1379 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};



template <>
struct __attribute__ ((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(float __v) const noexcept
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(double __v) const noexcept
    {
        // -0.0 and 0.0 should return same hash
       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(long double __v) const noexcept
    {
        // -0.0 and 0.0 should return same hash
        if (__v == 0.0L)
            return 0;
# 1554 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/utility" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};



template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash : public __enum_hash<_Tp>
{
};




template <>
struct __attribute__ ((__type_visibility__("default"))) hash<nullptr_t>
  : public unary_function<nullptr_t, size_t>
{
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  size_t operator()(nullptr_t) const noexcept {
    return 662607004ull;
  }
};



template <class _Key, class _Hash>
using __check_hash_requirements = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;

template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;


template <class _Type, class>
using __enable_hash_helper_imp = _Type;

template <class _Type, class ..._Keys>
using __enable_hash_helper = __enable_hash_helper_imp<_Type,
  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type
>;







} }
# 653 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 1
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    memory synopsis

namespace std
{

struct allocator_arg_t { };
inline constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template <class T, class Alloc> struct uses_allocator;

template <class Ptr>
struct pointer_traits
{
    typedef Ptr pointer;
    typedef <details> element_type;
    typedef <details> difference_type;

    template <class U> using rebind = <details>;

    static pointer pointer_to(<details>);
};

template <class T>
struct pointer_traits<T*>
{
    typedef T* pointer;
    typedef T element_type;
    typedef ptrdiff_t difference_type;

    template <class U> using rebind = U*;

    static pointer pointer_to(<details>) noexcept; // constexpr in C++20
};

template <class T> constexpr T* to_address(T* p) noexcept; // C++20
template <class Ptr> constexpr auto to_address(const Ptr& p) noexcept; // C++20

template <class Alloc>
struct allocator_traits
{
    typedef Alloc                        allocator_type;
    typedef typename allocator_type::value_type
                                         value_type;

    typedef Alloc::pointer | value_type* pointer;
    typedef Alloc::const_pointer
          | pointer_traits<pointer>::rebind<const value_type>
                                         const_pointer;
    typedef Alloc::void_pointer
          | pointer_traits<pointer>::rebind<void>
                                         void_pointer;
    typedef Alloc::const_void_pointer
          | pointer_traits<pointer>::rebind<const void>
                                         const_void_pointer;
    typedef Alloc::difference_type
          | pointer_traits<pointer>::difference_type
                                         difference_type;
    typedef Alloc::size_type
          | make_unsigned<difference_type>::type
                                         size_type;
    typedef Alloc::propagate_on_container_copy_assignment
          | false_type                   propagate_on_container_copy_assignment;
    typedef Alloc::propagate_on_container_move_assignment
          | false_type                   propagate_on_container_move_assignment;
    typedef Alloc::propagate_on_container_swap
          | false_type                   propagate_on_container_swap;
    typedef Alloc::is_always_equal
          | is_empty                     is_always_equal;

    template <class T> using rebind_alloc  = Alloc::rebind<T>::other | Alloc<T, Args...>;
    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;

    static pointer allocate(allocator_type& a, size_type n);                          // constexpr and [[nodiscard]] in C++20
    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint); // constexpr and [[nodiscard]] in C++20

    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept; // constexpr in C++20

    template <class T, class... Args>
    static void construct(allocator_type& a, T* p, Args&&... args); // constexpr in C++20

    template <class T>
    static void destroy(allocator_type& a, T* p); // constexpr in C++20

    static size_type max_size(const allocator_type& a); // noexcept in C++14, constexpr in C++20
    static allocator_type select_on_container_copy_construction(const allocator_type& a); // constexpr in C++20
};

template <>
class allocator<void> // deprecated in C++17, removed in C++20
{
public:
    typedef void*                                 pointer;
    typedef const void*                           const_pointer;
    typedef void                                  value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <class T>
class allocator
{
public:
    typedef size_t    size_type;
    typedef ptrdiff_t difference_type;
    typedef T*        pointer;                           // deprecated in C++17, removed in C++20
    typedef const T*  const_pointer;                     // deprecated in C++17, removed in C++20
    typedef typename add_lvalue_reference<T>::type
                      reference;                         // deprecated in C++17, removed in C++20
    typedef typename add_lvalue_reference<const T>::type
                      const_reference;                   // deprecated in C++17, removed in C++20

    typedef T         value_type;

    template <class U> struct rebind {typedef allocator<U> other;}; // deprecated in C++17, removed in C++20

    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    constexpr allocator() noexcept;                      // constexpr in C++20
    constexpr allocator(const allocator&) noexcept;      // constexpr in C++20
    template <class U>
      constexpr allocator(const allocator<U>&) noexcept; // constexpr in C++20
    ~allocator();                                        // constexpr in C++20
    pointer address(reference x) const noexcept;             // deprecated in C++17, removed in C++20
    const_pointer address(const_reference x) const noexcept; // deprecated in C++17, removed in C++20
    T* allocate(size_t n, const void* hint);          // deprecated in C++17, removed in C++20
    T* allocate(size_t n);                              // constexpr in C++20
    void deallocate(T* p, size_t n) noexcept;           // constexpr in C++20
    size_type max_size() const noexcept;              // deprecated in C++17, removed in C++20
    template<class U, class... Args>
        void construct(U* p, Args&&... args);         // deprecated in C++17, removed in C++20
    template <class U>
        void destroy(U* p);                           // deprecated in C++17, removed in C++20
};

template <class T, class U>
bool operator==(const allocator<T>&, const allocator<U>&) noexcept; // constexpr in C++20

template <class T, class U>
bool operator!=(const allocator<T>&, const allocator<U>&) noexcept; // constexpr in C++20

template <class OutputIterator, class T>
class raw_storage_iterator
    : public iterator<output_iterator_tag,
                      T,                               // purposefully not C++03
                      ptrdiff_t,                       // purposefully not C++03
                      T*,                              // purposefully not C++03
                      raw_storage_iterator&>           // purposefully not C++03
{
public:
    explicit raw_storage_iterator(OutputIterator x);
    raw_storage_iterator& operator*();
    raw_storage_iterator& operator=(const T& element);
    raw_storage_iterator& operator++();
    raw_storage_iterator  operator++(int);
};

template <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
template <class T> void               return_temporary_buffer(T* p) noexcept;

template <class T> T* addressof(T& r) noexcept;
template <class T> T* addressof(const T&& r) noexcept = delete;

template <class InputIterator, class ForwardIterator>
ForwardIterator
uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);

template <class InputIterator, class Size, class ForwardIterator>
ForwardIterator
uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);

template <class ForwardIterator, class T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);

template <class ForwardIterator, class Size, class T>
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

template <class T, class ...Args>
constexpr T* construct_at(T* location, Args&& ...args); // since C++20

template <class T>
void destroy_at(T* location); // constexpr in C++20

template <class ForwardIterator>
void destroy(ForwardIterator first, ForwardIterator last); // constexpr in C++20

template <class ForwardIterator, class Size>
ForwardIterator destroy_n(ForwardIterator first, Size n); // constexpr in C++20

template <class InputIterator, class ForwardIterator>
 ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);

template <class InputIterator, class Size, class ForwardIterator>
 pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);

template <class ForwardIterator>
 void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Size>
 ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);

template <class ForwardIterator>
 void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);

template <class ForwardIterator, class Size>
 ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);

template <class Y> struct auto_ptr_ref {};      // deprecated in C++11, removed in C++17

template<class X>
class auto_ptr                                  // deprecated in C++11, removed in C++17
{
public:
    typedef X element_type;

    explicit auto_ptr(X* p =0) throw();
    auto_ptr(auto_ptr&) throw();
    template<class Y> auto_ptr(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr&) throw();
    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
    auto_ptr& operator=(auto_ptr_ref<X> r) throw();
    ~auto_ptr() throw();

    typename add_lvalue_reference<X>::type operator*() const throw();
    X* operator->() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    auto_ptr(auto_ptr_ref<X>) throw();
    template<class Y> operator auto_ptr_ref<Y>() throw();
    template<class Y> operator auto_ptr<Y>() throw();
};

template <class T>
struct default_delete
{
    constexpr default_delete() noexcept = default;
    template <class U> default_delete(const default_delete<U>&) noexcept;

    void operator()(T*) const noexcept;
};

template <class T>
struct default_delete<T[]>
{
    constexpr default_delete() noexcept = default;
    void operator()(T*) const noexcept;
    template <class U> void operator()(U*) const = delete;
};

template <class T, class D = default_delete<T>>
class unique_ptr
{
public:
    typedef see below pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, see below d1) noexcept;
    unique_ptr(pointer p, see below d2) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    unique_ptr(nullptr_t) noexcept : unique_ptr() { }
    template <class U, class E>
        unique_ptr(unique_ptr<U, E>&& u) noexcept;
    template <class U>
        unique_ptr(auto_ptr<U>&& u) noexcept;       // removed in C++17

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    typename add_lvalue_reference<T>::type operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(unique_ptr& u) noexcept;
};

template <class T, class D>
class unique_ptr<T[], D>
{
public:
    typedef implementation-defined pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr unique_ptr() noexcept;
    explicit unique_ptr(pointer p) noexcept;
    unique_ptr(pointer p, see below d) noexcept;
    unique_ptr(pointer p, see below d) noexcept;
    unique_ptr(unique_ptr&& u) noexcept;
    unique_ptr(nullptr_t) noexcept : unique_ptr() { }

    // destructor
    ~unique_ptr();

    // assignment
    unique_ptr& operator=(unique_ptr&& u) noexcept;
    unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
  template <class U> void reset(U) = delete;
    void swap(unique_ptr& u) noexcept;
};

template <class T, class D>
    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;

template <class T1, class D1, class T2, class D2>
    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);

template <class T, class D>
    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;
template <class T, class D>
    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;

template <class T, class D>
    bool operator<(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>(nullptr_t, const unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);

class bad_weak_ptr
    : public std::exception
{
    bad_weak_ptr() noexcept;
};

template<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14
template<class T>                unique_ptr<T> make_unique(size_t n);           // C++14
template<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]

template<class E, class T, class Y, class D>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, unique_ptr<Y, D> const& p);

template<class T>
class shared_ptr
{
public:
    typedef T element_type;
    typedef weak_ptr<T> weak_type; // C++17

    // constructors:
    constexpr shared_ptr() noexcept;
    template<class Y> explicit shared_ptr(Y* p);
    template<class Y, class D> shared_ptr(Y* p, D d);
    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
    template <class D> shared_ptr(nullptr_t p, D d);
    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
    shared_ptr(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
    shared_ptr(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
    template<class Y> shared_ptr(auto_ptr<Y>&& r);          // removed in C++17
    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
    shared_ptr(nullptr_t) : shared_ptr() { }

    // destructor:
    ~shared_ptr();

    // assignment:
    shared_ptr& operator=(const shared_ptr& r) noexcept;
    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
    shared_ptr& operator=(shared_ptr&& r) noexcept;
    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);
    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r); // removed in C++17
    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);

    // modifiers:
    void swap(shared_ptr& r) noexcept;
    void reset() noexcept;
    template<class Y> void reset(Y* p);
    template<class Y, class D> void reset(Y* p, D d);
    template<class Y, class D, class A> void reset(Y* p, D d, A a);

    // observers:
    T* get() const noexcept;
    T& operator*() const noexcept;
    T* operator->() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
};

template<class T>
shared_ptr(weak_ptr<T>) -> shared_ptr<T>;
template<class T, class D>
shared_ptr(unique_ptr<T, D>) -> shared_ptr<T>;

// shared_ptr comparisons:
template<class T, class U>
    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;

template <class T>
    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
bool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;

// shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;

// shared_ptr casts:
template<class T, class U>
    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;

// shared_ptr I/O:
template<class E, class T, class Y>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);

// shared_ptr get_deleter:
template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;

template<class T, class... Args>
    shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>
    shared_ptr<T> allocate_shared(const A& a, Args&&... args);

template<class T>
class weak_ptr
{
public:
    typedef T element_type;

    // constructors
    constexpr weak_ptr() noexcept;
    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
    weak_ptr(weak_ptr&& r) noexcept;                      // C++14
    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14

    // destructor
    ~weak_ptr();

    // assignment
    weak_ptr& operator=(weak_ptr const& r) noexcept;
    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14
    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14

    // modifiers
    void swap(weak_ptr& r) noexcept;
    void reset() noexcept;

    // observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    shared_ptr<T> lock() const noexcept;
    template<class U> bool owner_before(shared_ptr<U> const& b) const noexcept;
    template<class U> bool owner_before(weak_ptr<U> const& b) const noexcept;
};

template<class T>
weak_ptr(shared_ptr<T>) -> weak_ptr<T>;

// weak_ptr specialized algorithms:
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;

// class owner_less:
template<class T> struct owner_less;

template<class T>
struct owner_less<shared_ptr<T> >
    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const noexcept;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
};

template<class T>
struct owner_less<weak_ptr<T> >
    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const noexcept;
    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const noexcept;
    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const noexcept;
};

template <>  // Added in C++14
struct owner_less<void>
{
    template <class _Tp, class _Up>
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
    template <class _Tp, class _Up>
    bool operator()( shared_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;
    template <class _Tp, class _Up>
    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept;
    template <class _Tp, class _Up>
    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const noexcept;

    typedef void is_transparent;
};

template<class T>
class enable_shared_from_this
{
protected:
    constexpr enable_shared_from_this() noexcept;
    enable_shared_from_this(enable_shared_from_this const&) noexcept;
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
    ~enable_shared_from_this();
public:
    shared_ptr<T> shared_from_this();
    shared_ptr<T const> shared_from_this() const;
};

template<class T>
    bool atomic_is_lock_free(const shared_ptr<T>* p);
template<class T>
    shared_ptr<T> atomic_load(const shared_ptr<T>* p);
template<class T>
    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);
template<class T>
    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);
template<class T>
    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
template<class T>
    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);
template<class T>
    shared_ptr<T>
    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);
template<class T>
    bool
    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
template<class T>
    bool
    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);
template<class T>
    bool
    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
                                          shared_ptr<T> w, memory_order success,
                                          memory_order failure);
template<class T>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,
                                            shared_ptr<T> w, memory_order success,
                                            memory_order failure);
// Hash support
template <class T> struct hash;
template <class T, class D> struct hash<unique_ptr<T, D> >;
template <class T> struct hash<shared_ptr<T> >;

template <class T, class Alloc>
  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;

// Pointer safety
enum class pointer_safety { relaxed, preferred, strict };
void declare_reachable(void *p);
template <class T> T *undeclare_reachable(T *p);
void declare_no_pointers(char *p, size_t n);
void undeclare_no_pointers(char *p, size_t n);
pointer_safety get_pointer_safety() noexcept;

void* align(size_t alignment, size_t size, void*& ptr, size_t& space);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 668 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__availability" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__availability" 2
# 17 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__availability" 3


// Libc++ is shipped by various vendors. In particular, it is used as a system
// library on macOS, iOS and other Apple platforms. In order for users to be
// able to compile a binary that is intended to be deployed to an older version
// of a platform, Clang provides availability attributes [1]. These attributes
// can be placed on declarations and are used to describe the life cycle of a
// symbol in the library.
//
// The main goal is to ensure a compile-time error if a symbol that hasn't been
// introduced in a previously released library is used in a program that targets
// that previously released library. Normally, this would be a load-time error
// when one tries to launch the program against the older library.
//
// For example, the filesystem library was introduced in the dylib in macOS 10.15.
// If a user compiles on a macOS 10.15 host but targets macOS 10.13 with their
// program, the compiler would normally not complain (because the required
// declarations are in the headers), but the dynamic loader would fail to find
// the symbols when actually trying to launch the program on macOS 10.13. To
// turn this into a compile-time issue instead, declarations are annotated with
// when they were introduced, and the compiler can produce a diagnostic if the
// program references something that isn't available on the deployment target.
//
// This mechanism is general in nature, and any vendor can add their markup to
// the library (see below). Whenever a new feature is added that requires support
// in the shared library, a macro should be added below to mark this feature
// as unavailable. When vendors decide to ship the feature as part of their
// shared library, they can update the markup appropriately.
//
// Note that this mechanism is disabled by default in the "upstream" libc++.
// Availability annotations are only meaningful when shipping libc++ inside
// a platform (i.e. as a system library), and so vendors that want them should
// turn those annotations on at CMake configuration time.
//
// [1]: https://clang.llvm.org/docs/AttributeReference.html#availability


// For backwards compatibility, allow users to define _LIBCPP_DISABLE_AVAILABILITY
// for a while.






// Availability markup is disabled when building the library, or when the compiler
// doesn't support the proper attributes.
# 76 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__availability" 3
    // This controls the availability of std::shared_mutex and std::shared_timed_mutex,
    // which were added to the dylib later.


    // These macros control the availability of std::bad_optional_access and
    // other exception types. These were put in the shared library to prevent
    // code bloat from every user program defining the vtable for these exception
    // types.




    // This controls the availability of std::uncaught_exceptions().


    // This controls the availability of the sized version of ::operator delete,
    // which was added to the dylib later.


    // This controls the availability of the std::future_error exception.


    // This controls the availability of std::type_info's vtable.
    // I can't imagine how using std::type_info can work at all if
    // this isn't supported.


    // This controls the availability of std::locale::category members
    // (e.g. std::locale::collate), which are defined in the dylib.


    // This controls the availability of atomic operations on std::shared_ptr
    // (e.g. `std::atomic_store(std::shared_ptr)`), which require a shared
    // lock table located in the dylib.


    // These macros control the availability of all parts of <filesystem> that
    // depend on something in the dylib.




    // This controls the availability of std::to_chars.


    // This controls the availability of the C++20 synchronization library,
    // which requires shared library support for various operations
    // (see libcxx/src/atomic.cpp).
# 191 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__availability" 3
// Define availability attributes that depend on _LIBCPP_NO_EXCEPTIONS.
// Those are defined in terms of the availability attributes above, and
// should not be vendor-specific.
# 669 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/typeinfo" 1
// -*- C++ -*-
//===-------------------------- typeinfo ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*

    typeinfo synopsis

namespace std {

class type_info
{
public:
    virtual ~type_info();

    bool operator==(const type_info& rhs) const noexcept;
    bool operator!=(const type_info& rhs) const noexcept;

    bool before(const type_info& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

    type_info(const type_info& rhs) = delete;
    type_info& operator=(const type_info& rhs) = delete;
};

class bad_cast
    : public exception
{
public:
    bad_cast() noexcept;
    bad_cast(const bad_cast&) noexcept;
    bad_cast& operator=(const bad_cast&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_typeid
    : public exception
{
public:
    bad_typeid() noexcept;
    bad_typeid(const bad_typeid&) noexcept;
    bad_typeid& operator=(const bad_typeid&) noexcept;
    virtual const char* what() const noexcept;
};

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 60 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/typeinfo" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 1
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    exception synopsis

namespace std
{

class exception
{
public:
    exception() noexcept;
    exception(const exception&) noexcept;
    exception& operator=(const exception&) noexcept;
    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class bad_exception
    : public exception
{
public:
    bad_exception() noexcept;
    bad_exception(const bad_exception&) noexcept;
    bad_exception& operator=(const bad_exception&) noexcept;
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*unexpected_handler)();
unexpected_handler set_unexpected(unexpected_handler  f ) noexcept;
unexpected_handler get_unexpected() noexcept;
[[noreturn]] void unexpected();

typedef void (*terminate_handler)();
terminate_handler set_terminate(terminate_handler  f ) noexcept;
terminate_handler get_terminate() noexcept;
[[noreturn]] void terminate() noexcept;

bool uncaught_exception()  noexcept;
int  uncaught_exceptions() noexcept;  // C++17

typedef unspecified exception_ptr;

exception_ptr current_exception() noexcept;
void rethrow_exception [[noreturn]] (exception_ptr p);
template<class E> exception_ptr make_exception_ptr(E e) noexcept;

class nested_exception
{
public:
    nested_exception() noexcept;
    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() = default;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    exception_ptr nested_ptr() const noexcept;
};

template <class T> [[noreturn]] void throw_with_nested(T&& t);
template <class E> void rethrow_if_nested(const E& e);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 80 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 2
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 23 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 2 3

namespace std { inline namespace __1 {

// addressof


template <class _Tp>
inline constexpr
__attribute__((__no_sanitize__("cfi"))) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
# 92 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 3
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;


// construct_at
# 110 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/base.h" 3
// destroy_at



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void destroy_at(_Tp* __loc) {
    ((void)0);
    __loc->~_Tp();
}



} }
# 82 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdlib" 1
// -*- C++ -*-
//===--------------------------- cstdlib ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cstdlib synopsis

Macros:

    EXIT_FAILURE
    EXIT_SUCCESS
    MB_CUR_MAX
    NULL
    RAND_MAX

namespace std
{

Types:

    size_t
    div_t
    ldiv_t
    lldiv_t                                                               // C99

double    atof (const char* nptr);
int       atoi (const char* nptr);
long      atol (const char* nptr);
long long atoll(const char* nptr);                                        // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
float              strtof  (const char* restrict nptr, char** restrict endptr); // C99
long double        strtold (const char* restrict nptr, char** restrict endptr); // C99
long               strtol  (const char* restrict nptr, char** restrict endptr, int base);
long long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
unsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
unsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
int rand(void);
void srand(unsigned int seed);
void* calloc(size_t nmemb, size_t size);
void free(void* ptr);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
void abort(void);
int atexit(void (*func)(void));
void exit(int status);
void _Exit(int status);
char* getenv(const char* name);
int system(const char* string);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
void qsort(void* base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));
int         abs(      int j);
long        abs(     long j);
long long   abs(long long j);                                             // C++0X
long       labs(     long j);
long long llabs(long long j);                                             // C99
div_t     div(      int numer,       int denom);
ldiv_t    div(     long numer,      long denom);
lldiv_t   div(long long numer, long long denom);                          // C++0X
ldiv_t   ldiv(     long numer,      long denom);
lldiv_t lldiv(long long numer, long long denom);                          // C99
int mblen(const char* s, size_t n);
int mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
int wctomb(char* s, wchar_t wchar);
size_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
size_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
int at_quick_exit(void (*func)(void))                                     // C++11
void quick_exit(int status);                                              // C++11
void *aligned_alloc(size_t alignment, size_t size);                       // C11

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 85 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdlib" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h" 1
// -*- C++ -*-
//===--------------------------- stdlib.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 21 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h"
/*
    stdlib.h synopsis

Macros:

    EXIT_FAILURE
    EXIT_SUCCESS
    MB_CUR_MAX
    NULL
    RAND_MAX

Types:

    size_t
    div_t
    ldiv_t
    lldiv_t                                                               // C99

double    atof (const char* nptr);
int       atoi (const char* nptr);
long      atol (const char* nptr);
long long atoll(const char* nptr);                                        // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
float              strtof  (const char* restrict nptr, char** restrict endptr); // C99
long double        strtold (const char* restrict nptr, char** restrict endptr); // C99
long               strtol  (const char* restrict nptr, char** restrict endptr, int base);
long long          strtoll (const char* restrict nptr, char** restrict endptr, int base); // C99
unsigned long      strtoul (const char* restrict nptr, char** restrict endptr, int base);
unsigned long long strtoull(const char* restrict nptr, char** restrict endptr, int base); // C99
int rand(void);
void srand(unsigned int seed);
void* calloc(size_t nmemb, size_t size);
void free(void* ptr);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
void abort(void);
int atexit(void (*func)(void));
void exit(int status);
void _Exit(int status);
char* getenv(const char* name);
int system(const char* string);
void* bsearch(const void* key, const void* base, size_t nmemb, size_t size,
              int (*compar)(const void *, const void *));
void qsort(void* base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));
int         abs(      int j);
long        abs(     long j);
long long   abs(long long j);                                             // C++0X
long       labs(     long j);
long long llabs(long long j);                                             // C99
div_t     div(      int numer,       int denom);
ldiv_t    div(     long numer,      long denom);
lldiv_t   div(long long numer, long long denom);                          // C++0X
ldiv_t   ldiv(     long numer,      long denom);
lldiv_t lldiv(long long numer, long long denom);                          // C99
int mblen(const char* s, size_t n);
int mbtowc(wchar_t* restrict pwc, const char* restrict s, size_t n);
int wctomb(char* s, wchar_t wchar);
size_t mbstowcs(wchar_t* restrict pwcs, const char* restrict s, size_t n);
size_t wcstombs(char* restrict s, const wchar_t* restrict pwcs, size_t n);
int at_quick_exit(void (*func)(void))                                     // C++11
void quick_exit(int status);                                              // C++11
void *aligned_alloc(size_t alignment, size_t size);                       // C11

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 88 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h" 2
# 91 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
// -*- C++ -*-
//===--------------------------- stdlib.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 94 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h" 2 3


extern "C++" {
// abs







// MSVCRT already has the correct prototype in <stdlib.h> if __cplusplus is defined

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long abs(long __x) noexcept {
  return __builtin_labs(__x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long abs(long long __x) noexcept {
  return __builtin_llabs(__x);
}




inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x); // Use builtins to prevent needing math.h
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double
abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}


// div







// MSVCRT already has the correct prototype in <stdlib.h> if __cplusplus is defined

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ldiv_t div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) lldiv_t div(long long __x,
                                             long long __y) noexcept {
  return ::lldiv(__x, __y);
}


} // extern "C++"
# 86 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdlib" 2
# 89 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdlib" 3








namespace std { inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;

using ::getenv;
using ::system;

using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;





using ::aligned_alloc;


} }
# 84 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 2
# 93 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 3


namespace std // purposefully not using versioning namespace
{


class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception(const exception&) noexcept = default;

    virtual ~exception() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bad_exception() noexcept {}
    virtual ~bad_exception() noexcept;
    virtual const char* what() const noexcept;
};
# 128 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 3
typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void terminate() noexcept;

__attribute__ ((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__ ((__visibility__("default"))) int uncaught_exceptions() noexcept;

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);



class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr() noexcept : __ptr_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}

    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr
make_exception_ptr(_Ep __e) noexcept
{

    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }




}
# 236 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/exception" 3
// nested_exception

class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;
//     nested_exception(const nested_exception&) noexcept = default;
//     nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept;

    // access functions
    [[noreturn]] void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};


template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void
    __do_throw(_Tp&& __t)
    {
        throw __nested<_Up>(std::__1::forward<_Tp>(__t));
    }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void

    __do_throw(_Tp&& __t)



    {
        throw std::__1::forward<_Tp>(__t);
    }
};


template <class _Tp>
[[noreturn]]
void
throw_with_nested(_Tp&& __t)
{

    typedef typename decay<_Tp>::type _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(std::__1::forward<_Tp>(__t));




}

template <class _From, class _To>
struct __can_dynamic_cast : public bool_constant<(is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value))> {};




template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
rethrow_if_nested(const _Ep& __e,
                  typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::__1::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
rethrow_if_nested(const _Ep&,
                  typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0)
{
}

} // std
# 62 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/typeinfo" 2
# 71 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/typeinfo" 3






namespace std // purposefully not using versioning namespace
{
# 120 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/typeinfo" 3
// ========================================================================== //
//                           Implementations
// ========================================================================== //
// ------------------------------------------------------------------------- //
//                               Unique
//               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 1)
// ------------------------------------------------------------------------- //
// This implementation of type_info assumes a unique copy of the RTTI for a
// given type inside a program. This is a valid assumption when abiding to
// Itanium ABI (http://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components).
// Under this assumption, we can always compare the addresses of the type names
// to implement equality-comparison of type_infos instead of having to perform
// a deep string comparison.
// -------------------------------------------------------------------------- //
//                             NonUnique
//               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 2)
// -------------------------------------------------------------------------- //
// This implementation of type_info does not assume there is always a unique
// copy of the RTTI for a given type inside a program. For various reasons
// the linker may have failed to merge every copy of a types RTTI
// (For example: -Bsymbolic or llvm.org/PR37398). Under this assumption, two
// type_infos are equal if their addresses are equal or if a deep string
// comparison is equal.
// -------------------------------------------------------------------------- //
//                          NonUniqueARMRTTIBit
//               (_LIBCPP_TYPEINFO_COMPARISON_IMPLEMENTATION = 3)
// -------------------------------------------------------------------------- //
// This implementation of type_info does not assume always a unique copy of
// the RTTI for a given type inside a program. It packs the pointer to the
// type name into a uintptr_t and reserves the high bit of that pointer (which
// is assumed to be free for use under the ABI in use) to represent whether
// that specific copy of the RTTI can be assumed unique inside the program.
// To implement equality-comparison of type_infos, we check whether BOTH
// type_infos are guaranteed unique, and if so, we simply compare the addresses
// of their type names instead of doing a deep string comparison, which is
// faster. If at least one of the type_infos can't guarantee uniqueness, we
// have no choice but to fall back to a deep string comparison.
//
// This implementation is specific to ARM64 on Apple platforms.
//
// Note that the compiler is the one setting (or unsetting) the high bit of
// the pointer when it constructs the type_info, depending on whether it can
// guarantee uniqueness for that specific type_info.

// This value can be overriden in the __config_site. When it's not overriden,
// we pick a default implementation based on the platform here.


  // Windows binaries can't merge typeinfos, so use the NonUnique implementation.







  // On all other platforms, assume the Itanium C++ ABI and use the Unique implementation.





struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return reinterpret_cast<size_t>(__v);
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs, __rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs, __rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

   private:
    // The unique bit is the top bit. It is expected that __type_name_t is 64 bits when
    // this implementation is actually used.
    typedef integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static bool __is_type_name_unique(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return !((__lhs & __rhs) & __non_unique_rtti_bit::value);
    }
  };

  typedef





    __non_unique_arm_rtti_bit_impl



     __impl;
};

class __attribute__ ((__visibility__("default"))) type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);

 protected:
    typedef __type_info_implementations::__impl __impl;

    __impl::__type_name_t __type_name;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:

    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }

    // XXX Emscripten: adding `always_inline` fixes
    // https://github.com/emscripten-core/emscripten/issues/13330
    __attribute__((always_inline))
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const type_info& __arg) const noexcept
    {
      return __impl::__eq(__type_name, __arg.__type_name);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }
};


class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  bad_cast(const bad_cast&) noexcept = default;
  virtual ~bad_cast() noexcept;
  virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char* what() const noexcept;
};

} // std



namespace std { inline namespace __1 {
[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_bad_cast()
{

    throw bad_cast();



}
} }
# 671 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 1
// -*- C++ -*-
//===----------------------------- new ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    new synopsis

namespace std
{

class bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    bad_alloc(const bad_alloc&) noexcept;
    bad_alloc& operator=(const bad_alloc&) noexcept;
    virtual const char* what() const noexcept;
};

class bad_array_new_length : public bad_alloc // C++14
{
public:
    bad_array_new_length() noexcept;
};

enum class align_val_t : size_t {}; // C++17

struct destroying_delete_t { // C++20
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{}; // C++20

struct nothrow_t { explicit nothrow_t() = default; };
extern const nothrow_t nothrow;
typedef void (*new_handler)();
new_handler set_new_handler(new_handler new_p) noexcept;
new_handler get_new_handler() noexcept;

// 21.6.4, pointer optimization barrier
template <class T> constexpr T* launder(T* p) noexcept; // C++17
}  // std

void* operator new(std::size_t size);                                   // replaceable, nodiscard in C++20
void* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17, nodiscard in C++20
void* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable, nodiscard in C++20
void* operator new(std::size_t size, std::align_val_t alignment,
                   const std::nothrow_t&) noexcept;                     // replaceable, C++17, nodiscard in C++20
void  operator delete(void* ptr) noexcept;                              // replaceable
void  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14
void  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17
void  operator delete(void* ptr, std::size_t size,
                      std::align_val_t alignment) noexcept;             // replaceable, C++17
void  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable
void  operator delete(void* ptr, std:align_val_t alignment,
                      const std::nothrow_t&) noexcept;                  // replaceable, C++17

void* operator new[](std::size_t size);                                 // replaceable, nodiscard in C++20
void* operator new[](std::size_t size,
                     std::align_val_t alignment) noexcept;              // replaceable, C++17, nodiscard in C++20
void* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable, nodiscard in C++20
void* operator new[](std::size_t size, std::align_val_t alignment,
                     const std::nothrow_t&) noexcept;                   // replaceable, C++17, nodiscard in C++20
void  operator delete[](void* ptr) noexcept;                            // replaceable
void  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14
void  operator delete[](void* ptr,
                        std::align_val_t alignment) noexcept;           // replaceable, C++17
void  operator delete[](void* ptr, std::size_t size,
                        std::align_val_t alignment) noexcept;           // replaceable, C++17
void  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable
void  operator delete[](void* ptr, std::align_val_t alignment,
                        const std::nothrow_t&) noexcept;                // replaceable, C++17

void* operator new  (std::size_t size, void* ptr) noexcept;             // nodiscard in C++20
void* operator new[](std::size_t size, void* ptr) noexcept;             // nodiscard in C++20
void  operator delete  (void* ptr, void*) noexcept;
void  operator delete[](void* ptr, void*) noexcept;

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 90 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 2
# 103 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 3
# 119 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 3
namespace std // purposefully not using versioning namespace
{


struct __attribute__ ((__visibility__("default"))) nothrow_t { explicit nothrow_t() = default; };
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    virtual ~bad_alloc() noexcept;
    virtual const char* what() const noexcept;
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    virtual ~bad_array_new_length() noexcept;
    virtual const char* what() const noexcept;
};

typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() noexcept;



[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_bad_alloc(); // not in C++ spec




enum class __attribute__ ((__type_visibility__("default"))) align_val_t : size_t { };
# 170 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 3
} // std
# 180 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/new" 3
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz) noexcept;



                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;


                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
                              __attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;

__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;



                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void* operator new (std::size_t, void* __p) noexcept {return __p;}
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator delete (void*, void*) noexcept {}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator delete[](void*, void*) noexcept {}



namespace std { inline namespace __1 {

constexpr inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool __is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void* __libcpp_operator_new(_Args ...__args) {

  return __builtin_operator_new(__args...);



}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __libcpp_operator_delete(_Args ...__args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void *__libcpp_allocate(size_t __size, size_t __align) {

  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }


  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args ...__args) {

  (void)__size;
  return __libcpp_operator_delete(__ptr, __args...);



}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __do_deallocate_handle_size(__ptr, __size, __align_val);
    } else {
      return __do_deallocate_handle_size(__ptr, __size);
    }

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {




    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __libcpp_operator_delete(__ptr, __align_val);
    } else {
      return __libcpp_operator_delete(__ptr);
    }

}


// Low-level helpers to call the aligned allocation and deallocation functions
// on the target platform. This is used to implement libc++'s own memory
// allocation routines -- if you need to allocate memory inside the library,
// chances are that you want to use `__libcpp_allocate` instead.
//
// Returns the allocated memory, or `nullptr` on failure.
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void* __libcpp_aligned_alloc(std::size_t __alignment, std::size_t __size) {



  void* __result = nullptr;
  ::posix_memalign(&__result, __alignment, __size);
  // If posix_memalign fails, __result is unmodified so we still return `nullptr`.
  return __result;

}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __libcpp_aligned_free(void* __ptr) {



  ::free(__ptr);

}



template <class _Tp>
                              inline
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void" );

    return __builtin_launder(__p);



}



template <class _Tp>
                              inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _Tp* launder(_Tp* __p) noexcept
{
    return std::__1::__launder(__p);
}


} }
# 674 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits" 1
// -*- C++ -*-
//===---------------------------- limits ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    limits synopsis

namespace std
{

template<class T>
class numeric_limits
{
public:
    static constexpr bool is_specialized = false;
    static constexpr T min() noexcept;
    static constexpr T max() noexcept;
    static constexpr T lowest() noexcept;

    static constexpr int  digits = 0;
    static constexpr int  digits10 = 0;
    static constexpr int  max_digits10 = 0;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int  radix = 0;
    static constexpr T epsilon() noexcept;
    static constexpr T round_error() noexcept;

    static constexpr int  min_exponent = 0;
    static constexpr int  min_exponent10 = 0;
    static constexpr int  max_exponent = 0;
    static constexpr int  max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr T infinity() noexcept;
    static constexpr T quiet_NaN() noexcept;
    static constexpr T signaling_NaN() noexcept;
    static constexpr T denorm_min() noexcept;

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
};

enum float_round_style
{
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template<> class numeric_limits<cv bool>;

template<> class numeric_limits<cv char>;
template<> class numeric_limits<cv signed char>;
template<> class numeric_limits<cv unsigned char>;
template<> class numeric_limits<cv wchar_t>;
template<> class numeric_limits<cv char8_t>; // C++20
template<> class numeric_limits<cv char16_t>;
template<> class numeric_limits<cv char32_t>;

template<> class numeric_limits<cv short>;
template<> class numeric_limits<cv int>;
template<> class numeric_limits<cv long>;
template<> class numeric_limits<cv long long>;
template<> class numeric_limits<cv unsigned short>;
template<> class numeric_limits<cv unsigned int>;
template<> class numeric_limits<cv unsigned long>;
template<> class numeric_limits<cv unsigned long long>;

template<> class numeric_limits<cv float>;
template<> class numeric_limits<cv double>;
template<> class numeric_limits<cv long double>;

}  // std

*/

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 105 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits" 2
# 117 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 121 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits" 2 3



namespace std { inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;





    static constexpr const bool traps = false;

    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __min;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __max;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return 0.5L;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type min() noexcept {return __base::min();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type max() noexcept {return __base::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type lowest() noexcept {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type round_error() noexcept {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr type denorm_min() noexcept {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 676 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 1
// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    iterator synopsis

namespace std
{

template<class Iterator>
struct iterator_traits
{
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
};

template<class T>
struct iterator_traits<T*>
{
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T& reference;
    typedef random_access_iterator_tag iterator_category;
};

template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator
{
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
};

struct input_iterator_tag  {};
struct output_iterator_tag {};
struct forward_iterator_tag       : public input_iterator_tag         {};
struct bidirectional_iterator_tag : public forward_iterator_tag       {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

// 27.4.3, iterator operations
template <class InputIterator, class Distance>  // constexpr in C++17
  constexpr void advance(InputIterator& i, Distance n);

template <class InputIterator>  // constexpr in C++17
  constexpr typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);

template <class InputIterator>  // constexpr in C++17
  constexpr InputIterator next(InputIterator x,
typename iterator_traits<InputIterator>::difference_type n = 1);

template <class BidirectionalIterator>  // constexpr in C++17
  constexpr BidirectionalIterator prev(BidirectionalIterator x,
    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);

template <class Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<Iterator>::iterator_category,
                      typename iterator_traits<Iterator>::value_type,
                      typename iterator_traits<Iterator>::difference_type,
                      typename iterator_traits<Iterator>::pointer,
                      typename iterator_traits<Iterator>::reference>
{
protected:
    Iterator current;
public:
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type difference_type;
    typedef typename iterator_traits<Iterator>::reference       reference;
    typedef typename iterator_traits<Iterator>::pointer         pointer;

    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(Iterator x);
    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);
    constexpr Iterator base() const;
    constexpr reference operator*() const;
    constexpr pointer   operator->() const;
    constexpr reverse_iterator& operator++();
    constexpr reverse_iterator  operator++(int);
    constexpr reverse_iterator& operator--();
    constexpr reverse_iterator  operator--(int);
    constexpr reverse_iterator  operator+ (difference_type n) const;
    constexpr reverse_iterator& operator+=(difference_type n);
    constexpr reverse_iterator  operator- (difference_type n) const;
    constexpr reverse_iterator& operator-=(difference_type n);
    constexpr reference         operator[](difference_type n) const;
};

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool                          // constexpr in C++17
operator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr auto
operator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)
-> decltype(__y.base() - __x.base());   // constexpr in C++17

template <class Iterator>
constexpr reverse_iterator<Iterator>
operator+(typename reverse_iterator<Iterator>::difference_type n,
          const reverse_iterator<Iterator>& x);   // constexpr in C++17

template <class Iterator>
constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17

template <class Container>
class back_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                   container_type;
    typedef void                        value_type;
    typedef void                        difference_type;
    typedef void                        reference;
    typedef void                        pointer;

    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
};

template <class Container> back_insert_iterator<Container> back_inserter(Container& x);

template <class Container>
class front_insert_iterator
{
protected:
    Container* container;
public:
    typedef Container                    container_type;
    typedef void                         value_type;
    typedef void                         difference_type;
    typedef void                         reference;
    typedef void                         pointer;

    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
};

template <class Container> front_insert_iterator<Container> front_inserter(Container& x);

template <class Container>
class insert_iterator
{
protected:
    Container* container;
    typename Container::iterator iter;
public:
    typedef Container              container_type;
    typedef void                   value_type;
    typedef void                   difference_type;
    typedef void                   reference;
    typedef void                   pointer;

    insert_iterator(Container& x, typename Container::iterator i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
};

template <class Container, class Iterator>
insert_iterator<Container> inserter(Container& x, Iterator i);

template <class Iterator>
class move_iterator {
public:
    typedef Iterator                                              iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
    typedef Iterator                                              pointer;
    typedef typename iterator_traits<Iterator>::value_type        value_type;
    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
    typedef value_type&&                                          reference;

    constexpr move_iterator();  // all the constexprs are in C++17
    constexpr explicit move_iterator(Iterator i);
    template <class U>
      constexpr move_iterator(const move_iterator<U>& u);
    template <class U>
      constexpr move_iterator& operator=(const move_iterator<U>& u);
    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer operator->() const;
    constexpr move_iterator& operator++();
    constexpr move_iterator operator++(int);
    constexpr move_iterator& operator--();
    constexpr move_iterator operator--(int);
    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator& operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator& operator-=(difference_type n);
    constexpr unspecified operator[](difference_type n) const;
private:
    Iterator current; // exposition only
};

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr bool   // constexpr in C++17
operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

template <class Iterator1, class Iterator2>
constexpr auto   // constexpr in C++17
operator-(const move_iterator<Iterator1>& x,
          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());

template <class Iterator>
constexpr move_iterator<Iterator> operator+(   // constexpr in C++17
            typename move_iterator<Iterator>::difference_type n,
            const move_iterator<Iterator>& x);

template <class Iterator>   // constexpr in C++17
constexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);


template <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>
class istream_iterator
    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream<charT,traits> istream_type;

    constexpr istream_iterator();
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x);
    ~istream_iterator();

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator& operator++();
    istream_iterator  operator++(int);
};

template <class T, class charT, class traits, class Distance>
bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);
template <class T, class charT, class traits, class Distance>
bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                const istream_iterator<T,charT,traits,Distance>& y);

template <class T, class charT = char, class traits = char_traits<charT> >
class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void ,void>
{
public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream<charT,traits> ostream_type;

    ostream_iterator(ostream_type& s);
    ostream_iterator(ostream_type& s, const charT* delimiter);
    ostream_iterator(const ostream_iterator& x);
    ~ostream_iterator();
    ostream_iterator& operator=(const T& value);

    ostream_iterator& operator*();
    ostream_iterator& operator++();
    ostream_iterator& operator++(int);
};

template<class charT, class traits = char_traits<charT> >
class istreambuf_iterator
    : public iterator<input_iterator_tag, charT,
                      typename traits::off_type, unspecified,
                      charT>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_istream<charT,traits>   istream_type;

    istreambuf_iterator() noexcept;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(a-private-type) noexcept;

    charT                operator*() const;
    pointer operator->() const;
    istreambuf_iterator& operator++();
    a-private-type       operator++(int);

    bool equal(const istreambuf_iterator& b) const;
};

template <class charT, class traits>
bool operator==(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);
template <class charT, class traits>
bool operator!=(const istreambuf_iterator<charT,traits>& a,
                const istreambuf_iterator<charT,traits>& b);

template <class charT, class traits = char_traits<charT> >
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_ostream<charT,traits>   ostream_type;

    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);
    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator& operator++(int);
    bool failed() const noexcept;
};

template <class C> constexpr auto begin(C& c) -> decltype(c.begin());
template <class C> constexpr auto begin(const C& c) -> decltype(c.begin());
template <class C> constexpr auto end(C& c) -> decltype(c.end());
template <class C> constexpr auto end(const C& c) -> decltype(c.end());
template <class T, size_t N> constexpr T* begin(T (&array)[N]);
template <class T, size_t N> constexpr T* end(T (&array)[N]);

template <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14
template <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14
template <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14
template <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14
template <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14
template <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14
template <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14
template <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14
template <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14
template <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14
template <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14
template <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14

// 24.8, container access:
template <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17
template <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17

template <class C> constexpr auto ssize(const C& c)
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(c.size())>>;				       // C++20
template <class T, ptrdiff_t> constexpr ptrdiff_t ssize(const T (&array)[N]) noexcept; // C++20

template <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17
template <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17
template <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17
template <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17
template <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17
template <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17
template <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 418 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 2
# 22 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 3


namespace std { inline namespace __1 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__type_visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};


// __weak_result_type

template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function // bool is true
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function // bool is true
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp // bool is true
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};

// 0 argument case

template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};

// 1 argument case

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};

// 2 argument case

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};



// 3 or more arguments

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(std::__1::__invoke(declval<_Tp>(), declval<_Args>()...)) type;
};
# 311 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 3
template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper
{

    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return std::__1::__invoke(std::__1::forward<_Args>(__args)...);
    }
# 340 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 3
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true>
{

    template <class ..._Args>
    static void __call(_Args&&... __args) {
        std::__1::__invoke(std::__1::forward<_Args>(__args)...);
    }
# 371 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 3
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type* __f_;

public:
    // construct/copy/destroy
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference_wrapper(type& __f) noexcept
        : __f_(std::__1::addressof(__f)) {}

    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps


    // access
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator type&() const noexcept {return *__f_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    type& get() const noexcept {return *__f_;}


    // invoke
    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__1::__invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
    }
# 512 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__functional_base" 3
};


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__1::ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return std::__1::cref(__t.get());
}


template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};


// allocator_arg_t

struct __attribute__ ((__type_visibility__("default"))) allocator_arg_t { explicit allocator_arg_t() = default; };




/* _LIBCPP_INLINE_VAR */ constexpr allocator_arg_t allocator_arg = allocator_arg_t();


// uses_allocator

template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};


template <class _Tp, class _Alloc>
inline constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;




// allocator construction

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef typename __uncvref<_Alloc>::type _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)...);
}

// FIXME: This should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}

// FIXME: This should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__1::forward<_Args>(__args)..., __a);
}



} }
# 420 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 2
# 430 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3


namespace std { inline namespace __1 {
template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits;

struct __attribute__ ((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};






template <class _Iter>
struct __iter_traits_cache {
  using type = _If<
    __is_primary_template<iterator_traits<_Iter> >::value,
    _Iter,
    iterator_traits<_Iter>
  >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = _EnableIf<
                          __is_primary_template<iterator_traits<_Iter> >::value,
                          random_access_iterator_tag
                        >;
};

template <class _Iter, class _Tester> struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or<
    __test_iter_concept<_Iter, __iter_concept_concept_test>,
    __test_iter_concept<_Iter, __iter_concept_category_test>,
    __test_iter_concept<_Iter, __iter_concept_random_fallback>
  >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;


template <class _Tp>
struct __has_iterator_typedefs
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename __void_t<typename _Up::iterator_category>::type* = 0,
                                            typename __void_t<typename _Up::difference_type>::type* = 0,
                                            typename __void_t<typename _Up::value_type>::type* = 0,
                                            typename __void_t<typename _Up::reference>::type* = 0,
                                            typename __void_t<typename _Up::pointer>::type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0,0,0,0,0)) == 1;
};


template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = nullptr);
public:
    static const bool value = sizeof(__test<_Tp>(nullptr)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};

// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
//    conforming extension which allows some programs to compile and behave as
//    the client expects instead of failing at compile time.

template <class _Iter>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {

  using __primary_template = iterator_traits;
};

template<class _Tp>
struct __attribute__ ((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_cv<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;



};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};





template <class _Tp>
struct __is_cpp17_contiguous_iterator : public false_type {};



template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};


template<class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template<class _InputIterator>
using __iter_key_type = remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template<class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template<class _InputIterator>
using __iter_to_alloc_type = pair<
    add_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>,
    typename iterator_traits<_InputIterator>::value_type::second_type>;


template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__type_visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
void advance(_InputIter& __i, _Distance __orig_n)
{
    ((void)0);

    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    std::__1::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return std::__1::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_cpp17_input_iterator<_InputIter>::value,
    _InputIter
>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);


    std::__1::advance(__x, __n);
    return __x;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_cpp17_input_iterator<_InputIter>::value,
    _InputIter
>::type
prev(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1)
{
    ((void)0);

    std::__1::advance(__x, -__n);
    return __x;
}


template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
  : true_type {};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    /*mutable*/ _Iter __t; // no longer used as of LWG #2360, not removed due to ABI break

    static_assert(!__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined behavior");

protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator() : __t(), current() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)
            { __t = current = __u.base(); return *this; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pointer operator->() const {return std::__1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator operator+ (difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator operator- (difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator[](difference_type __n) const {return *(*this + __n);}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
# 867 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


template <class _Container>
class __attribute__ ((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit back_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit front_insert_iterator(_Container& __x) : container(std::__1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      void>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr istream_iterator() : __in_stream_(nullptr), __value_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator(istream_type& __s) : __in_stream_(std::__1::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp* operator->() const {return std::__1::addressof((operator*()));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);

    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = nullptr;
        return __sbuf_ == nullptr;
    }
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr istreambuf_iterator() noexcept : __sbuf_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;



    typedef void difference_type;

    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = nullptr;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool failed() const noexcept {return __sbuf_ == nullptr;}

    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};

template <class _Iter>
class __attribute__ ((__type_visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef iterator_type pointer;

    typedef typename iterator_traits<iterator_type>::reference __reference;
    typedef typename conditional<
            is_reference<__reference>::value,
            typename remove_reference<__reference>::type&&,
            __reference
        >::type reference;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator*() const { return static_cast<reference>(*__i); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    pointer operator->() const { return __i;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator operator+ (difference_type __n) const {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator operator- (difference_type __n) const {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
-> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
# 1323 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}

// __wrap_iter

template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base());







template <class _Iter>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) move_backward(_B1, _B1, _B2);



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);
# 1420 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter() noexcept

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = nullptr) noexcept
            : __i(__u.base())
    {



    }
# 1474 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference operator*() const noexcept
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr pointer operator->() const noexcept
    {




        return (pointer)std::__1::addressof(*__i);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator++() noexcept
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator--() noexcept
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator+=(difference_type __n) noexcept
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference operator[](difference_type __n) const noexcept
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr iterator_type base() const noexcept {return __i;}

private:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __wrap_iter(iterator_type __x) noexcept : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__ ((__type_visibility__("default"))) vector;
    template <class _Tp, size_t> friend class __attribute__ ((__type_visibility__("default"))) span;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;

    template <class _Iter1, class _Iter2>
    constexpr friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) noexcept;


    template <class _Iter1, class _Iter2>
    constexpr friend
    auto
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base());







    template <class _Iter1>
    constexpr friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) noexcept;

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);


    template <class _Tp>
    constexpr friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
# 1626 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
-> decltype(__x.base() - __y.base())
{




    return __x.base() - __y.base();
}
# 1739 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept
{
    __x += __n;
    return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public bool_constant<(is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value)> {};


template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}



template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}



template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::__1::begin(__c))
{
    return std::__1::begin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto cend(const _Cp& __c) -> decltype(std::__1::end(__c))
{
    return std::__1::end(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto crbegin(const _Cp& __c) -> decltype(std::__1::rbegin(__c))
{
    return std::__1::rbegin(__c);
}

template <class _Cp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
auto crend(const _Cp& __c) -> decltype(std::__1::rend(__c))
{
    return std::__1::rend(__c);
}
# 1943 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
// #if _LIBCPP_STD_VER > 11
// template <>
// struct _LIBCPP_TEMPLATE_VIS plus<void>
// {
//     template <class _T1, class _T2>
//     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
//     auto operator()(_T1&& __t, _T2&& __u) const
//     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))
//     -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))
//         { return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }
//     typedef void is_transparent;
// };
// #endif

template <class _Cont>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto size(const _Cont& __c)
noexcept(noexcept(__c.size()))
-> decltype (__c.size())
{ return __c.size(); }

template <class _Tp, size_t _Sz>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }
# 1981 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iterator" 3
template <class _Cont>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr auto empty(const _Cont& __c)
noexcept(noexcept(__c.empty()))
-> decltype (__c.empty())
{ return __c.empty(); }

template <class _Tp, size_t _Sz>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }

template <class _Ep>
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }

template <class _Cont> constexpr
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto data(_Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Cont> constexpr
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
auto data(const _Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }

template <class _Tp, size_t _Sz>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }

template <class _Ep>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }



} }
# 677 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 1
// -*- C++ -*-
//===--------------------------- tuple ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    tuple synopsis

namespace std
{

template <class... T>
class tuple {
public:
    explicit(see-below) constexpr tuple();
    explicit(see-below) tuple(const T&...);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(U&&...);  // constexpr in C++14
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;
    template <class... U>
        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
    template <class U1, class U2>
        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
    template <class U1, class U2>
        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14

    // allocator-extended constructors
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a);
    template <class Alloc>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);

    tuple& operator=(const tuple&);
    tuple&
        operator=(tuple&&) noexcept(AND(is_nothrow_move_assignable<T>::value ...));
    template <class... U>
        tuple& operator=(const tuple<U...>&);
    template <class... U>
        tuple& operator=(tuple<U...>&&);
    template <class U1, class U2>
        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2
    template <class U1, class U2>
        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2

    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));
};

template <class ...T>
tuple(T...) -> tuple<T...>;                                         // since C++17
template <class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
template <class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17

inline constexpr unspecified ignore;

template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14

// [tuple.apply], calling a function with a tuple of arguments:
template <class F, class Tuple>
  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17
template <class T, class Tuple>
  constexpr T make_from_tuple(Tuple&& t); // C++17

// 20.4.1.4, tuple helper classes:
template <class T> struct tuple_size; // undefined
template <class... T> struct tuple_size<tuple<T...>>;
template <class T>
 inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
template <size_t I, class T> struct tuple_element; // undefined
template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
template <size_t I, class T>
  using tuple_element_t = typename tuple_element <I, T>::type; // C++14

// 20.4.1.5, element access:
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&
    get(tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&
    get(const tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&&
    get(tuple<T...>&&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&&
    get(const tuple<T...>&&) noexcept; // constexpr in C++14

template <class T1, class... T>
    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
template <class T1, class... T>
    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
template <class T1, class... T>
    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
template <class T1, class... T>
    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14

// 20.4.1.6, relational operators:
template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14
template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14

template <class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc>;

template <class... Types>
  void
  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 149 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 2
# 158 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 3


namespace std { inline namespace __1 {




// __tuple_leaf

template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;

    template <class _Tp>
    static constexpr bool __can_bind_reference() {

      return !__reference_binds_to_temporary(_Hp, _Tp);



    }

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                      _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::__1::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            __value_ = std::__1::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const _Hp& get() const noexcept {return __value_;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = _EnableIf<
                  _And<
                    _IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__1::forward<_Tp>(__t), __a) {}

    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_leaf&
        operator=(_Tp&& __t) noexcept((is_nothrow_assignable<_Hp&, _Tp>::value))
        {
            _Hp::operator=(std::__1::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::__1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swallow(_Tp&&...) noexcept {}

template <class _Tp>
struct __all_default_constructible;

template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };

// __tuple_impl

template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :

            __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

            : __tuple_leaf<_Indx, _Tp>(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t) noexcept((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__1::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tuple_impl&
    operator=(const __tuple_impl& __t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tuple_impl&
    operator=(__tuple_impl&& __t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};



template <class ..._Tp>
class __attribute__ ((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

    _BaseT __base_;




    static constexpr bool _EnableImplicitReducedArityExtension = false;


    template <class ..._Args>
    struct _PackExpandsToThisTuple : false_type {};

    template <class _Arg>
    struct _PackExpandsToThisTuple<_Arg>
        : is_same<typename __uncvref<_Arg>::type, tuple> {};

    template <bool _MaybeEnable, class _Dummy = void>
    struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckArgsConstructor<true, _Dummy>
    {
        template <int&...>
        static constexpr bool __enable_implicit_default() {
           return __all<__is_implicitly_default_constructible<_Tp>::value... >::value;
        }

        template <int&...>
        static constexpr bool __enable_explicit_default() {
            return
                __all<is_default_constructible<_Tp>::value...>::value &&
                !__enable_implicit_default< >();
        }


        template <class ..._Args>
        static constexpr bool __enable_explicit() {
            return
                __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                !__tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }

        template <class ..._Args>
        static constexpr bool __enable_implicit() {
            return
               __tuple_constructible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __tuple_convertible<
                    tuple<_Args...>,
                    typename __make_tuple_types<tuple,
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value &&
                __all_default_constructible<
                    typename __make_tuple_types<tuple, sizeof...(_Tp),
                             sizeof...(_Args) < sizeof...(_Tp) ?
                                 sizeof...(_Args) :
                                 sizeof...(_Tp)>::type
                >::value;
        }
    };

    template <bool _MaybeEnable,
              bool = sizeof...(_Tp) == 1,
              class _Dummy = void>
    struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, false, _Dummy>
    {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_constructible<_Tuple, tuple>::value
                && __tuple_convertible<_Tuple, tuple>::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, tuple>::value
               && !__tuple_convertible<_Tuple, tuple>::value;
        }
    };

    template <class _Dummy>
    struct _CheckTupleLikeConstructor<true, true, _Dummy>
    {
        // This trait is used to disable the tuple-like constructor when
        // the UTypes... constructor should be selected instead.
        // See LWG issue #2549.
        template <class _Tuple>
        using _PreferTupleLikeConstructor = _Or<
            // Don't attempt the two checks below if the tuple we are given
            // has the same type as this tuple.
            _IsSame<__uncvref_t<_Tuple>, tuple>,
            _Lazy<_And,
                _Not<is_constructible<_Tp..., _Tuple>>,
                _Not<is_convertible<_Tuple, _Tp...>>
            >
        >;

        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                __tuple_convertible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>
            >::value;
        }

        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return _And<
                __tuple_constructible<_Tuple, tuple>,
                _PreferTupleLikeConstructor<_Tuple>,
                _Not<__tuple_convertible<_Tuple, tuple>>
            >::value;
        }
    };

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableImplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >;

    template <class _Tuple, bool _DisableIfLValue>
    using _EnableExplicitTupleLikeConstructor = _EnableIf<
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                             && !_PackExpandsToThisTuple<_Tuple>::value
                             && (!is_lvalue_reference<_Tuple>::value || !_DisableIfLValue)
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:

    template <bool _Dummy = true, _EnableIf<
        _CheckArgsConstructor<_Dummy>::__enable_implicit_default()
    , void*> = nullptr>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    template <bool _Dummy = true, _EnableIf<
        _CheckArgsConstructor<_Dummy>::__enable_explicit_default()
    , void*> = nullptr>
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    tuple()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

    tuple(tuple const&) = default;
    tuple(tuple&&) = default;

    template <class _AllocArgT, class _Alloc, _EnableIf<
             _CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::value >::__enable_implicit_default()
      , void*> = nullptr
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <class _AllocArgT, class _Alloc, _EnableIf<
             _CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::value>::__enable_explicit_default()
      , void*> = nullptr
    >
    explicit __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple(_AllocArgT, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    explicit tuple(const _Tp& ... __t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_implicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc, bool _Dummy = true,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                            _Dummy
                         >::template __enable_explicit<_Tp const&...>(),
                         bool
                      >::type = false
        >
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      explicit
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp)
                             && !_PackIsTuple
                         >::template __enable_implicit<_Up...>() ||
                        _CheckArgsConstructor<
                            _EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackIsTuple
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 793 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) <= sizeof...(_Tp)
                             && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>() ||
                         _CheckArgsConstructor<
                            !_EnableImplicitReducedArityExtension
                            && sizeof...(_Up) < sizeof...(_Tp)
                            && !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(_Up&&... __u)
            noexcept(( is_nothrow_constructible<_BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up... >::value ))
# 826 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 3
            : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_implicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              typename enable_if
                      <
                         _CheckArgsConstructor<
                             sizeof...(_Up) == sizeof...(_Tp) &&
                             !_PackExpandsToThisTuple<_Up...>::value
                         >::template __enable_explicit<_Up...>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__1::forward<_Up>(__u)...) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableImplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}
    template <class _Tuple, _EnableExplicitTupleLikeConstructor<_Tuple, true> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(_Tuple&& __t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
            : __base_(std::__1::forward<_Tuple>(__t)) {}

    template <class _Tuple, _EnableExplicitTupleLikeConstructor<const _Tuple&, false> = false>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit
        tuple(const _Tuple& __t) noexcept((is_nothrow_constructible<_BaseT, const _Tuple&>::value))
            : __base_(__t) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_implicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              typename enable_if
                      <
                         _CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value
                         >::template __enable_explicit<_Tuple>(),
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

    using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
    using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)
        noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(__t.__base_);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)
        noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value))
    {
        __base_.operator=(static_cast<_BaseT&&>(__t.__base_));
        return *this;
    }

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple&
        operator=(_Tuple&& __t) noexcept((is_nothrow_assignable<_BaseT&, _Tuple>::value))
        {
            __base_.operator=(std::__1::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};

template <>
class __attribute__ ((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr tuple() noexcept = default;
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(tuple&) noexcept {}
};


template <class ..._Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;


template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}

// get

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}



namespace __find_detail {

static constexpr size_t __not_found = -1;
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_idx_return(__i, __find_idx(__i + 1, __matches), __matches[__i]);
}

template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert(value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous, "type occurs more than once in type list");
};

template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

} // namespace __find_detail;

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__1::move(__tup));
}



// tie

template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace {
  inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::__1::get<_Ip-1>(__x) == std::__1::get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
            return true;
        if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
            return false;
        return __tuple_less<_Ip-1>()(__x, __y);
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}

// tuple_cat

template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename __uncvref<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return std::__1::forward_as_tuple(
            std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
            std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef typename remove_reference<_Tuple0>::type _T0;
        typedef typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
            tuple<_Types...,
                  typename __apply_cv<_Tuple0, typename tuple_element<
                                                   _J0, _T0>::type>::type&&...>,
            typename __make_tuple_indices<sizeof...(_Types) +
                                          tuple_size<_T0>::value>::type,
            typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
            std::__1::forward_as_tuple(
                std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...),
            std::__1::forward<_Tuple1>(__t1), std::__1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__1::forward<_Tuple0>(__t0),
                                            std::__1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>( __first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...)
{
}


template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



template <class _Fn, class _Tuple, size_t ..._Id>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
                                            __tuple_indices<_Id...>)
noexcept(noexcept(std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...))) { return std::__1::__invoke_constexpr( std::__1::forward<_Fn>(__f), std::__1::get<_Id>(std::__1::forward<_Tuple>(__t))...); }





template <class _Fn, class _Tuple>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
noexcept(noexcept(std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__1::__apply_tuple_impl( std::__1::forward<_Fn>(__f), std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }





template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
noexcept(noexcept(_Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...))) { return _Tp(std::__1::get<_Idx>(std::__1::forward<_Tuple>(__t))...); }



template <class _Tp, class _Tuple>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _Tp make_from_tuple(_Tuple&& __t)
noexcept(noexcept(std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__1::__make_from_tuple_impl<_Tp>(std::__1::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
# 1451 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/tuple" 3
} }
# 680 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdexcept" 1
// -*- C++ -*-
//===--------------------------- stdexcept --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    stdexcept synopsis

namespace std
{

class logic_error;
    class domain_error;
    class invalid_argument;
    class length_error;
    class out_of_range;
class runtime_error;
    class range_error;
    class overflow_error;
    class underflow_error;

for each class xxx_error:

class xxx_error : public exception // at least indirectly
{
public:
    explicit xxx_error(const string& what_arg);
    explicit xxx_error(const char*   what_arg);

    virtual const char* what() const noexcept // returns what_arg
};

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 45 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdexcept" 2
# 51 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdexcept" 3


namespace std { inline namespace __1 {


class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;

    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();

    const char* c_str() const noexcept {return __imp_;}
};


} }

namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{

private:
    std::__1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char* what() const noexcept;





};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit domain_error(const char* __s) : logic_error(__s) {}


    domain_error(const domain_error&) noexcept = default;
    virtual ~domain_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}


    invalid_argument(const invalid_argument&) noexcept = default;
    virtual ~invalid_argument() noexcept;

};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit length_error(const char* __s) : logic_error(__s) {}

    length_error(const length_error&) noexcept = default;
    virtual ~length_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit out_of_range(const char* __s) : logic_error(__s) {}


    out_of_range(const out_of_range&) noexcept = default;
    virtual ~out_of_range() noexcept;

};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit range_error(const char* __s) : runtime_error(__s) {}


    range_error(const range_error&) noexcept = default;
    virtual ~range_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}


    overflow_error(const overflow_error&) noexcept = default;
    virtual ~overflow_error() noexcept;

};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}


    underflow_error(const underflow_error&) noexcept = default;
    virtual ~underflow_error() noexcept;

};

} // std

namespace std { inline namespace __1 {

// in the dylib
[[noreturn]] __attribute__ ((__visibility__("default"))) void __throw_runtime_error(const char*);

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_logic_error(const char*__msg)
{

    throw logic_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_domain_error(const char*__msg)
{

    throw domain_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_invalid_argument(const char*__msg)
{

    throw invalid_argument(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_length_error(const char*__msg)
{

    throw length_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_out_of_range(const char*__msg)
{

    throw out_of_range(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_range_error(const char*__msg)
{

    throw range_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_overflow_error(const char*__msg)
{

    throw overflow_error(__msg);




}

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_underflow_error(const char*__msg)
{

    throw underflow_error(__msg);




}

} }
# 681 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/pointer_traits.h" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/pointer_traits.h" 2
# 18 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/pointer_traits.h" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 22 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/pointer_traits.h" 2 3

namespace std { inline namespace __1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
              typename __void_t<typename _Tp::element_type>::type> : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp,
            typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
#pragma GCC diagnostic push
# 78 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{

    typedef typename _Tp::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{

    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;


    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;





private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;


    template <class _Up> using rebind = _Up*;




private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) noexcept
        {return std::__1::addressof(__r);}
};

template <class _From, class _To>
struct __rebind_pointer {

    typedef typename pointer_traits<_From>::template rebind<_To> type;



};

} }
# 16 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 2
# 20 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 24 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 2 3

namespace std { inline namespace __1 {





// __pointer
template <class _Tp, class = void> struct __has_pointer : false_type { }; template <class _Tp> struct __has_pointer<_Tp, typename __void_t<typename _Tp:: pointer >::type> : true_type { };
template <class _Tp, class _Alloc,
          class _RawAlloc = typename remove_reference<_Alloc>::type,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
    using type = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
    using type = _Tp*;
};

// __const_pointer
template <class _Tp, class = void> struct __has_const_pointer : false_type { }; template <class _Tp> struct __has_const_pointer<_Tp, typename __void_t<typename _Tp:: const_pointer >::type> : true_type { };
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
    using type = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<const _Tp>;

};

// __void_pointer
template <class _Tp, class = void> struct __has_void_pointer : false_type { }; template <class _Tp> struct __has_void_pointer<_Tp, typename __void_t<typename _Tp:: void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
    using type = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<void>;

};

// __const_void_pointer
template <class _Tp, class = void> struct __has_const_void_pointer : false_type { }; template <class _Tp> struct __has_const_void_pointer<_Tp, typename __void_t<typename _Tp:: const_void_pointer >::type> : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
    using type = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {



    using type = typename pointer_traits<_Ptr>::template rebind<const void>;

};

// __size_type
template <class _Tp, class = void> struct __has_size_type : false_type { }; template <class _Tp> struct __has_size_type<_Tp, typename __void_t<typename _Tp:: size_type >::type> : true_type { };
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> { };
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
    using type = typename _Alloc::size_type;
};

// __alloc_traits_difference_type
template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type { }; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, typename __void_t<typename _Tp:: difference_type >::type> : true_type { };
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
    using type = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
    using type = typename _Alloc::difference_type;
};

// __propagate_on_container_copy_assignment
template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_copy_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_copy_assignment;
};

// __propagate_on_container_move_assignment
template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, typename __void_t<typename _Tp:: propagate_on_container_move_assignment >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_move_assignment;
};

// __propagate_on_container_swap
template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { }; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, typename __void_t<typename _Tp:: propagate_on_container_swap >::type> : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type { };
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
    using type = typename _Alloc::propagate_on_container_swap;
};

// __is_always_equal
template <class _Tp, class = void> struct __has_is_always_equal : false_type { }; template <class _Tp> struct __has_is_always_equal<_Tp, typename __void_t<typename _Tp:: is_always_equal >::type> : true_type { };
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> { };
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
    using type = typename _Alloc::is_always_equal;
};

// __allocator_traits_rebind
#pragma GCC diagnostic push
# 149 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type { };
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, typename __void_t<
    typename _Tp::template rebind<_Up>::other
>::type> : true_type { };

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
    using type = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
    using type = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
    using type = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template<class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 174 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"

// __has_allocate_hint
template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type { };

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, decltype(
    (void)declval<_Alloc>().allocate(declval<_SizeType>(), declval<_ConstVoidPtr>())
)> : true_type { };

// __has_construct
template <class, class _Alloc, class ..._Args>
struct __has_construct_impl : false_type { };

template <class _Alloc, class ..._Args>
struct __has_construct_impl<decltype(
    (void)declval<_Alloc>().construct(declval<_Args>()...)
), _Alloc, _Args...> : true_type { };

template <class _Alloc, class ..._Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> { };

// __has_destroy
template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type { };

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype(
    (void)declval<_Alloc>().destroy(declval<_Pointer>())
)> : true_type { };

// __has_max_size
template <class _Alloc, class = void>
struct __has_max_size : false_type { };

template <class _Alloc>
struct __has_max_size<_Alloc, decltype(
    (void)declval<_Alloc&>().max_size()
)> : true_type { };

// __has_select_on_container_copy_construction
template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type { };

template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, decltype(
    (void)declval<_Alloc>().select_on_container_copy_construction()
)> : true_type { };

#pragma GCC diagnostic pop

template <class _Alloc>
struct __attribute__ ((__type_visibility__("default"))) allocator_traits
{
    using allocator_type = _Alloc;
    using value_type = typename allocator_type::value_type;
    using pointer = typename __pointer<value_type, allocator_type>::type;
    using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
    using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
    using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
    using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
    using size_type = typename __size_type<allocator_type, difference_type>::type;
    using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
    using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
    using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
    using is_always_equal = typename __is_always_equal<allocator_type>::type;


    template <class _Tp>
    using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
    template <class _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
# 258 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer allocate(allocator_type& __a, size_type __n) {
        return __a.allocate(__n);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 267 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
 }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer) {
        return __a.allocate(__n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
        __a.deallocate(__p, __n);
    }

    template <class _Tp, class... _Args, class =
        _EnableIf<__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 287 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 __a.construct(__p, std::__1::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
 }
    template <class _Tp, class... _Args, class = void, class =
        _EnableIf<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void construct(allocator_type&, _Tp* __p, _Args&&... __args) {



        ::new ((void*)__p) _Tp(std::__1::forward<_Args>(__args)...);

    }

    template <class _Tp, class =
        _EnableIf<__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 306 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 __a.destroy(__p);
#pragma GCC diagnostic pop
 }
    template <class _Tp, class = void, class =
        _EnableIf<!__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static void destroy(allocator_type&, _Tp* __p) {



        __p->~_Tp();

    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
# 325 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
 return __a.max_size();
#pragma GCC diagnostic pop
 }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_max_size<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type max_size(const allocator_type&) noexcept {
        return numeric_limits<size_type>::max() / sizeof(value_type);
    }

    template <class _Ap = _Alloc, class =
        _EnableIf<__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a.select_on_container_copy_construction();
    }
    template <class _Ap = _Alloc, class = void, class =
        _EnableIf<!__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a;
    }
};

template <class _Traits, class _Tp>
struct __rebind_alloc_helper {

    using type = typename _Traits::template rebind_alloc<_Tp>;



};

// __is_default_allocator
template <class _Tp>
struct __is_default_allocator : false_type { };

template <class _Tp>
struct __is_default_allocator<std::__1::allocator<_Tp> > : true_type { };

// __is_cpp17_move_insertable
template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{ };

template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value
> > : true_type { };

// __is_cpp17_copy_insertable
template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
        is_copy_constructible<typename _Alloc::value_type>::value &&
        __is_cpp17_move_insertable<_Alloc>::value
    >
{ };

template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, _EnableIf<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value
> >
    : __is_cpp17_move_insertable<_Alloc>
{ };



} }
# 683 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/utilities.h" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/utilities.h" 2
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/utilities.h" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 23 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__memory/utilities.h" 2 3


namespace std { inline namespace __1 {

// Helper class to allocate memory using an Allocator in an exception safe
// manner.
//
// The intended usage of this class is as follows:
//
// 0
// 1     __allocation_guard<SomeAllocator> guard(alloc, 10);
// 2     do_some_initialization_that_may_throw(guard.__get());
// 3     save_allocated_pointer_in_a_noexcept_operation(guard.__release_ptr());
// 4
//
// If line (2) throws an exception during initialization of the memory, the
// guard's destructor will be called, and the memory will be released using
// Allocator deallocation. Otherwise, we release the memory from the guard on
// line (3) in an operation that can't throw -- after that, the guard is not
// responsible for the memory anymore.
//
// This is similar to a unique_ptr, except it's easier to use with a
// custom allocator.
template<class _Alloc>
struct __allocation_guard {
    using _Pointer = typename allocator_traits<_Alloc>::pointer;
    using _Size = typename allocator_traits<_Alloc>::size_type;

    template<class _AllocT> // we perform the allocator conversion inside the constructor
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __allocation_guard(_AllocT __alloc, _Size __n)
        : __alloc_(std::__1::move(__alloc))
        , __n_(__n)
        , __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_)) // initialization order is important
    { }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__allocation_guard() noexcept {
        if (__ptr_ != nullptr) {
            allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Pointer __release_ptr() noexcept { // not called __release() because it's a keyword in objective-c++
        _Pointer __tmp = __ptr_;
        __ptr_ = nullptr;
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Pointer __get() const noexcept {
        return __ptr_;
    }

private:
    _Alloc __alloc_;
    _Size __n_;
    _Pointer __ptr_;
};

} }
# 686 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2
# 693 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 697 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 2 3


namespace std { inline namespace __1 {

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {





    return *__value;

}

template <class _ValueType>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {





    return *__value;

}

template <bool _UsePointerTraits> struct __to_address_helper;

template <> struct __to_address_helper<true> {
    template <class _Pointer>
    using __return_type = decltype(pointer_traits<_Pointer>::to_address(std::__1::declval<const _Pointer&>()));

    template <class _Pointer>
    constexpr
    static __return_type<_Pointer>
    __do_it(const _Pointer &__p) noexcept { return pointer_traits<_Pointer>::to_address(__p); }
};

template <class _Pointer, bool _Dummy = true>
using __choose_to_address = __to_address_helper<_IsValidExpansion<__to_address_helper<_Dummy>::template __return_type, _Pointer>::value>;


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp*
__to_address(_Tp* __p) noexcept
{
    static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename __choose_to_address<_Pointer>::template __return_type<_Pointer>
__to_address(const _Pointer& __p) noexcept {
  return __choose_to_address<_Pointer>::__do_it(__p);
}

template <> struct __to_address_helper<false> {
    template <class _Pointer>
    using __return_type = typename pointer_traits<_Pointer>::element_type*;

    template <class _Pointer>
    constexpr
    static __return_type<_Pointer>
    __do_it(const _Pointer &__p) noexcept { return std::__1::__to_address(__p.operator->()); }
};
# 787 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
template <class _Tp> class allocator;


template <>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};


// allocator

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator() noexcept { }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<_Tp*>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void deallocate(_Tp* __p, size_t __n) noexcept {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(__p);
        } else {
            std::__1::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
        }
    }

    // C++20 Removed members

    __attribute__ ((deprecated)) typedef _Tp* pointer;
    __attribute__ ((deprecated)) typedef const _Tp* const_pointer;
    __attribute__ ((deprecated)) typedef _Tp& reference;
    __attribute__ ((deprecated)) typedef const _Tp& const_reference;

    template <class _Up>
    struct __attribute__ ((deprecated)) rebind {
        typedef allocator<_Up> other;
    };

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer address(reference __x) const noexcept {
        return std::__1::addressof(__x);
    }
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer address(const_reference __x) const noexcept {
        return std::__1::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((deprecated))
    _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator() noexcept { }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator(const allocator<_Up>&) noexcept { }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_length_error("allocator<const T>::allocate(size_t n)"
                                 " 'n' exceeds maximum supported size");
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<const _Tp*>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void deallocate(const _Tp* __p, size_t __n) {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(const_cast<_Tp*>(__p));
        } else {
            std::__1::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));
        }
    }

    // C++20 Removed members

    __attribute__ ((deprecated)) typedef const _Tp* pointer;
    __attribute__ ((deprecated)) typedef const _Tp* const_pointer;
    __attribute__ ((deprecated)) typedef const _Tp& reference;
    __attribute__ ((deprecated)) typedef const _Tp& const_reference;

    template <class _Up>
    struct __attribute__ ((deprecated)) rebind {
        typedef allocator<_Up> other;
    };

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer address(const_reference __x) const noexcept {
        return std::__1::addressof(__x);
    }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __attribute__ ((deprecated))
    const _Tp* allocate(size_t __n, const void*) {
        return allocate(__n);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type max_size() const noexcept {
        return size_type(~0) / sizeof(_Tp);
    }

    template <class _Up, class... _Args>
    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void construct(_Up* __p, _Args&&... __args) {
        ::new ((void*)__p) _Up(std::__1::forward<_Args>(__args)...);
    }

    __attribute__ ((deprecated)) __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void destroy(pointer __p) {
        __p->~_Tp();
    }

};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_forward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2) {
        _Traits::construct(__a, std::__1::__to_address(__begin2),



            std::__1::move_if_noexcept(*__begin1)

        );
    }
}

template <class _Alloc, class _Tp, typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_forward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Iter, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_range_forward(_Alloc& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2) {
    typedef allocator_traits<_Alloc> _Traits;
    for (; __begin1 != __end1; ++__begin1, (void) ++__begin2) {
        _Traits::construct(__a, std::__1::__to_address(__begin2), *__begin1);
    }
}

template <class _Alloc, class _Source, class _Dest,
          class _RawSource = typename remove_const<_Source>::type,
          class _RawDest = typename remove_const<_Dest>::type,
          class =
    typename enable_if<
        is_trivially_copy_constructible<_Dest>::value &&
        is_same<_RawSource, _RawDest>::value &&
        (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Dest*, _Source&>::value)
    >::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_range_forward(_Alloc&, _Source* __begin1, _Source* __end1, _Dest*& __begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
        std::__1::memcpy(const_cast<_RawDest*>(__begin2), __begin1, _Np * sizeof(_Dest));
        __begin2 += _Np;
    }
}

template <class _Alloc, class _Ptr>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_backward_with_exception_guarantees(_Alloc& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2) {
    static_assert(__is_cpp17_move_insertable<_Alloc>::value,
        "The specified type does not meet the requirements of Cpp17MoveInsertable");
    typedef allocator_traits<_Alloc> _Traits;
    while (__end1 != __begin1) {
        _Traits::construct(__a, std::__1::__to_address(__end2 - 1),



            std::__1::move_if_noexcept(*--__end1)

        );
        --__end2;
    }
}

template <class _Alloc, class _Tp, class = typename enable_if<
    (__is_default_allocator<_Alloc>::value || !__has_construct<_Alloc, _Tp*, _Tp>::value) &&
    is_trivially_move_constructible<_Tp>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __construct_backward_with_exception_guarantees(_Alloc&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2) {
    ptrdiff_t _Np = __end1 - __begin1;
    __end2 -= _Np;
    if (_Np > 0)
        std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp, // purposefully not C++03
                      ptrdiff_t, // purposefully not C++03
                      _Tp*, // purposefully not C++03
                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new ((void*)std::__1::addressof(*__x_)) _Tp(__element); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator=(_Tp&& __element)
        {::new ((void*)std::__1::addressof(*__x_)) _Tp(std::__1::move(__element)); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _OutputIterator base() const { return __x_; }

};

template <class _Tp>
                      __attribute__((__no_sanitize__("cfi")))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {

    if (__is_overaligned_for_new(alignof(_Tp)))
        {
            align_val_t __al =
                align_val_t(alignment_of<_Tp>::value);
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), __al, nothrow));
        } else {
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), nothrow));
        }
# 1130 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__1::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}
# 1206 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
// Tag used to default initialize one or both of the pair's elements.
struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, class = typename enable_if<
      !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_(std::__1::forward<_Up>(__u))
    {
    }



  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}



  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __get() noexcept { return __value_; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const_reference __get() const noexcept { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp __value_type;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr __compressed_pair_elem() = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(__default_init_tag) {}
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, class = typename enable_if<
        !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value
  >::type>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr explicit
  __compressed_pair_elem(_Up&& __u)
      : __value_type(std::__1::forward<_Up>(__u))
  {}


  template <class... _Args, size_t... _Indexes>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __get() noexcept { return *this; }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const_reference __get() const noexcept { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
public:
  // NOTE: This static assert should never fire because __compressed_pair
  // is *almost never* used in a scenario where it's possible for T1 == T2.
  // (The exception is std::function where it is possible that the function
  //  object and the allocator have the same type).
  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous "
    "implementation for this configuration");

    typedef __compressed_pair_elem<_T1, 0> _Base1;
    typedef __compressed_pair_elem<_T2, 1> _Base2;

    template <bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value
      >::type
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::__1::forward<_U1>(__t1)), _Base2(std::__1::forward<_U2>(__t2)) {}


  template <class... _Args1, class... _Args2>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}


  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  static _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
  static _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(__compressed_pair& __x)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)

  {
    using std::__1::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}

// default_delete

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr default_delete() noexcept = default;



  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  default_delete(const default_delete<_Up>&,
                 typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =
                     0) noexcept {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};

public:

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr default_delete() noexcept = default;




  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  default_delete(const default_delete<_Up[]>&,
                 typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat { int __for_bool_; };

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p, __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}
# 1575 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
# 1611 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};


template <class _Tp, class _Dp>
class __attribute__ ((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;

  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr() noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer(), __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterConvertible<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
      class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
      class = _EnableIfDeleterAssignable<_Ep>
  >
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr&
  operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }






public:
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  ~unique_ptr() { reset(); }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer get() const noexcept {
    return __ptr_.first();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }

};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if<
    __is_swappable<_Dp>::value,
    void
>::type
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}



template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp, class _Dp>



struct __attribute__ ((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >

{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result_type operator()(const argument_type& __ptr) const
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t __size_;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __process(_Tp*, true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr(true_type) noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __incr() noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __f != __l; ++__f, (void) ++__r)
            ::new ((void*)std::__1::addressof(*__r)) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __r;
    try
    {

        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)
            ::new ((void*)std::__1::addressof(*__r)) value_type(*__f);

    }
    catch (...)
    {
        for (; __s != __r; ++__s)
            __s->~value_type();
        throw;
    }

    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __f != __l; ++__f)
            ::new ((void*)std::__1::addressof(*__f)) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

    _ForwardIterator __s = __f;
    try
    {

        for (; __n > 0; ++__f, (void) --__n)
            ::new ((void*)std::__1::addressof(*__f)) value_type(__x);

    }
    catch (...)
    {
        for (; __s != __f; ++__s)
            __s->~value_type();
        throw;
    }

    return __f;
}



template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void destroy(_ForwardIterator __first, _ForwardIterator __last) {
    for (; __first != __last; ++__first)
        std::__1::destroy_at(std::__1::addressof(*__first));
}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
    for (; __n > 0; (void)++__first, --__n)
        std::__1::destroy_at(std::__1::addressof(*__first));
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt;
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __idx != __last; ++__idx)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt();

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}

template <class _ForwardIterator, class _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;
    auto __idx = __first;

    try {

    for (; __n > 0; (void)++__idx, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt();
    return __idx;

    } catch (...) {
        std::__1::destroy(__first, __idx);
        throw;
    }

}


template <class _InputIt, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __first != __last; (void)++__idx, ++__first)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt(std::__1::move(*__first));
    return __idx;

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}

template <class _InputIt, class _Size, class _ForwardIt>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_InputIt, _ForwardIt>
uninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {
    using _Vt = typename iterator_traits<_ForwardIt>::value_type;
    auto __idx = __first_res;

    try {

    for (; __n > 0; ++__idx, (void)++__first, --__n)
        ::new ((void*)std::__1::addressof(*__idx)) _Vt(std::__1::move(*__first));
    return {__first, __idx};

    } catch (...) {
        std::__1::destroy(__first_res, __idx);
        throw;
    }

}




// NOTE: Relaxed and acq/rel atomics (for increment and decrement respectively)
// should be sufficient for thread safety.
// See https://bugs.llvm.org/show_bug.cgi?id=22803
# 2403 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{



    return __t += 1;

}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{



    return __t -= 1;

}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    bad_weak_ptr() noexcept = default;
    bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
    virtual ~bad_weak_ptr() noexcept;
    virtual const char* what() const noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_bad_weak_ptr()
{

    throw bad_weak_ptr();



}

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }

    void __release_weak() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;

    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) {}


    virtual const void* __get_deleter(const type_info&) const noexcept;


private:
    virtual void __on_zero_shared() noexcept;
    virtual void __on_zero_shared_weak() noexcept;
};



template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::__1::addressof(__data_.first().second()) : nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;

    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template<class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
        : __storage_(std::__1::move(__a))
    {





        ::new ((void*)__get_elem()) _Tp(std::__1::forward<_Args>(__args)...);

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }

private:
    virtual void __on_zero_shared() noexcept {





        __get_elem()->~_Tp();

    }

    virtual void __on_zero_shared_weak() noexcept {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
            pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }

    // This class implements the control block for non-array shared pointers created
    // through `std::allocate_shared` and `std::make_shared`.
    //
    // In previous versions of the library, we used a compressed pair to store
    // both the _Alloc and the _Tp. This implies using EBO, which is incompatible
    // with Allocator construction for _Tp. To allow implementing P0674 in C++20,
    // we now use a properly aligned char buffer while making sure that we maintain
    // the same layout that we had when we used a compressed pair.
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct alignas(_CompressedPair) _Storage {
        char __blob_[sizeof(_CompressedPair)];

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit _Storage(_Alloc&& __a) {
            ::new ((void*)__get_alloc()) _Alloc(std::__1::move(__a));
        }
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ~_Storage() {
            __get_alloc()->~_Alloc();
        }
        _Alloc* __get_alloc() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc*>(__first);
            return __alloc;
        }
        __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp*>(__second);
            return __elem;
        }
    };

    static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
    static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__ ((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};

template<class _Tp> class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this;

template<class _Tp, class _Up>
struct __compatible_with

    : is_convertible<remove_extent_t<_Tp>*, remove_extent_t<_Up>*> {};
# 2691 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) shared_ptr
{
public:

    typedef weak_ptr<_Tp> weak_type;
    typedef remove_extent_t<_Tp> element_type;




private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr shared_ptr() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr shared_ptr(nullptr_t) noexcept;
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr(const shared_ptr& __r) noexcept;
    template<class _Yp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr(shared_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type = __nat())
                       noexcept;
    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());





    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());

    ~shared_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr& operator=(const shared_ptr& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(const shared_ptr<_Yp>& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr& operator=(shared_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(shared_ptr<_Yp>&& __r);
# 2795 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(unique_ptr<_Yp, _Dp>&& __r);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(shared_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            __compatible_with<_Yp, element_type>::value,
            void
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    element_type* get() const noexcept {return __ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename add_lvalue_reference<element_type>::type operator*() const noexcept
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    element_type* operator->() const noexcept
    {
        static_assert(!std::__1::is_array<_Tp>::value,
                      "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool unique() const noexcept {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const noexcept {return get() != nullptr;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(shared_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(weak_ptr<_Up> const& __p) const noexcept
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}


    typename add_lvalue_reference<element_type>::type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator[](ptrdiff_t __i) const
    {
            static_assert(std::__1::is_array<_Tp>::value,
                          "std::shared_ptr<T>::operator[] is only valid when T is an array type.");
            return __ptr_[__i];
    }



    template <class _Dp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        _Dp* __get_deleter() const noexcept
            {return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);}


    template<class _Yp, class _CntrlBlk>
    static shared_ptr<_Tp>
    __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }

private:
    template <class _Yp, bool = is_function<_Yp>::value>
        struct __shared_ptr_default_allocator
        {
            typedef allocator<_Yp> type;
        };

    template <class _Yp>
        struct __shared_ptr_default_allocator<_Yp, true>
        {
            typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
        };

    template <class _Yp, class _OrigPtr>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if<is_convertible<_OrigPtr*,
                                          const enable_shared_from_this<_Yp>*
        >::value,
            void>::type
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,
                           _OrigPtr* __ptr) noexcept
        {
            typedef typename remove_cv<_Yp>::type _RawYp;
            if (__e && __e->__weak_this_.expired())
            {
                __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __enable_weak_this(...) noexcept {}

    template <class, class _Yp>
        struct __shared_ptr_default_delete
            : default_delete<_Yp> {};

    template <class _Yp, class _Un, size_t _Sz>
        struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
            : default_delete<_Yp[]> {};

    template <class _Yp, class _Un>
        struct __shared_ptr_default_delete<_Yp[], _Un>
            : default_delete<_Yp[]> {};

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
};


template<class _Tp>
shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
template<class _Tp, class _Dp>
shared_ptr(unique_ptr<_Tp, _Dp>) -> shared_ptr<_Tp>;


template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(nullptr)
{

    try
    {

        typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
        typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
    : __ptr_(__p)
{

    try
    {

        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__1::addressof(*__hold2.get())) _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());
        __enable_weak_this(__p, __p);

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(nullptr)
{

    try
    {

        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new ((void*)std::__1::addressof(*__hold2.get())) _CntrlBlk(__p, __d, __a);
        __cntrl_ = std::__1::addressof(*__hold2.release());

    }
    catch (...)
    {
        __d(__p);
        throw;
    }

}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<__compatible_with<_Yp, element_type>::value, __nat>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}
# 3154 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,
                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{

    if (__ptr_ == nullptr)
        __cntrl_ = nullptr;
    else

    {
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*,
                                     reference_wrapper<typename remove_reference<_Dp>::type>,
                                     _AllocT > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__r.get(), std::__1::ref(__r.get_deleter()), _AllocT());
        __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
}

template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) noexcept
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) noexcept
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}
# 3278 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
template<class _Tp>
template <class _Yp, class _Dp>
inline
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                   typename shared_ptr<_Tp>::element_type*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::swap(shared_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline
void
shared_ptr<_Tp>::reset() noexcept
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline
typename enable_if
<
    __compatible_with<_Yp, typename shared_ptr<_Tp>::element_type>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}

//
// std::allocate_shared and std::make_shared
//
template<class _Tp, class _Alloc, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void*)std::__1::addressof(*__guard.__get())) _ControlBlock(__a, std::__1::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::__1::addressof(*__control_block));
}

template<class _Tp, class ..._Args, class = _EnableIf<!is_array<_Tp>::value> >
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
shared_ptr<_Tp> make_shared(_Args&& ...__args)
{
    return std::__1::allocate_shared<_Tp>(allocator<_Tp>(), std::__1::forward<_Args>(__args)...);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{




    return less<>()(__x.get(), __y.get());


}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) noexcept
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET* __p = dynamic_cast<_ET*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}

template<class _Tp, class _Up>
shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}



template<class _Dp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}



template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         noexcept;
    ~weak_ptr();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(weak_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(weak_ptr<_Yp>&& __r) noexcept;

    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        operator=(shared_ptr<_Yp> const& __r) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(weak_ptr& __r) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool expired() const noexcept
        {return __cntrl_ == nullptr || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__type_visibility__("default"))) shared_ptr;
};


template<class _Tp>
weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;


template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}

template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::__1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::__1::swap(__ptr_, __r.__ptr_);
    std::__1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}

template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == nullptr)
        __throw_bad_weak_ptr();
}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}


template <class _Tp = void> struct owner_less;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) owner_less<void>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    typedef void is_transparent;
};


template<class _Tp>
class __attribute__ ((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr<_Tp> weak_from_this() noexcept
       { return __weak_this_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    weak_ptr<const _Tp> weak_from_this() const noexcept
        { return __weak_this_; }


    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result_type operator()(const argument_type& __ptr) const noexcept
    {
        return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
# 4108 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
//enum class
# 4118 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/memory" 3
struct __attribute__ ((__visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer_safety() : __v_() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator int() const {return __v_;}
};






// This function is only offered in C++03 under ABI v1.

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pointer_safety get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}




__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

// --- Helper for container swap --
template <typename _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)

    noexcept



{
    using std::__1::swap;
    swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __swap_allocator(_Alloc & __a1, _Alloc & __a2)

    noexcept



{
    std::__1::__swap_allocator(__a1, __a2,
      integral_constant<bool, std::__1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >
struct __noexcept_move_assign_container : public integral_constant<bool,
    _Traits::propagate_on_container_move_assignment::value

        || _Traits::is_always_equal::value



    > {};


template <class _Tp, class _Alloc>
struct __temp_value {
    typedef allocator_traits<_Alloc> _Traits;

    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
    _Alloc &__a;

    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
    _Tp & get() { return *__addr(); }

    template<class... _Args>
    __attribute__((__no_sanitize__("cfi")))
    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc) {
      _Traits::construct(__a, reinterpret_cast<_Tp*>(addressof(__v)),
                         std::__1::forward<_Args>(__args)...);
    }

    ~__temp_value() { _Traits::destroy(__a, __addr()); }
    };

template<typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template<typename _Alloc>
struct __is_allocator<_Alloc,
       typename __void_t<typename _Alloc::value_type>::type,
       typename __void_t<decltype(std::__1::declval<_Alloc&>().allocate(size_t(0)))>::type
     >
   : true_type {};

// __builtin_new_allocator -- A non-templated helper for allocating and
// deallocating memory using __builtin_operator_new and
// __builtin_operator_delete. It should be used in preference to
// `std::allocator<T>` to avoid additional instantiations.
struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

    constexpr explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void* p) const noexcept {
        std::__1::__libcpp_deallocate(p, __size_, __align_);
    }

   private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
      return __holder_t(std::__1::__libcpp_allocate(__s, __align),
                     __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void* __p, size_t __s,
                                 size_t __align) noexcept {
      std::__1::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static __holder_t __allocate_type(size_t __n) {
      return __allocate_bytes(__n * sizeof(_Tp), alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__ ((__always_inline__))
  static void __deallocate_type(void* __p, size_t __n) noexcept {
      __deallocate_bytes(__p, __n * sizeof(_Tp), alignof(_Tp));
  }
};


} }
# 654 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 1
// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    functional synopsis

namespace std
{

template <class Arg, class Result>
struct unary_function
{
    typedef Arg    argument_type;
    typedef Result result_type;
};

template <class Arg1, class Arg2, class Result>
struct binary_function
{
    typedef Arg1   first_argument_type;
    typedef Arg2   second_argument_type;
    typedef Result result_type;
};

template <class T>
class reference_wrapper
    : public unary_function<T1, R> // if wrapping a unary functor
    : public binary_function<T1, T2, R> // if wraping a binary functor
{
public:
    // types
    typedef T type;
    typedef see below result_type; // Not always defined

    // construct/copy/destroy
    reference_wrapper(T&) noexcept;
    reference_wrapper(T&&) = delete; // do not bind to temps
    reference_wrapper(const reference_wrapper<T>& x) noexcept;

    // assignment
    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;

    // access
    operator T& () const noexcept;
    T& get() const noexcept;

    // invoke
    template <class... ArgTypes>
      typename result_of<T&(ArgTypes&&...)>::type
          operator() (ArgTypes&&...) const;
};

template <class T> reference_wrapper<T> ref(T& t) noexcept;
template <class T> void ref(const T&& t) = delete;
template <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;

template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
template <class T> void cref(const T&& t) = delete;
template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;

template <class T> struct unwrap_reference;                                       // since C++20
template <class T> struct unwrap_ref_decay : unwrap_reference<decay_t<T>> { };    // since C++20
template <class T> using unwrap_reference_t = typename unwrap_reference<T>::type; // since C++20
template <class T> using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type; // since C++20

template <class T> // <class T=void> in C++14
struct plus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct minus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct multiplies : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct divides : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct modulus : binary_function<T, T, T>
{
    T operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct negate : unary_function<T, T>
{
    T operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct not_equal_to : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct greater_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct less_equal : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_and : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_or : binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct logical_not : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class T> // <class T=void> in C++14
struct bit_and : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_or : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T> // <class T=void> in C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x, const T& y) const;
};

template <class T=void> // C++14
struct bit_xor : unary_function<T, bool>
{
    bool operator()(const T& x) const;
};

template <class Predicate>
class unary_negate // deprecated in C++17
    : public unary_function<typename Predicate::argument_type, bool>
{
public:
    explicit unary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::argument_type& x) const;
};

template <class Predicate> // deprecated in C++17
unary_negate<Predicate> not1(const Predicate& pred);

template <class Predicate>
class binary_negate // deprecated in C++17
    : public binary_function<typename Predicate::first_argument_type,
                             typename Predicate::second_argument_type,
                             bool>
{
public:
    explicit binary_negate(const Predicate& pred);
    bool operator()(const typename Predicate::first_argument_type& x,
                    const typename Predicate::second_argument_type& y) const;
};

template <class Predicate> // deprecated in C++17
binary_negate<Predicate> not2(const Predicate& pred);

template <class F>
constexpr unspecified not_fn(F&& f); // C++17, constexpr in C++20

template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;

    // See C++14 20.9.9, Function object binders
template <class T> inline constexpr bool is_bind_expression_v
  = is_bind_expression<T>::value; // C++17
template <class T> inline constexpr int is_placeholder_v
  = is_placeholder<T>::value; // C++17


template<class Fn, class... BoundArgs>
  constexpr unspecified bind(Fn&&, BoundArgs&&...);  // constexpr in C++20
template<class R, class Fn, class... BoundArgs>
  constexpr unspecified bind(Fn&&, BoundArgs&&...);  // constexpr in C++20

template<class F, class... Args>
 constexpr // constexpr in C++20
 invoke_result_t<F, Args...> invoke(F&& f, Args&&... args) // C++17
    noexcept(is_nothrow_invocable_v<F, Args...>);

namespace placeholders {
  // M is the implementation-defined number of placeholders
  extern unspecified _1;
  extern unspecified _2;
  .
  .
  .
  extern unspecified _Mp;
}

template <class Operation>
class binder1st     // deprecated in C++11, removed in C++17
    : public unary_function<typename Operation::second_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                               op;
    typename Operation::first_argument_type value;
public:
    binder1st(const Operation& x, const typename Operation::first_argument_type y);
    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;
};

template <class Operation, class T>
binder1st<Operation> bind1st(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17

template <class Operation>
class binder2nd     // deprecated in C++11, removed in C++17
    : public unary_function<typename Operation::first_argument_type,
                            typename Operation::result_type>
{
protected:
    Operation                                op;
    typename Operation::second_argument_type value;
public:
    binder2nd(const Operation& x, const typename Operation::second_argument_type y);
    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;
    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;
};

template <class Operation, class T>
binder2nd<Operation> bind2nd(const Operation& op, const T& x);  // deprecated in C++11, removed in C++17

template <class Arg, class Result>      // deprecated in C++11, removed in C++17
class pointer_to_unary_function : public unary_function<Arg, Result>
{
public:
    explicit pointer_to_unary_function(Result (*f)(Arg));
    Result operator()(Arg x) const;
};

template <class Arg, class Result>
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));      // deprecated in C++11, removed in C++17

template <class Arg1, class Arg2, class Result>      // deprecated in C++11, removed in C++17
class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
{
public:
    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
    Result operator()(Arg1 x, Arg2 y) const;
};

template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));      // deprecated in C++11, removed in C++17

template<class S, class T>      // deprecated in C++11, removed in C++17
class mem_fun_t : public unary_function<T*, S>
{
public:
    explicit mem_fun_t(S (T::*p)());
    S operator()(T* p) const;
};

template<class S, class T, class A>
class mem_fun1_t : public binary_function<T*, A, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit mem_fun1_t(S (T::*p)(A));
    S operator()(T* p, A x) const;
};

template<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());      // deprecated in C++11, removed in C++17
template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));     // deprecated in C++11, removed in C++17

template<class S, class T>
class mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit mem_fun_ref_t(S (T::*p)());
    S operator()(T& p) const;
};

template<class S, class T, class A>
class mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit mem_fun1_ref_t(S (T::*p)(A));
    S operator()(T& p, A x) const;
};

template<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());      // deprecated in C++11, removed in C++17
template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));     // deprecated in C++11, removed in C++17

template <class S, class T>
class const_mem_fun_t : public unary_function<const T*, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit const_mem_fun_t(S (T::*p)() const);
    S operator()(const T* p) const;
};

template <class S, class T, class A>
class const_mem_fun1_t : public binary_function<const T*, A, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit const_mem_fun1_t(S (T::*p)(A) const);
    S operator()(const T* p, A x) const;
};

template <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);      // deprecated in C++11, removed in C++17
template <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);     // deprecated in C++11, removed in C++17

template <class S, class T>
class const_mem_fun_ref_t : public unary_function<T, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit const_mem_fun_ref_t(S (T::*p)() const);
    S operator()(const T& p) const;
};

template <class S, class T, class A>
class const_mem_fun1_ref_t : public binary_function<T, A, S>      // deprecated in C++11, removed in C++17
{
public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
    S operator()(const T& p, A x) const;
};

template <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);   // deprecated in C++11, removed in C++17
template <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);  // deprecated in C++11, removed in C++17

template<class R, class T>
constexpr unspecified mem_fn(R T::*); // constexpr in C++20

class bad_function_call
    : public exception
{
};

template<class> class function; // undefined

template<class R, class... ArgTypes>
class function<R(ArgTypes...)>
  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and
                                      // ArgTypes contains T1
  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and
                                      // ArgTypes contains T1 and T2
{
public:
    typedef R result_type;

    // construct/copy/destroy:
    function() noexcept;
    function(nullptr_t) noexcept;
    function(const function&);
    function(function&&) noexcept;
    template<class F>
      function(F);
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&) noexcept;            // removed in C++17
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept; // removed in C++17
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, const function&);    // removed in C++17
    template<Allocator Alloc>
      function(allocator_arg_t, const Alloc&, function&&);         // removed in C++17
    template<class F, Allocator Alloc>
      function(allocator_arg_t, const Alloc&, F);                  // removed in C++17

    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class F>
      function& operator=(F&&);
    template<class F>
      function& operator=(reference_wrapper<F>) noexcept;

    ~function();

    // function modifiers:
    void swap(function&) noexcept;
    template<class F, class Alloc>
      void assign(F&&, const Alloc&);                 // Removed in C++17

    // function capacity:
    explicit operator bool() const noexcept;

    // function invocation:
    R operator()(ArgTypes...) const;

    // function target access:
    const std::type_info& target_type() const noexcept;
    template <typename T>       T* target() noexcept;
    template <typename T> const T* target() const noexcept;
};

// Deduction guides
template<class R, class ...Args>
function(R(*)(Args...)) -> function<R(Args...)>; // since C++17

template<class F>
function(F) -> function<see-below>; // since C++17

// Null pointer comparisons:
template <class R, class ... ArgTypes>
  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class R, class ... ArgTypes>
  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

template <class R, class ... ArgTypes>
  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;

template <class  R, class ... ArgTypes>
  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;

// specialized algorithms:
template <class  R, class ... ArgTypes>
  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;

template <class T> struct hash;

template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char8_t>; // since C++20
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;

template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;

template<class T> struct hash<T*>;
template <> struct hash<nullptr_t>;  // C++17

}  // std

POLICY:  For non-variadic implementations, the number of arguments is limited
         to 3.  It is hoped that the need for non-variadic implementations
         will be minimal.

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 505 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 2
# 517 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3


namespace std { inline namespace __1 {


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) negate<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(- std::__1::forward<_Tp>(__x)))
    -> decltype (- std::__1::forward<_Tp>(__x))
        { return - std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};



// less in <__functional_base>


template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(!std::__1::forward<_Tp>(__x)))
    -> decltype (!std::__1::forward<_Tp>(__x))
        { return !std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__type_visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};


template <>
struct __attribute__ ((__type_visibility__("default"))) bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_T1&& __t, _T2&& __u) const
    noexcept(noexcept(std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u)))
    -> decltype (std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u))
        { return std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>
struct __attribute__ ((__type_visibility__("default"))) bit_not : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct __attribute__ ((__type_visibility__("default"))) bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Tp&& __x) const
    noexcept(noexcept(~std::__1::forward<_Tp>(__x)))
    -> decltype (~std::__1::forward<_Tp>(__x))
        { return ~std::__1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
__attribute__ ((deprecated)) inline constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__type_visibility__("default"))) __attribute__ ((deprecated)) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit constexpr
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
__attribute__ ((deprecated)) inline constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}
# 1279 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
////////////////////////////////////////////////////////////////////////////////
//                                MEMFUN
//==============================================================================

template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:
    // types
    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __mem_fn(type __f) noexcept : __f_(__f) {}


    // invoke
    template <class... _ArgTypes>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename __invoke_return<type, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__1::__invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
    }
# 1405 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm) noexcept
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}

////////////////////////////////////////////////////////////////////////////////
//                                FUNCTION
//==============================================================================

// bad_function_call

class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{






};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_bad_function_call()
{

    throw bad_function_call();



}
# 1449 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
template<class _Fp> class __attribute__ ((__type_visibility__("default"))) function; // undefined

namespace __function
{

template<class _Rp>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __not_null(_Fp const&) { return true; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __not_null(_Fp* __ptr) { return __ptr; }

template <class _Ret, class _Class>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __not_null(_Ret _Class::*__ptr) { return __ptr; }

template <class _Fp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __not_null(function<_Fp> const& __f) { return !!__f; }


template <class _Rp, class ..._Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __not_null(_Rp (^__p)(_Args...)) { return __p; }


} // namespace __function



namespace __function {

// __alloc_func holds a functor and an allocator.

template <class _Fp, class _Ap, class _FB> class __alloc_func;
template <class _Fp, class _FB>
class __default_alloc_func;

template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Ap> __f_;

  public:
    typedef _Fp _Target;
    typedef _Ap _Alloc;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Target& __target() const { return __f_.first(); }

    // WIN32 APIs may define __allocator, so use __get_allocator instead.
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Alloc& __get_allocator() const { return __f_.second(); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __alloc_func(_Target&& __f)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
               std::__1::forward_as_tuple())
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __alloc_func(const _Target& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
               std::__1::forward_as_tuple(__a))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __alloc_func(const _Target& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
               std::__1::forward_as_tuple(std::__1::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __alloc_func(_Target&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
               std::__1::forward_as_tuple(std::__1::move(__a)))
    {
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Rp operator()(_ArgTypes&&... __arg)
    {
        typedef __invoke_void_return_wrapper<_Rp> _Invoker;
        return _Invoker::__call(__f_.first(),
                                std::__1::forward<_ArgTypes>(__arg)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __alloc_func* __clone() const
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef
            typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
                _AA;
        _AA __a(__f_.second());
        typedef __allocator_destructor<_AA> _Dp;
        unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
        ::new ((void*)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));
        return __hold.release();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void destroy() noexcept { __f_.~__compressed_pair<_Target, _Alloc>(); }

    static void __destroy_and_delete(__alloc_func* __f) {
      typedef allocator_traits<_Alloc> __alloc_traits;
      typedef typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
          _FunAlloc;
      _FunAlloc __a(__f->__get_allocator());
      __f->destroy();
      __a.deallocate(__f, 1);
    }
};

template <class _Fp, class _Rp, class... _ArgTypes>
class __default_alloc_func<_Fp, _Rp(_ArgTypes...)> {
  _Fp __f_;

public:
  typedef _Fp _Target;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  const _Target& __target() const { return __f_; }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit __default_alloc_func(_Target&& __f) : __f_(std::__1::move(__f)) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  explicit __default_alloc_func(const _Target& __f) : __f_(__f) {}

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  _Rp operator()(_ArgTypes&&... __arg) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_, std::__1::forward<_ArgTypes>(__arg)...);
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  __default_alloc_func* __clone() const {
      __builtin_new_allocator::__holder_t __hold =
        __builtin_new_allocator::__allocate_type<__default_alloc_func>(1);
    __default_alloc_func* __res =
        ::new ((void*)__hold.get()) __default_alloc_func(__f_);
    (void)__hold.release();
    return __res;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void destroy() noexcept { __f_.~_Target(); }

  static void __destroy_and_delete(__default_alloc_func* __f) {
    __f->destroy();
      __builtin_new_allocator::__deallocate_type<__default_alloc_func>(__f, 1);
  }
};

// __base provides an abstract interface for copyable functors.

template<class _Fp> class __attribute__ ((__type_visibility__("default"))) __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __base() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() noexcept = 0;
    virtual void destroy_deallocate() noexcept = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;

    virtual const void* target(const type_info&) const noexcept = 0;
    virtual const std::type_info& target_type() const noexcept = 0;

};

// __func implements __base for a given functor type.

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(_Fp&& __f)
        : __f_(std::__1::move(__f)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(__f, __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(__f, std::__1::move(__a)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(std::__1::move(__f), std::__1::move(__a)) {}

    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() noexcept;
    virtual void destroy_deallocate() noexcept;
    virtual _Rp operator()(_ArgTypes&&... __arg);

    virtual const void* target(const type_info&) const noexcept;
    virtual const std::type_info& target_type() const noexcept;

};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new ((void*)__hold.get()) __func(__f_.__target(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new ((void*)__p) __func(__f_.__target(), __f_.__get_allocator());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept
{
    __f_.destroy();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
    _Ap __a(__f_.__get_allocator());
    __f_.destroy();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const void*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const noexcept
{
    if (__ti == typeid(_Fp))
        return &__f_.__target();
    return nullptr;
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
const std::type_info&
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const noexcept
{
    return typeid(_Fp);
}



// __value_func creates a value-type from a __func.

template <class _Fp> class __value_func;

template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)>
{
    typename aligned_storage<3 * sizeof(void*)>::type __buf_;

    typedef __base<_Rp(_ArgTypes...)> __func;
    __func* __f_;

    __attribute__((__no_sanitize__("cfi"))) static __func* __as_base(void* p)
    {
        return reinterpret_cast<__func*>(p);
    }

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_func() noexcept : __f_(nullptr) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __value_func(_Fp&& __f, const _Alloc& __a)
        : __f_(nullptr)
    {
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            _FunAlloc __af(__a);
            if (sizeof(_Fun) <= sizeof(__buf_) &&
                is_nothrow_copy_constructible<_Fp>::value &&
                is_nothrow_copy_constructible<_FunAlloc>::value)
            {
                __f_ =
                    ::new ((void*)&__buf_) _Fun(std::__1::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get()) _Fun(std::__1::move(__f), _Alloc(__a));
                __f_ = __hold.release();
            }
        }
    }

    template <class _Fp,
        class = typename enable_if<!is_same<typename decay<_Fp>::type, __value_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __value_func(_Fp&& __f)
        : __value_func(std::__1::forward<_Fp>(__f), allocator<_Fp>()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_func(const __value_func& __f)
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
            __f_ = __f.__f_->__clone();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_func(__value_func&& __f) noexcept
    {
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__value_func()
    {
        if ((void*)__f_ == &__buf_)
            __f_->destroy();
        else if (__f_)
            __f_->destroy_deallocate();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_func& operator=(__value_func&& __f)
    {
        *this = nullptr;
        if (__f.__f_ == nullptr)
            __f_ = nullptr;
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f_ = __as_base(&__buf_);
            __f.__f_->__clone(__f_);
        }
        else
        {
            __f_ = __f.__f_;
            __f.__f_ = nullptr;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_func& operator=(nullptr_t)
    {
        __func* __f = __f_;
        __f_ = nullptr;
        if ((void*)__f == &__buf_)
            __f->destroy();
        else if (__f)
            __f->destroy_deallocate();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        if (__f_ == nullptr)
            __throw_bad_function_call();
        return (*__f_)(std::__1::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(__value_func& __f) noexcept
    {
        if (&__f == this)
            return;
        if ((void*)__f_ == &__buf_ && (void*)__f.__f_ == &__f.__buf_)
        {
            typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
            __func* __t = __as_base(&__tempbuf);
            __f_->__clone(__t);
            __f_->destroy();
            __f_ = nullptr;
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = nullptr;
            __f_ = __as_base(&__buf_);
            __t->__clone(__as_base(&__f.__buf_));
            __t->destroy();
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f_ == &__buf_)
        {
            __f_->__clone(__as_base(&__f.__buf_));
            __f_->destroy();
            __f_ = __f.__f_;
            __f.__f_ = __as_base(&__f.__buf_);
        }
        else if ((void*)__f.__f_ == &__f.__buf_)
        {
            __f.__f_->__clone(__as_base(&__buf_));
            __f.__f_->destroy();
            __f.__f_ = __f_;
            __f_ = __as_base(&__buf_);
        }
        else
            std::__1::swap(__f_, __f.__f_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const noexcept { return __f_ != nullptr; }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const std::type_info& target_type() const noexcept
    {
        if (__f_ == nullptr)
            return typeid(void);
        return __f_->target_type();
    }

    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp* target() const noexcept
    {
        if (__f_ == nullptr)
            return nullptr;
        return (const _Tp*)__f_->target(typeid(_Tp));
    }

};

// Storage for a functor object, to be used with __policy to manage copy and
// destruction.
union __policy_storage
{
    mutable char __small[sizeof(void*) * 2];
    void* __large;
};

// True if _Fun can safely be held in __policy_storage.__small.
template <typename _Fun>
struct __use_small_storage
    : public std::__1::integral_constant<
          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
                    alignof(_Fun) <= alignof(__policy_storage) &&
                    std::__1::is_trivially_copy_constructible<_Fun>::value &&
                    std::__1::is_trivially_destructible<_Fun>::value> {};

// Policy contains information about how to copy, destroy, and move the
// underlying functor. You can think of it as a vtable of sorts.
struct __policy
{
    // Used to copy or destroy __large values. null for trivial objects.
    void* (*const __clone)(const void*);
    void (*const __destroy)(void*);

    // True if this is the null policy (no value).
    const bool __is_null;

    // The target type. May be null if RTTI is disabled.
    const std::type_info* const __type_info;

    // Returns a pointer to a static policy object suitable for the functor
    // type.
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static const __policy* __create()
    {
        return __choose_policy<_Fun>(__use_small_storage<_Fun>());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static const __policy* __create_empty()
    {
        static const constexpr __policy __policy_ = {nullptr, nullptr,
                                                             true,

                                                             &typeid(void)



        };
        return &__policy_;
    }

  private:
    template <typename _Fun> static void* __large_clone(const void* __s)
    {
        const _Fun* __f = static_cast<const _Fun*>(__s);
        return __f->__clone();
    }

    template <typename _Fun>
    static void __large_destroy(void* __s) {
      _Fun::__destroy_and_delete(static_cast<_Fun*>(__s));
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static const __policy*
    __choose_policy(/* is_small = */ false_type) {
      static const constexpr __policy __policy_ = {
          &__large_clone<_Fun>, &__large_destroy<_Fun>, false,

          &typeid(typename _Fun::_Target)



      };
        return &__policy_;
    }

    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static const __policy*
        __choose_policy(/* is_small = */ true_type)
    {
        static const constexpr __policy __policy_ = {
            nullptr, nullptr, false,

            &typeid(typename _Fun::_Target)



        };
        return &__policy_;
    }
};

// Used to choose between perfect forwarding or pass-by-value. Pass-by-value is
// faster for types that can be passed in registers.
template <typename _Tp>
using __fast_forward =
    typename std::__1::conditional<std::__1::is_scalar<_Tp>::value, _Tp, _Tp&&>::type;

// __policy_invoker calls an instance of __alloc_func held in __policy_storage.

template <class _Fp> struct __policy_invoker;

template <class _Rp, class... _ArgTypes>
struct __policy_invoker<_Rp(_ArgTypes...)>
{
    typedef _Rp (*__Call)(const __policy_storage*,
                          __fast_forward<_ArgTypes>...);

    __Call __call_;

    // Creates an invoker that throws bad_function_call.
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_invoker() : __call_(&__call_empty) {}

    // Creates an invoker that calls the given instance of __func.
    template <typename _Fun>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static __policy_invoker __create()
    {
        return __policy_invoker(&__call_impl<_Fun>);
    }

  private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __policy_invoker(__Call __c) : __call_(__c) {}

    static _Rp __call_empty(const __policy_storage*,
                            __fast_forward<_ArgTypes>...)
    {
        __throw_bad_function_call();
    }

    template <typename _Fun>
    static _Rp __call_impl(const __policy_storage* __buf,
                           __fast_forward<_ArgTypes>... __args)
    {
        _Fun* __f = reinterpret_cast<_Fun*>(__use_small_storage<_Fun>::value
                                                ? &__buf->__small
                                                : __buf->__large);
        return (*__f)(std::__1::forward<_ArgTypes>(__args)...);
    }
};

// __policy_func uses a __policy and __policy_invoker to create a type-erased,
// copyable functor.

template <class _Fp> class __policy_func;

template <class _Rp, class... _ArgTypes> class __policy_func<_Rp(_ArgTypes...)>
{
    // Inline storage for small objects.
    __policy_storage __buf_;

    // Calls the value stored in __buf_. This could technically be part of
    // policy, but storing it here eliminates a level of indirection inside
    // operator().
    typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
    __invoker __invoker_;

    // The policy that describes how to move / copy / destroy __buf_. Never
    // null, even if the function is empty.
    const __policy* __policy_;

  public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_func() : __policy_(__policy::__create_empty()) {}

    template <class _Fp, class _Alloc>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __policy_func(_Fp&& __f, const _Alloc& __a)
        : __policy_(__policy::__create_empty())
    {
        typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
        typedef allocator_traits<_Alloc> __alloc_traits;
        typedef typename __rebind_alloc_helper<__alloc_traits, _Fun>::type
            _FunAlloc;

        if (__function::__not_null(__f))
        {
            __invoker_ = __invoker::template __create<_Fun>();
            __policy_ = __policy::__create<_Fun>();

            _FunAlloc __af(__a);
            if (__use_small_storage<_Fun>())
            {
                ::new ((void*)&__buf_.__small)
                    _Fun(std::__1::move(__f), _Alloc(__af));
            }
            else
            {
                typedef __allocator_destructor<_FunAlloc> _Dp;
                unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
                ::new ((void*)__hold.get())
                    _Fun(std::__1::move(__f), _Alloc(__af));
                __buf_.__large = __hold.release();
            }
        }
    }

    template <class _Fp, class = typename enable_if<!is_same<typename decay<_Fp>::type, __policy_func>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __policy_func(_Fp&& __f)
        : __policy_(__policy::__create_empty()) {
      typedef __default_alloc_func<_Fp, _Rp(_ArgTypes...)> _Fun;

      if (__function::__not_null(__f)) {
        __invoker_ = __invoker::template __create<_Fun>();
        __policy_ = __policy::__create<_Fun>();
        if (__use_small_storage<_Fun>()) {
          ::new ((void*)&__buf_.__small) _Fun(std::__1::move(__f));
        } else {
          __builtin_new_allocator::__holder_t __hold =
              __builtin_new_allocator::__allocate_type<_Fun>(1);
          __buf_.__large = ::new ((void*)__hold.get()) _Fun(std::__1::move(__f));
          (void)__hold.release();
        }
      }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_func(const __policy_func& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__clone)
            __buf_.__large = __policy_->__clone(__f.__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_func(__policy_func&& __f)
        : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
          __policy_(__f.__policy_)
    {
        if (__policy_->__destroy)
        {
            __f.__policy_ = __policy::__create_empty();
            __f.__invoker_ = __invoker();
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__policy_func()
    {
        if (__policy_->__destroy)
            __policy_->__destroy(__buf_.__large);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_func& operator=(__policy_func&& __f)
    {
        *this = nullptr;
        __buf_ = __f.__buf_;
        __invoker_ = __f.__invoker_;
        __policy_ = __f.__policy_;
        __f.__policy_ = __policy::__create_empty();
        __f.__invoker_ = __invoker();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __policy_func& operator=(nullptr_t)
    {
        const __policy* __p = __policy_;
        __policy_ = __policy::__create_empty();
        __invoker_ = __invoker();
        if (__p->__destroy)
            __p->__destroy(__buf_.__large);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Rp operator()(_ArgTypes&&... __args) const
    {
        return __invoker_.__call_(std::__1::addressof(__buf_),
                                  std::__1::forward<_ArgTypes>(__args)...);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(__policy_func& __f)
    {
        std::__1::swap(__invoker_, __f.__invoker_);
        std::__1::swap(__policy_, __f.__policy_);
        std::__1::swap(__buf_, __f.__buf_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const noexcept
    {
        return !__policy_->__is_null;
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const std::type_info& target_type() const noexcept
    {
        return *__policy_->__type_info;
    }

    template <typename _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const _Tp* target() const noexcept
    {
        if (__policy_->__is_null || typeid(_Tp) != *__policy_->__type_info)
            return nullptr;
        if (__policy_->__clone) // Out of line storage.
            return reinterpret_cast<const _Tp*>(__buf_.__large);
        else
            return reinterpret_cast<const _Tp*>(&__buf_.__small);
    }

};



extern "C" void *_Block_copy(const void *);
extern "C" void _Block_release(const void *);

template<class _Rp1, class ..._ArgTypes1, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Rp1(^)(_ArgTypes1...), _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    typedef _Rp1(^__block_type)(_ArgTypes1...);
    __block_type __f_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(__block_type const& __f)
        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
    { }

    // [TODO] add && to save on a retain

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __func(__block_type __f, const _Alloc& /* unused */)
        : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr))
    { }

    virtual __base<_Rp(_ArgTypes...)>* __clone() const {
        ((void)0);



        return nullptr;
    }

    virtual void __clone(__base<_Rp(_ArgTypes...)>* __p) const {
        ::new ((void*)__p) __func(__f_);
    }

    virtual void destroy() noexcept {
        if (__f_)
            _Block_release(__f_);
        __f_ = 0;
    }

    virtual void destroy_deallocate() noexcept {
        ((void)0);



    }

    virtual _Rp operator()(_ArgTypes&& ... __arg) {
        return std::__1::__invoke(__f_, std::__1::forward<_ArgTypes>(__arg)...);
    }


    virtual const void* target(type_info const& __ti) const noexcept {
        if (__ti == typeid(__func::__block_type))
            return &__f_;
        return (const void*)nullptr;
    }

    virtual const std::type_info& target_type() const noexcept {
        return typeid(__func::__block_type);
    }

};



} // __function

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__type_visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{

    typedef __function::__value_func<_Rp(_ArgTypes...)> __func;




    __func __f_;

    template <class _Fp, bool = _And<
        _IsNotSame<__uncvref_t<_Fp>, function>,
        __invokable<_Fp, _ArgTypes...>
    >::value>
    struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value = is_void<_Rp>::value ||
                __is_core_convertible<typename __invoke_of<_Fp, _ArgTypes...>::type,
                                      _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };

  template <class _Fp>
  using _EnableIfLValueCallable = typename enable_if<__callable<_Fp&>::value>::type;
public:
    typedef _Rp result_type;

    // construct/copy/destroy:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    function() noexcept { }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    function(nullptr_t) noexcept {}
    function(const function&);
    function(function&&) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<_Fp>>
    function(_Fp);
# 2391 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
    function& operator=(const function&);
    function& operator=(function&&) noexcept;
    function& operator=(nullptr_t) noexcept;
    template<class _Fp, class = _EnableIfLValueCallable<typename decay<_Fp>::type>>
    function& operator=(_Fp&&);

    ~function();

    // function modifiers:
    void swap(function&) noexcept;
# 2409 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
    // function capacity:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const noexcept {
      return static_cast<bool>(__f_);
    }

    // deleted overloads close possible hole in the type system
    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:
    // function invocation:
    _Rp operator()(_ArgTypes...) const;


    // function target access:
    const std::type_info& target_type() const noexcept;
    template <typename _Tp> _Tp* target() noexcept;
    template <typename _Tp> const _Tp* target() const noexcept;

};


template<class _Rp, class ..._Ap>
function(_Rp(*)(_Ap...)) -> function<_Rp(_Ap...)>;

template<class _Fp>
struct __strip_signature;

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...)> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile &> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile &> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile noexcept> { using type = _Rp(_Ap...); };

template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) volatile & noexcept> { using type = _Rp(_Ap...); };
template<class _Rp, class _Gp, class ..._Ap>
struct __strip_signature<_Rp (_Gp::*) (_Ap...) const volatile & noexcept> { using type = _Rp(_Ap...); };

template<class _Fp, class _Stripped = typename __strip_signature<decltype(&_Fp::operator())>::type>
function(_Fp) -> function<_Stripped>;


template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f) : __f_(__f.__f_) {}
# 2489 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) noexcept
    : __f_(std::__1::move(__f.__f_)) {}
# 2501 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(std::__1::move(__f)) {}
# 2513 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) noexcept
{
    __f_ = std::__1::move(__f.__f_);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept
{
    __f_ = nullptr;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__1::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) noexcept
{
    __f_.swap(__f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{
    return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}



template<class _Rp, class ..._ArgTypes>
const std::type_info&
function<_Rp(_ArgTypes...)>::target_type() const noexcept
{
    return __f_.target_type();
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
_Tp*
function<_Rp(_ArgTypes...)>::target() noexcept
{
    return (_Tp*)(__f_.template target<_Tp>());
}

template<class _Rp, class ..._ArgTypes>
template <typename _Tp>
const _Tp*
function<_Rp(_ArgTypes...)>::target() const noexcept
{
    return __f_.template target<_Tp>();
}



template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) noexcept {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) noexcept
{return __x.swap(__y);}







////////////////////////////////////////////////////////////////////////////////
//                                  BIND
//==============================================================================

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;


template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};


template <class _Tp>
inline constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;


namespace placeholders
{

template <int _Np> struct __ph {};
# 2661 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
/* _LIBCPP_INLINE_VAR */ constexpr __ph<1> _1{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<2> _2{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<3> _3{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<4> _4{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<5> _5{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<6> _6{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<7> _7{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<8> _8{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<9> _9{};
/* _LIBCPP_INLINE_VAR */ constexpr __ph<10> _10{};


} // placeholders

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};




template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename _EnableIf
<
    is_bind_expression<_Ti>::value,
    __invoke_of<_Ti&, _Uj...>
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return std::__1::__mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;

template <bool _Invokable, class _Ti, class ..._Uj>
struct __mu_return_invokable // false
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...> >
    : public __mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti,
                              __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                              is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                              _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return std::__1::__invoke(__f, std::__1::__mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__1::forward<_Gp>(__f)),
          __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return std::__1::__apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__1::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;


    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__1::forward<_Gp>(__f),
               std::__1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base&>(*this), std::__1::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value || is_void<_Rp>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            typedef __invoke_void_return_wrapper<_Rp> _Invoker;
            return _Invoker::__call(static_cast<base const&>(*this), std::__1::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__1::forward<_Fp>(__f), std::__1::forward<_BoundArgs>(__bound_args)...);
}





template <class _Fn, class ..._Args>
                              invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
{
    return std::__1::__invoke(std::__1::forward<_Fn>(__f), std::__1::forward<_Args>(__args)...);
}

template <class _DecayFunc>
class __attribute__ ((__type_visibility__("default"))) __not_fn_imp {
  _DecayFunc __fd;

public:
    __not_fn_imp() = delete;

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Args&& ...__args) &
            noexcept(noexcept(!std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...); }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Args&& ...__args) &&
            noexcept(noexcept(!std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...); }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Args&& ...__args) const&
            noexcept(noexcept(!std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(__fd, std::__1::forward<_Args>(__args)...); }


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    auto operator()(_Args&& ...__args) const&&
            noexcept(noexcept(!std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...)))
        -> decltype( !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...))
        { return !std::__1::invoke(std::__1::move(__fd), std::__1::forward<_Args>(__args)...); }

private:
    template <class _RawFunc,
              class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __not_fn_imp(_RawFunc&& __rf)
        : __fd(std::__1::forward<_RawFunc>(__rf)) {}

    template <class _RawFunc>
    friend inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
};

template <class _RawFunc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
    return __not_fn_imp<decay_t<_RawFunc>>(std::__1::forward<_RawFunc>(__fn));
}



// struct hash<T*> in <memory>

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1> constexpr
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return std::__1::make_pair(__first1, __first1); // Everything matches an empty sequence
    while (true)
    {
        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
        while (true)
        {
            if (__first1 == __last1) // return __last1 if no element matches *__first2
                return std::__1::make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
        // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2) // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
                return std::__1::make_pair(__first1, __m1);
            if (++__m1 == __last1) // Otherwise if source exhaused, pattern not found
                return std::__1::make_pair(__last1, __last1);
            if (!__pred(*__m1, *__m2)) // if there is a mismatch, restart with a new __first1
            {
                ++__first1;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr
pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;
    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    const _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return std::__1::make_pair(__first1, __first1);
    const _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return std::__1::make_pair(__last1, __last1);
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1); // Start of pattern match can't go beyond here

    while (true)
    {
        while (true)
        {
            if (__first1 == __s)
                return std::__1::make_pair(__last1, __last1);
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;
         while (true)
         {
             if (++__m2 == __last2)
                 return std::__1::make_pair(__first1, __first1 + __len2);
             ++__m1; // no need to check range on __m1 because __s guarantees we have enough source
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
    }
}



// default searcher
template<class _ForwardIterator, class _BinaryPredicate = equal_to<>>
class __attribute__ ((__visibility__("default"))) default_searcher {
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    default_searcher(_ForwardIterator __f, _ForwardIterator __l,
                       _BinaryPredicate __p = _BinaryPredicate())
        : __first_(__f), __last_(__l), __pred_(__p) {}

    template <typename _ForwardIterator2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<_ForwardIterator2, _ForwardIterator2>
    operator () (_ForwardIterator2 __f, _ForwardIterator2 __l) const
    {
        return std::__1::__search(__f, __l, __first_, __last_, __pred_,
            typename std::__1::iterator_traits<_ForwardIterator>::iterator_category(),
            typename std::__1::iterator_traits<_ForwardIterator2>::iterator_category());
    }

private:
    _ForwardIterator __first_;
    _ForwardIterator __last_;
    _BinaryPredicate __pred_;
    };
# 3169 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/functional" 3
template <class _Container, class _Predicate>
inline typename _Container::size_type
__libcpp_erase_if_container(_Container& __c, _Predicate __pred) {
  typename _Container::size_type __old_size = __c.size();

  const typename _Container::iterator __last = __c.end();
  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }

  return __old_size - __c.size();
}

} }
# 655 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 1
// -*- C++ -*-
//===------------------------------ bit ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===---------------------------------------------------------------------===//




/*
    bit synopsis

namespace std {

  // [bit.pow.two], integral powers of 2
  template <class T>
    constexpr bool has_single_bit(T x) noexcept; // C++20
  template <class T>
    constexpr T bit_ceil(T x);                   // C++20
  template <class T>
    constexpr T bit_floor(T x) noexcept;         // C++20
  template <class T>
    constexpr T bit_width(T x) noexcept;         // C++20

  // [bit.rotate], rotating
  template<class T>
    constexpr T rotl(T x, unsigned int s) noexcept; // C++20
  template<class T>
    constexpr T rotr(T x, unsigned int s) noexcept; // C++20

  // [bit.count], counting
  template<class T>
    constexpr int countl_zero(T x) noexcept;  // C++20
  template<class T>
    constexpr int countl_one(T x) noexcept;   // C++20
  template<class T>
    constexpr int countr_zero(T x) noexcept;  // C++20
  template<class T>
    constexpr int countr_one(T x) noexcept;   // C++20
  template<class T>
    constexpr int popcount(T x) noexcept;     // C++20

  // [bit.endian], endian
  enum class endian {
    little = see below,        // C++20
    big = see below,           // C++20
    native = see below         // C++20
};

} // namespace std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 58 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bits" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bits" 2
# 17 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bits" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 21 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bits" 2 3


namespace std { inline namespace __1 {



inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_ctz(unsigned __x) noexcept { return __builtin_ctz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_ctz(unsigned long __x) noexcept { return __builtin_ctzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_ctz(unsigned long long __x) noexcept { return __builtin_ctzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_clz(unsigned __x) noexcept { return __builtin_clz(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_clz(unsigned long __x) noexcept { return __builtin_clzl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_clz(unsigned long long __x) noexcept { return __builtin_clzll(__x); }


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_popcount(unsigned __x) noexcept { return __builtin_popcount(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_popcount(unsigned long __x) noexcept { return __builtin_popcountl(__x); }

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __libcpp_popcount(unsigned long long __x) noexcept { return __builtin_popcountll(__x); }
# 142 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bits" 3
} }
# 59 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 2
# 73 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 77 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 2 3

namespace std { inline namespace __1 {


template <class _Tp>
using __bitop_unsigned_integer = integral_constant<bool,
         is_integral<_Tp>::value &&
         is_unsigned<_Tp>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, bool>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, signed char>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, wchar_t>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, char16_t>::value &&
        _IsNotSame<typename remove_cv<_Tp>::type, char32_t>::value
    >;


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp __rotl(_Tp __t, unsigned int __cnt) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotl requires unsigned");
    const unsigned int __dig = numeric_limits<_Tp>::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp __rotr(_Tp __t, unsigned int __cnt) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotr requires unsigned");
    const unsigned int __dig = numeric_limits<_Tp>::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}



template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __countr_zero(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_zero requires unsigned");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;

    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_ctz(static_cast<unsigned int>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_ctz(static_cast<unsigned long>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_ctz(static_cast<unsigned long long>(__t));
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while ((__iter = __libcpp_ctz(static_cast<unsigned long long>(__t))) == __ulldigits)
        {
            __ret += __iter;
            __t >>= __ulldigits;
        }
        return __ret + __iter;
    }
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __countl_zero(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_zero requires unsigned");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;

    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_clz(static_cast<unsigned int>(__t))
              - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_clz(static_cast<unsigned long>(__t))
              - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_clz(static_cast<unsigned long long>(__t))
              - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while (true) {
            __t = __rotr(__t, __ulldigits);
            if ((__iter = __countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                break;
            __ret += __iter;
            }
        return __ret + __iter;
    }
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __countl_one(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_one requires unsigned");
    return __t != numeric_limits<_Tp>::max()
        ? __countl_zero(static_cast<_Tp>(~__t))
        : numeric_limits<_Tp>::digits;
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int __countr_one(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_one requires unsigned");
    return __t != numeric_limits<_Tp>::max()
        ? __countr_zero(static_cast<_Tp>(~__t))
        : numeric_limits<_Tp>::digits;
}


template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
int
__popcount(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__libcpp_popcount requires unsigned");
    if (sizeof(_Tp) <= sizeof(unsigned int))
        return __libcpp_popcount(static_cast<unsigned int>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return __libcpp_popcount(static_cast<unsigned long>(__t));
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return __libcpp_popcount(static_cast<unsigned long long>(__t));
    else
    {
        int __ret = 0;
        while (__t != 0)
        {
            __ret += __libcpp_popcount(static_cast<unsigned long long>(__t));
            __t >>= numeric_limits<unsigned long long>::digits;
        }
        return __ret;
    }
}


// integral log base 2
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
unsigned __bit_log2(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__bit_log2 requires unsigned");
    return numeric_limits<_Tp>::digits - 1 - __countl_zero(__t);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool __has_single_bit(_Tp __t) noexcept
{
    static_assert(__bitop_unsigned_integer<_Tp>::value, "__has_single_bit requires unsigned");
    return __t != 0 && (((__t & (__t - 1)) == 0));
}
# 367 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bit" 3
} }
# 658 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2
# 664 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 668 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 2 3


namespace std { inline namespace __1 {

// I'd like to replace these with _VSTD::equal_to<void>, but can't because:
//   * That only works with C++14 and later, and
//   * We haven't included <functional> here.
template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __invert // invert the sense of a comparison
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __invert() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __invert(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};

// Perform division by two quickly for positive integers (llvm.org/PR39129)

template <typename _Integral>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_integral<_Integral>::value,
    _Integral
>::type
__half_positive(_Integral __value)
{
    return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
}

template <typename _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    !is_integral<_Tp>::value,
    _Tp
>::type
__half_positive(_Tp __value)
{
    return __value / 2;
}
# 835 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 3
template <class _Comp>
struct __comp_ref_type {
  // Pass the comparator by lvalue reference. Or in debug mode, using a
  // debugging wrapper that stores a reference.

  typedef typename add_lvalue_reference<_Comp>::type type;



};

// all_of

template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}

// any_of

template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}

// none_of

template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

// for_each

template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return __f;
}


// for_each_n

template <class _InputIterator, class _Size, class _Function>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InputIterator
for_each_n(_InputIterator __first, _Size __orig_n, _Function __f)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    while (__n > 0)
    {
         __f(*__first);
         ++__first;
         --__n;
    }
    return __first;
}


// find

template <class _InputIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}

// find_if

template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}

// find_if_not

template<class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}

// find_end

template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
                              _ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{
    // modeled after search algorithm
    _ForwardIterator1 __r = __last1; // __last1 is the "default" answer
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1) // if source exhausted return last correct answer
                return __r; //    (or __last1 if never found)
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
        // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            { // Pattern exhaused, record answer and search for another one
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1) // Source exhausted, return last answer
                return __r;
            if (!__pred(*__m1, *__m2)) // mismatch, restart with a new __first
            {
                ++__first1;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
                              _BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{
    // modeled after search algorithm (in reverse)
    if (__first2 == __last2)
        return __last1; // Everything matches an empty sequence
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks
        while (true)
        {
            if (__first1 == __l1) // return __last1 if no element matches *__first2
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        // *__l1 matches *__l2, now match elements before here
        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2) // If pattern exhausted, __m1 is the answer (works for 1 element pattern)
                return __m1;
            if (__m1 == __first1) // Otherwise if source exhaused, pattern not found
                return __last1;
            if (!__pred(*--__m1, *--__m2)) // if there is a mismatch, restart with a new __l1
            {
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
constexpr _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1); // End of pattern match can't go before here
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
                                 // no need to check range on __m1 because __s guarantees we have enough source
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

// find_first_of

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
constexpr _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}

// adjacent_find

template <class _ForwardIterator, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}

// count

template <class _InputIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}

// count_if

template <class _InputIterator, class _Predicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}

// mismatch

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _BinaryPredicate __pred)
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}


// equal

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,
        input_iterator_tag, input_iterator_tag )
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
      random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                        typename add_lvalue_reference<_BinaryPredicate>::type>
                       (__first1, __last1, __first2, __pred );
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )
{
    return std::__1::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}


// is_permutation

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                                                    bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{
//  shorten sequences as much as possible by lopping of any equal prefix
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    if (__first1 == __last1)
        return true;

//  __first1 != __last1 && *__first1 != *__first2
    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);
    // For each element in [f1, l1) see if there are the same number of
    //    equal elements in [f2, l2)
    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {
    //  Have we already counted the number of *__i in [f1, l1)?
        _ForwardIterator1 __match = __first1;
        for (; __match != __i; ++__match)
            if (__pred(*__match, *__i))
                break;
        if (__match == __i) {
            // Count number of *__i in [f2, l2)
            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;
            // Count number of *__i in [__i, l1) (we can start with 1)
            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
                              bool
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _BinaryPredicate __pred,
                 forward_iterator_tag, forward_iterator_tag )
{
//  shorten sequences as much as possible by lopping of any equal prefix
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    if (__first1 == __last1)
        return __first2 == __last2;
    else if (__first2 == __last2)
        return false;

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__1::distance(__first1, __last1);

    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
    _D2 __l2 = std::__1::distance(__first2, __last2);
    if (__l1 != __l2)
        return false;

    // For each element in [f1, l1) see if there are the same number of
    //    equal elements in [f2, l2)
    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {
    //  Have we already counted the number of *__i in [f1, l1)?
        _ForwardIterator1 __match = __first1;
        for (; __match != __i; ++__match)
            if (__pred(*__match, *__i))
                break;
        if (__match == __i) {
            // Count number of *__i in [f2, l2)
            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;
            // Count number of *__i in [__i, l1) (we can start with 1)
            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
    }
    return true;
}

template<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
                              bool
__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
               _BinaryPredicate __pred,
               random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__1::distance(__first1, __last1) != std::__1::distance(__first2, __last2))
        return false;
    return std::__1::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
                                 typename add_lvalue_reference<_BinaryPredicate>::type>
                                (__first1, __last1, __first2, __pred );
}

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
               _BinaryPredicate __pred )
{
    return std::__1::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template<class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::__is_permutation(__first1, __last1, __first2, __last2,
        __equal_to<__v1, __v2>(),
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}


// search
// __search is in <functional>

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category())
            .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _Searcher>
                      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher &__s)
{ return __s(__f, __l).first; }


// search_n

template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
                              _ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {
        // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)
        {
            if (__first == __last) // return __last if no element matches __value_
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }
        // *__first matches __value_, now match elements after here
        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count) // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;
            if (++__m == __last) // Otherwise if source exhaused, pattern not found
                return __last;
            if (!__pred(*__m, __value_)) // if there is a mismatch, restart with a new __first
            {
                __first = __m;
                ++__first;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
                              _RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1); // Start of pattern match can't go beyond here
    while (true)
    {
        // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)
        {
            if (__first >= __s) // return __last if no element matches __value_
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }
        // *__first matches __value_, now match elements after here
        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count) // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;
             ++__m; // no need to check range on __m because __s guarantees we have enough source
            if (!__pred(*__m, __value_)) // if there is a mismatch, restart with a new __first
            {
                __first = __m;
                ++__first;
                break;
            } // else there is a match, check next elements
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, std::__1::__convert_to_integral(__count), __value_, __pred,
           typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::search_n(__first, __last, std::__1::__convert_to_integral(__count),
                           __value_, __equal_to<__v, _Tp>());
}

// copy
template <class _Iter>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    const _Tp*
>::type
__unwrap_iter(__wrap_iter<const _Tp*> __i)
{
    return __i.base();
}
# 1705 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
__copy_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__copy_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_constexpr(
            std::__1::__unwrap_iter(__first), std::__1::__unwrap_iter(__last), std::__1::__unwrap_iter(__result));
    } else {
        return std::__1::__copy(
            std::__1::__unwrap_iter(__first), std::__1::__unwrap_iter(__last), std::__1::__unwrap_iter(__result));
    }
}

// copy_backward

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
__copy_backward_constexpr(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    return std::__1::__copy_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    if (__libcpp_is_constant_evaluated()) {
        return std::__1::__copy_backward_constexpr(std::__1::__unwrap_iter(__first),
                                                std::__1::__unwrap_iter(__last),
                                                std::__1::__unwrap_iter(__result));
    } else {
        return std::__1::__copy_backward(std::__1::__unwrap_iter(__first),
                                      std::__1::__unwrap_iter(__last),
                                      std::__1::__unwrap_iter(__result));
    }
}

// copy_if

template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// copy_n

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::__1::copy(__first, __first + __n, __result);
}

// move

// __move_constexpr exists so that __move doesn't call itself when delegating to the constexpr
// version of __move.
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_OutputIterator
__move_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = std::__1::move(*__first);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    if (__libcpp_is_constant_evaluated())
        return std::__1::__move_constexpr(__first, __last, __result);
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move(std::__1::__unwrap_iter(__first), std::__1::__unwrap_iter(__last), std::__1::__unwrap_iter(__result));
}

// move_backward

// __move_backward_constexpr exists so that __move_backward doesn't call itself when delegating to
// the constexpr version of __move_backward.
template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_OutputIterator
__move_backward_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__1::move(*--__last);
    return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__1::__move_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    if (__libcpp_is_constant_evaluated())
        return std::__1::__move_backward_constexpr(__first, __last, __result);
    const size_t __n = static_cast<size_t>(__last - __first);
    if (__n > 0)
    {
        __result -= __n;
        std::__1::memmove(__result, __first, __n * sizeof(_Up));
    }
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__1::__move_backward(std::__1::__unwrap_iter(__first), std::__1::__unwrap_iter(__last), std::__1::__unwrap_iter(__result));
}

// iter_swap

// moved to <type_traits> for better swap / noexcept support

// transform

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

// replace

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}

// replace_if

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}

// replace_copy

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// replace_copy_if

template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// fill_n

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__1::__fill_n(__first, std::__1::__convert_to_integral(__n), __value_);
}

// fill

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// generate

template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}

// generate_n

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(std::__1::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}

// remove

template <class _ForwardIterator, class _Tp>
                                                    _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

// remove_if

template <class _ForwardIterator, class _Predicate>
                                                    _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

// remove_copy

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// remove_copy_if

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// unique

template <class _ForwardIterator, class _BinaryPredicate>
                                                    _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {
        // ...  a  a  ?  ...
        //      f     i
        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__1::unique(__first, __last, __equal_to<__v>());
}

// unique_copy

template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
                              _OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
                              _ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}

// reverse

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        std::__1::iter_swap(__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}

// reverse_copy

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}

// rotate

template <class _ForwardIterator>
constexpr _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__1::move(*__first);
    _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
    *__lm1 = std::__1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
constexpr _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__1::prev(__last);
    value_type __tmp = std::__1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
    *__first = std::__1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
constexpr _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
constexpr _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__1::forward_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__1::bidirectional_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__1::random_access_iterator_tag)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__1::next(__first) == __middle)
            return std::__1::__rotate_left(__first, __last);
        if (std::__1::next(__middle) == __last)
            return std::__1::__rotate_right(__first, __last);
        return std::__1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__1::__rotate(__first, __middle, __last,
                           typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}

// rotate_copy

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
}

// min_element

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::min_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// min

template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__1::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}



// max_element

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::max_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// max

template <class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__1::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}




// clamp
template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
{
    ((void)0);
    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;

}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
{
    return std::__1::clamp(__v, __lo, __hi, __less<_Tp>());
}


// minmax_element

template <class _ForwardIterator, class _Compare>
                      constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::minmax_element requires a ForwardIterator");
  pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// minmax

template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__1::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    pair<_Tp, _Tp> __result(*__first, *__first);

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(*__first, __prev)) {
            if ( __comp(*__first, __result.first)) __result.first = *__first;
            if (!__comp(__prev, __result.second)) __result.second = __prev;
            }
        else {
            if ( __comp(__prev, __result.first)) __result.first = __prev;
            if (!__comp(*__first, __result.second)) __result.second = *__first;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__1::minmax(__t, __less<_Tp>());
}



// random_shuffle

// __independent_bits_engine

template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UIntType) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:
    // types
    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:
    // constructors and seeding functions
    __independent_bits_engine(_Engine& __e, size_t __w);

    // generating functions
    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}

// uniform_int_distribution

template<class _IntType = int>
class uniform_int_distribution
{
public:
    // types
    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:
    // constructors and reset functions

    uniform_int_distribution() : uniform_int_distribution(0) {}
    explicit uniform_int_distribution(
        result_type __a, result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}






    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}

    // generating functions
    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);

    // property functions
    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __libcpp_clz(_Rp) - 1;
    if ((_Rp & (numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}
# 3180 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 3
template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator & __g,
                         input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void) ++__k) {
    _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
        _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
        _Difference;
  static_assert(__is_cpp17_forward_iterator<_PopulationIterator>::value ||
                __is_cpp17_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(
      __first, __last, __output_iter, _CommonType(__n),
      __g, _PopCategory());
}


template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_SampleIterator sample(_PopulationIterator __first,
                       _PopulationIterator __last, _SampleIterator __output_iter,
                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
    return std::__1::__sample(__first, __last, __output_iter, __n, __g);
}


template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _UniformRandomNumberGenerator&& __g)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}
# 3375 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/algorithm" 3
// is_partitioned

template <class _InputIterator, class _Predicate>
                                                    bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

// partition

template <class _Predicate, class _ForwardIterator>
                              _ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
                              _BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// partition_copy

template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
                              pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

// partition_point

template<class _ForwardIterator, class _Predicate>
                              _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

// stable_partition

template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{
    // *__first is known to be false
    // __len >= 1
    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    { // The buffer is big enough to use
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__1::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__1::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }
        // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__1::move(*__t2);
        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;
    }
    // Else not enough buffer, do in place
    // __len >= 3
    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2; // __len2 >= 2
    std::__1::advance(__m, __len2);
    // recurse on [__first, __m), *__first know to be false
    // F?????????????????
    // f       m         l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = std::__1::__stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);
    // TTTFFFFF??????????
    // f  ff   m         l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    // TTTFFFFFTTTF??????
    // f  ff   m  m1     l
    __second_false = std::__1::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:
    // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf   l
    return std::__1::rotate(__first_false, __m, __second_false);
    // TTTTTTTTFFFFFFFFFF
    //         |
}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator()(_Tp* __p) const {std::__1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3; // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    // We now have a reduced range [__first, __last)
    // *__first is known to be false
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{
    // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    { // The buffer is big enough to use
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(std::__1::move(*__first));
        __d.template __incr<value_type>();
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__1::move(*__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(std::__1::move(*__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }
        // move *__last, known to be true
        *__first = std::__1::move(*__i);
        __i = ++__first;
        // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = std::__1::move(*__t2);
        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;
    }
    // Else not enough buffer, do in place
    // __len >= 4
    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2; // __len2 >= 2
    std::__1::advance(__m, __len2);
    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false
    // F????????????????T
    // f       m        l
    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }
    // F???TFFF?????????T
    // f   m1  m        l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = std::__1::__stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:
    // TTTFFFFF?????????T
    // f  ff   m        l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    // TTTFFFFFTTTF?????T
    // f  ff   m  m1    l
    __second_false = std::__1::__stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:
    // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf  l
    return std::__1::rotate(__first_false, __m, __second_false);
    // TTTTTTTTFFFFFFFFFF
    //         |
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4; // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    // __first points to first false, everything prior to __first is already set.
    // Either prove [__first, __last) is all false and return __first, or point __last to last true
    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));
    // We now have a reduced range [__first, __last]
    // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    difference_type __len = std::__1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__1::__stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

// is_sorted_until

template <class _ForwardIterator, class _Compare>
                                                    _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// is_sorted

template <class _ForwardIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// sort

// stable, 2-3 compares, 0-2 swaps

template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x)) // if x <= y
    {
        if (!__c(*__z, *__y)) // if y <= z
            return __r; // x <= y && y <= z
                                   // x <= y && y > z
        swap(*__y, *__z); // x <= z && y < z
        __r = 1;
        if (__c(*__y, *__x)) // if x > y
        {
            swap(*__x, *__y); // x < y && y <= z
            __r = 2;
        }
        return __r; // x <= y && y < z
    }
    if (__c(*__z, *__y)) // x > y, if y > z
    {
        swap(*__x, *__z); // x < y && y < z
        __r = 1;
        return __r;
    }
    swap(*__x, *__y); // x > y && y <= z
    __r = 1; // x < y && x <= z
    if (__c(*__z, *__y)) // if y > z
    {
        swap(*__y, *__z); // x <= y && y < z
        __r = 2;
    }
    return __r;
} // x <= y && y <= z

// stable, 3-6 compares, 0-5 swaps

template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = std::__1::__sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}

// stable, 4-10 compares, 0-9 swaps

template <class _Compare, class _ForwardIterator>
__attribute__ ((__visibility__("hidden")))
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = std::__1::__sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}

// Assumes size > 0
template <class _Compare, class _BidirectionalIterator>
void
__selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BidirectionalIterator __i = std::__1::min_element<_BidirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BidirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BidirectionalIterator __j = __i;
            value_type __t(std::__1::move(*__j));
            for (_BidirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__1::move(*__k);
            *__j = std::__1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__1::__sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    std::__1::__sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BidirectionalIterator>
void
__insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                      typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new ((void*)__last2) value_type(std::__1::move(*__first1));
        __d.template __incr<value_type>();
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new ((void*)__j2) value_type(std::__1::move(*__i2));
                __d.template __incr<value_type>();
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__1::move(*__i2);
                *__j2 = std::__1::move(*__first1);
            }
            else
            {
                ::new ((void*)__j2) value_type(std::__1::move(*__first1));
                __d.template __incr<value_type>();
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }
        // __len > 5
        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }
        // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;
        // j points beyond range to be tested, *__m is known to be <= *__lm1
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m)) // if *__first == *__m
        {
            // *__first == *__m, *__first doesn't go in first part
            // manually guard downward moving __j against __i
            while (true)
            {
                if (__i == --__j)
                {
                    // *__first == *__m, *__m <= all other elements
                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
                    ++__i; // __first + 1
                    __j = __last;
                    if (!__comp(*__first, *--__j)) // we need a guard if *__first == *(__last-1)
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return; // [__first, __last) all equivalent elements
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }
                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }
                    // [__first, __i) == *__first and *__first < [__i, __last)
                    // The first part is sorted, sort the second part
                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break; // found guard for downward moving __j, now use unguarded partition
                }
            }
        }
        // It is known that *__i < *__m
        ++__i;
        // j points beyond range to be tested, *__m is known to be <= *__lm1
        // if not yet partitioned...
        if (__i < __j)
        {
            // known that *(__i - 1) < *__m
            // known that __i <= __m
            while (true)
            {
                // __m still guards upward moving __i
                while (__comp(*__i, *__m))
                    ++__i;
                // It is now known that a guard exists for downward moving __j
                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;
                // It is known that __m != __j
                // If __m just moved, follow it
                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }
        // [__first, __i) < *__m and *__m <= [__i, __last)
        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }
        // [__first, __i) < *__i and *__i <= [__i+1, __last)
        // If we were given a perfect partition, see if insertion sort is quick...
        if (__n_swaps == 0)
        {
            bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }
        // sort smaller range with recursive call and larger with tail recursion elimination
        if (__i - __first < __last - __i)
        {
            std::__1::__sort<_Compare>(__first, __i, __comp);
            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
            __first = ++__i;
        }
        else
        {
            std::__1::__sort<_Compare>(__i+1, __last, __comp);
            // _VSTD::__sort<_Compare>(__first, __i, __comp);
            __last = __i;
        }
    }
}

// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__sort<_Comp_ref>(__first, __last, _Comp_ref(__comp));
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__1::sort((uintptr_t*)__first, (uintptr_t*)__last, __less<uintptr_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}

extern template __attribute__ ((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__ ((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

extern template __attribute__ ((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);

// lower_bound

template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// upper_bound

template <class _Compare, class _ForwardIterator, class _Tp>
                              _ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__1::__upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}

// equal_range

template <class _Compare, class _ForwardIterator, class _Tp>
                              pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__1::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::__1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      std::__1::__lower_bound<_Compare>(__first, __m, __value_, __comp),
                      std::__1::__upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__equal_range<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// binary_search

template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = std::__1::__lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__binary_search<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

// merge

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>

_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__1::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}

// inplace_merge

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__1::move(__first1, __last1, __result);
            return;
        }

        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    // __first2 through __last2 are already in the right spot.
}

template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__1::move(*__i));
        std::__1::__half_inplace_merge<_Compare>(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(std::__1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        typedef __invert<_Compare> _Inverted;
        std::__1::__half_inplace_merge<_Inverted>(_Rv(__p), _Rv(__buff),
                                    _RBi(__middle), _RBi(__first),
                                    _RBi(__last), _Inverted(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {
        // if __middle == __last, we're done
        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return std::__1::__buffered_inplace_merge<_Compare>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);
        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0
        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        // __first < __middle < __last
        // *__first > *__middle
        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that
        //     all elements in:
        //         [__first, __m1)  <= [__middle, __m2)
        //         [__middle, __m2) <  [__m1, __middle)
        //         [__m1, __middle) <= [__m2, __last)
        //     and __m1 or __m2 is in the middle of its range
        _BidirectionalIterator __m1; // "median" of [__first, __middle)
        _BidirectionalIterator __m2; // "median" of [__middle, __last)
        difference_type __len11; // distance(__first, __m1)
        difference_type __len21; // distance(__middle, __m2)
        // binary search smaller range
        if (__len1 < __len2)
        { // __len >= 1, __len2 >= 2
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__1::advance(__m2, __len21);
            __m1 = std::__1::__upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            { // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1
                // It is known *__first > *__middle
                swap(*__first, *__middle);
                return;
            }
            // __len1 >= 2, __len2 >= 1
            __len11 = __len1 / 2;
            __m1 = __first;
            std::__1::advance(__m1, __len11);
            __m2 = std::__1::__lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11; // distance(__m1, __middle)
        difference_type __len22 = __len2 - __len21; // distance(__m2, __last)
        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)
        // swap middle two partitions
        __middle = std::__1::rotate(__m1, __middle, __m2);
        // __len12 and __len21 now have swapped meanings
        // merge smaller range with recursive call and larger with tail recursion elimination
        if (__len11 + __len21 < __len12 + __len22)
        {
            std::__1::__inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
//          _VSTD::__inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            std::__1::__inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
//          _VSTD::__inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__1::distance(__first, __middle);
    difference_type __len2 = std::__1::distance(__middle, __last);
    difference_type __buf_size = std::__1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

// stable_sort

template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, (void)__d.template __incr<value_type>())
                ::new ((void*)__result) value_type(std::__1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new ((void*)__result) value_type(std::__1::move(*__first2));
            __d.template __incr<value_type>();
            ++__first2;
        }
        else
        {
            ::new ((void*)__result) value_type(std::__1::move(*__first1));
            __d.template __incr<value_type>();
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result)
                *__result = std::__1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, (void) ++__result)
        *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new ((void*)__first2) value_type(std::__1::move(*__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
        if (__comp(*--__last1, *__first1))
        {
            ::new ((void*)__first2) value_type(std::__1::move(*__last1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__1::move(*__first1));
        }
        else
        {
            ::new ((void*)__first2) value_type(std::__1::move(*__first1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(std::__1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        std::__1::__insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    std::__1::__stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    std::__1::__stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    std::__1::__merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        std::__1::__insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        std::__1::__stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)nullptr);
        std::__1::__stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)nullptr);
        std::__1::__merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
//         _VSTD::__merge<_Compare>(move_iterator<value_type*>(__buff),
//                                  move_iterator<value_type*>(__buff + __l2),
//                                  move_iterator<_RandomAccessIterator>(__buff + __l2),
//                                  move_iterator<_RandomAccessIterator>(__buff + __len),
//                                  __first, __comp);
        return;
    }
    std::__1::__stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    std::__1::__stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    std::__1::__inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// is_heap_until

template <class _RandomAccessIterator, class _Compare>
                                                    _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// is_heap

template <class _RandomAccessIterator, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// push_heap

template <class _Compare, class _RandomAccessIterator>
void
__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__1::move(*__last));
            do
            {
                *__last = std::__1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// pop_heap

template <class _Compare, class _RandomAccessIterator>
void
__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,
            _Compare __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    // left-child of __start is at 2 * __start + 1
    // right-child of __start is at 2 * __start + 2
    difference_type __child = __start - __first;

    if (__len < 2 || (__len - 2) / 2 < __child)
        return;

    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
        // right-child exists and is greater than left-child
        ++__child_i;
        ++__child;
    }

    // check if we are in heap-order
    if (__comp(*__child_i, *__start))
        // we are, __start is larger than it's largest child
        return;

    value_type __top(std::__1::move(*__start));
    do
    {
        // we are not in heap-order, swap the parent with it's largest child
        *__start = std::__1::move(*__child_i);
        __start = __child_i;

        if ((__len - 2) / 2 < __child)
            break;

        // recompute the child based off of the updated parent
        __child = 2 * __child + 1;
        __child_i = __first + __child;

        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
            // right-child exists and is greater than left-child
            ++__child_i;
            ++__child;
        }

        // check if we are in heap-order
    } while (!__comp(*__child_i, __top));
    *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        std::__1::__sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// make_heap

template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {
        // start from the first parent, there is no need to consider children
        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)
        {
            std::__1::__sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__make_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// sort_heap

template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, (void) --__n)
        std::__1::__pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__sort_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// partial_sort

template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    std::__1::__make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            std::__1::__sift_down<_Compare>(__first, __middle, __comp, __len, __first);
        }
    }
    std::__1::__sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// partial_sort_copy

template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, (void) ++__r)
            *__r = *__first;
        std::__1::__make_heap<_Compare>(__result_first, __r, __comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                std::__1::__sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
            }
        std::__1::__sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// nth_element

template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            std::__1::__selection_sort<_Compare>(__first, __last, __comp);
            return;
        }
        // __len > __limit >= 3
        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);
        // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;
        // j points beyond range to be tested, *__lm1 is known to be <= *__m
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m)) // if *__first == *__m
        {
            // *__first == *__m, *__first doesn't go in first part
            // manually guard downward moving __j against __i
            while (true)
            {
                if (__i == --__j)
                {
                    // *__first == *__m, *__m <= all other elements
                    // Partition instead into [__first, __i) == *__first and *__first < [__i, __last)
                    ++__i; // __first + 1
                    __j = __last;
                    if (!__comp(*__first, *--__j)) // we need a guard if *__first == *(__last-1)
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return; // [__first, __last) all equivalent elements
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }
                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }
                    // [__first, __i) == *__first and *__first < [__i, __last)
                    // The first part is sorted,
                    if (__nth < __i)
                        return;
                    // __nth_element the second part
                    // _VSTD::__nth_element<_Compare>(__i, __nth, __last, __comp);
                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break; // found guard for downward moving __j, now use unguarded partition
                }
            }
        }
        ++__i;
        // j points beyond range to be tested, *__lm1 is known to be <= *__m
        // if not yet partitioned...
        if (__i < __j)
        {
            // known that *(__i - 1) < *__m
            while (true)
            {
                // __m still guards upward moving __i
                while (__comp(*__i, *__m))
                    ++__i;
                // It is now known that a guard exists for downward moving __j
                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;
                // It is known that __m != __j
                // If __m just moved, follow it
                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }
        // [__first, __i) < *__m and *__m <= [__i, __last)
        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }
        // [__first, __i) < *__i and *__i <= [__i+1, __last)
        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {
            // We were given a perfectly partitioned sequence.  Coincidence?
            if (__nth < __i)
            {
                // Check for [__first, __i) already sorted
                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))
                        // not yet sorted, so sort
                        goto not_sorted;
                    __m = __j;
                }
                // [__first, __i) sorted
                return;
            }
            else
            {
                // Check for [__i, __last) already sorted
                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))
                        // not yet sorted, so sort
                        goto not_sorted;
                    __m = __j;
                }
                // [__i, __last) sorted
                return;
            }
        }
not_sorted:
        // __nth_element on range containing __nth
        if (__nth < __i)
        {
            // _VSTD::__nth_element<_Compare>(__first, __nth, __i, __comp);
            __last = __i;
        }
        else
        {
            // _VSTD::__nth_element<_Compare>(__i+1, __nth, __last, __comp);
            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    std::__1::__nth_element<_Comp_ref>(__first, __nth, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

// includes

template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// set_union

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            if (!__comp(*__first1, *__first2))
                ++__first2;
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// set_intersection

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}

// set_difference

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}

// set_symmetric_difference

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
                              _OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}

// lexicographical_compare

template <class _Compare, class _InputIterator1, class _InputIterator2>
                              bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}

// next_permutation

template <class _Compare, class _BidirectionalIterator>
                              bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__next_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

// prev_permutation

template <class _Compare, class _BidirectionalIterator>
                              bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return std::__1::__prev_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }
# 8 "SEAL/native/src/seal/c/utilities.h" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 1
// -*- C++ -*-
//===--------------------------- string -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    string synopsis

namespace std
{

template <class stateT>
class fpos
{
private:
    stateT st;
public:
    fpos(streamoff = streamoff());

    operator streamoff() const;

    stateT state() const;
    void state(stateT);

    fpos& operator+=(streamoff);
    fpos  operator+ (streamoff) const;
    fpos& operator-=(streamoff);
    fpos  operator- (streamoff) const;
};

template <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);

template <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);
template <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static int              compare(const char_type* s1, const char_type* s2, size_t n);
    static size_t           length(const char_type* s);
    static const char_type* find(const char_type* s, size_t n, const char_type& a);
    static char_type*       move(char_type* s1, const char_type* s2, size_t n);
    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);
    static char_type*       assign(char_type* s, size_t n, char_type a);

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
// types:
    typedef traits traits_type;
    typedef typename traits_type::char_type value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef implementation-defined iterator;
    typedef implementation-defined const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    static const size_type npos = -1;

    basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    explicit basic_string(const allocator_type& a);
    basic_string(const basic_string& str);
    basic_string(basic_string&& str)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    basic_string(const basic_string& str, size_type pos,
                 const allocator_type& a = allocator_type());
    basic_string(const basic_string& str, size_type pos, size_type n,
                 const Allocator& a = Allocator());
    template<class T>
        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17
    template <class T>
        explicit basic_string(const T& t, const Allocator& a = Allocator()); // C++17
    basic_string(const value_type* s, const allocator_type& a = allocator_type());
    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());
    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());
    template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const allocator_type& a = allocator_type());
    basic_string(initializer_list<value_type>, const Allocator& = Allocator());
    basic_string(const basic_string&, const Allocator&);
    basic_string(basic_string&&, const Allocator&);

    ~basic_string();

    operator basic_string_view<charT, traits>() const noexcept;

    basic_string& operator=(const basic_string& str);
    template <class T>
        basic_string& operator=(const T& t); // C++17
    basic_string& operator=(basic_string&& str)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value ); // C++17
    basic_string& operator=(const value_type* s);
    basic_string& operator=(value_type c);
    basic_string& operator=(initializer_list<value_type>);

    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    size_type size() const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;

    void resize(size_type n, value_type c);
    void resize(size_type n);

    void reserve(size_type res_arg);
    void reserve(); // deprecated in C++20
    void shrink_to_fit();
    void clear() noexcept;
    bool empty() const noexcept;

    const_reference operator[](size_type pos) const;
    reference       operator[](size_type pos);

    const_reference at(size_type n) const;
    reference       at(size_type n);

    basic_string& operator+=(const basic_string& str);
    template <class T>
        basic_string& operator+=(const T& t);              // C++17
    basic_string& operator+=(const value_type* s);
    basic_string& operator+=(value_type c);
    basic_string& operator+=(initializer_list<value_type>);

    basic_string& append(const basic_string& str);
    template <class T>
        basic_string& append(const T& t);                 // C++17
    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14
    template <class T>
        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17
    basic_string& append(const value_type* s, size_type n);
    basic_string& append(const value_type* s);
    basic_string& append(size_type n, value_type c);
    template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);
    basic_string& append(initializer_list<value_type>);

    void push_back(value_type c);
    void pop_back();
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    basic_string& assign(const basic_string& str);
    template <class T>
        basic_string& assign(const T& t);  // C++17
    basic_string& assign(basic_string&& str);
    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14
    template <class T>
        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17
    basic_string& assign(const value_type* s, size_type n);
    basic_string& assign(const value_type* s);
    basic_string& assign(size_type n, value_type c);
    template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);
    basic_string& assign(initializer_list<value_type>);

    basic_string& insert(size_type pos1, const basic_string& str);
    template <class T>
        basic_string& insert(size_type pos1, const T& t);
    basic_string& insert(size_type pos1, const basic_string& str,
                         size_type pos2, size_type n);
    template <class T>
        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17
    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14
    basic_string& insert(size_type pos, const value_type* s);
    basic_string& insert(size_type pos, size_type n, value_type c);
    iterator      insert(const_iterator p, value_type c);
    iterator      insert(const_iterator p, size_type n, value_type c);
    template<class InputIterator>
        iterator insert(const_iterator p, InputIterator first, InputIterator last);
    iterator      insert(const_iterator p, initializer_list<value_type>);

    basic_string& erase(size_type pos = 0, size_type n = npos);
    iterator      erase(const_iterator position);
    iterator      erase(const_iterator first, const_iterator last);

    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
    template <class T>
    basic_string& replace(size_type pos1, size_type n1, const T& t);  // C++17
    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
                          size_type pos2, size_type n2=npos); // C++14
    template <class T>
        basic_string& replace(size_type pos1, size_type n1, const T& t,
                              size_type pos2, size_type n); // C++17
    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);
    basic_string& replace(size_type pos, size_type n1, const value_type* s);
    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);
    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
    template <class T>
        basic_string& replace(const_iterator i1, const_iterator i2, const T& t);  // C++17
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);
    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);
    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);
    template<class InputIterator>
        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);
    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);

    size_type copy(value_type* s, size_type n, size_type pos = 0) const;
    basic_string substr(size_type pos = 0, size_type n = npos) const;

    void swap(basic_string& str)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17

    const value_type* c_str() const noexcept;
    const value_type* data() const noexcept;
          value_type* data()       noexcept;   // C++17

    allocator_type get_allocator() const noexcept;

    size_type find(const basic_string& str, size_type pos = 0) const noexcept;
    template <class T>
        size_type find(const T& t, size_type pos = 0) const;  // C++17
    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find(const value_type* s, size_type pos = 0) const noexcept;
    size_type find(value_type c, size_type pos = 0) const noexcept;

    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
    template <class T>
        size_type rfind(const T& t, size_type pos = npos) const;  // C++17
    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;
    size_type rfind(value_type c, size_type pos = npos) const noexcept;

    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;
    template <class T>
        size_type find_first_of(const T& t, size_type pos = 0) const; // C++17
    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;
    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;

    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;
    template <class T>
        size_type find_last_of(const T& t, size_type pos = npos) const noexcept;  // C++17
    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;
    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;

    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;
    template <class T>
        size_type find_first_not_of(const T& t, size_type pos = 0) const; // C++17
    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;
    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;

    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;
    template <class T>
        size_type find_last_not_of(const T& t, size_type pos = npos) const; // C++17
    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;
    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;
    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;

    int compare(const basic_string& str) const noexcept;
    template <class T>
        int compare(const T& t) const noexcept;  // C++17
    int compare(size_type pos1, size_type n1, const basic_string& str) const;
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t) const;  // C++17
    int compare(size_type pos1, size_type n1, const basic_string& str,
                size_type pos2, size_type n2=npos) const; // C++14
    template <class T>
        int compare(size_type pos1, size_type n1, const T& t,
                    size_type pos2, size_type n2=npos) const; // C++17
    int compare(const value_type* s) const noexcept;
    int compare(size_type pos1, size_type n1, const value_type* s) const;
    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;

    bool starts_with(basic_string_view<charT, traits> sv) const noexcept; // C++20
    bool starts_with(charT c) const noexcept;                             // C++20
    bool starts_with(const charT* s) const;                               // C++20
    bool ends_with(basic_string_view<charT, traits> sv) const noexcept;   // C++20
    bool ends_with(charT c) const noexcept;                               // C++20
    bool ends_with(const charT* s) const;                                 // C++20

    constexpr bool contains(basic_string_view<charT, traits> sv) const noexcept; // C++2b
    constexpr bool contains(charT c) const noexcept;                             // C++2b
    constexpr bool contains(const charT* s) const;                               // C++2b

    bool __invariants() const;
};

template<class InputIterator,
         class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
basic_string(InputIterator, InputIterator, Allocator = Allocator())
   -> basic_string<typename iterator_traits<InputIterator>::value_type,
                  char_traits<typename iterator_traits<InputIterator>::value_type>,
                  Allocator>;   // C++17

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs,
          const basic_string<charT, traits, Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
operator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs,
                const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;

template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;

template<class charT, class traits, class Allocator>
void swap(basic_string<charT, traits, Allocator>& lhs,
          basic_string<charT, traits, Allocator>& rhs)
            noexcept(noexcept(lhs.swap(rhs)));

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,
        charT delim);

template<class charT, class traits, class Allocator>
basic_istream<charT, traits>&
getline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);

template<class charT, class traits, class Allocator, class U>
typename basic_string<charT, traits, Allocator>::size_type
erase(basic_string<charT, traits, Allocator>& c, const U& value);    // C++20
template<class charT, class traits, class Allocator, class Predicate>
typename basic_string<charT, traits, Allocator>::size_type
erase_if(basic_string<charT, traits, Allocator>& c, Predicate pred); // C++20

typedef basic_string<char>    string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

int                stoi  (const string& str, size_t* idx = nullptr, int base = 10);
long               stol  (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const string& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const string& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const string& str, size_t* idx = nullptr, int base = 10);

float       stof (const string& str, size_t* idx = nullptr);
double      stod (const string& str, size_t* idx = nullptr);
long double stold(const string& str, size_t* idx = nullptr);

string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);

int                stoi  (const wstring& str, size_t* idx = nullptr, int base = 10);
long               stol  (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long      stoul (const wstring& str, size_t* idx = nullptr, int base = 10);
long long          stoll (const wstring& str, size_t* idx = nullptr, int base = 10);
unsigned long long stoull(const wstring& str, size_t* idx = nullptr, int base = 10);

float       stof (const wstring& str, size_t* idx = nullptr);
double      stod (const wstring& str, size_t* idx = nullptr);
long double stold(const wstring& str, size_t* idx = nullptr);

wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);

template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;

basic_string<char>     operator "" s( const char *str,     size_t len ); // C++14
basic_string<wchar_t>  operator "" s( const wchar_t *str,  size_t len ); // C++14
basic_string<char16_t> operator "" s( const char16_t *str, size_t len ); // C++14
basic_string<char32_t> operator "" s( const char32_t *str, size_t len ); // C++14

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 511 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 1
// -*- C++ -*-
//===------------------------ string_view ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
string_view synopsis

namespace std {

    // 7.2, Class template basic_string_view
    template<class charT, class traits = char_traits<charT>>
        class basic_string_view;

    // 7.9, basic_string_view non-member comparison functions
    template<class charT, class traits>
    constexpr bool operator==(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator!=(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator< (basic_string_view<charT, traits> x,
                                 basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator> (basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator<=(basic_string_view<charT, traits> x,
                                 basic_string_view<charT, traits> y) noexcept;
    template<class charT, class traits>
    constexpr bool operator>=(basic_string_view<charT, traits> x,
                              basic_string_view<charT, traits> y) noexcept;
    // see below, sufficient additional overloads of comparison functions

    // 7.10, Inserters and extractors
    template<class charT, class traits>
      basic_ostream<charT, traits>&
        operator<<(basic_ostream<charT, traits>& os,
                   basic_string_view<charT, traits> str);

    // basic_string_view typedef names
    typedef basic_string_view<char> string_view;
    typedef basic_string_view<char16_t> u16string_view;
    typedef basic_string_view<char32_t> u32string_view;
    typedef basic_string_view<wchar_t> wstring_view;

    template<class charT, class traits = char_traits<charT>>
    class basic_string_view {
      public:
      // types
      typedef traits traits_type;
      typedef charT value_type;
      typedef charT* pointer;
      typedef const charT* const_pointer;
      typedef charT& reference;
      typedef const charT& const_reference;
      typedef implementation-defined const_iterator;
      typedef const_iterator iterator;
      typedef reverse_iterator<const_iterator> const_reverse_iterator;
      typedef const_reverse_iterator reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      static constexpr size_type npos = size_type(-1);

      // 7.3, basic_string_view constructors and assignment operators
      constexpr basic_string_view() noexcept;
      constexpr basic_string_view(const basic_string_view&) noexcept = default;
      basic_string_view& operator=(const basic_string_view&) noexcept = default;
      template<class Allocator>
      constexpr basic_string_view(const charT* str);
      constexpr basic_string_view(const charT* str, size_type len);

      // 7.4, basic_string_view iterator support
      constexpr const_iterator begin() const noexcept;
      constexpr const_iterator end() const noexcept;
      constexpr const_iterator cbegin() const noexcept;
      constexpr const_iterator cend() const noexcept;
      const_reverse_iterator rbegin() const noexcept;
      const_reverse_iterator rend() const noexcept;
      const_reverse_iterator crbegin() const noexcept;
      const_reverse_iterator crend() const noexcept;

      // 7.5, basic_string_view capacity
      constexpr size_type size() const noexcept;
      constexpr size_type length() const noexcept;
      constexpr size_type max_size() const noexcept;
      constexpr bool empty() const noexcept;

      // 7.6, basic_string_view element access
      constexpr const_reference operator[](size_type pos) const;
      constexpr const_reference at(size_type pos) const;
      constexpr const_reference front() const;
      constexpr const_reference back() const;
      constexpr const_pointer data() const noexcept;

      // 7.7, basic_string_view modifiers
      constexpr void remove_prefix(size_type n);
      constexpr void remove_suffix(size_type n);
      constexpr void swap(basic_string_view& s) noexcept;

      size_type copy(charT* s, size_type n, size_type pos = 0) const;

      constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
      constexpr int compare(basic_string_view s) const noexcept;
      constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
      constexpr int compare(size_type pos1, size_type n1,
                            basic_string_view s, size_type pos2, size_type n2) const;
      constexpr int compare(const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
      constexpr int compare(size_type pos1, size_type n1,
                            const charT* s, size_type n2) const;
      constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find(const charT* s, size_type pos, size_type n) const;
      constexpr size_type find(const charT* s, size_type pos = 0) const;
      constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
      constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
      constexpr size_type rfind(const charT* s, size_type pos = npos) const;
      constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
      constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
      constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
      constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
      constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
      constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
      constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
      constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
      constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
      constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
      constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
      constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
      constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

      constexpr bool starts_with(basic_string_view s) const noexcept; // C++20
      constexpr bool starts_with(charT c) const noexcept;             // C++20
      constexpr bool starts_with(const charT* s) const;               // C++20
      constexpr bool ends_with(basic_string_view s) const noexcept;   // C++20
      constexpr bool ends_with(charT c) const noexcept;               // C++20
      constexpr bool ends_with(const charT* s) const;                 // C++20

      constexpr bool contains(basic_string_view s) const noexcept; // C++2b
      constexpr bool contains(charT c) const noexcept;             // C++2b
      constexpr bool contains(const charT* s) const;               // C++2b

     private:
      const_pointer data_;  // exposition only
      size_type     size_;  // exposition only
    };

  // 7.11, Hash support
  template <class T> struct hash;
  template <> struct hash<string_view>;
  template <> struct hash<u16string_view>;
  template <> struct hash<u32string_view>;
  template <> struct hash<wstring_view>;

  constexpr basic_string_view<char>     operator "" sv( const char *str,     size_t len ) noexcept;
  constexpr basic_string_view<wchar_t>  operator "" sv( const wchar_t *str,  size_t len ) noexcept;
  constexpr basic_string_view<char16_t> operator "" sv( const char16_t *str, size_t len ) noexcept;
  constexpr basic_string_view<char32_t> operator "" sv( const char32_t *str, size_t len ) noexcept;

}  // namespace std


*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 179 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 1
// -*- C++ -*-
//===-------------------------- __string ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    string synopsis

namespace std
{

template <class charT>
struct char_traits
{
    typedef charT     char_type;
    typedef ...       int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;
    static constexpr bool eq(char_type c1, char_type c2) noexcept;
    static constexpr bool lt(char_type c1, char_type c2) noexcept;

    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);
    static constexpr size_t length(const char_type* s);
    static constexpr const char_type*
                            find(const char_type* s, size_t n, const char_type& a);

    static constexpr char_type* move(char_type* s1, const char_type* s2, size_t n); // constexpr in C++20
    static constexpr char_type* copy(char_type* s1, const char_type* s2, size_t n); // constexpr in C++20
    static constexpr char_type* assign(char_type* s, size_t n, char_type a);        // constexpr in C++20

    static constexpr int_type  not_eof(int_type c) noexcept;
    static constexpr char_type to_char_type(int_type c) noexcept;
    static constexpr int_type  to_int_type(char_type c) noexcept;
    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;
    static constexpr int_type  eof() noexcept;
};

template <> struct char_traits<char>;
template <> struct char_traits<wchar_t>;
template <> struct char_traits<char8_t>;  // c++20

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 57 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdio" 1
// -*- C++ -*-
//===---------------------------- cstdio ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cstdio synopsis

Macros:

    BUFSIZ
    EOF
    FILENAME_MAX
    FOPEN_MAX
    L_tmpnam
    NULL
    SEEK_CUR
    SEEK_END
    SEEK_SET
    TMP_MAX
    _IOFBF
    _IOLBF
    _IONBF
    stderr
    stdin
    stdout

namespace std
{

Types:

FILE
fpos_t
size_t

int remove(const char* filename);
int rename(const char* old, const char* new);
FILE* tmpfile(void);
char* tmpnam(char* s);
int fclose(FILE* stream);
int fflush(FILE* stream);
FILE* fopen(const char* restrict filename, const char* restrict mode);
FILE* freopen(const char* restrict filename, const char * restrict mode,
              FILE * restrict stream);
void setbuf(FILE* restrict stream, char* restrict buf);
int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
int fprintf(FILE* restrict stream, const char* restrict format, ...);
int fscanf(FILE* restrict stream, const char * restrict format, ...);
int printf(const char* restrict format, ...);
int scanf(const char* restrict format, ...);
int snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
int sprintf(char* restrict s, const char* restrict format, ...);
int sscanf(const char* restrict s, const char* restrict format, ...);
int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
int vprintf(const char* restrict format, va_list arg);
int vscanf(const char* restrict format, va_list arg);                          // C99
int vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
              va_list arg);
int vsprintf(char* restrict s, const char* restrict format, va_list arg);
int vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
int fgetc(FILE* stream);
char* fgets(char* restrict s, int n, FILE* restrict stream);
int fputc(int c, FILE* stream);
int fputs(const char* restrict s, FILE* restrict stream);
int getc(FILE* stream);
int getchar(void);
char* gets(char* s);  // removed in C++14
int putc(int c, FILE* stream);
int putchar(int c);
int puts(const char* s);
int ungetc(int c, FILE* stream);
size_t fread(void* restrict ptr, size_t size, size_t nmemb,
             FILE* restrict stream);
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
              FILE* restrict stream);
int fgetpos(FILE* restrict stream, fpos_t* restrict pos);
int fseek(FILE* stream, long offset, int whence);
int fsetpos(FILE*stream, const fpos_t* pos);
long ftell(FILE* stream);
void rewind(FILE* stream);
void clearerr(FILE* stream);
int feof(FILE* stream);
int ferror(FILE* stream);
void perror(const char* s);

}  // std
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 99 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdio" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdio.h" 1
// -*- C++ -*-
//===---------------------------- stdio.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 21 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdio.h"
/*
    stdio.h synopsis

Macros:

    BUFSIZ
    EOF
    FILENAME_MAX
    FOPEN_MAX
    L_tmpnam
    NULL
    SEEK_CUR
    SEEK_END
    SEEK_SET
    TMP_MAX
    _IOFBF
    _IOLBF
    _IONBF
    stderr
    stdin
    stdout

Types:

FILE
fpos_t
size_t

int remove(const char* filename);
int rename(const char* old, const char* new);
FILE* tmpfile(void);
char* tmpnam(char* s);
int fclose(FILE* stream);
int fflush(FILE* stream);
FILE* fopen(const char* restrict filename, const char* restrict mode);
FILE* freopen(const char* restrict filename, const char * restrict mode,
              FILE * restrict stream);
void setbuf(FILE* restrict stream, char* restrict buf);
int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);
int fprintf(FILE* restrict stream, const char* restrict format, ...);
int fscanf(FILE* restrict stream, const char * restrict format, ...);
int printf(const char* restrict format, ...);
int scanf(const char* restrict format, ...);
int snprintf(char* restrict s, size_t n, const char* restrict format, ...);    // C99
int sprintf(char* restrict s, const char* restrict format, ...);
int sscanf(const char* restrict s, const char* restrict format, ...);
int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);  // C99
int vprintf(const char* restrict format, va_list arg);
int vscanf(const char* restrict format, va_list arg);                          // C99
int vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
              va_list arg);
int vsprintf(char* restrict s, const char* restrict format, va_list arg);
int vsscanf(const char* restrict s, const char* restrict format, va_list arg); // C99
int fgetc(FILE* stream);
char* fgets(char* restrict s, int n, FILE* restrict stream);
int fputc(int c, FILE* stream);
int fputs(const char* restrict s, FILE* restrict stream);
int getc(FILE* stream);
int getchar(void);
char* gets(char* s);  // removed in C++14
int putc(int c, FILE* stream);
int putchar(int c);
int puts(const char* s);
int ungetc(int c, FILE* stream);
size_t fread(void* restrict ptr, size_t size, size_t nmemb,
             FILE* restrict stream);
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,
              FILE* restrict stream);
int fgetpos(FILE* restrict stream, fpos_t* restrict pos);
int fseek(FILE* stream, long offset, int whence);
int fsetpos(FILE*stream, const fpos_t* pos);
long ftell(FILE* stream);
void rewind(FILE* stream);
void clearerr(FILE* stream);
int feof(FILE* stream);
int ferror(FILE* stream);
void perror(const char* s);
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 102 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdio.h" 2
# 105 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdio.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 1 3
// -*- C++ -*-
//===---------------------------- stdio.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 108 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdio.h" 2 3
# 100 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdio" 2
# 103 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cstdio" 3


namespace std { inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::vfprintf;
using ::vfscanf;
using ::vsscanf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;

using ::fgetpos;

using ::fseek;

using ::fsetpos;

using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;



using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;


} }
# 59 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwchar" 1
// -*- C++ -*-
//===--------------------------- cwchar -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cwchar synopsis

Macros:

    NULL
    WCHAR_MAX
    WCHAR_MIN
    WEOF

namespace std
{

Types:

    mbstate_t
    size_t
    tm
    wint_t

int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);  // C99
int vswprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, va_list arg);
int vswscanf(const wchar_t* restrict s, const wchar_t* restrict format, va_list arg);  // C99
int vwprintf(const wchar_t* restrict format, va_list arg);
int vwscanf(const wchar_t* restrict format, va_list arg);  // C99
int wprintf(const wchar_t* restrict format, ...);
int wscanf(const wchar_t* restrict format, ...);
wint_t fgetwc(FILE* stream);
wchar_t* fgetws(wchar_t* restrict s, int n, FILE* restrict stream);
wint_t fputwc(wchar_t c, FILE* stream);
int fputws(const wchar_t* restrict s, FILE* restrict stream);
int fwide(FILE* stream, int mode);
wint_t getwc(FILE* stream);
wint_t getwchar();
wint_t putwc(wchar_t c, FILE* stream);
wint_t putwchar(wchar_t c);
wint_t ungetwc(wint_t c, FILE* stream);
double wcstod(const wchar_t* restrict nptr, wchar_t** restrict endptr);
float wcstof(const wchar_t* restrict nptr, wchar_t** restrict endptr);         // C99
long double wcstold(const wchar_t* restrict nptr, wchar_t** restrict endptr);  // C99
long wcstol(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
long long wcstoll(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
unsigned long wcstoul(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
unsigned long long wcstoull(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);  // C99
wchar_t* wcscpy(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wcscat(wchar_t* restrict s1, const wchar_t* restrict s2);
wchar_t* wcsncat(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
int wcscmp(const wchar_t* s1, const wchar_t* s2);
int wcscoll(const wchar_t* s1, const wchar_t* s2);
int wcsncmp(const wchar_t* s1, const wchar_t* s2, size_t n);
size_t wcsxfrm(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
      wchar_t* wcschr(      wchar_t* s, wchar_t c);
size_t wcscspn(const wchar_t* s1, const wchar_t* s2);
size_t wcslen(const wchar_t* s);
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
      wchar_t* wcsrchr(      wchar_t* s, wchar_t c);
size_t wcsspn(const wchar_t* s1, const wchar_t* s2);
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
      wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);
wchar_t* wcstok(wchar_t* restrict s1, const wchar_t* restrict s2, wchar_t** restrict ptr);
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
      wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);
int wmemcmp(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemcpy(wchar_t* restrict s1, const wchar_t* restrict s2, size_t n);
wchar_t* wmemmove(wchar_t* s1, const wchar_t* s2, size_t n);
wchar_t* wmemset(wchar_t* s, wchar_t c, size_t n);
size_t wcsftime(wchar_t* restrict s, size_t maxsize, const wchar_t* restrict format,
                const tm* restrict timeptr);
wint_t btowc(int c);
int wctob(wint_t c);
int mbsinit(const mbstate_t* ps);
size_t mbrlen(const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
size_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
size_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,
                 mbstate_t* restrict ps);
size_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,
                 mbstate_t* restrict ps);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 106 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwchar" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwctype" 1
// -*- C++ -*-
//===--------------------------- cwctype ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cwctype synopsis

Macros:

    WEOF

namespace std
{

Types:

    wint_t
    wctrans_t
    wctype_t

int iswalnum(wint_t wc);
int iswalpha(wint_t wc);
int iswblank(wint_t wc);  // C99
int iswcntrl(wint_t wc);
int iswdigit(wint_t wc);
int iswgraph(wint_t wc);
int iswlower(wint_t wc);
int iswprint(wint_t wc);
int iswpunct(wint_t wc);
int iswspace(wint_t wc);
int iswupper(wint_t wc);
int iswxdigit(wint_t wc);
int iswctype(wint_t wc, wctype_t desc);
wctype_t wctype(const char* property);
wint_t towlower(wint_t wc);
wint_t towupper(wint_t wc);
wint_t towctrans(wint_t wc, wctrans_t desc);
wctrans_t wctrans(const char* property);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 53 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwctype" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cctype" 1
// -*- C++ -*-
//===---------------------------- cctype ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cctype synopsis

namespace std
{

int isalnum(int c);
int isalpha(int c);
int isblank(int c);  // C99
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);
int tolower(int c);
int toupper(int c);

}  // std
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 38 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cctype" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctype.h" 1
// -*- C++ -*-
//===---------------------------- ctype.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    ctype.h synopsis

int isalnum(int c);
int isalpha(int c);
int isblank(int c);  // C99
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);
int tolower(int c);
int toupper(int c);
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 33 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctype.h" 2
# 36 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctype.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 1 3
// -*- C++ -*-
//===---------------------------- ctype.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 39 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctype.h" 2 3
# 39 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cctype" 2
# 42 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cctype" 3


namespace std { inline namespace __1 {
# 103 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cctype" 3
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }
# 54 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwctype" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wctype.h" 1
// -*- C++ -*-
//===--------------------------- wctype.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    wctype.h synopsis

Macros:

    WEOF

Types:

    wint_t
    wctrans_t
    wctype_t

int iswalnum(wint_t wc);
int iswalpha(wint_t wc);
int iswblank(wint_t wc);  // C99
int iswcntrl(wint_t wc);
int iswdigit(wint_t wc);
int iswgraph(wint_t wc);
int iswlower(wint_t wc);
int iswprint(wint_t wc);
int iswpunct(wint_t wc);
int iswspace(wint_t wc);
int iswupper(wint_t wc);
int iswxdigit(wint_t wc);
int iswctype(wint_t wc, wctype_t desc);
wctype_t wctype(const char* property);
wint_t towlower(wint_t wc);
wint_t towupper(wint_t wc);
wint_t towctrans(wint_t wc, wctrans_t desc);
wctrans_t wctrans(const char* property);

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 48 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wctype.h" 2
# 51 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wctype.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 1 3
// -*- C++ -*-
//===--------------------------- wctype.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 55 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wctype.h" 2 3
# 55 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwctype" 2
# 58 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwctype" 3


namespace std { inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }
# 107 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwchar" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/wchar.h" 1
// -*- C++ -*-
//===--------------------------- wchar.h ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 108 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwchar" 2
# 111 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cwchar" 3


namespace std { inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;
using ::swscanf;
using ::vfwscanf;
using ::vswscanf;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;
using ::wcstof;
using ::wcstold;
using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;
using ::vwscanf;
using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;


} }
# 61 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 2
# 67 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 71 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 2 3


namespace std { inline namespace __1 {

// The the extern template ABI lists are kept outside of <string> to improve the
// readability of that header.

// The extern template ABI lists are kept outside of <string> to improve the
// readability of that header. We maintain 2 ABI lists:
// - _LIBCPP_STRING_V1_EXTERN_TEMPLATE_LIST
// - _LIBCPP_STRING_UNSTABLE_EXTERN_TEMPLATE_LIST
// As the name implies, the ABI lists define the V1 (Stable) and unstable ABI.
//
// For unstable, we may explicitly remove function that are external in V1,
// and add (new) external functions to better control inlining and compiler
// optimization opportunities.
//
// For stable, the ABI list should rarely change, except for adding new
// functions supporting new c++ version / API changes. Typically entries
// must never be removed from the stable list.
# 192 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
// char_traits

template <class _CharT>
struct __attribute__ ((__type_visibility__("default"))) char_traits
{
    typedef _CharT char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline void constexpr
        assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    size_t length(const char_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);
    static
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static
    char_type* assign(char_type* __s, size_t __n, char_type __a);

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(EOF);}
};

template <class _CharT>
constexpr int
char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

template <class _CharT>
inline
constexpr size_t
char_traits<_CharT>::length(const char_type* __s)
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

template <class _CharT>
inline
constexpr const _CharT*
char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

template <class _CharT>
                              _CharT*
char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

template <class _CharT>
inline
_CharT*
char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

// constexpr versions of move/copy/assign.

template <class _CharT>
static inline
_CharT* __move_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    if (__s1 < __s2) {
      std::__1::copy(__s2, __s2 + __n, __s1);
    } else if (__s2 < __s1) {
      std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
    }
    return __s1;
}

template <class _CharT>
static inline
_CharT* __copy_constexpr(_CharT* __s1, const _CharT* __s2, size_t __n) noexcept
{
    std::__1::copy_n(__s2, __n, __s1);
    return __s1;
}

template <class _CharT>
static inline
_CharT* __assign_constexpr(_CharT* __s, size_t __n, _CharT __a) noexcept
{
     std::__1::fill_n(__s, __n, __a);
     return __s;
}

// char_traits<char>

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char>
{
    typedef char char_type;
    typedef int int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
            {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return (unsigned char)__c1 < (unsigned char)__c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static inline size_t constexpr
    length(const char_type* __s) noexcept {return __builtin_strlen(__s);}
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__1::memmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : (char_type*)std::__1::memcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : (char_type*)std::__1::memset(__s, to_int_type(__a), __n);
        }

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type((unsigned char)__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(EOF);}
};

inline constexpr
int
char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_memcmp(__s1, __s2, __n);
# 430 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
}

inline constexpr
const char*
char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 451 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
}


// char_traits<wchar_t>

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;
    typedef streamoff off_type;
    typedef streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    static constexpr
    size_t length(const char_type* __s) noexcept;
    static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    static inline
    char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__move_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__1::wmemmove(__s1, __s2, __n);
        }
    static inline
    char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
        {
            ((void)0);
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__copy_constexpr(__s1, __s2, __n)
                       : __n == 0 ? __s1 : std::__1::wmemcpy(__s1, __s2, __n);
        }
    static inline
    char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept
        {
            return __libcpp_is_constant_evaluated()
                       ? std::__1::__assign_constexpr(__s, __n, __a)
                       : __n == 0 ? __s : std::__1::wmemset(__s, __a, __n);
        }
    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(WEOF);}
};

inline constexpr
int
char_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0)
        return 0;

    return __builtin_wmemcmp(__s1, __s2, __n);
# 532 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
}


template <class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
inline size_t __char_traits_length_checked(const typename _Traits::char_type* __s) noexcept {



  return _Traits::length(__s);

}

inline constexpr
size_t
char_traits<wchar_t>::length(const char_type* __s) noexcept
{

    return __builtin_wcslen(__s);
# 560 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
}

inline constexpr
const wchar_t*
char_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    if (__n == 0)
        return nullptr;

    return __builtin_wmemchr(__s, __a, __n);
# 581 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
}
# 695 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__string" 3
template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char16_t>
{
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFF);}
};

inline constexpr
int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char16_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char16_t*
char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char16_t*
char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char16_t*
char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}

template <>
struct __attribute__ ((__type_visibility__("default"))) char_traits<char32_t>
{
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    static inline constexpr
    void assign(char_type& __c1, const char_type& __c2) noexcept {__c1 = __c2;}
    static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept
        {return __c1 < __c2;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    int compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    size_t length(const char_type* __s) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr
    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static char_type* assign(char_type* __s, size_t __n, char_type __a) noexcept;

    static inline constexpr int_type not_eof(int_type __c) noexcept
        {return eq_int_type(__c, eof()) ? ~eof() : __c;}
    static inline constexpr char_type to_char_type(int_type __c) noexcept
        {return char_type(__c);}
    static inline constexpr int_type to_int_type(char_type __c) noexcept
        {return int_type(__c);}
    static inline constexpr bool eq_int_type(int_type __c1, int_type __c2) noexcept
        {return __c1 == __c2;}
    static inline constexpr int_type eof() noexcept
        {return int_type(0xFFFFFFFF);}
};

inline constexpr
int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    for (; __n; --__n, ++__s1, ++__s2)
    {
        if (lt(*__s1, *__s2))
            return -1;
        if (lt(*__s2, *__s1))
            return 1;
    }
    return 0;
}

inline constexpr
size_t
char_traits<char32_t>::length(const char_type* __s) noexcept
{
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
        ++__len;
    return __len;
}

inline constexpr
const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) noexcept
{
    for (; __n; --__n)
    {
        if (eq(*__s, __a))
            return __s;
        ++__s;
    }
    return nullptr;
}

inline
char32_t*
char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    if (__n == 0) return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2)
    {
        for (; __n; --__n, ++__s1, ++__s2)
            assign(*__s1, *__s2);
    }
    else if (__s2 < __s1)
    {
        __s1 += __n;
        __s2 += __n;
        for (; __n; --__n)
            assign(*--__s1, *--__s2);
    }
    return __r;
}

inline
char32_t*
char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) noexcept
{
    ((void)0);
    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    return __r;
}

inline
char32_t*
char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) noexcept
{
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
        assign(*__s, __a);
    return __r;
}



// helper fns for basic_string and string_view

// __str_find
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find(const _CharT *__p, _SizeT __sz,
             _CharT __c, _SizeT __pos) noexcept
{
    if (__pos >= __sz)
        return __npos;
    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
    if (__r == nullptr)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) {
  // Take advantage of knowing source and pattern lengths.
  // Stop short when source is smaller than pattern.
  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;

  // First element of __first2 is loop invariant.
  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;
    // Check whether __first1 still has at least __len2 bytes.
    if (__len1 < __len2)
      return __last1;

    // Find __f2 the first byte matching in __first1.
    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == nullptr)
      return __last1;

    // It is faster to compare from the first byte of __first1 even if we
    // already know that it matches the first byte of __first2: this is because
    // __first2 is most likely aligned, as it is user's "pattern" string, and
    // __first1 + 1 is most likely not aligned, as the match is in the middle of
    // the string.
    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find(const _CharT *__p, _SizeT __sz,
       const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos > __sz)
        return __npos;

    if (__n == 0) // There is nothing to search, just return __pos.
        return __pos;

    const _CharT *__r = __search_substring<_CharT, _Traits>(
        __p + __pos, __p + __sz, __s, __s + __n);

    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


// __str_rfind

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_rfind(const _CharT *__p, _SizeT __sz,
              _CharT __c, _SizeT __pos) noexcept
{
    if (__sz < 1)
        return __npos;
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
    {
        if (_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}

template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_rfind(const _CharT *__p, _SizeT __sz,
        const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    __pos = std::__1::min(__pos, __sz);
    if (__n < __sz - __pos)
        __pos += __n;
    else
        __pos = __sz;
    const _CharT* __r = std::__1::__find_end(
                  __p, __p + __pos, __s, __s + __n, _Traits::eq,
                        random_access_iterator_tag(), random_access_iterator_tag());
    if (__n > 0 && __r == __p + __pos)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}

// __str_find_first_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_first_of(const _CharT *__p, _SizeT __sz,
                const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos >= __sz || __n == 0)
        return __npos;
    const _CharT* __r = std::__1::__find_first_of_ce
        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );
    if (__r == __p + __sz)
        return __npos;
    return static_cast<_SizeT>(__r - __p);
}


// __str_find_last_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_last_of(const _CharT *__p, _SizeT __sz,
               const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
    {
    if (__n != 0)
    {
        if (__pos < __sz)
            ++__pos;
        else
            __pos = __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __p;)
        {
            const _CharT* __r = _Traits::find(__s, __n, *--__ps);
            if (__r)
                return static_cast<_SizeT>(__ps - __p);
        }
    }
    return __npos;
}


// __str_find_first_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                    const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (_Traits::find(__s, __n, *__ps) == nullptr)
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz,
                          _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
    {
        const _CharT* __pe = __p + __sz;
        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
            if (!_Traits::eq(*__ps, __c))
                return static_cast<_SizeT>(__ps - __p);
    }
    return __npos;
}


// __str_find_last_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                   const _CharT* __s, _SizeT __pos, _SizeT __n) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (_Traits::find(__s, __n, *--__ps) == nullptr)
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}


template<class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz,
                         _CharT __c, _SizeT __pos) noexcept
{
    if (__pos < __sz)
        ++__pos;
    else
        __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;)
        if (!_Traits::eq(*--__ps, __c))
            return static_cast<_SizeT>(__ps - __p);
    return __npos;
}

template<class _Ptr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
size_t __do_string_hash(_Ptr __p, _Ptr __e)
{
    typedef typename iterator_traits<_Ptr>::value_type value_type;
    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >
struct __quoted_output_proxy
{
    _Iter __first;
    _Iter __last;
    _CharT __delim;
    _CharT __escape;

    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}
    //  This would be a nice place for a string_ref
};

} }
# 180 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 2
# 190 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 194 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 2 3


namespace std { inline namespace __1 {

template<class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__type_visibility__("default"))) basic_string_view;

typedef basic_string_view<char> string_view;



typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;

template<class _CharT, class _Traits>
class
    __attribute__((__preferred_name__(string_view)))



    __attribute__((__preferred_name__(u16string_view)))
    __attribute__((__preferred_name__(u32string_view)))
    __attribute__((__preferred_name__(wstring_view)))
    basic_string_view {
public:
    // types
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _CharT* pointer;
    typedef const _CharT* const_pointer;
    typedef _CharT& reference;
    typedef const _CharT& const_reference;
    typedef const_pointer const_iterator; // See [string.view.iterators]
    typedef const_iterator iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr const size_type npos = -1; // size_type(-1);

    static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    // [string.view.cons], construct/copy
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view() noexcept : __data (nullptr), __size(0) {}

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view(const basic_string_view&) noexcept = default;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view& operator=(const basic_string_view&) noexcept = default;

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view(const _CharT* __s, size_type __len) noexcept
        : __data(__s), __size(__len)
    {

    ((void)0);

    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view(const _CharT* __s)
        : __data(__s), __size(std::__1::__char_traits_length_checked<_Traits>(__s)) {}

    // [string.view.iterators], iterators
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept { return cbegin(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept { return cend(); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept { return __data; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept { return __data + __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept { return const_reverse_iterator(cbegin()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }

    // [string.view.capacity], capacity
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type length() const noexcept { return __size; }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept { return numeric_limits<size_type>::max(); }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool empty() const noexcept { return __size == 0; }

    // [string.view.access], element access
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reference operator[](size_type __pos) const noexcept {
      return ((void)0), __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reference at(size_type __pos) const
    {
        return __pos >= size()
            ? (__throw_out_of_range("string_view::at"), __data[0])
            : __data[__pos];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reference front() const noexcept
    {
        return ((void)0), __data[0];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reference back() const noexcept
    {
        return ((void)0), __data[__size-1];
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer data() const noexcept { return __data; }

    // [string.view.modifiers], modifiers:
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void remove_prefix(size_type __n) noexcept
    {
        ((void)0);
        __data += __n;
        __size -= __n;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void remove_suffix(size_type __n) noexcept
    {
        ((void)0);
        __size -= __n;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_string_view& __other) noexcept
    {
        const value_type *__p = __data;
        __data = __other.__data;
        __other.__data = __p;

        size_type __sz = __size;
        __size = __other.__size;
        __other.__size = __sz;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const
    {
        if (__pos > size())
            __throw_out_of_range("string_view::copy");
        size_type __rlen = std::__1::min(__n, size() - __pos);
        _Traits::copy(__s, data() + __pos, __rlen);
        return __rlen;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string_view substr(size_type __pos = 0, size_type __n = npos) const
    {
        return __pos > size()
            ? (__throw_out_of_range("string_view::substr"), basic_string_view())
            : basic_string_view(data() + __pos, std::__1::min(__n, size() - __pos));
    }

    constexpr int compare(basic_string_view __sv) const noexcept
    {
        size_type __rlen = std::__1::min( size(), __sv.size());
        int __retval = _Traits::compare(data(), __sv.data(), __rlen);
        if ( __retval == 0 ) // first __rlen chars matched
            __retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );
        return __retval;
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const
    {
        return substr(__pos1, __n1).compare(__sv);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare( size_type __pos1, size_type __n1,
                basic_string_view __sv, size_type __pos2, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(const _CharT* __s) const noexcept
    {
        return compare(basic_string_view(__s));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s));
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const
    {
        return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
    }

    // find
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(_CharT __c, size_type __pos = 0) const noexcept
    {
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(const _CharT* __s, size_type __pos = 0) const
    {
        ((void)0);
        return __str_find<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }

    // rfind
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(basic_string_view __s, size_type __pos = npos) const noexcept
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(_CharT __c, size_type __pos = npos) const noexcept
    {
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_rfind<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }

    // find_first_of
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept
    { return find(__c, __pos); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(const _CharT* __s, size_type __pos=0) const
    {
        ((void)0);
        return __str_find_first_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }

    // find_last_of
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept
    { return rfind(__c, __pos); }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }

    // find_first_not_of
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const noexcept
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(_CharT __c, size_type __pos=0) const noexcept
    {
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const
    {
        ((void)0);
        return __str_find_first_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }

    // find_last_not_of
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const noexcept
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s.data(), __pos, __s.size());
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(_CharT __c, size_type __pos=npos) const noexcept
    {
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __c, __pos);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, __n);
    }

    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const
    {
        ((void)0);
        return __str_find_last_not_of<value_type, size_type, traits_type, npos>
            (data(), size(), __s, __pos, traits_type::length(__s));
    }
# 643 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 3
private:
    const value_type* __data;
    size_type __size;
};


// [string.view.comparison]
// operator ==
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size()) return false;
    return __lhs.compare(__rhs) == 0;
}


// operator !=
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    if ( __lhs.size() != __rhs.size())
        return true;
    return __lhs.compare(__rhs) != 0;
}


// operator <
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}


// operator >
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator>(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) > 0;
}


// operator <=
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) <= 0;
}


// operator >=
template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator>=(basic_string_view<_CharT, _Traits> __lhs,
                typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}

template<class _CharT, class _Traits>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,
                basic_string_view<_CharT, _Traits> __rhs) noexcept
{
    return __lhs.compare(__rhs) >= 0;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __str);

// [string.view.hash]
template<class _CharT>
struct __attribute__ ((__type_visibility__("default"))) hash<basic_string_view<_CharT, char_traits<_CharT> > >
    : public unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const noexcept {
        return __do_string_hash(__val.data(), __val.data() + __val.size());
    }
};



inline namespace literals
{
  inline namespace string_view_literals
  {
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    basic_string_view<char> operator "" sv(const char *__str, size_t __len) noexcept
    {
        return basic_string_view<char> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len) noexcept
    {
        return basic_string_view<wchar_t> (__str, __len);
    }
# 853 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string_view" 3
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len) noexcept
    {
        return basic_string_view<char32_t> (__str, __len);
    }
  }
}

} }
# 512 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 2
# 533 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 537 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 2 3


namespace std { inline namespace __1 {

// fpos

template <class _StateT>
class __attribute__ ((__type_visibility__("default"))) fpos
{
private:
    _StateT __st_;
    streamoff __off_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) operator streamoff() const {return __off_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) _StateT state() const {return __st_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void state(_StateT __st) {__st_ = __st;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fpos operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fpos operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}
};

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) - streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) == streamoff(__y);}

template <class _StateT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)
    {return streamoff(__x) != streamoff(__y);}

// basic_string

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,
          const basic_string<_CharT, _Traits, _Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__ ((__visibility__("default"))) string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&);

template <bool>
class __attribute__ ((__type_visibility__("default"))) __basic_string_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__basic_string_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void
__basic_string_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("basic_string");
}

extern template class __attribute__ ((__visibility__("default"))) __basic_string_common<true>;
# 635 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
template <class _Iter, bool = __is_cpp17_forward_iterator<_Iter>::value>
struct __libcpp_string_gets_noexcept_iterator_impl : public bool_constant<(( noexcept(++(declval<_Iter&>())) && is_nothrow_assignable<_Iter&, _Iter>::value && noexcept(declval<_Iter>() == declval<_Iter>()) && noexcept(*declval<_Iter>())))> {};






template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};



template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public bool_constant<(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view : public _BoolConstant<
      is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
     !is_convertible<const _Tp&, const _CharT*>::value
    > {};



template <class _CharT, size_t = sizeof(_CharT)>
struct __padding
{
    unsigned char __xx[sizeof(_CharT)-1];
};

template <class _CharT>
struct __padding<_CharT, 1>
{
};
# 678 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;


template<class _CharT, class _Traits, class _Allocator>
class
    __attribute__ ((__type_visibility__("default")))




    __attribute__((__preferred_name__(u16string)))
    __attribute__((__preferred_name__(u32string)))

    basic_string
    : private __basic_string_common<true>
{
public:
    typedef basic_string __self;
    typedef basic_string_view<_CharT, _Traits> __self_view;
    typedef _Traits traits_type;
    typedef _CharT value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
    static_assert(( is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
    static_assert(( is_trivial<value_type>::value), "Character type of basic_string must be trivial");
    static_assert(( is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");
    static_assert(( is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:



    struct __long
    {
        pointer __data_;
        size_type __size_;
        size_type __cap_;
    };





    static const size_type __short_mask = 0x80;
    static const size_type __long_mask = ~(size_type(~0) >> 1);


    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?
                      (sizeof(__long) - 1)/sizeof(value_type) : 2};

    struct __short
    {
        value_type __data_[__min_cap];
        struct
            : __padding<value_type>
        {
            unsigned char __size_;
        };
    };
# 786 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
    union __ulx{__long __lx; __short __lxx;};

    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};

    struct __raw
    {
        size_type __words[__n_words];
    };

    struct __rep
    {
        union
        {
            __long __l;
            __short __s;
            __raw __r;
        };
    };

    __compressed_pair<__rep, allocator_type> __r_;

public:
    __attribute__ ((__visibility__("default")))
    static const size_type npos = -1;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit basic_string(const allocator_type& __a)



        noexcept;


    basic_string(const basic_string& __str);
    basic_string(const basic_string& __str, const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(basic_string&& __str)



        noexcept;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(basic_string&& __str, const allocator_type& __a);


    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(const _CharT* __s) : __r_(__default_init_tag(), __default_init_tag()) {
      ((void)0);
      __init(__s, traits_type::length(__s));



    }

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string(const _CharT* __s, const _Allocator& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(const _CharT* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(size_type __n, _CharT __c);

    template <class = _EnableIf<__is_allocator<_Allocator>::value, nullptr_t> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string(size_type __n, _CharT __c, const _Allocator& __a);

    basic_string(const basic_string& __str, size_type __pos, size_type __n,
                 const _Allocator& __a = _Allocator());
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(const basic_string& __str, size_type __pos,
                 const _Allocator& __a = _Allocator());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        basic_string(const _Tp& __t, size_type __pos, size_type __n,
                     const allocator_type& __a = allocator_type());

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                                          !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t);

    template<class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
        inline __attribute__ ((__visibility__("hidden")))
        explicit basic_string(const _Tp& __t, const allocator_type& __a);

    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string(_InputIterator __first, _InputIterator __last);
    template<class _InputIterator, class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value> >
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(initializer_list<_CharT> __il);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string(initializer_list<_CharT> __il, const _Allocator& __a);


    inline ~basic_string();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator __self_view() const noexcept { return __self_view(data(), size()); }

    basic_string& operator=(const basic_string& __str);

    template <class _Tp, class = _EnableIf<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value> >
    basic_string& operator=(const _Tp& __t)
        {__self_view __sv = __t; return assign(__sv);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& operator=(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
     __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string& operator=(const value_type* __s) {return assign(__s);}
    basic_string& operator=(value_type __c);
# 930 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator begin() noexcept
        {return iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept
        {return const_iterator(__get_pointer());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator end() noexcept
        {return iterator(__get_pointer() + size());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept
        {return const_iterator(__get_pointer() + size());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type size() const noexcept
        {return __is_long() ? __get_long_size() : __get_short_size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type length() const noexcept {return size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type capacity() const noexcept
        {return (__is_long() ? __get_long_cap()
                             : static_cast<size_type>(__min_cap)) - 1;}

    void resize(size_type __n, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void resize(size_type __n) {resize(__n, value_type());}

    void reserve(size_type __requested_capacity);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __resize_default_init(size_type __n);

                                __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reserve() noexcept {shrink_to_fit();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void shrink_to_fit() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept;
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept {return size() == 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference operator[](size_type __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator[](size_type __pos) noexcept;

    const_reference at(size_type __n) const;
    reference at(size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string& operator+=(const basic_string& __str) {return append(__str);}

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string >::value,
            basic_string&
        >
                                            operator+=(const _Tp& __t) {__self_view __sv = __t; return append(__sv);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string& operator+=(const value_type* __s) {return append(__s);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string& operator+=(value_type __c) {push_back(__c); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& append(const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf<
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t) { __self_view __sv = __t; return append(__sv.data(), __sv.size()); }
    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  append(const _Tp& __t, size_type __pos, size_type __n=npos);
    basic_string& append(const value_type* __s, size_type __n);
    basic_string& append(const value_type* __s);
    basic_string& append(size_type __n, value_type __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __append_default_init(size_type __n);

    template <class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    append(_InputIterator __first, _InputIterator __last) {
      const basic_string __temp (__first, __last, __alloc());
      append(__temp.data(), __temp.size());
      return *this;
    }
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    append(_ForwardIterator __first, _ForwardIterator __last) {
      return __append_forward_unsafe(__first, __last);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}


    void push_back(value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void pop_back();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference front() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference front() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference back() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference back() const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 assign(const _Tp & __t) { __self_view __sv = __t; return assign(__sv.data(), __sv.size()); }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& assign(const basic_string& __str) { return *this = __str; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& assign(basic_string&& __str)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
        {*this = std::__1::move(__str); return *this;}

    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
            && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  assign(const _Tp & __t, size_type __pos, size_type __n=npos);
    basic_string& assign(const value_type* __s, size_type __n);
    basic_string& assign(const value_type* __s);
    basic_string& assign(size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
           __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            basic_string&
        >
        assign(_InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            basic_string&
        >
        assign(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& insert(size_type __pos1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                 insert(size_type __pos1, const _Tp& __t)
    { __self_view __sv = __t; return insert(__pos1, __sv.data(), __sv.size()); }

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
    basic_string& insert(size_type __pos, const value_type* __s);
    basic_string& insert(size_type __pos, size_type __n, value_type __c);
    iterator insert(const_iterator __pos, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __pos, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
           __is_exactly_cpp17_input_iterator<_InputIterator>::value
                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
    template<class _ForwardIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value
                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
            iterator
        >
        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __pos, initializer_list<value_type> __il)
                    {return insert(__pos, __il.begin(), __il.end());}


    basic_string& erase(size_type __pos = 0, size_type __n = npos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t) { __self_view __sv = __t; return replace(__pos1, __n1, __sv.data(), __sv.size()); }
    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            basic_string&
        >
                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            basic_string&
        >
                  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) { __self_view __sv = __t; return replace(__i1 - begin(), __i2 - __i1, __sv); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
    template<class _InputIterator>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            basic_string&
        >
        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)
        {return replace(__i1, __i2, __il.begin(), __il.end());}


    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string substr(size_type __pos = 0, size_type __n = npos) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_string& __str)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_type* c_str() const noexcept {return data();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_type* data() const noexcept {return std::__1::__to_address(__get_pointer());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_type* data() noexcept {return std::__1::__to_address(__get_pointer());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept {return __alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find(const _Tp& __t, size_type __pos = 0) const;
    size_type find(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find(const value_type* __s, size_type __pos = 0) const noexcept;
    size_type find(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              rfind(const _Tp& __t, size_type __pos = npos) const;
    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type rfind(const value_type* __s, size_type __pos = npos) const noexcept;
    size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_of(const _Tp& __t, size_type __pos = 0) const;
    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_of(const _Tp& __t, size_type __pos = npos) const;
    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_first_not_of(const _Tp &__t, size_type __pos = 0) const;
    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            size_type
        >
              find_last_not_of(const _Tp& __t, size_type __pos = npos) const;
    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(const basic_string& __str) const noexcept;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
        compare(const _Tp &__t) const;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden")))
    _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
            int
        >
         compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;

    template <class _Tp>
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        _EnableIf
        <
            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string>::value,
            int
        >
        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
    int compare(const value_type* __s) const noexcept;
    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
# 1454 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool __invariants() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __clear_and_shrink() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __shrink_or_extend(size_type __target_capacity);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool __is_long() const noexcept
        {return bool(__r_.first().__s.__size_ & __short_mask);}
# 1473 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type& __alloc() noexcept
        {return __r_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const allocator_type& __alloc() const noexcept
        {return __r_.second();}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_short_size(size_type __s) noexcept



        {__r_.first().__s.__size_ = (unsigned char)(__s);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type __get_short_size() const noexcept



        {return __r_.first().__s.__size_;}
# 1519 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_long_size(size_type __s) noexcept
        {__r_.first().__l.__size_ = __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type __get_long_size() const noexcept
        {return __r_.first().__l.__size_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_size(size_type __s) noexcept
        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_long_cap(size_type __s) noexcept
        {__r_.first().__l.__cap_ = __long_mask | __s;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type __get_long_cap() const noexcept
        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_long_pointer(pointer __p) noexcept
        {__r_.first().__l.__data_ = __p;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer __get_long_pointer() noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer __get_long_pointer() const noexcept
        {return __r_.first().__l.__data_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer __get_short_pointer() noexcept
        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer __get_short_pointer() const noexcept
        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer __get_pointer() noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_pointer __get_pointer() const noexcept
        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __zero() noexcept
        {
            size_type (&__a)[__n_words] = __r_.first().__r.__words;
            for (unsigned __i = 0; __i < __n_words; ++__i)
                __a[__i] = 0;
        }

    template <size_type __a> static
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        size_type __align_it(size_type __s) noexcept
            {return (__s + (__a-1)) & ~(__a-1);}
    enum {__alignment = 16};
    static __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type __recommend(size_type __s) noexcept
        {
        if (__s < __min_cap) return static_cast<size_type>(__min_cap) - 1;
        size_type __guess = __align_it<sizeof(value_type) < __alignment ?
                     __alignment/sizeof(value_type) : 1 > (__s+1) - 1;
        if (__guess == __min_cap) ++__guess;
        return __guess;
        }

    inline
    void __init(const value_type* __s, size_type __sz, size_type __reserve);
    inline
    void __init(const value_type* __s, size_type __sz);
    inline
    void __init(size_type __n, value_type __c);

    // Slow path for the (inlined) copy constructor for 'long' strings.
    // Always externally instantiated and not inlined.
    // Requires that __s is zero terminated.
    // The main reason for this function to exist is because for unstable, we
    // want to allow inlining of the copy constructor. However, we don't want
    // to call the __init() functions as those are marked as inline which may
    // result in over-aggressive inlining by the compiler, where our aim is
    // to only inline the fast path code directly in the ctor.
    void __init_copy_ctor_external(const value_type* __s, size_type __sz);

    template <class _InputIterator>
    inline
    _EnableIf
    <
        __is_exactly_cpp17_input_iterator<_InputIterator>::value
    >
    __init(_InputIterator __first, _InputIterator __last);

    template <class _ForwardIterator>
    inline
    _EnableIf
    <
        __is_cpp17_forward_iterator<_ForwardIterator>::value
    >
    __init(_ForwardIterator __first, _ForwardIterator __last);

    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                   size_type __n_copy, size_type __n_del, size_type __n_add = 0);
    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                               size_type __n_copy, size_type __n_del,
                               size_type __n_add, const value_type* __p_new_stuff);

    // __assign_no_alias is invoked for assignment operations where we
    // have proof that the input does not alias the current instance.
    // For example, operator=(basic_string) performs a 'self' check.
    template <bool __is_short>
    basic_string& __assign_no_alias(const value_type* __s, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __erase_to_end(size_type __pos);

    // __erase_external_with_move is invoked for erase() invocations where
    // `n ~= npos`, likely requiring memory moves on the string data.
    void __erase_external_with_move(size_type __pos, size_type __n);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const basic_string& __str)
        {__copy_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const basic_string& __str, true_type)
        {
            if (__alloc() == __str.__alloc())
                __alloc() = __str.__alloc();
            else
            {
                if (!__str.__is_long())
                {
                    __clear_and_shrink();
                    __alloc() = __str.__alloc();
                }
                else
                {
                    allocator_type __a = __str.__alloc();
                    pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                    __clear_and_shrink();
                    __alloc() = std::__1::move(__a);
                    __set_long_pointer(__p);
                    __set_long_cap(__str.__get_long_cap());
                    __set_long_size(__str.size());
                }
            }
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const basic_string&, false_type) noexcept
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign(basic_string& __str, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign(basic_string& __str, true_type)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void
    __move_assign_alloc(basic_string& __str)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


    {__move_assign_alloc(__str, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(basic_string& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(basic_string&, false_type)
        noexcept
        {}

    basic_string& __assign_external(const value_type* __s);
    basic_string& __assign_external(const value_type* __s, size_type __n);

    // Assigns the value in __s, guaranteed to be __n < __min_cap in length.
    inline basic_string& __assign_short(const value_type* __s, size_type __n) {
      pointer __p = __is_long()
                        ? (__set_long_size(__n), __get_long_pointer())
                        : (__set_short_size(__n), __get_short_pointer());
      traits_type::move(std::__1::__to_address(__p), __s, __n);
      traits_type::assign(__p[__n], value_type());
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __invalidate_iterators_past(size_type);

    friend basic_string operator+<>(const basic_string&, const basic_string&);
    friend basic_string operator+<>(const value_type*, const basic_string&);
    friend basic_string operator+<>(value_type, const basic_string&);
    friend basic_string operator+<>(const basic_string&, const value_type*);
    friend basic_string operator+<>(const basic_string&, value_type);
};

// These declarations must appear before any functions are implicitly used
// so that they have the correct visibility specifier.




extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, allocator<char> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::erase(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);
extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, allocator<wchar_t> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::erase(size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__ ((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__ ((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(basic_string const&); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__ ((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__ ((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);




template<class _InputIterator,
         class _CharT = typename iterator_traits<_InputIterator>::value_type,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_cpp17_input_iterator<_InputIterator>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>
         >
basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
  -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_allocator<_Allocator>::value>
         >
explicit basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;

template<class _CharT,
         class _Traits,
         class _Allocator = allocator<_CharT>,
         class = _EnableIf<__is_allocator<_Allocator>::value>,
         class _Sz = typename allocator_traits<_Allocator>::size_type
         >
basic_string(basic_string_view<_CharT, _Traits>, _Sz, _Sz, const _Allocator& = _Allocator())
  -> basic_string<_CharT, _Traits, _Allocator>;


template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()
{



}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                      )
{
# 1801 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
     : __r_(__default_init_tag(), __default_init_tag())
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)



        noexcept

: __r_(__default_init_tag(), __a)
{



    __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,
                                                       size_type __sz,
                                                       size_type __reserve)
{
    if (__reserve > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__reserve < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__reserve);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)
{
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    traits_type::copy(std::__1::__to_address(__p), __s, __sz);
    traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n)
     : __r_(__default_init_tag(), __default_init_tag())
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    ((void)0);
    __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)
    : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__1::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());




}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (!__str.__is_long())
        __r_.first().__r = __str.__r_.first().__r;
    else
        __init_copy_ctor_external(std::__1::__to_address(__str.__get_long_pointer()),
                                  __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(
    const value_type* __s, size_type __sz) {
  pointer __p;
  if (__sz < __min_cap) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      this->__throw_length_error();
    size_t __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_address(__p), __s, __sz + 1);
}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)



        noexcept

    : __r_(std::__1::move(__str.__r_))
{
    __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move
        __init(std::__1::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
    else
    {
        __r_.first().__r = __str.__r_.first().__r;
        __str.__zero();
    }





}



template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)
{
    if (__n > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__n < __min_cap)
    {
        __set_short_size(__n);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__n);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__n);
    }
    traits_type::assign(std::__1::__to_address(__p), __n, __c);
    traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,
                                                        size_type __pos, size_type __n,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,
                                                        const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
        this->__throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp & __t, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
_EnableIf
<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)
{
    __zero();

    try
    {

    for (; __first != __last; ++__first)
        push_back(*__first);

    }
    catch (...)
    {
        if (__is_long())
            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        throw;
    }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
>
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__sz > max_size())
        this->__throw_length_error();
    pointer __p;
    if (__sz < __min_cap)
    {
        __set_short_size(__sz);
        __p = __get_short_pointer();
    }
    else
    {
        size_type __cap = __recommend(__sz);
        __p = __alloc_traits::allocate(__alloc(), __cap+1);
        __set_long_pointer(__p);
        __set_long_cap(__cap+1);
        __set_long_size(__sz);
    }
    for (; __first != __last; ++__first, (void) ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator, class>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,
                                                        const allocator_type& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
     : __r_(__default_init_tag(), __default_init_tag())
{
    __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline

basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il, const _Allocator& __a)
    : __r_(__default_init_tag(), __a)
{
    __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string()
{



    if (__is_long())
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace
    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,
     size_type __n_copy, size_type __n_del, size_type __n_add, const value_type* __p_new_stuff)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap - 1)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    if (__n_add != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
    __old_sz = __n_copy + __n_add + __sec_cp_sz;
    __set_long_size(__old_sz);
    traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                                                     size_type __n_copy, size_type __n_del, size_type __n_add)
{
    size_type __ms = max_size();
    if (__delta_cap > __ms - __old_cap)
        this->__throw_length_error();
    pointer __old_p = __get_pointer();
    size_type __cap = __old_cap < __ms / 2 - __alignment ?
                          __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) :
                          __ms - 1;
    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
    __invalidate_all_iterators();
    if (__n_copy != 0)
        traits_type::copy(std::__1::__to_address(__p),
                          std::__1::__to_address(__old_p), __n_copy);
    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
    if (__sec_cp_sz != 0)
        traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                          std::__1::__to_address(__old_p) + __n_copy + __n_del,
                          __sec_cp_sz);
    if (__old_cap+1 != __min_cap)
        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
    __set_long_pointer(__p);
    __set_long_cap(__cap+1);
}

// assign

template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(
    const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? __min_cap : __get_long_cap();
  if (__n < __cap) {
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__1::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(
    const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type* __p = std::__1::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)
{
    ((void)0);
    return (__builtin_constant_p(__n) && __n < __min_cap)
               ? __assign_short(__s, __n)
               : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)
{
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    value_type* __p = std::__1::__to_address(__get_pointer());
    traits_type::assign(__p, __n, __c);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)
{
    pointer __p;
    if (__is_long())
    {
        __p = __get_long_pointer();
        __set_long_size(1);
    }
    else
    {
        __p = __get_short_pointer();
        __set_short_size(1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
    __invalidate_iterators_past(1);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)
{
  if (this != &__str) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        __r_.first().__r = __str.__r_.first().__r;
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__alloc() != __str.__alloc())
        assign(__str);
    else
        __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)

    noexcept



{
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());






  }
  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  __str.__set_short_size(0);
  traits_type::assign(__str.__get_short_pointer()[0], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__str, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
     __is_exactly_cpp17_input_iterator <_InputIterator>::value
          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    const basic_string __temp(__first, __last, __alloc());
    assign(__temp.data(), __temp.size());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    size_type __cap = capacity();
    if (__cap < __n)
    {
        size_type __sz = size();
        __grow_by(__cap, __n - __cap, __sz, 0, __sz);
    }
    else
        __invalidate_iterators_past(__n);
    pointer __p = __get_pointer();
    for (; __first != __last; ++__first, ++__p)
        traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());
    __set_size(__n);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)
{
    ((void)0);
    return __builtin_constant_p(*__s)
               ? (traits_type::length(__s) < __min_cap
                      ? __assign_short(__s, traits_type::length(__s))
                      : __assign_external(__s, traits_type::length(__s)))
               : __assign_external(__s);
}
// append

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_address(__get_pointer());
            traits_type::copy(__p + __sz, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        traits_type::assign(std::__1::__to_address(__p) + __sz, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n)
{
    if (__n)
    {
        size_type __cap = capacity();
        size_type __sz = size();
        if (__cap - __sz < __n)
            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
        pointer __p = __get_pointer();
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)
{
    bool __is_short = !__is_long();
    size_type __cap;
    size_type __sz;
    if (__is_short)
    {
        __cap = __min_cap - 1;
        __sz = __get_short_size();
    }
    else
    {
        __cap = __get_long_cap() - 1;
        __sz = __get_long_size();
    }
    if (__sz == __cap)
    {
        __grow_by(__cap, 1, __sz, __sz, 0);
        __is_short = !__is_long();
    }
    pointer __p;
    if (__is_short)
    {
        __p = __get_short_pointer() + __sz;
        __set_short_size(__sz+1);
    }
    else
    {
        __p = __get_long_pointer() + __sz;
        __set_long_size(__sz+1);
    }
    traits_type::assign(*__p, __c);
    traits_type::assign(*++__p, value_type());
}

template <class _Tp>
bool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)
{
    return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)
{
    return false;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
    _ForwardIterator __first, _ForwardIterator __last)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "function requires a ForwardIterator");
    size_type __sz = size();
    size_type __cap = capacity();
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_ref = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_ref), data(), data() + size()))
        {
            const basic_string __temp (__first, __last, __alloc());
            append(__temp.data(), __temp.size());
        }
        else
        {
            if (__cap - __sz < __n)
                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
            pointer __p = __get_pointer() + __sz;
            for (; __first != __last; ++__p, ++__first)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, value_type());
            __set_size(__sz + __n);
        }
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)
{
    return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)
{
    size_type __sz = __str.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
    _EnableIf
    <
        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
        basic_string<_CharT, _Traits, _Allocator>&
    >
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)
{
    __self_view __sv = __t;
    size_type __sz = __sv.size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)
{
    ((void)0);
    return append(__s, traits_type::length(__s));
}

// insert

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __cap = capacity();
    if (__cap - __sz >= __n)
    {
        if (__n)
        {
            value_type* __p = std::__1::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
            {
                if (__p + __pos <= __s && __s < __p + __sz)
                    __s += __n;
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
            }
            traits_type::move(__p + __pos, __s, __n);
            __sz += __n;
            __set_size(__sz);
            traits_type::assign(__p[__sz], value_type());
        }
    }
    else
        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    if (__n)
    {
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_address(__get_pointer());
            size_type __n_move = __sz - __pos;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
            __p = std::__1::__to_address(__get_long_pointer());
        }
        traits_type::assign(__p + __pos, __n, __c);
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
   __is_exactly_cpp17_input_iterator<_InputIterator>::value
        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
   typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)
{





    const basic_string __temp(__first, __last, __alloc());
    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template<class _ForwardIterator>
_EnableIf
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value
        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
>
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)
{





    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n)
    {
        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
        _CharRef __tmp_char = *__first;
        if (__ptr_in_range(std::__1::addressof(__tmp_char), data(), data() + size()))
        {
            const basic_string __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }

        size_type __sz = size();
        size_type __cap = capacity();
        value_type* __p;
        if (__cap - __sz >= __n)
        {
            __p = std::__1::__to_address(__get_pointer());
            size_type __n_move = __sz - __ip;
            if (__n_move != 0)
                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
        }
        else
        {
            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
            __p = std::__1::__to_address(__get_long_pointer());
        }
        __sz += __n;
        __set_size(__sz);
        traits_type::assign(__p[__sz], value_type());
        for (__p += __ip; __first != __last; ++__p, ++__first)
            traits_type::assign(*__p, *__first);
    }
    return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)
{
    return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,
                                                  size_type __pos2, size_type __n)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,
                                                  size_type __pos2, size_type __n)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return insert(__pos1, __sv.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)
{
    ((void)0);
    return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)
{
    size_type __ip = static_cast<size_type>(__pos - begin());
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap == __sz)
    {
        __grow_by(__cap, 1, __sz, __ip, 0, 1);
        __p = std::__1::__to_address(__get_long_pointer());
    }
    else
    {
        __p = std::__1::__to_address(__get_pointer());
        size_type __n_move = __sz - __ip;
        if (__n_move != 0)
            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
    }
    traits_type::assign(__p[__ip], __c);
    traits_type::assign(__p[++__sz], value_type());
    __set_size(__sz);
    return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)
{





    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
}

// replace

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    ((void)0);
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    if (__cap - __sz + __n1 >= __n2)
    {
        value_type* __p = std::__1::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
            {
                if (__n1 > __n2)
                {
                    traits_type::move(__p + __pos, __s, __n2);
                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    goto __finish;
                }
                if (__p + __pos < __s && __s < __p + __sz)
                {
                    if (__p + __pos + __n1 <= __s)
                        __s += __n2 - __n1;
                    else // __p + __pos < __s < __p + __pos + __n1
                    {
                        traits_type::move(__p + __pos, __s, __n1);
                        __pos += __n1;
                        __s += __n2;
                        __n2 -= __n1;
                        __n1 = 0;
                    }
                }
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
            }
        }
        traits_type::move(__p + __pos, __s, __n2);
__finish:
// __sz += __n2 - __n1; in this and the below function below can cause unsigned
// integer overflow, but this is a safe operation, so we disable the check.
        __sz += __n2 - __n1;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
    else
        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    __n1 = std::__1::min(__n1, __sz - __pos);
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz + __n1 >= __n2)
    {
        __p = std::__1::__to_address(__get_pointer());
        if (__n1 != __n2)
        {
            size_type __n_move = __sz - __pos - __n1;
            if (__n_move != 0)
                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
        }
    }
    else
    {
        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
        __p = std::__1::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n2, __c);
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
_EnableIf
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,
                                                   _InputIterator __j1, _InputIterator __j2)
{
    const basic_string __temp(__j1, __j2, __alloc());
    return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)
{
    return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,
                                                   size_type __pos2, size_type __n2)
{
    size_type __str_sz = __str.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    basic_string<_CharT, _Traits, _Allocator>&
>
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,
                                                   size_type __pos2, size_type __n2)
{
    __self_view __sv = __t;
    size_type __str_sz = __sv.size();
    if (__pos2 > __str_sz)
        this->__throw_out_of_range();
    return replace(__pos1, __n1, __sv.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)
{
    ((void)0);
    return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),
                   __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)
{
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
}

// erase

// 'externally instantiated' erase() implementation, called when __n != npos.
// Does not check __pos against size()
template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(
    size_type __pos, size_type __n)
{
    if (__n)
    {
        size_type __sz = size();
        value_type* __p = std::__1::__to_address(__get_pointer());
        __n = std::__1::min(__n, __sz - __pos);
        size_type __n_move = __sz - __pos - __n;
        if (__n_move != 0)
            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
        __sz -= __n;
        __set_size(__sz);
        __invalidate_iterators_past(__sz);
        traits_type::assign(__p[__sz], value_type());
    }
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  if (__pos > size()) this->__throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)
{





    ((void)0);

    iterator __b = begin();
    size_type __r = static_cast<size_type>(__pos - __b);
    erase(__r, 1);
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)
{





    ((void)0);
    iterator __b = begin();
    size_type __r = static_cast<size_type>(__first - __b);
    erase(__r, static_cast<size_type>(__last - __first));
    return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::pop_back()
{
    ((void)0);
    size_type __sz;
    if (__is_long())
    {
        __sz = __get_long_size() - 1;
        __set_long_size(__sz);
        traits_type::assign(*(__get_long_pointer() + __sz), value_type());
    }
    else
    {
        __sz = __get_short_size() - 1;
        __set_short_size(__sz);
        traits_type::assign(*(__get_short_pointer() + __sz), value_type());
    }
    __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept
{
    __invalidate_all_iterators();
    if (__is_long())
    {
        traits_type::assign(*__get_long_pointer(), value_type());
        __set_long_size(0);
    }
    else
    {
        traits_type::assign(*__get_short_pointer(), value_type());
        __set_short_size(0);
    }
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)
{
    if (__is_long())
    {
        traits_type::assign(*(__get_long_pointer() + __pos), value_type());
        __set_long_size(__pos);
    }
    else
    {
        traits_type::assign(*(__get_short_pointer() + __pos), value_type());
        __set_short_size(__pos);
    }
    __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)
{
    size_type __sz = size();
    if (__n > __sz)
        append(__n - __sz, __c);
    else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n)
{
    size_type __sz = size();
    if (__n > __sz) {
       __append_default_init(__n - __sz);
    } else
        __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept
{
    size_type __m = __alloc_traits::max_size(__alloc());



    return __m - __alignment;

}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity)
{
    if (__requested_capacity > max_size())
        this->__throw_length_error();






    size_type __target_capacity = std::__1::max(__requested_capacity, size());
    __target_capacity = __recommend(__target_capacity);
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() noexcept
{
    size_type __target_capacity = __recommend(size());
    if (__target_capacity == capacity()) return;

    __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity)
{
    size_type __cap = capacity();
    size_type __sz = size();

    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__target_capacity == __min_cap - 1)
    {
        __was_long = true;
        __now_long = false;
        __new_data = __get_short_pointer();
        __p = __get_long_pointer();
    }
    else
    {
        if (__target_capacity > __cap)
            __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);
        else
        {

            try
            {

                __new_data = __alloc_traits::allocate(__alloc(), __target_capacity+1);

            }
            catch (...)
            {
                return;
            }




        }
        __now_long = true;
        __was_long = __is_long();
        __p = __get_pointer();
    }
    traits_type::copy(std::__1::__to_address(__new_data),
                        std::__1::__to_address(__p), size()+1);
    if (__was_long)
        __alloc_traits::deallocate(__alloc(), __p, __cap+1);
    if (__now_long)
    {
        __set_long_cap(__target_capacity+1);
        __set_long_size(__sz);
        __set_long_pointer(__new_data);
    }
    else
        __set_short_size(__sz);
    __invalidate_all_iterators();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const noexcept
{
    ((void)0);
    return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) noexcept
{
    ((void)0);
    return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front() noexcept
{
    ((void)0);
    return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const noexcept
{
    ((void)0);
    return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back() noexcept
{
    ((void)0);
    return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const noexcept
{
    ((void)0);
    return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const
{
    size_type __sz = size();
    if (__pos > __sz)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n, __sz - __pos);
    traits_type::copy(__s, data() + __pos, __rlen);
    return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const
{
    return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)

        noexcept




{







    ((void)0);



    std::__1::swap(__r_.first(), __str.__r_.first());
    std::__1::__swap_allocator(__alloc(), __str.__alloc());
}

// find

template <class _Traits>
struct __attribute__ ((__visibility__("hidden"))) __traits_eq
{
    typedef typename _Traits::char_type char_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const char_type& __x, const char_type& __y) noexcept
        {return _Traits::eq(__x, __y);}
};

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos,
                                                size_type __n) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,
                                                size_type __pos) const noexcept
{
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c,
                                                size_type __pos) const noexcept
{
    return __str_find<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// rfind

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,
                                                 size_type __pos) const noexcept
{
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,
                                                 size_type __pos) const noexcept
{
    return __str_rfind<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// find_first_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos,
                                                         size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,
                                                         size_type __pos) const noexcept
{
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,
                                                         size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,
                                                         size_type __pos) const noexcept
{
    return find(__c, __pos);
}

// find_last_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos,
                                                        size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,
                                                        size_type __pos) const noexcept
{
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,
                                                        size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,
                                                        size_type __pos) const noexcept
{
    return rfind(__c, __pos);
}

// find_first_not_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos,
                                                             size_type __n) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,
                                                             size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,
                                                             size_type __pos) const noexcept
{
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// find_last_not_of

template<class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos,
                                                            size_type __n) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, __n);
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __str.data(), __pos, __str.size());
}

template<class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
>
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t,
                                                size_type __pos) const
{
    __self_view __sv = __t;
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __sv.data(), __pos, __sv.size());
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,
                                                            size_type __pos) const noexcept
{
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __s, __pos, traits_type::length(__s));
}

template<class _CharT, class _Traits, class _Allocator>
inline
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,
                                                            size_type __pos) const noexcept
{
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>
        (data(), size(), __c, __pos);
}

// compare

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const
{
    __self_view __sv = __t;
    size_t __lhs_sz = size();
    size_t __rhs_sz = __sv.size();
    int __result = traits_type::compare(data(), __sv.data(),
                                        std::__1::min(__lhs_sz, __rhs_sz));
    if (__result != 0)
        return __result;
    if (__lhs_sz < __rhs_sz)
        return -1;
    if (__lhs_sz > __rhs_sz)
        return 1;
    return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const noexcept
{
    return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s,
                                                   size_type __n2) const
{
    ((void)0);
    size_type __sz = size();
    if (__pos1 > __sz || __n2 == npos)
        this->__throw_out_of_range();
    size_type __rlen = std::__1::min(__n1, __sz - __pos1);
    int __r = traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
    if (__r == 0)
    {
        if (__rlen < __n2)
            __r = -1;
        else if (__rlen > __n2)
            __r = 1;
    }
    return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t) const
{
    __self_view __sv = __t;
    return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str) const
{
    return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
_EnableIf
<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value
    && !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
    int
>
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp& __t,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
    __self_view __sv = __t;
    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string& __str,
                                                   size_type __pos2,
                                                   size_type __n2) const
{
        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const noexcept
{
    ((void)0);
    return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const value_type* __s) const
{
    ((void)0);
    return compare(__pos1, __n1, __s, traits_type::length(__s));
}

// __invariants

template<class _CharT, class _Traits, class _Allocator>
inline
bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const
{
    if (size() > capacity())
        return false;
    if (capacity() < __min_cap - 1)
        return false;
    if (data() == nullptr)
        return false;
    if (data()[size()] != value_type())
        return false;
    return true;
}

// __clear_and_shrink

template<class _CharT, class _Traits, class _Allocator>
inline
void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept
{
    clear();
    if(__is_long())
    {
        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
        __set_long_cap(0);
        __set_short_size(0);
        traits_type::assign(*__get_short_pointer(), value_type());
    }
}

// operator==

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),
                                                        __rhs.data(),
                                                        __lhs_sz) == 0;
}

template<class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) noexcept
{
    size_t __lhs_sz = __lhs.size();
    if (__lhs_sz != __rhs.size())
        return false;
    const char* __lp = __lhs.data();
    const char* __rp = __rhs.data();
    if (__lhs.__is_long())
        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
        if (*__lp != *__rp)
            return false;
    return true;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __lhs_len = _Traits::length(__lhs);
    if (__lhs_len != __rhs.size()) return false;
    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    typedef basic_string<_CharT, _Traits, _Allocator> _String;
    ((void)0);
    size_t __rhs_len = _Traits::length(__rhs);
    if (__rhs_len != __lhs.size()) return false;
    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs == __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs == __rhs);
}

// operator<

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __lhs.compare(__rhs) < 0;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs.compare(__lhs) > 0;
}

// operator>

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return __rhs < __lhs;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return __rhs < __lhs;
}

// operator<=

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__rhs < __lhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__rhs < __lhs);
}

// operator>=

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs) noexcept
{
    return !(__lhs < __rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) noexcept
{
    return !(__lhs < __rhs);
}

// operator +

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
    __r.__init(&__lhs, 1, 1 + __rhs_sz);
    __r.append(__rhs.data(), __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
inline
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
    __r.append(__rhs, __rhs_sz);
    return __r;
}

template<class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)
{
    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
    __r.push_back(__rhs);
    return __r;
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    return std::__1::move(__rhs.insert(0, __lhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)
{
    __rhs.insert(__rhs.begin(), __lhs);
    return std::__1::move(__rhs);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)
{
    return std::__1::move(__lhs.append(__rhs));
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)
{
    __lhs.push_back(__rhs);
    return std::__1::move(__lhs);
}



// swap

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,
     basic_string<_CharT, _Traits, _Allocator>& __rhs)
     noexcept(noexcept(__lhs.swap(__rhs)))
{
    __lhs.swap(__rhs);
}

__attribute__ ((__visibility__("default"))) int stoi (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const string& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) double stod (const string& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) string to_string(int __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned __val);
__attribute__ ((__visibility__("default"))) string to_string(long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__ ((__visibility__("default"))) string to_string(long long __val);
__attribute__ ((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__ ((__visibility__("default"))) string to_string(float __val);
__attribute__ ((__visibility__("default"))) string to_string(double __val);
__attribute__ ((__visibility__("default"))) string to_string(long double __val);

__attribute__ ((__visibility__("default"))) int stoi (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long stol (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long stoul (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) long long stoll (const wstring& __str, size_t* __idx = nullptr, int __base = 10);
__attribute__ ((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = nullptr, int __base = 10);

__attribute__ ((__visibility__("default"))) float stof (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) double stod (const wstring& __str, size_t* __idx = nullptr);
__attribute__ ((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = nullptr);

__attribute__ ((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__ ((__visibility__("default"))) wstring to_wstring(long double __val);

template<class _CharT, class _Traits, class _Allocator>
__attribute__ ((__visibility__("default")))
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
               basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __attribute__ ((__type_visibility__("default")))
    hash<basic_string<_CharT, char_traits<_CharT>, _Allocator> >
    : public unary_function<
          basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t>
{
    size_t
    operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const noexcept
    { return __do_string_hash(__val.data(), __val.data() + __val.size()); }
};


template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str);

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str);
# 4519 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
// Literal suffixes for basic_string [basic.string.literals]
inline namespace literals
{
  inline namespace string_literals
  {
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string<char> operator "" s( const char *__str, size_t __len )
    {
        return basic_string<char> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string<wchar_t> operator "" s( const wchar_t *__str, size_t __len )
    {
        return basic_string<wchar_t> (__str, __len);
    }
# 4544 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/string" 3
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string<char16_t> operator "" s( const char16_t *__str, size_t __len )
    {
        return basic_string<char16_t> (__str, __len);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string<char32_t> operator "" s( const char32_t *__str, size_t __len )
    {
        return basic_string<char32_t> (__str, __len);
    }
  }
}


} }
# 10 "SEAL/native/src/seal/c/utilities.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 1
// -*- C++ -*-
//===-------------------------- unordered_map -----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*

    unordered_map synopsis

#include <initializer_list>

namespace std
{

template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
          class Alloc = allocator<pair<const Key, T>>>
class unordered_map
{
public:
    // types
    typedef Key                                                        key_type;
    typedef T                                                          mapped_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef pair<const key_type, mapped_type>                          value_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    typedef unspecified                             node_type;            // C++17
    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17

    unordered_map()
        noexcept(
            is_nothrow_default_constructible<hasher>::value &&
            is_nothrow_default_constructible<key_equal>::value &&
            is_nothrow_default_constructible<allocator_type>::value);
    explicit unordered_map(size_type n, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    explicit unordered_map(const allocator_type&);
    unordered_map(const unordered_map&);
    unordered_map(const unordered_map&, const Allocator&);
    unordered_map(unordered_map&&)
        noexcept(
            is_nothrow_move_constructible<hasher>::value &&
            is_nothrow_move_constructible<key_equal>::value &&
            is_nothrow_move_constructible<allocator_type>::value);
    unordered_map(unordered_map&&, const Allocator&);
    unordered_map(initializer_list<value_type>, size_type n = 0,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_map(size_type n, const allocator_type& a)
      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14
    unordered_map(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_map(n, hf, key_equal(), a) {}  // C++14
    template <class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14
    template <class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        const allocator_type& a)
      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14
    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14
    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
      const allocator_type& a)
      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14
    ~unordered_map();
    unordered_map& operator=(const unordered_map&);
    unordered_map& operator=(unordered_map&&)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<hasher>::value &&
            is_nothrow_move_assignable<key_equal>::value);
    unordered_map& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const noexcept;

    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin()  const noexcept;
    const_iterator end()    const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend()   const noexcept;

    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    template <class P>
        pair<iterator, bool> insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    template <class P>
        iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);                                       // C++17
    node_type extract(const key_type& x);                                             // C++17
    insert_return_type insert(node_type&& nh);                                        // C++17
    iterator           insert(const_iterator hint, node_type&& nh);                   // C++17

    template <class... Args>
        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17
    template <class... Args>
        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17
    template <class... Args>
        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17
    template <class... Args>
        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17
    template <class M>
        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17
    template <class M>
        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17
    template <class M>
        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17
    template <class M>
        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17

    iterator erase(const_iterator position);
    iterator erase(iterator position);  // C++14
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17

    void swap(unordered_map&)
        noexcept(
            (!allocator_type::propagate_on_container_swap::value ||
             __is_nothrow_swappable<allocator_type>::value) &&
            __is_nothrow_swappable<hasher>::value &&
            __is_nothrow_swappable<key_equal>::value);

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++20
    template<typename K>
        const_iterator find(const K& x) const;  // C++20
    size_type count(const key_type& k) const;
    template<typename K>
        size_type count(const K& k) const; // C++20
    bool contains(const key_type& k) const; // C++20
    template<typename K>
        bool contains(const K& k) const; // C++20
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator, iterator>             equal_range(const K& k); // C++20
    template<typename K>
        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20

    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);

    mapped_type&       at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y)
              noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
               const unordered_map<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
               const unordered_map<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
          class Alloc = allocator<pair<const Key, T>>>
class unordered_multimap
{
public:
    // types
    typedef Key                                                        key_type;
    typedef T                                                          mapped_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef pair<const key_type, mapped_type>                          value_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    typedef unspecified node_type;    // C++17

    unordered_multimap()
        noexcept(
            is_nothrow_default_constructible<hasher>::value &&
            is_nothrow_default_constructible<key_equal>::value &&
            is_nothrow_default_constructible<allocator_type>::value);
    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    explicit unordered_multimap(const allocator_type&);
    unordered_multimap(const unordered_multimap&);
    unordered_multimap(const unordered_multimap&, const Allocator&);
    unordered_multimap(unordered_multimap&&)
        noexcept(
            is_nothrow_move_constructible<hasher>::value &&
            is_nothrow_move_constructible<key_equal>::value &&
            is_nothrow_move_constructible<allocator_type>::value);
    unordered_multimap(unordered_multimap&&, const Allocator&);
    unordered_multimap(initializer_list<value_type>, size_type n = 0,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_multimap(size_type n, const allocator_type& a)
      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14
    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14
    template <class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14
    template <class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        const allocator_type& a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14
    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14
    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf,
      const allocator_type& a)
      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14
    ~unordered_multimap();
    unordered_multimap& operator=(const unordered_multimap&);
    unordered_multimap& operator=(unordered_multimap&&)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<hasher>::value &&
            is_nothrow_move_assignable<key_equal>::value);
    unordered_multimap& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const noexcept;

    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin()  const noexcept;
    const_iterator end()    const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend()   const noexcept;

    template <class... Args>
        iterator emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    template <class P>
        iterator insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    template <class P>
        iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);                // C++17
    node_type extract(const key_type& x);                      // C++17
    iterator insert(node_type&& nh);                           // C++17
    iterator insert(const_iterator hint, node_type&& nh);      // C++17

    iterator erase(const_iterator position);
    iterator erase(iterator position);  // C++14
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17
    template<class H2, class P2>
      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17
    template<class H2, class P2>
      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17

    void swap(unordered_multimap&)
        noexcept(
            (!allocator_type::propagate_on_container_swap::value ||
             __is_nothrow_swappable<allocator_type>::value) &&
            __is_nothrow_swappable<hasher>::value &&
            __is_nothrow_swappable<key_equal>::value);

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++20
    template<typename K>
        const_iterator find(const K& x) const;  // C++20
    size_type count(const key_type& k) const;
    template<typename K>
        size_type count(const K& k) const; // C++20
    bool contains(const key_type& k) const; // C++20
    template<typename K>
        bool contains(const K& k) const; // C++20
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator, iterator>             equal_range(const K& k); // C++20
    template<typename K>
        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20

    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
              noexcept(noexcept(x.swap(y)));

template <class K, class T, class H, class P, class A, class Predicate>
    typename unordered_map<K, T, H, P, A>::size_type
    erase_if(unordered_map<K, T, H, P, A>& c, Predicate pred);       // C++20

template <class K, class T, class H, class P, class A, class Predicate>
    typename unordered_multimap<K, T, H, P, A>::size_type
    erase_if(unordered_multimap<K, T, H, P, A>& c, Predicate pred);  // C++20

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

template <class Key, class T, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 435 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 2




# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 1
// -*- C++ -*-
//===---------------------------- cmath -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cmath synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

namespace std
{

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

double       hypot(double x, double y, double z);                // C++17
float        hypot(float x, float y, float z);                   // C++17
long double  hypot(long double x, long double y, long double z); // C++17

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

constexpr float       lerp(float a, float b, float t) noexcept;                   // C++20
constexpr double      lerp(double a, double b, double t) noexcept;                // C++20
constexpr long double lerp(long double a, long double b, long double t) noexcept; // C++20

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 308 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 1
// -*- C++ -*-
//===---------------------------- math.h ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    math.h synopsis

Macros:

    HUGE_VAL
    HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
    FP_INFINITE             // C99
    FP_NAN                  // C99
    FP_NORMAL               // C99
    FP_SUBNORMAL            // C99
    FP_ZERO                 // C99
    FP_FAST_FMA             // C99
    FP_FAST_FMAF            // C99
    FP_FAST_FMAL            // C99
    FP_ILOGB0               // C99
    FP_ILOGBNAN             // C99
    MATH_ERRNO              // C99
    MATH_ERREXCEPT          // C99
    math_errhandling        // C99

Types:

    float_t                 // C99
    double_t                // C99

// C90

floating_point abs(floating_point x);

floating_point acos (arithmetic x);
float          acosf(float x);
long double    acosl(long double x);

floating_point asin (arithmetic x);
float          asinf(float x);
long double    asinl(long double x);

floating_point atan (arithmetic x);
float          atanf(float x);
long double    atanl(long double x);

floating_point atan2 (arithmetic y, arithmetic x);
float          atan2f(float y, float x);
long double    atan2l(long double y, long double x);

floating_point ceil (arithmetic x);
float          ceilf(float x);
long double    ceill(long double x);

floating_point cos (arithmetic x);
float          cosf(float x);
long double    cosl(long double x);

floating_point cosh (arithmetic x);
float          coshf(float x);
long double    coshl(long double x);

floating_point exp (arithmetic x);
float          expf(float x);
long double    expl(long double x);

floating_point fabs (arithmetic x);
float          fabsf(float x);
long double    fabsl(long double x);

floating_point floor (arithmetic x);
float          floorf(float x);
long double    floorl(long double x);

floating_point fmod (arithmetic x, arithmetic y);
float          fmodf(float x, float y);
long double    fmodl(long double x, long double y);

floating_point frexp (arithmetic value, int* exp);
float          frexpf(float value, int* exp);
long double    frexpl(long double value, int* exp);

floating_point ldexp (arithmetic value, int exp);
float          ldexpf(float value, int exp);
long double    ldexpl(long double value, int exp);

floating_point log (arithmetic x);
float          logf(float x);
long double    logl(long double x);

floating_point log10 (arithmetic x);
float          log10f(float x);
long double    log10l(long double x);

floating_point modf (floating_point value, floating_point* iptr);
float          modff(float value, float* iptr);
long double    modfl(long double value, long double* iptr);

floating_point pow (arithmetic x, arithmetic y);
float          powf(float x, float y);
long double    powl(long double x, long double y);

floating_point sin (arithmetic x);
float          sinf(float x);
long double    sinl(long double x);

floating_point sinh (arithmetic x);
float          sinhf(float x);
long double    sinhl(long double x);

floating_point sqrt (arithmetic x);
float          sqrtf(float x);
long double    sqrtl(long double x);

floating_point tan (arithmetic x);
float          tanf(float x);
long double    tanl(long double x);

floating_point tanh (arithmetic x);
float          tanhf(float x);
long double    tanhl(long double x);

//  C99

bool signbit(arithmetic x);

int fpclassify(arithmetic x);

bool isfinite(arithmetic x);
bool isinf(arithmetic x);
bool isnan(arithmetic x);
bool isnormal(arithmetic x);

bool isgreater(arithmetic x, arithmetic y);
bool isgreaterequal(arithmetic x, arithmetic y);
bool isless(arithmetic x, arithmetic y);
bool islessequal(arithmetic x, arithmetic y);
bool islessgreater(arithmetic x, arithmetic y);
bool isunordered(arithmetic x, arithmetic y);

floating_point acosh (arithmetic x);
float          acoshf(float x);
long double    acoshl(long double x);

floating_point asinh (arithmetic x);
float          asinhf(float x);
long double    asinhl(long double x);

floating_point atanh (arithmetic x);
float          atanhf(float x);
long double    atanhl(long double x);

floating_point cbrt (arithmetic x);
float          cbrtf(float x);
long double    cbrtl(long double x);

floating_point copysign (arithmetic x, arithmetic y);
float          copysignf(float x, float y);
long double    copysignl(long double x, long double y);

floating_point erf (arithmetic x);
float          erff(float x);
long double    erfl(long double x);

floating_point erfc (arithmetic x);
float          erfcf(float x);
long double    erfcl(long double x);

floating_point exp2 (arithmetic x);
float          exp2f(float x);
long double    exp2l(long double x);

floating_point expm1 (arithmetic x);
float          expm1f(float x);
long double    expm1l(long double x);

floating_point fdim (arithmetic x, arithmetic y);
float          fdimf(float x, float y);
long double    fdiml(long double x, long double y);

floating_point fma (arithmetic x, arithmetic y, arithmetic z);
float          fmaf(float x, float y, float z);
long double    fmal(long double x, long double y, long double z);

floating_point fmax (arithmetic x, arithmetic y);
float          fmaxf(float x, float y);
long double    fmaxl(long double x, long double y);

floating_point fmin (arithmetic x, arithmetic y);
float          fminf(float x, float y);
long double    fminl(long double x, long double y);

floating_point hypot (arithmetic x, arithmetic y);
float          hypotf(float x, float y);
long double    hypotl(long double x, long double y);

int ilogb (arithmetic x);
int ilogbf(float x);
int ilogbl(long double x);

floating_point lgamma (arithmetic x);
float          lgammaf(float x);
long double    lgammal(long double x);

long long llrint (arithmetic x);
long long llrintf(float x);
long long llrintl(long double x);

long long llround (arithmetic x);
long long llroundf(float x);
long long llroundl(long double x);

floating_point log1p (arithmetic x);
float          log1pf(float x);
long double    log1pl(long double x);

floating_point log2 (arithmetic x);
float          log2f(float x);
long double    log2l(long double x);

floating_point logb (arithmetic x);
float          logbf(float x);
long double    logbl(long double x);

long lrint (arithmetic x);
long lrintf(float x);
long lrintl(long double x);

long lround (arithmetic x);
long lroundf(float x);
long lroundl(long double x);

double      nan (const char* str);
float       nanf(const char* str);
long double nanl(const char* str);

floating_point nearbyint (arithmetic x);
float          nearbyintf(float x);
long double    nearbyintl(long double x);

floating_point nextafter (arithmetic x, arithmetic y);
float          nextafterf(float x, float y);
long double    nextafterl(long double x, long double y);

floating_point nexttoward (arithmetic x, long double y);
float          nexttowardf(float x, long double y);
long double    nexttowardl(long double x, long double y);

floating_point remainder (arithmetic x, arithmetic y);
float          remainderf(float x, float y);
long double    remainderl(long double x, long double y);

floating_point remquo (arithmetic x, arithmetic y, int* pquo);
float          remquof(float x, float y, int* pquo);
long double    remquol(long double x, long double y, int* pquo);

floating_point rint (arithmetic x);
float          rintf(float x);
long double    rintl(long double x);

floating_point round (arithmetic x);
float          roundf(float x);
long double    roundl(long double x);

floating_point scalbln (arithmetic x, long ex);
float          scalblnf(float x, long ex);
long double    scalblnl(long double x, long ex);

floating_point scalbn (arithmetic x, int ex);
float          scalbnf(float x, int ex);
long double    scalbnl(long double x, int ex);

floating_point tgamma (arithmetic x);
float          tgammaf(float x);
long double    tgammal(long double x);

floating_point trunc (arithmetic x);
float          truncf(float x);
long double    truncl(long double x);

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 295 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 2
# 298 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 1 3
// -*- C++ -*-
//===---------------------------- math.h ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 1515 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
// This include lives outside the header guard in order to support an MSVC
// extension which allows users to do:
//
// #define _USE_MATH_DEFINES
// #include <math.h>
//
// and receive the definitions of mathematical constants, even if <math.h>
// has previously been included.
# 301 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 2 3



// We support including .h headers inside 'extern "C"' contexts, so switch
// back to C++ linkage before including these C++ headers.
extern "C++" {


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stdlib.h" 1 3
// -*- C++ -*-
//===--------------------------- stdlib.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 309 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 2 3



// signbit
# 374 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// fpclassify
# 420 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isfinite
# 454 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isinf
# 502 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isnan
# 550 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isnormal
# 580 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isgreater
# 610 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isgreaterequal
# 640 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isless
# 670 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// islessequal
# 700 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// islessgreater
# 730 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// isunordered
# 760 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/math.h" 3
// abs
//
// handled in stdlib.h

// div
//
// handled in stdlib.h

// acos


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float acos(float __lcpp_x) noexcept {return ::acosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double acos(long double __lcpp_x) noexcept {return ::acosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {return ::acos((double)__lcpp_x);}

// asin


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float asin(float __lcpp_x) noexcept {return ::asinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double asin(long double __lcpp_x) noexcept {return ::asinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {return ::asin((double)__lcpp_x);}

// atan


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atan(float __lcpp_x) noexcept {return ::atanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atan(long double __lcpp_x) noexcept {return ::atanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {return ::atan((double)__lcpp_x);}

// atan2


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atan2(float __lcpp_y, float __lcpp_x) noexcept {return ::atan2f(__lcpp_y, __lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atan2(long double __lcpp_y, long double __lcpp_x) noexcept {return ::atan2l(__lcpp_y, __lcpp_x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}

// ceil


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float ceil(float __lcpp_x) noexcept {return ::ceilf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double ceil(long double __lcpp_x) noexcept {return ::ceill(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {return ::ceil((double)__lcpp_x);}

// cos


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cos(float __lcpp_x) noexcept {return ::cosf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cos(long double __lcpp_x) noexcept {return ::cosl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {return ::cos((double)__lcpp_x);}

// cosh


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cosh(float __lcpp_x) noexcept {return ::coshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cosh(long double __lcpp_x) noexcept {return ::coshl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {return ::cosh((double)__lcpp_x);}

// exp


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float exp(float __lcpp_x) noexcept {return ::expf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double exp(long double __lcpp_x) noexcept {return ::expl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {return ::exp((double)__lcpp_x);}

// fabs


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fabs(float __lcpp_x) noexcept {return ::fabsf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fabs(long double __lcpp_x) noexcept {return ::fabsl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {return ::fabs((double)__lcpp_x);}

// floor


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float floor(float __lcpp_x) noexcept {return ::floorf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double floor(long double __lcpp_x) noexcept {return ::floorl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {return ::floor((double)__lcpp_x);}

// fmod


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmod(float __lcpp_x, float __lcpp_y) noexcept {return ::fmodf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmod(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmodl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// frexp


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float frexp(float __lcpp_x, int* __lcpp_e) noexcept {return ::frexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double frexp(long double __lcpp_x, int* __lcpp_e) noexcept {return ::frexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int* __lcpp_e) noexcept {return ::frexp((double)__lcpp_x, __lcpp_e);}

// ldexp


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float ldexp(float __lcpp_x, int __lcpp_e) noexcept {return ::ldexpf(__lcpp_x, __lcpp_e);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double ldexp(long double __lcpp_x, int __lcpp_e) noexcept {return ::ldexpl(__lcpp_x, __lcpp_e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {return ::ldexp((double)__lcpp_x, __lcpp_e);}

// log


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log(float __lcpp_x) noexcept {return ::logf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log(long double __lcpp_x) noexcept {return ::logl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {return ::log((double)__lcpp_x);}

// log10


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log10(float __lcpp_x) noexcept {return ::log10f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log10(long double __lcpp_x) noexcept {return ::log10l(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {return ::log10((double)__lcpp_x);}

// modf


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float modf(float __lcpp_x, float* __lcpp_y) noexcept {return ::modff(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double modf(long double __lcpp_x, long double* __lcpp_y) noexcept {return ::modfl(__lcpp_x, __lcpp_y);}


// pow


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float pow(float __lcpp_x, float __lcpp_y) noexcept {return ::powf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double pow(long double __lcpp_x, long double __lcpp_y) noexcept {return ::powl(__lcpp_x, __lcpp_y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// sin


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sin(float __lcpp_x) noexcept {return ::sinf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sin(long double __lcpp_x) noexcept {return ::sinl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {return ::sin((double)__lcpp_x);}

// sinh


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sinh(float __lcpp_x) noexcept {return ::sinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sinh(long double __lcpp_x) noexcept {return ::sinhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {return ::sinh((double)__lcpp_x);}

// sqrt


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float sqrt(float __lcpp_x) noexcept {return ::sqrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double sqrt(long double __lcpp_x) noexcept {return ::sqrtl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {return ::sqrt((double)__lcpp_x);}

// tan


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tan(float __lcpp_x) noexcept {return ::tanf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tan(long double __lcpp_x) noexcept {return ::tanl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {return ::tan((double)__lcpp_x);}

// tanh


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tanh(float __lcpp_x) noexcept {return ::tanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tanh(long double __lcpp_x) noexcept {return ::tanhl(__lcpp_x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {return ::tanh((double)__lcpp_x);}

// acosh

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float acosh(float __lcpp_x) noexcept {return ::acoshf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double acosh(long double __lcpp_x) noexcept {return ::acoshl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {return ::acosh((double)__lcpp_x);}

// asinh

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float asinh(float __lcpp_x) noexcept {return ::asinhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double asinh(long double __lcpp_x) noexcept {return ::asinhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {return ::asinh((double)__lcpp_x);}

// atanh

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float atanh(float __lcpp_x) noexcept {return ::atanhf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double atanh(long double __lcpp_x) noexcept {return ::atanhl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {return ::atanh((double)__lcpp_x);}

// cbrt

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float cbrt(float __lcpp_x) noexcept {return ::cbrtf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double cbrt(long double __lcpp_x) noexcept {return ::cbrtl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {return ::cbrt((double)__lcpp_x);}

// copysign

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float copysign(float __lcpp_x,
                                                float __lcpp_y) noexcept {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// erf

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float erf(float __lcpp_x) noexcept {return ::erff(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double erf(long double __lcpp_x) noexcept {return ::erfl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {return ::erf((double)__lcpp_x);}

// erfc

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float erfc(float __lcpp_x) noexcept {return ::erfcf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double erfc(long double __lcpp_x) noexcept {return ::erfcl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {return ::erfc((double)__lcpp_x);}

// exp2

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float exp2(float __lcpp_x) noexcept {return ::exp2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double exp2(long double __lcpp_x) noexcept {return ::exp2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {return ::exp2((double)__lcpp_x);}

// expm1

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float expm1(float __lcpp_x) noexcept {return ::expm1f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double expm1(long double __lcpp_x) noexcept {return ::expm1l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {return ::expm1((double)__lcpp_x);}

// fdim

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fdim(float __lcpp_x, float __lcpp_y) noexcept {return ::fdimf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fdim(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fdiml(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// fma

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value &&
                     std::_IsSame<_A3, __result_type>::value)), "");
    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}

// fmax

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmax(float __lcpp_x, float __lcpp_y) noexcept {return ::fmaxf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmax(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fmaxl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// fmin

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float fmin(float __lcpp_x, float __lcpp_y) noexcept {return ::fminf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double fmin(long double __lcpp_x, long double __lcpp_y) noexcept {return ::fminl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// hypot

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float hypot(float __lcpp_x, float __lcpp_y) noexcept {return ::hypotf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double hypot(long double __lcpp_x, long double __lcpp_y) noexcept {return ::hypotl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// ilogb

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) int ilogb(float __lcpp_x) noexcept {return ::ilogbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) int ilogb(long double __lcpp_x) noexcept {return ::ilogbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {return ::ilogb((double)__lcpp_x);}

// lgamma

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float lgamma(float __lcpp_x) noexcept {return ::lgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double lgamma(long double __lcpp_x) noexcept {return ::lgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {return ::lgamma((double)__lcpp_x);}

// llrint

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llrint(float __lcpp_x) noexcept {return ::llrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llrint(long double __lcpp_x) noexcept {return ::llrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {return ::llrint((double)__lcpp_x);}

// llround

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llround(float __lcpp_x) noexcept {return ::llroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long long llround(long double __lcpp_x) noexcept {return ::llroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {return ::llround((double)__lcpp_x);}

// log1p

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log1p(float __lcpp_x) noexcept {return ::log1pf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log1p(long double __lcpp_x) noexcept {return ::log1pl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {return ::log1p((double)__lcpp_x);}

// log2

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float log2(float __lcpp_x) noexcept {return ::log2f(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double log2(long double __lcpp_x) noexcept {return ::log2l(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {return ::log2((double)__lcpp_x);}

// logb

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float logb(float __lcpp_x) noexcept {return ::logbf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double logb(long double __lcpp_x) noexcept {return ::logbl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {return ::logb((double)__lcpp_x);}

// lrint

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lrint(float __lcpp_x) noexcept {return ::lrintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lrint(long double __lcpp_x) noexcept {return ::lrintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {return ::lrint((double)__lcpp_x);}

// lround

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lround(float __lcpp_x) noexcept {return ::lroundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long lround(long double __lcpp_x) noexcept {return ::lroundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {return ::lround((double)__lcpp_x);}

// nan

// nearbyint

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nearbyint(float __lcpp_x) noexcept {return ::nearbyintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nearbyint(long double __lcpp_x) noexcept {return ::nearbyintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {return ::nearbyint((double)__lcpp_x);}

// nextafter

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nextafter(float __lcpp_x, float __lcpp_y) noexcept {return ::nextafterf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nextafterl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// nexttoward

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {return ::nexttowardl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {return ::nexttoward((double)__lcpp_x, __lcpp_y);}

// remainder

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float remainder(float __lcpp_x, float __lcpp_y) noexcept {return ::remainderf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double remainder(long double __lcpp_x, long double __lcpp_y) noexcept {return ::remainderl(__lcpp_x, __lcpp_y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

// remquo

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) noexcept {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) noexcept {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::_EnableIf
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}

// rint

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float rint(float __lcpp_x) noexcept {return ::rintf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double rint(long double __lcpp_x) noexcept {return ::rintl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {return ::rint((double)__lcpp_x);}

// round

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float round(float __lcpp_x) noexcept {return ::roundf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double round(long double __lcpp_x) noexcept {return ::roundl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {return ::round((double)__lcpp_x);}

// scalbln

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float scalbln(float __lcpp_x, long __lcpp_y) noexcept {return ::scalblnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double scalbln(long double __lcpp_x, long __lcpp_y) noexcept {return ::scalblnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {return ::scalbln((double)__lcpp_x, __lcpp_y);}

// scalbn

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float scalbn(float __lcpp_x, int __lcpp_y) noexcept {return ::scalbnf(__lcpp_x, __lcpp_y);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double scalbn(long double __lcpp_x, int __lcpp_y) noexcept {return ::scalbnl(__lcpp_x, __lcpp_y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {return ::scalbn((double)__lcpp_x, __lcpp_y);}

// tgamma

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float tgamma(float __lcpp_x) noexcept {return ::tgammaf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double tgamma(long double __lcpp_x) noexcept {return ::tgammal(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {return ::tgamma((double)__lcpp_x);}

// trunc

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float trunc(float __lcpp_x) noexcept {return ::truncf(__lcpp_x);}
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double trunc(long double __lcpp_x) noexcept {return ::truncl(__lcpp_x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {return ::trunc((double)__lcpp_x);}

} // extern "C++"
# 309 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 2
# 314 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 318 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 2 3

namespace std { inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;


using ::abs;


using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float hypot( float x, float y, float z ) { return sqrt(x*x + y*y + z*z); }
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) double hypot( double x, double y, double z ) { return sqrt(x*x + y*y + z*z); }
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) long double hypot( long double x, long double y, long double z ) { return sqrt(x*x + y*y + z*z); }

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename _EnableIf
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}


template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isnan(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept
{
    return isnan(__lcpp_x);
}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isinf(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept
{
    return isinf(__lcpp_x);
}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{

    return __builtin_isfinite(__lcpp_x);



}

template <class _A1>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept
{
    return isfinite(__lcpp_x);
}
# 643 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cmath" 3
template <class _IntT, class _FloatT,
    bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),
    int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr _IntT __max_representable_int_for_float() noexcept {
  static_assert(is_floating_point<_FloatT>::value, "must be a floating point type");
  static_assert(is_integral<_IntT>::value, "must be an integral type");
  static_assert(numeric_limits<_FloatT>::radix == 2, "FloatT has incorrect radix");
  static_assert((_IsSame<_FloatT, float>::value || _IsSame<_FloatT, double>::value
                 || _IsSame<_FloatT,long double>::value), "unsupported floating point type");
  return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);
}

// Convert a floating point number to the specified integral type after
// clamping to the integral types representable range.
//
// The behavior is undefined if `__r` is NaN.
template <class _IntT, class _RealT>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_IntT __clamp_to_integral(_RealT __r) noexcept {
  using _Lim = numeric_limits<_IntT>;
  const _IntT _MaxVal = __max_representable_int_for_float<_IntT, _RealT>();
  if (__r >= ::nextafter(static_cast<_RealT>(_MaxVal), INFINITY)) {
    return _Lim::max();
  } else if (__r <= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast<_IntT>(__r);
}

} }
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 2
# 26 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 30 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 2 3


namespace std { inline namespace __1 {

template <class _Key, class _Tp>
struct __hash_value_type;

template <class _Tp>
struct __is_hash_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_hash_value_type : false_type {};

template <class _One>
struct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {};

__attribute__ ((__visibility__("default")))
size_t __next_prime(size_t __n);

template <class _NodePtr>
struct __hash_node_base
{
    typedef typename pointer_traits<_NodePtr>::element_type __node_type;
    typedef __hash_node_base __first_node;
    typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;
    typedef _NodePtr __node_pointer;




  typedef typename conditional<
      is_pointer<__node_pointer>::value,
      __node_base_pointer,
      __node_pointer>::type __next_pointer;


    __next_pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __next_pointer __ptr() noexcept {
        return static_cast<__next_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __node_pointer __upcast() noexcept {
        return static_cast<__node_pointer>(
            pointer_traits<__node_base_pointer>::pointer_to(*this));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t __hash() const noexcept {
        return static_cast<__node_type const&>(*this).__hash_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __hash_node_base() noexcept : __next_(nullptr) {}
};

template <class _Tp, class _VoidPtr>
struct __hash_node
    : public __hash_node_base
             <
                 typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type
             >
{
    typedef _Tp __node_value_type;

    size_t __hash_;
    __node_value_type __value_;
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__is_hash_power2(size_t __bc)
{
    return __bc > 2 && !(__bc & (__bc - 1));
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
size_t
__constrain_hash(size_t __h, size_t __bc)
{
    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :
        (__h < __bc ? __h : __h % __bc);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
size_t
__next_hash_pow2(size_t __n)
{
    return __n < 2 ? __n : (size_t(1) << (numeric_limits<size_t>::digits - __libcpp_clz(__n-1)));
}


template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;

template <class _NodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_iterator;
template <class _ConstNodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
template <class _NodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_local_iterator;
template <class _ConstNodePtr> class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
template <class _HashIterator> class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
template <class _HashIterator> class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;

template <class _Tp>
struct __hash_key_value_types {
  static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __hash_value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static key_type const& __get_key(__container_value_type const& __v) {
    return __v.first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__get_value());
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __hash_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __hash_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >
    : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>

{
  typedef __hash_key_value_types<_Tp> __base;

public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef __hash_node_base<__node_pointer> __node_base_type;
  typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef typename __node_base_type::__next_pointer __next_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _HashIterator>
struct __hash_node_types_from_iterator;
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};


template <class _NodeValueTp, class _VoidPtr>
struct __make_hash_node_types {
  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
  typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;
  typedef __hash_node_types<_NodePtr> type;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __hash_iterator() noexcept : __node_(nullptr) {



    }
# 322 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_iterator operator++(int)
    {
        __hash_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)
        {return !(__x == __y);}

private:
# 370 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator
{
    static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;

public:
    typedef __hash_iterator<_NodePtr> __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __hash_const_iterator() noexcept : __node_(nullptr) {



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_)
    {



    }
# 443 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_iterator operator++(int)
    {
        __hash_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
        {return !(__x == __y);}

private:
# 490 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_iterator(__next_pointer __node) noexcept
        : __node_(__node)
        {}

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_local_iterator
{
    typedef __hash_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __hash_local_iterator() noexcept : __node_(nullptr) {



    }
# 555 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_local_iterator operator++(int)
    {
        __hash_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
        {return !(__x == __y);}

private:
# 610 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_local_iterator(__next_pointer __node, size_t __bucket,
                          size_t __bucket_count) noexcept
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator;
};

template <class _ConstNodePtr>
class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator
{
    typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
    typedef _ConstNodePtr __node_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

    __next_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
    typedef typename __pointer_traits::element_type __node;
    typedef typename remove_const<__node>::type __non_const_node;
    typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type
        __non_const_node_pointer;
public:
    typedef __hash_local_iterator<__non_const_node_pointer>
                                                    __non_const_iterator;

    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__node_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __hash_const_local_iterator() noexcept : __node_(nullptr) {



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_local_iterator(const __non_const_iterator& __x) noexcept
        : __node_(__x.__node_),
          __bucket_(__x.__bucket_),
          __bucket_count_(__x.__bucket_count_)
    {



    }
# 700 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {
        ((void)0);

        return __node_->__upcast()->__value_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {
        ((void)0);

        return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_local_iterator& operator++() {
        ((void)0);

        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_local_iterator operator++(int)
    {
        __hash_const_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
        {return !(__x == __y);}

private:
# 755 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_const_local_iterator(__next_pointer __node, size_t __bucket,
                                size_t __bucket_count) noexcept
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
};

template <class _Alloc>
class __bucket_list_deallocator
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;

    __compressed_pair<size_type, allocator_type> __data_;
public:
    typedef typename __alloc_traits::pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bucket_list_deallocator()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
        : __data_(0, __default_init_tag()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bucket_list_deallocator(const allocator_type& __a, size_type __size)
        noexcept(is_nothrow_copy_constructible<allocator_type>::value)
        : __data_(__size, __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bucket_list_deallocator(__bucket_list_deallocator&& __x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value)
        : __data_(std::__1::move(__x.__data_))
    {
        __x.size() = 0;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type& size() noexcept {return __data_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __data_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type& __alloc() noexcept {return __data_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const allocator_type& __alloc() const noexcept {return __data_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
    {
        __alloc_traits::deallocate(__alloc(), __p, size());
    }
};

template <class _Alloc> class __hash_map_node_destructor;

template <class _Alloc>
class __hash_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __hash_node_types<pointer> _NodeTypes;

    allocator_type& __na_;

public:
    bool __value_constructed;

    __hash_node_destructor(__hash_node_destructor const&) = default;
    __hash_node_destructor& operator=(const __hash_node_destructor&) = delete;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __hash_node_destructor(allocator_type& __na,
                                    bool __constructed = false) noexcept
        : __na_(__na),
          __value_constructed(__constructed)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __hash_map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;

template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__hash_node<_Tp, _VoidPtr>, _Alloc>
    : __hash_node_destructor<_Alloc>
{
    using __hash_node_destructor<_Alloc>::__hash_node_destructor;
};


template <class _Key, class _Hash, class _Equal>
struct __enforce_unordered_container_requirements {

    static_assert(__check_hash_requirements<_Key, _Hash>::value,
    "the specified hash does not meet the Hash requirements");
    static_assert(is_copy_constructible<_Equal>::value,
    "the specified comparator is required to be copy constructible");

    typedef int type;
};

template <class _Key, class _Hash, class _Equal>

    __attribute__((diagnose_if(!__invokable<_Equal const&, _Key const&, _Key const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))

    __attribute__((diagnose_if(!__invokable<_Hash const&, _Key const&>::value, "the specified hash functor does not provide a viable const call operator", "warning")))


typename __enforce_unordered_container_requirements<_Key, _Hash, _Equal>::type
__diagnose_unordered_container_requirements(int);

// This dummy overload is used so that the compiler won't emit a spurious
// "no matching function for call to __diagnose_unordered_xxx" diagnostic
// when the overload above causes a hard error.
template <class _Key, class _Hash, class _Equal>
int __diagnose_unordered_container_requirements(void*);

template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table
{
public:
    typedef _Tp value_type;
    typedef _Hash hasher;
    typedef _Equal key_equal;
    typedef _Alloc allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename
      __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type
                                                                     _NodeTypes;
public:

    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;
    typedef typename _NodeTypes::key_type key_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;

    typedef typename __alloc_traits::size_type size_type;



    typedef typename _NodeTypes::difference_type difference_type;
public:
    // Create __node

    typedef typename _NodeTypes::__node_type __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename _NodeTypes::__void_pointer __void_pointer;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_pointer __node_const_pointer;
    typedef typename _NodeTypes::__node_base_type __first_node;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__next_pointer __next_pointer;

private:
    // check for sane allocator pointer rebinding semantics. Rebinding the
    // allocator for a new pointer type should be exactly the same as rebinding
    // the pointer using 'pointer_traits'.
    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:

    typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;
    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
    typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
    typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;

    // --- Member data begin ---
    __bucket_list __bucket_list_;
    __compressed_pair<__first_node, __node_allocator> __p1_;
    __compressed_pair<size_type, hasher> __p2_;
    __compressed_pair<float, key_equal> __p3_;
    // --- Member data end ---

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type& size() noexcept {return __p2_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __p2_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    hasher& hash_function() noexcept {return __p2_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const hasher& hash_function() const noexcept {return __p2_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float& max_load_factor() noexcept {return __p3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float max_load_factor() const noexcept {return __p3_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_equal& key_eq() noexcept {return __p3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const key_equal& key_eq() const noexcept {return __p3_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __node_allocator& __node_alloc() noexcept {return __p1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const __node_allocator& __node_alloc() const noexcept
        {return __p1_.second();}

public:
    typedef __hash_iterator<__node_pointer> iterator;
    typedef __hash_const_iterator<__node_pointer> const_iterator;
    typedef __hash_local_iterator<__node_pointer> local_iterator;
    typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_table()
        noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_table(const hasher& __hf, const key_equal& __eql);
    __hash_table(const hasher& __hf, const key_equal& __eql,
                 const allocator_type& __a);
    explicit __hash_table(const allocator_type& __a);
    __hash_table(const __hash_table& __u);
    __hash_table(const __hash_table& __u, const allocator_type& __a);
    __hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value);





    __hash_table(__hash_table&& __u, const allocator_type& __a);
    ~__hash_table();

    __hash_table& operator=(const __hash_table& __u);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_table& operator=(__hash_table&& __u)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);




    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept
    {
        return std::__1::min<size_type>(
            __node_traits::max_size(__node_alloc()),
            numeric_limits<difference_type >::max()
        );
    }

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __next_pointer __node_insert_multi_prepare(size_t __cp_hash,
                                               value_type& __cp_val);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_insert_multi_perform(__node_pointer __cp,
                                     __next_pointer __pn) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __next_pointer __node_insert_unique_prepare(size_t __nd_hash,
                                                value_type& __nd_val);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_insert_unique_perform(__node_pointer __ptr) noexcept;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_insert_multi(const_iterator __p,
                                             __node_pointer __nd);

    template <class _Key, class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
      return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                          __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
      return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }
    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __emplace_multi(_Args&&... __args);
    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __insert_unique(__container_value_type&& __x) {
      return __emplace_unique_key_args(_NodeTypes::__get_key(__x), std::__1::move(__x));
    }

    template <class _Pp, class = typename enable_if<
            !__is_same_uncvref<_Pp, __container_value_type>::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __insert_unique(_Pp&& __x) {
      return __emplace_unique(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(_Pp&& __x) {
      return __emplace_multi(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_multi(__p, std::__1::forward<_Pp>(__x));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __insert_unique(const __container_value_type& __x) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
    }


    template <class _NodeHandle, class _InsertReturnType>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _InsertReturnType __node_handle_insert_unique(_NodeHandle&& __nh);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_unique(const_iterator __hint,
                                         _NodeHandle&& __nh);
    template <class _Table>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_handle_merge_unique(_Table& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_multi(_NodeHandle&& __nh);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_multi(const_iterator __hint, _NodeHandle&& __nh);
    template <class _Table>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_handle_merge_multi(_Table& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _NodeHandle __node_handle_extract(key_type const& __key);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _NodeHandle __node_handle_extract(const_iterator __it);


    void clear() noexcept;
    void rehash(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void reserve(size_type __n)
        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket_count() const noexcept
    {
        return __bucket_list_.get_deleter().size();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        size_type bucket(const _Key& __k) const
        {
            ((void)0);

            return __constrain_hash(hash_function()(__k), bucket_count());
        }

    template <class _Key>
        iterator find(const _Key& __x);
    template <class _Key>
        const_iterator find(const _Key& __x) const;

    typedef __hash_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __first, const_iterator __last);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);
    __node_holder remove(const_iterator __p) noexcept;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    void swap(__hash_table& __u)
# 1262 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
     noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_bucket_count() const noexcept
        {return max_size(); }
    size_type bucket_size(size_type __n) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) float load_factor() const noexcept
    {
        size_type __bc = bucket_count();
        return __bc != 0 ? (float)size() / __bc : 0.f;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void max_load_factor(float __mlf) noexcept
    {
        ((void)0);

        max_load_factor() = std::__1::max(__mlf, load_factor());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator
    begin(size_type __n)
    {
        ((void)0);




        return local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator
    end(size_type __n)
    {
        ((void)0);




        return local_iterator(nullptr, __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator
    cbegin(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator
    cend(size_type __n) const
    {
        ((void)0);




        return const_local_iterator(nullptr, __n, bucket_count());

    }
# 1342 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
private:
    void __rehash(size_type __n);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    template <class _First, class ..._Rest>
    __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __hash_table& __u)
        {__copy_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}
    void __copy_assign_alloc(const __hash_table& __u, true_type);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __copy_assign_alloc(const __hash_table&, false_type) {}

    void __move_assign(__hash_table& __u, false_type);
    void __move_assign(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__hash_table& __u)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || (is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value))



        {__move_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__hash_table& __u, true_type)
        noexcept(is_nothrow_move_assignable<__pointer_allocator>::value && is_nothrow_move_assignable<__node_allocator>::value)


    {
        __bucket_list_.get_deleter().__alloc() =
                std::__1::move(__u.__bucket_list_.get_deleter().__alloc());
        __node_alloc() = std::__1::move(__u.__node_alloc());
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __move_assign_alloc(__hash_table&, false_type) noexcept {}

    void __deallocate_node(__next_pointer __np) noexcept;
    __next_pointer __detach() noexcept;

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()
    noexcept(is_nothrow_default_constructible<__bucket_list>::value && is_nothrow_default_constructible<__first_node>::value && is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_default_constructible<hasher>::value && is_nothrow_default_constructible<key_equal>::value)





    : __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql)
    : __bucket_list_(nullptr, __bucket_list_deleter()),
      __p1_(),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag())
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)
    : __bucket_list_(nullptr,
          __bucket_list_deleter(allocator_traits<__pointer_allocator>::
              select_on_container_copy_construction(
                  __u.__bucket_list_.get_deleter().__alloc()), 0)),
      __p1_(__default_init_tag(), allocator_traits<__node_allocator>::
          select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)
        noexcept(is_nothrow_move_constructible<__bucket_list>::value && is_nothrow_move_constructible<__first_node>::value && is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<hasher>::value && is_nothrow_move_constructible<key_equal>::value)





    : __bucket_list_(std::__1::move(__u.__bucket_list_)),
      __p1_(std::__1::move(__u.__p1_)),
      __p2_(std::__1::move(__u.__p2_)),
      __p3_(std::__1::move(__u.__p3_))
{
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, std::__1::move(__u.hash_function())),
      __p3_(std::__1::move(__u.__p3_))
{
    if (__a == allocator_type(__u.__node_alloc()))
    {
        __bucket_list_.reset(__u.__bucket_list_.release());
        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
        __u.__bucket_list_.get_deleter().size() = 0;
        if (__u.size() > 0)
        {
            __p1_.first().__next_ = __u.__p1_.first().__next_;
            __u.__p1_.first().__next_ = nullptr;
            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
                __p1_.first().__ptr();
            size() = __u.size();
            __u.size() = 0;
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()
{







    __deallocate_node(__p1_.first().__next_);



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(
        const __hash_table& __u, true_type)
{
    if (__node_alloc() != __u.__node_alloc())
    {
        clear();
        __bucket_list_.reset();
        __bucket_list_.get_deleter().size() = 0;
    }
    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
    __node_alloc() = __u.__node_alloc();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)
{
    if (this != &__u)
    {
        __copy_assign_alloc(__u);
        hash_function() = __u.hash_function();
        key_eq() = __u.key_eq();
        max_load_factor() = __u.max_load_factor();
        __assign_multi(__u.begin(), __u.end());
    }
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)
    noexcept
{
    __node_allocator& __na = __node_alloc();
    while (__np != nullptr)
    {
        __next_pointer __next = __np->__next_;
# 1579 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
        __node_pointer __real_np = __np->__upcast();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));
        __node_traits::deallocate(__na, __real_np, 1);
        __np = __next;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() noexcept
{
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
        __bucket_list_[__i] = nullptr;
    size() = 0;
    __next_pointer __cache = __p1_.first().__next_;
    __p1_.first().__next_ = nullptr;
    return __cache;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, true_type)
    noexcept(is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)



{
    clear();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    __move_assign_alloc(__u);
    size() = __u.size();
    hash_function() = std::__1::move(__u.hash_function());
    max_load_factor() = __u.max_load_factor();
    key_eq() = std::__1::move(__u.key_eq());
    __p1_.first().__next_ = __u.__p1_.first().__next_;
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, false_type)
{
    if (__node_alloc() == __u.__node_alloc())
        __move_assign(__u, true_type());
    else
    {
        hash_function() = std::__1::move(__u.hash_function());
        key_eq() = std::__1::move(__u.key_eq());
        max_load_factor() = __u.max_load_factor();
        if (bucket_count() != 0)
        {
            __next_pointer __cache = __detach();

            try
            {

                const_iterator __i = __u.begin();
                while (__cache != nullptr && __u.size() != 0)
                {
                    __cache->__upcast()->__value_ =
                        std::__1::move(__u.remove(__i++)->__value_);
                    __next_pointer __next = __cache->__next_;
                    __node_insert_multi(__cache->__upcast());
                    __cache = __next;
                }

            }
            catch (...)
            {
                __deallocate_node(__cache);
                throw;
            }

            __deallocate_node(__cache);
        }
        const_iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));
            __node_insert_multi(__h.get());
            __h.release();
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value && is_nothrow_move_assignable<hasher>::value && is_nothrow_move_assignable<key_equal>::value)




{
    __move_assign(__u, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,
                                                          _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");

    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();

        try
        {

            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_unique(__cache->__upcast());
                __cache = __next;
            }

        }
        catch (...)
        {
            __deallocate_node(__cache);
            throw;
        }

        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,
                                                         _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (bucket_count() != 0)
    {
        __next_pointer __cache = __detach();

        try
        {

            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__upcast()->__value_ = *__first;
                __next_pointer __next = __cache->__next_;
                __node_insert_multi(__cache->__upcast());
                __cache = __next;
            }

        }
        catch (...)
        {
            __deallocate_node(__cache);
            throw;
        }

        __deallocate_node(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() noexcept
{



    return iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() noexcept
{



    return iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const noexcept
{



    return const_iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const noexcept
{



    return const_iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() noexcept
{
    if (size() > 0)
    {
        __deallocate_node(__p1_.first().__next_);
        __p1_.first().__next_ = nullptr;
        size_type __bc = bucket_count();
        for (size_type __i = 0; __i < __bc; ++__i)
            __bucket_list_[__i] = nullptr;
        size() = 0;
    }
}


// Prepare the container for an insertion of the value __value with the hash
// __hash. This does a lookup into the container to see if __value is already
// present, and performs a rehash if necessary. Returns a pointer to the
// existing element if it exists, otherwise nullptr.
//
// Note that this function does forward exceptions if key_eq() throws, and never
// mutates __value or actually inserts into the map.
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_prepare(
    size_t __hash, value_type& __value)
{
    size_type __bc = bucket_count();

    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __ndptr = __bucket_list_[__chash];
        if (__ndptr != nullptr)
        {
            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&
                                             __constrain_hash(__ndptr->__hash(), __bc) == __chash;
                                                     __ndptr = __ndptr->__next_)
            {
                if (key_eq()(__ndptr->__upcast()->__value_, __value))
                    return __ndptr;
            }
        }
    }
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                                     size_type(ceil(float(size() + 1) / max_load_factor()))));
    }
    return nullptr;
}

// Insert the node __nd into the container by pushing it into the right bucket,
// and updating size(). Assumes that __nd->__hash is up-to-date, and that
// rehashing has already occurred and that no element with the same key exists
// in the map.
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_perform(
    __node_pointer __nd) noexcept
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__nd->__hash(), __bc);
    // insert_after __bucket_list_[__chash], or __first_node if bucket is null
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn == nullptr)
    {
        __pn =__p1_.first().__ptr();
        __nd->__next_ = __pn->__next_;
        __pn->__next_ = __nd->__ptr();
        // fix up __bucket_list_
        __bucket_list_[__chash] = __pn;
        if (__nd->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();
    }
    else
    {
        __nd->__next_ = __pn->__next_;
        __pn->__next_ = __nd->__ptr();
    }
    ++size();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)
{
    __nd->__hash_ = hash_function()(__nd->__value_);
    __next_pointer __existing_node =
        __node_insert_unique_prepare(__nd->__hash(), __nd->__value_);

    // Insert the node, unless it already exists in the container.
    bool __inserted = false;
    if (__existing_node == nullptr)
    {
        __node_insert_unique_perform(__nd);
        __existing_node = __nd->__ptr();
        __inserted = true;
    }



    return pair<iterator, bool>(iterator(__existing_node), __inserted);

}

// Prepare the container for an insertion of the value __cp_val with the hash
// __cp_hash. This does a lookup into the container to see if __cp_value is
// already present, and performs a rehash if necessary. Returns a pointer to the
// last occurrence of __cp_val in the map.
//
// Note that this function does forward exceptions if key_eq() throws, and never
// mutates __value or actually inserts into the map.
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_prepare(
    size_t __cp_hash, value_type& __cp_val)
{
    size_type __bc = bucket_count();
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                       size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
    }
    size_t __chash = __constrain_hash(__cp_hash, __bc);
    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn != nullptr)
    {
        for (bool __found = false; __pn->__next_ != nullptr &&
                                   __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
                                                           __pn = __pn->__next_)
        {
            //      __found    key_eq()     action
            //      false       false       loop
            //      true        true        loop
            //      false       true        set __found to true
            //      true        false       break
            if (__found != (__pn->__next_->__hash() == __cp_hash &&
                            key_eq()(__pn->__next_->__upcast()->__value_, __cp_val)))
            {
                if (!__found)
                    __found = true;
                else
                    break;
            }
        }
    }
    return __pn;
}

// Insert the node __cp into the container after __pn (which is the last node in
// the bucket that compares equal to __cp). Rehashing, and checking for
// uniqueness has already been performed (in __node_insert_multi_prepare), so
// all we need to do is update the bucket and size(). Assumes that __cp->__hash
// is up-to-date.
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_perform(
    __node_pointer __cp, __next_pointer __pn) noexcept
{
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cp->__hash_, __bc);
    if (__pn == nullptr)
    {
        __pn =__p1_.first().__ptr();
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();
        // fix up __bucket_list_
        __bucket_list_[__chash] = __pn;
        if (__cp->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]
                = __cp->__ptr();
    }
    else
    {
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp->__ptr();
        if (__cp->__next_ != nullptr)
        {
            size_t __nhash = __constrain_hash(__cp->__next_->__hash(), __bc);
            if (__nhash != __chash)
                __bucket_list_[__nhash] = __cp->__ptr();
        }
    }
    ++size();
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)
{
    __cp->__hash_ = hash_function()(__cp->__value_);
    __next_pointer __pn = __node_insert_multi_prepare(__cp->__hash(), __cp->__value_);
    __node_insert_multi_perform(__cp, __pn);




    return iterator(__cp->__ptr());

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(
        const_iterator __p, __node_pointer __cp)
{





    if (__p != end() && key_eq()(*__p, __cp->__value_))
    {
        __next_pointer __np = __p.__node_;
        __cp->__hash_ = __np->__hash();
        size_type __bc = bucket_count();
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
        }
        size_t __chash = __constrain_hash(__cp->__hash_, __bc);
        __next_pointer __pp = __bucket_list_[__chash];
        while (__pp->__next_ != __np)
            __pp = __pp->__next_;
        __cp->__next_ = __np;
        __pp->__next_ = static_cast<__next_pointer>(__cp);
        ++size();



        return iterator(static_cast<__next_pointer>(__cp));

    }
    return __node_insert_multi(__cp);
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key, class ..._Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{

    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __next_pointer __nd;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__hash, __bc);
        __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__upcast()->__value_, __k))
                    goto __done;
            }
        }
    }
    {
        __node_holder __h = __construct_node_hash(__hash, std::__1::forward<_Args>(__args)...);
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__1::max<size_type>(2 * __bc + !__is_hash_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__hash, __bc);
        }
        // insert_after __bucket_list_[__chash], or __first_node if bucket is null
        __next_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn = __p1_.first().__ptr();
            __h->__next_ = __pn->__next_;
            __pn->__next_ = __h.get()->__ptr();
            // fix up __bucket_list_
            __bucket_list_[__chash] = __pn;
            if (__h->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__h->__next_->__hash(), __bc)]
                    = __h.get()->__ptr();
        }
        else
        {
            __h->__next_ = __pn->__next_;
            __pn->__next_ = static_cast<__next_pointer>(__h.get());
        }
        __nd = static_cast<__next_pointer>(__h.release());
        // increment size
        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__nd), __inserted);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(
        const_iterator __p, _Args&&... __args)
{





    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle, class _InsertReturnType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InsertReturnType
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return _InsertReturnType{end(), false, _NodeHandle()};
    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);
    if (__result.second)
        __nh.__release_ptr();
    return _InsertReturnType{__result.first, __result.second, std::__1::move(__nh)};
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_unique(
    const_iterator, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    pair<iterator, bool> __result = __node_insert_unique(__nh.__ptr_);
    if (__result.second)
        __nh.__release_ptr();
    return __result.first;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodeHandle
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(
    key_type const& __key)
{
    iterator __i = find(__key);
    if (__i == end())
        return _NodeHandle();
    return __node_handle_extract<_NodeHandle>(__i);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodeHandle
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_extract(
    const_iterator __p)
{
    allocator_type __alloc(__node_alloc());
    return _NodeHandle(remove(__p).release(), __alloc);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Table>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_unique(
    _Table& __source)
{
    static_assert(is_same<__node, typename _Table::__node>::value, "");

    for (typename _Table::iterator __it = __source.begin();
         __it != __source.end();)
    {
        __node_pointer __src_ptr = __it.__node_->__upcast();
        size_t __hash = hash_function()(__src_ptr->__value_);
        __next_pointer __existing_node =
            __node_insert_unique_prepare(__hash, __src_ptr->__value_);
        auto __prev_iter = __it++;
        if (__existing_node == nullptr)
        {
            (void)__source.remove(__prev_iter).release();
            __src_ptr->__hash_ = __hash;
            __node_insert_unique_perform(__src_ptr);
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    iterator __result = __node_insert_multi(__nh.__ptr_);
    __nh.__release_ptr();
    return __result;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_insert_multi(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    iterator __result = __node_insert_multi(__hint, __nh.__ptr_);
    __nh.__release_ptr();
    return __result;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Table>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_handle_merge_multi(
    _Table& __source)
{
    static_assert(is_same<typename _Table::__node, __node>::value, "");

    for (typename _Table::iterator __it = __source.begin();
         __it != __source.end();)
    {
        __node_pointer __src_ptr = __it.__node_->__upcast();
        size_t __src_hash = hash_function()(__src_ptr->__value_);
        __next_pointer __pn =
            __node_insert_multi_prepare(__src_hash, __src_ptr->__value_);
        (void)__source.remove(__it++).release();
        __src_ptr->__hash_ = __src_hash;
        __node_insert_multi_perform(__src_ptr, __pn);
    }
}


template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    if (__n == 1)
        __n = 2;
    else if (__n & (__n - 1))
        __n = __next_prime(__n);
    size_type __bc = bucket_count();
    if (__n > __bc)
        __rehash(__n);
    else if (__n < __bc)
    {
        __n = std::__1::max<size_type>
              (
                  __n,
                  __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :
                                           __next_prime(size_t(ceil(float(size()) / max_load_factor())))
              );
        if (__n < __bc)
            __rehash(__n);
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)
{



    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
    __bucket_list_.reset(__nbc > 0 ?
                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);
    __bucket_list_.get_deleter().size() = __nbc;
    if (__nbc > 0)
    {
        for (size_type __i = 0; __i < __nbc; ++__i)
            __bucket_list_[__i] = nullptr;
        __next_pointer __pp = __p1_.first().__ptr();
        __next_pointer __cp = __pp->__next_;
        if (__cp != nullptr)
        {
            size_type __chash = __constrain_hash(__cp->__hash(), __nbc);
            __bucket_list_[__chash] = __pp;
            size_type __phash = __chash;
            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;
                                                           __cp = __pp->__next_)
            {
                __chash = __constrain_hash(__cp->__hash(), __nbc);
                if (__chash == __phash)
                    __pp = __cp;
                else
                {
                    if (__bucket_list_[__chash] == nullptr)
                    {
                        __bucket_list_[__chash] = __pp;
                        __pp = __cp;
                        __phash = __chash;
                    }
                    else
                    {
                        __next_pointer __np = __cp;
                        for (; __np->__next_ != nullptr &&
                               key_eq()(__cp->__upcast()->__value_,
                                        __np->__next_->__upcast()->__value_);
                                                           __np = __np->__next_)
                            ;
                        __pp->__next_ = __np->__next_;
                        __np->__next_ = __bucket_list_[__chash]->__next_;
                        __bucket_list_[__chash]->__next_ = __cp;

                    }
                }
            }
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__nd->__hash() == __hash
                  || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return iterator(__nd);

            }
        }
    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __next_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                (__hash == __nd->__hash()
                    || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                           __nd = __nd->__next_)
            {
                if ((__nd->__hash() == __hash)
                    && key_eq()(__nd->__upcast()->__value_, __k))



                    return const_iterator(__nd);

            }
        }

    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class ..._Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_hash_value_type<_Args...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = hash_function()(__h->__value_);
    __h->__next_ = nullptr;
    return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _First, class ..._Rest>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(
    size_t __hash, _First&& __f, _Rest&& ...__rest)
{
    static_assert(!__is_hash_value_type<_First, _Rest...>::value,
                  "Construct cannot be called with a hash value type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                             std::__1::forward<_First>(__f),
                             std::__1::forward<_Rest>(__rest)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = nullptr;
    return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)
{
    __next_pointer __np = __p.__node_;
# 2495 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    iterator __r(__np);

    ++__r;
    remove(__p);
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,
                                                const_iterator __last)
{
# 2515 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    for (const_iterator __p = __first; __first != __last; __p = __first)
    {
        ++__first;
        erase(__p);
    }
    __next_pointer __np = __last.__node_;



    return iterator (__np);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)
{
    size_type __r = 0;
    iterator __i = find(__k);
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            erase(__i++);
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) noexcept
{
    // current node
    __next_pointer __cn = __p.__node_;
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cn->__hash(), __bc);
    // find previous node
    __next_pointer __pn = __bucket_list_[__chash];
    for (; __pn->__next_ != __cn; __pn = __pn->__next_)
        ;
    // Fix up __bucket_list_
        // if __pn is not in same bucket (before begin is not in same bucket) &&
        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)
    if (__pn == __p1_.first().__ptr()
            || __constrain_hash(__pn->__hash(), __bc) != __chash)
    {
        if (__cn->__next_ == nullptr
            || __constrain_hash(__cn->__next_->__hash(), __bc) != __chash)
            __bucket_list_[__chash] = nullptr;
    }
        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)
    if (__cn->__next_ != nullptr)
    {
        size_t __nhash = __constrain_hash(__cn->__next_->__hash(), __bc);
        if (__nhash != __chash)
            __bucket_list_[__nhash] = __pn;
    }
    // remove __cn
    __pn->__next_ = __cn->__next_;
    __cn->__next_ = nullptr;
    --size();
# 2607 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const
{
    return static_cast<size_type>(find(__k) != end());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const
{
    size_type __r = 0;
    const_iterator __i = find(__k);
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__i;
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)
# 2718 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
  noexcept(__is_nothrow_swappable<hasher>::value && __is_nothrow_swappable<key_equal>::value)

{
    ((void)0);



    {
    __node_pointer_pointer __npp = __bucket_list_.release();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __u.__bucket_list_.reset(__npp);
    }
    std::__1::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
    std::__1::__swap_allocator(__bucket_list_.get_deleter().__alloc(),
             __u.__bucket_list_.get_deleter().__alloc());
    std::__1::__swap_allocator(__node_alloc(), __u.__node_alloc());
    std::__1::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
    __p2_.swap(__u.__p2_);
    __p3_.swap(__u.__p3_);
    if (size() > 0)
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =
            __p1_.first().__ptr();
    if (__u.size() > 0)
        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =
            __u.__p1_.first().__ptr();



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const
{
    ((void)0);

    __next_pointer __np = __bucket_list_[__n];
    size_type __bc = bucket_count();
    size_type __r = 0;
    if (__np != nullptr)
    {
        for (__np = __np->__next_; __np != nullptr &&
                                   __constrain_hash(__np->__hash(), __bc) == __n;
                                                    __np = __np->__next_, ++__r)
            ;
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,
     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2809 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__hash_table" 3
} }
# 436 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__node_handle" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__node_handle" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/optional" 1
// -*- C++ -*-
//===-------------------------- optional ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    optional synopsis

// C++1z

namespace std {
  // 23.6.3, optional for object types
  template <class T> class optional;

  // 23.6.4, no-value state indicator
  struct nullopt_t{see below };
  inline constexpr nullopt_t nullopt(unspecified );

  // 23.6.5, class bad_optional_access
  class bad_optional_access;

  // 23.6.6, relational operators
  template <class T, class U>
  constexpr bool operator==(const optional<T>&, const optional<U>&);
  template <class T, class U>
  constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template <class T, class U>
  constexpr bool operator<(const optional<T>&, const optional<U>&);
  template <class T, class U>
  constexpr bool operator>(const optional<T>&, const optional<U>&);
  template <class T, class U>
  constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template <class T, class U>
  constexpr bool operator>=(const optional<T>&, const optional<U>&);

  // 23.6.7 comparison with nullopt
  template <class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator==(nullopt_t, const optional<T>&) noexcept;
  template <class T> constexpr bool operator!=(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator!=(nullopt_t, const optional<T>&) noexcept;
  template <class T> constexpr bool operator<(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator<(nullopt_t, const optional<T>&) noexcept;
  template <class T> constexpr bool operator<=(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator<=(nullopt_t, const optional<T>&) noexcept;
  template <class T> constexpr bool operator>(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator>(nullopt_t, const optional<T>&) noexcept;
  template <class T> constexpr bool operator>=(const optional<T>&, nullopt_t) noexcept;
  template <class T> constexpr bool operator>=(nullopt_t, const optional<T>&) noexcept;

  // 23.6.8, comparison with T
  template <class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template <class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template <class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template <class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template <class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template <class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template <class T, class U> constexpr bool operator>=(const T&, const optional<U>&);

  // 23.6.9, specialized algorithms
  template <class T> void swap(optional<T>&, optional<T>&) noexcept(see below );
  template <class T> constexpr optional<see below > make_optional(T&&);
  template <class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template <class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // 23.6.10, hash support
  template <class T> struct hash;
  template <class T> struct hash<optional<T>>;

  template <class T> class optional {
  public:
    using value_type = T;

    // 23.6.3.1, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    optional(const optional &);
    optional(optional &&) noexcept(see below);
    template <class... Args> constexpr explicit optional(in_place_t, Args &&...);
    template <class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args &&...);
    template <class U = T>
      constexpr EXPLICIT optional(U &&);
    template <class U>
      constexpr EXPLICIT optional(const optional<U> &);
    template <class U>
      constexpr EXPLICIT optional(optional<U> &&);

    // 23.6.3.2, destructor
    ~optional();

    // 23.6.3.3, assignment
    optional &operator=(nullopt_t) noexcept;
    optional &operator=(const optional &);                // constexpr in C++20
    optional &operator=(optional &&) noexcept(see below); // constexpr in C++20
    template <class U = T> optional &operator=(U &&);
    template <class U> optional &operator=(const optional<U> &);
    template <class U> optional &operator=(optional<U> &&);
    template <class... Args> T& emplace(Args &&...);
    template <class U, class... Args>
      T& emplace(initializer_list<U>, Args &&...);

    // 23.6.3.4, swap
    void swap(optional &) noexcept(see below );

    // 23.6.3.5, observers
    constexpr T const *operator->() const;
    constexpr T *operator->();
    constexpr T const &operator*() const &;
    constexpr T &operator*() &;
    constexpr T &&operator*() &&;
    constexpr const T &&operator*() const &&;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr T const &value() const &;
    constexpr T &value() &;
    constexpr T &&value() &&;
    constexpr const T &&value() const &&;
    template <class U> constexpr T value_or(U &&) const &;
    template <class U> constexpr T value_or(U &&) &&;

    // 23.6.3.6, modifiers
    void reset() noexcept;

  private:
    T *val; // exposition only
  };

template<class T>
  optional(T) -> optional<T>;

} // namespace std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 150 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/optional" 2
# 163 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/optional" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 167 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/optional" 2 3


namespace std // purposefully not using versioning namespace
{

class __attribute__ ((__visibility__("default"))) bad_optional_access
    : public exception
{
public:
    // Get the key function ~bad_optional_access() into the dylib
    virtual ~bad_optional_access() noexcept;
    virtual const char* what() const noexcept;
};

} // std



namespace std { inline namespace __1 {

[[noreturn]]
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

void __throw_bad_optional_access() {

        throw bad_optional_access();



}

struct nullopt_t
{
    struct __secret_tag { __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __secret_tag() = default; };
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr explicit nullopt_t(__secret_tag, __secret_tag) noexcept {}
};

inline constexpr nullopt_t nullopt{nullopt_t::__secret_tag{}, nullopt_t::__secret_tag{}};

template <class _Tp, bool = is_trivially_destructible<_Tp>::value>
struct __optional_destruct_base;

template <class _Tp>
struct __optional_destruct_base<_Tp, false>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__optional_destruct_base()
    {
        if (__engaged_)
            __val_.~value_type();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept
    {
        if (__engaged_)
        {
            __val_.~value_type();
            __engaged_ = false;
        }
    }
};

template <class _Tp>
struct __optional_destruct_base<_Tp, true>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept
    {
        if (__engaged_)
        {
            __engaged_ = false;
        }
    }
};

template <class _Tp, bool = is_reference<_Tp>::value>
struct __optional_storage_base : __optional_destruct_base<_Tp>
{
    using __base = __optional_destruct_base<_Tp>;
    using value_type = _Tp;
    using __base::__base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr bool has_value() const noexcept
    {
        return this->__engaged_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type& __get() & noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr const value_type& __get() const& noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type&& __get() && noexcept
    {
        return std::__1::move(this->__val_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr const value_type&& __get() const&& noexcept
    {
        return std::__1::move(this->__val_);
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __construct(_Args&&... __args)
    {
        ((void)0);
        ::new ((void*)std::__1::addressof(this->__val_)) value_type(std::__1::forward<_Args>(__args)...);
        this->__engaged_ = true;
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __assign_from(_That&& __opt)
    {
        if (this->__engaged_ == __opt.has_value())
        {
            if (this->__engaged_)
                this->__val_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (this->__engaged_)
                this->reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};

// optional<T&> is currently required ill-formed, however it may to be in the
// future. For this reason it has already been implemented to ensure we can
// make the change in an ABI compatible manner.
template <class _Tp>
struct __optional_storage_base<_Tp, true>
{
    using value_type = _Tp;
    using __raw_type = remove_reference_t<_Tp>;
    __raw_type* __value_;

    template <class _Up>
    static constexpr bool __can_bind_reference() {
        using _RawUp = typename remove_reference<_Up>::type;
        using _UpPtr = _RawUp*;
        using _RawTp = typename remove_reference<_Tp>::type;
        using _TpPtr = _RawTp*;
        using _CheckLValueArg = integral_constant<bool,
            (is_lvalue_reference<_Up>::value && is_convertible<_UpPtr, _TpPtr>::value)
        || is_same<_RawUp, reference_wrapper<_RawTp>>::value
        || is_same<_RawUp, reference_wrapper<typename remove_const<_RawTp>::type>>::value
        >;
        return (is_lvalue_reference<_Tp>::value && _CheckLValueArg::value)
            || (is_rvalue_reference<_Tp>::value && !is_lvalue_reference<_Up>::value &&
                is_convertible<_UpPtr, _TpPtr>::value);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __optional_storage_base() noexcept
        : __value_(nullptr) {}

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit __optional_storage_base(in_place_t, _UArg&& __uarg)
        : __value_(std::__1::addressof(__uarg))
    {
      static_assert(__can_bind_reference<_UArg>(),
        "Attempted to construct a reference element in tuple from a "
        "possible temporary");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reset() noexcept { __value_ = nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr bool has_value() const noexcept
      { return __value_ != nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type& __get() const& noexcept
      { return *__value_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type&& __get() const&& noexcept
      { return std::__1::forward<value_type>(*__value_); }

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __construct(_UArg&& __val)
    {
        ((void)0);
        static_assert(__can_bind_reference<_UArg>(),
            "Attempted to construct a reference element in tuple from a "
            "possible temporary");
        __value_ = std::__1::addressof(__val);
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __assign_from(_That&& __opt)
    {
        if (has_value() == __opt.has_value())
        {
            if (has_value())
                *__value_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (has_value())
                reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};

template <class _Tp, bool = is_trivially_copy_constructible<_Tp>::value>
struct __optional_copy_base : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;
};

template <class _Tp>
struct __optional_copy_base<_Tp, false> : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_base() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_base(const __optional_copy_base& __opt)
    {
        this->__construct_from(__opt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_base(__optional_copy_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_base& operator=(const __optional_copy_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_base& operator=(__optional_copy_base&&) = default;
};

template <class _Tp, bool = is_trivially_move_constructible<_Tp>::value>
struct __optional_move_base : __optional_copy_base<_Tp>
{
    using __optional_copy_base<_Tp>::__optional_copy_base;
};

template <class _Tp>
struct __optional_move_base<_Tp, false> : __optional_copy_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_base<_Tp>::__optional_copy_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_base(const __optional_move_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_base(__optional_move_base&& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type>)
    {
        this->__construct_from(std::__1::move(__opt));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_base& operator=(const __optional_move_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_base& operator=(__optional_move_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_copy_constructible<_Tp>::value &&
    is_trivially_copy_assignable<_Tp>::value>
struct __optional_copy_assign_base : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;
};

template <class _Tp>
struct __optional_copy_assign_base<_Tp, false> : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_assign_base(const __optional_copy_assign_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_assign_base(__optional_copy_assign_base&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_assign_base& operator=(const __optional_copy_assign_base& __opt)
    {
        this->__assign_from(__opt);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_copy_assign_base& operator=(__optional_copy_assign_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_move_constructible<_Tp>::value &&
    is_trivially_move_assignable<_Tp>::value>
struct __optional_move_assign_base : __optional_copy_assign_base<_Tp>
{
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;
};

template <class _Tp>
struct __optional_move_assign_base<_Tp, false> : __optional_copy_assign_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_assign_base(const __optional_move_assign_base& __opt) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_assign_base(__optional_move_assign_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_assign_base& operator=(const __optional_move_assign_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __optional_move_assign_base& operator=(__optional_move_assign_base&& __opt)
        noexcept(is_nothrow_move_assignable_v<value_type> &&
                 is_nothrow_move_constructible_v<value_type>)
    {
        this->__assign_from(std::__1::move(__opt));
        return *this;
    }
};

template <class _Tp>
using __optional_sfinae_ctor_base_t = __sfinae_ctor_base<
    is_copy_constructible<_Tp>::value,
    is_move_constructible<_Tp>::value
>;

template <class _Tp>
using __optional_sfinae_assign_base_t = __sfinae_assign_base<
    (is_copy_constructible<_Tp>::value && is_copy_assignable<_Tp>::value),
    (is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value)
>;

template <class _Tp>
class optional
    : private __optional_move_assign_base<_Tp>
    , private __optional_sfinae_ctor_base_t<_Tp>
    , private __optional_sfinae_assign_base_t<_Tp>
{
    using __base = __optional_move_assign_base<_Tp>;
public:
    using value_type = _Tp;

private:
     // Disable the reference extension using this static assert.
    static_assert(!is_same_v<__uncvref_t<value_type>, in_place_t>,
        "instantiation of optional with in_place_t is ill-formed");
    static_assert(!is_same_v<__uncvref_t<value_type>, nullopt_t>,
        "instantiation of optional with nullopt_t is ill-formed");
    static_assert(!is_reference_v<value_type>,
        "instantiation of optional with a reference type is ill-formed");
    static_assert(is_destructible_v<value_type>,
        "instantiation of optional with a non-destructible type is ill-formed");
    static_assert(!is_array_v<value_type>,
        "instantiation of optional with an array type is ill-formed");

    // LWG2756: conditionally explicit conversion from _Up
    struct _CheckOptionalArgsConstructor {
      template <class _Up>
      static constexpr bool __enable_implicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 is_convertible_v<_Up&&, _Tp>;
      }

      template <class _Up>
      static constexpr bool __enable_explicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 !is_convertible_v<_Up&&, _Tp>;
      }
    };
    template <class _Up>
    using _CheckOptionalArgsCtor = _If<
        _IsNotSame<__uncvref_t<_Up>, in_place_t>::value &&
        _IsNotSame<__uncvref_t<_Up>, optional>::value,
        _CheckOptionalArgsConstructor,
        __check_tuple_constructor_fail
    >;
    template <class _QualUp>
    struct _CheckOptionalLikeConstructor {
      template <class _Up, class _Opt = optional<_Up>>
      using __check_constructible_from_opt = _Or<
          is_constructible<_Tp, _Opt&>,
          is_constructible<_Tp, _Opt const&>,
          is_constructible<_Tp, _Opt&&>,
          is_constructible<_Tp, _Opt const&&>,
          is_convertible<_Opt&, _Tp>,
          is_convertible<_Opt const&, _Tp>,
          is_convertible<_Opt&&, _Tp>,
          is_convertible<_Opt const&&, _Tp>
      >;
      template <class _Up, class _Opt = optional<_Up>>
      using __check_assignable_from_opt = _Or<
          is_assignable<_Tp&, _Opt&>,
          is_assignable<_Tp&, _Opt const&>,
          is_assignable<_Tp&, _Opt&&>,
          is_assignable<_Tp&, _Opt const&&>
      >;
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_implicit() {
          return is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_explicit() {
          return !is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_assign() {
          // Construction and assignability of _QUp to _Tp has already been
          // checked.
          return !__check_constructible_from_opt<_Up>::value &&
              !__check_assignable_from_opt<_Up>::value;
      }
    };

    template <class _Up, class _QualUp>
    using _CheckOptionalLikeCtor = _If<
      _And<
         _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
    template <class _Up, class _QualUp>
    using _CheckOptionalLikeAssign = _If<
      _And<
          _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>,
          is_assignable<_Tp&, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr optional() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr optional(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr optional(optional&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr optional(nullopt_t) noexcept {}

    template <class _InPlaceT, class... _Args, class = _EnableIf<
          _And<
              _IsSame<_InPlaceT, in_place_t>,
              is_constructible<value_type, _Args...>
            >::value
        >
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit optional(_InPlaceT, _Args&&... __args)
        : __base(in_place, std::__1::forward<_Args>(__args)...) {}

    template <class _Up, class... _Args, class = _EnableIf<
        is_constructible_v<value_type, initializer_list<_Up>&, _Args...>>
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
        : __base(in_place, __il, std::__1::forward<_Args>(__args)...) {}

    template <class _Up = value_type, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}

    template <class _Up, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}

    // LWG2756: conditionally explicit conversion from const optional<_Up>&
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }

    // LWG2756: conditionally explicit conversion from optional<_Up>&&
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional& operator=(nullopt_t) noexcept
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) optional& operator=(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) optional& operator=(optional&&) = default;

    // LWG2756
    template <class _Up = value_type,
              class = _EnableIf<
                      _And<
                          _IsNotSame<__uncvref_t<_Up>, optional>,
                          _Or<
                              _IsNotSame<__uncvref_t<_Up>, value_type>,
                              _Not<is_scalar<value_type>>
                          >,
                          is_constructible<value_type, _Up>,
                          is_assignable<value_type&, _Up>
                      >::value>
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional&
    operator=(_Up&& __v)
    {
        if (this->has_value())
            this->__get() = std::__1::forward<_Up>(__v);
        else
            this->__construct(std::__1::forward<_Up>(__v));
        return *this;
    }

    // LWG2756
    template <class _Up, _EnableIf<
        _CheckOptionalLikeAssign<_Up, _Up const&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional&
    operator=(const optional<_Up>& __v)
    {
        this->__assign_from(__v);
        return *this;
    }

    // LWG2756
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    optional&
    operator=(optional<_Up>&& __v)
    {
        this->__assign_from(std::__1::move(__v));
        return *this;
    }

    template <class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp &
    emplace(_Args&&... __args)
    {
        reset();
        this->__construct(std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    template <class _Up, class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, initializer_list<_Up>&, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp &
    emplace(initializer_list<_Up> __il, _Args&&... __args)
    {
        reset();
        this->__construct(__il, std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(optional& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type> &&
                 is_nothrow_swappable_v<value_type>)
    {
        if (this->has_value() == __opt.has_value())
        {
            using std::__1::swap;
            if (this->has_value())
                swap(this->__get(), __opt.__get());
        }
        else
        {
            if (this->has_value())
            {
                __opt.__construct(std::__1::move(this->__get()));
                reset();
            }
            else
            {
                this->__construct(std::__1::move(__opt.__get()));
                __opt.reset();
            }
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    add_pointer_t<value_type const>
    operator->() const
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    add_pointer_t<value_type>
    operator->()
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const value_type&
    operator*() const&
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    value_type&
    operator*() &
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    value_type&&
    operator*() &&
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    const value_type&&
    operator*() const&&
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr explicit operator bool() const noexcept { return has_value(); }

    using __base::has_value;
    using __base::__get;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    constexpr value_type const& value() const&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    constexpr value_type& value() &
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    constexpr value_type&& value() &&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    constexpr value_type const&& value() const&&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type value_or(_Up&& __v) const&
    {
        static_assert(is_copy_constructible_v<value_type>,
                      "optional<T>::value_or: T must be copy constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? this->__get() :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr value_type value_or(_Up&& __v) &&
    {
        static_assert(is_move_constructible_v<value_type>,
                      "optional<T>::value_or: T must be move constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? std::__1::move(this->__get()) :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    using __base::reset;

private:
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static _Up*
    __operator_arrow(true_type, _Up& __x)
    {
        return std::__1::addressof(__x);
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static constexpr _Up*
    __operator_arrow(false_type, _Up& __x)
    {
        return &__x;
    }
};


template<class T>
    optional(T) -> optional<T>;


// Comparisons between optionals
template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() ==
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x == *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() !=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x != *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x < *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return false;
    if (!static_cast<bool>(__y))
        return true;
    return *__x > *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return true;
    if (!static_cast<bool>(__y))
        return false;
    return *__x <= *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x >= *__y;
}

// Comparisons with nullopt
template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const optional<_Tp>&, nullopt_t) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(nullopt_t, const optional<_Tp>&) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(nullopt_t, const optional<_Tp>&) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const optional<_Tp>&, nullopt_t) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

// Comparisons with T
template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() ==
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x == __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() ==
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator==(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v == *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() !=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x != __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() !=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator!=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v != *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x < __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v < *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x <= __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() <=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator<=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v <= *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x > __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v > *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x >= __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_EnableIf<
    is_convertible_v<decltype(std::__1::declval<const _Tp&>() >=
        std::__1::declval<const _Up&>()), bool>,
    bool
>
operator>=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v >= *__x : true;
}


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_EnableIf<
    is_move_constructible_v<_Tp> && is_swappable_v<_Tp>,
    void
>
swap(optional<_Tp>& __x, optional<_Tp>& __y) noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
optional<decay_t<_Tp>> make_optional(_Tp&& __v)
{
    return optional<decay_t<_Tp>>(std::__1::forward<_Tp>(__v));
}

template <class _Tp, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
optional<_Tp> make_optional(_Args&&... __args)
{
    return optional<_Tp>(in_place, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Up, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
optional<_Tp> make_optional(initializer_list<_Up> __il, _Args&&... __args)
{
    return optional<_Tp>(in_place, __il, std::__1::forward<_Args>(__args)...);
}

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<
    __enable_hash_helper<optional<_Tp>, remove_const_t<_Tp>>
>
{
    typedef optional<_Tp> argument_type;
    typedef size_t result_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result_type operator()(const argument_type& __opt) const
    {
        return static_cast<bool>(__opt) ? hash<remove_const_t<_Tp>>()(*__opt) : 0;
    }
};

} }
# 16 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__node_handle" 2
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__node_handle" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 23 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__node_handle" 2 3

namespace std { inline namespace __1 {



// Specialized in __tree & __hash_table for their _NodeType.
template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;

template <class _NodeType, class _Alloc,
          template <class, class> class _MapOrSetSpecifics>
class __attribute__ ((__type_visibility__("default"))) __basic_node_handle
    : public _MapOrSetSpecifics<
          _NodeType,
          __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>
{
    template <class _Tp, class _Compare, class _Allocator>
        friend class __tree;
    template <class _Tp, class _Hash, class _Equal, class _Allocator>
        friend class __hash_table;
    friend struct _MapOrSetSpecifics<
        _NodeType, __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>;

    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_pointer<typename __alloc_traits::void_pointer,
                                      _NodeType>::type
        __node_pointer_type;

public:
    typedef _Alloc allocator_type;

private:
    __node_pointer_type __ptr_ = nullptr;
    optional<allocator_type> __alloc_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __release_ptr()
    {
        __ptr_ = nullptr;
        __alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __destroy_node_pointer()
    {
        if (__ptr_ != nullptr)
        {
            typedef typename __allocator_traits_rebind<
                allocator_type, _NodeType>::type __node_alloc_type;
            __node_alloc_type __alloc(*__alloc_);
            __generic_container_node_destructor<_NodeType, __node_alloc_type>(
                __alloc, true)(__ptr_);
            __ptr_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __basic_node_handle(__node_pointer_type __ptr,
                        allocator_type const& __alloc)
            : __ptr_(__ptr), __alloc_(__alloc)
    {
    }

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __basic_node_handle() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __basic_node_handle(__basic_node_handle&& __other) noexcept
            : __ptr_(__other.__ptr_),
              __alloc_(std::__1::move(__other.__alloc_))
    {
        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __basic_node_handle& operator=(__basic_node_handle&& __other)
    {
        ((void)0);






        __destroy_node_pointer();
        __ptr_ = __other.__ptr_;

        if (__alloc_traits::propagate_on_container_move_assignment::value ||
            __alloc_ == std::__1::nullopt)
            __alloc_ = std::__1::move(__other.__alloc_);

        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;

        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const { return *__alloc_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const { return __ptr_ != nullptr; }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const { return __ptr_ == nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(__basic_node_handle& __other) noexcept(
        __alloc_traits::propagate_on_container_swap::value ||
        __alloc_traits::is_always_equal::value)
    {
        using std::__1::swap;
        swap(__ptr_, __other.__ptr_);
        if (__alloc_traits::propagate_on_container_swap::value ||
            __alloc_ == std::__1::nullopt || __other.__alloc_ == std::__1::nullopt)
            swap(__alloc_, __other.__alloc_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    friend void swap(__basic_node_handle& __a, __basic_node_handle& __b)
        noexcept(noexcept(__a.swap(__b))) { __a.swap(__b); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__basic_node_handle()
    {
        __destroy_node_pointer();
    }
};

template <class _NodeType, class _Derived>
struct __set_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_type& value() const
    {
        return static_cast<_Derived const*>(this)->__ptr_->__value_;
    }
};

template <class _NodeType, class _Derived>
struct __map_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type::key_type key_type;
    typedef typename _NodeType::__node_value_type::mapped_type mapped_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_type& key() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    mapped_type& mapped() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().second;
    }
};

template <class _NodeType, class _Alloc>
using __set_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __set_node_handle_specifics>;

template <class _NodeType, class _Alloc>
using __map_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __map_node_handle_specifics>;

template <class _Iterator, class _NodeType>
struct __attribute__ ((__type_visibility__("default"))) __insert_return_type
{
    _Iterator position;
    bool inserted;
    _NodeType node;
};



} }
# 437 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 2
# 446 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3


namespace std { inline namespace __1 {

template <class _Key, class _Cp, class _Hash, class _Pred,
          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
class __unordered_map_hasher
    : private _Hash
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : _Hash() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : _Hash(__h) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Hash& hash_function() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const _Cp& __x) const
        {return static_cast<const _Hash&>(*this)(__x.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const _Key& __x) const
        {return static_cast<const _Hash&>(*this)(__x);}






    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));
    }
};

template <class _Key, class _Cp, class _Hash, class _Pred>
class __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, false>
{
    _Hash __hash_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_hasher()
        noexcept(is_nothrow_default_constructible<_Hash>::value)
        : __hash_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_hasher(const _Hash& __h)
        noexcept(is_nothrow_copy_constructible<_Hash>::value)
        : __hash_(__h) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Hash& hash_function() const noexcept {return __hash_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const _Cp& __x) const
        {return __hash_(__x.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const _Key& __x) const
        {return __hash_(__x);}






    void swap(__unordered_map_hasher&__y)
        noexcept(__is_nothrow_swappable<_Hash>::value)
    {
        using std::__1::swap;
        swap(__hash_, __y.__hash_);
    }
};

template <class _Key, class _Cp, class _Hash, class _Pred, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __x,
     __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Key, class _Cp, class _Pred, class _Hash,
          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>
class __unordered_map_equal
    : private _Pred
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : _Pred() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : _Pred(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Pred& key_eq() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);}
# 574 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));
    }
};

template <class _Key, class _Cp, class _Pred, class _Hash>
class __unordered_map_equal<_Key, _Cp, _Pred, _Hash, false>
{
    _Pred __pred_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_equal()
        noexcept(is_nothrow_default_constructible<_Pred>::value)
        : __pred_() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __unordered_map_equal(const _Pred& __p)
        noexcept(is_nothrow_copy_constructible<_Pred>::value)
        : __pred_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Pred& key_eq() const noexcept {return __pred_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return __pred_(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return __pred_(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return __pred_(__x, __y.__get_value().first);}
# 624 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    void swap(__unordered_map_equal&__y)
        noexcept(__is_nothrow_swappable<_Pred>::value)
    {
        using std::__1::swap;
        swap(__pred_, __y.__pred_);
    }
};

template <class _Key, class _Cp, class _Pred, class _Hash, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __x,
     __unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Alloc>
class __hash_map_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:

    typedef typename __alloc_traits::pointer pointer;
private:

    allocator_type& __na_;

    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __hash_map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)
        noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
# 689 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};


template <class _Key, class _Tp>
struct __hash_value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_type& __get_value()
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_type& __get_value() const
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__1::move(const_cast<key_type&>(__v.first)),
            std::__1::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_value_type& operator=(const __hash_value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_value_type& operator=(__hash_value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__1::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __hash_value_type(const __hash_value_type& __v) = delete;
    __hash_value_type(__hash_value_type&& __v) = delete;
    template <class ..._Args>
    explicit __hash_value_type(_Args&& ...__args) = delete;

    ~__hash_value_type() = delete;
};
# 810 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
template <class _HashIterator>
class __attribute__ ((__type_visibility__("default"))) __hash_map_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_iterator(_HashIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_iterator operator++(int)
    {
        __hash_map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator;
};

template <class _HashIterator>
class __attribute__ ((__type_visibility__("default"))) __hash_map_const_iterator
{
    _HashIterator __i_;

    typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _NodeTypes::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_const_iterator(_HashIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)
                 noexcept
                : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __hash_map_const_iterator operator++(int)
    {
        __hash_map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
class unordered_multimap;

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) unordered_map
{
public:
    // types
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef typename __identity<_Hash>::type hasher;
    typedef typename __identity<_Pred>::type key_equal;
    typedef typename __identity<_Alloc>::type allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_pointer __node_pointer;
    typedef typename __table::__node_const_pointer __node_const_pointer;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;

    static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
    static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;


    typedef __map_node_handle<__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());
    unordered_map(size_type __n, const hasher& __hf,
                  const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit unordered_map(const allocator_type& __a);
    unordered_map(const unordered_map& __u);
    unordered_map(const unordered_map& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map(unordered_map&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_map(unordered_map&& __u, const allocator_type& __a);
    unordered_map(initializer_list<value_type> __il);
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__il, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~unordered_map() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map& operator=(const unordered_map& __u)
    {

        __table_ = __u.__table_;
# 1061 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map& operator=(unordered_map&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_map& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    iterator insert(const_iterator __p, const value_type& __x) {





        ((void)__p);

        return insert(__x).first;
    }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> insert(value_type&& __x)
        {return __table_.__insert_unique(std::__1::move(__x));}

    iterator insert(const_iterator __p, value_type&& __x) {





        ((void)__p);

        return __table_.__insert_unique(std::__1::move(__x)).first;
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert(_Pp&& __x)
            {return __table_.__insert_unique(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert(const_iterator __p, _Pp&& __x)
        {





          ((void)__p);

            return insert(std::__1::forward<_Pp>(__x)).first;
        }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> emplace(_Args&&... __args) {
        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {





          ((void)__p);

        return __table_.__emplace_unique(std::__1::forward<_Args>(__args)...).first;
    }




    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)
    {
        return __table_.__emplace_unique_key_args(__k, piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)
    {
        return __table_.__emplace_unique_key_args(__k, piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)
    {





        ((void)__h);

        return try_emplace(__k, std::__1::forward<_Args>(__args)...).first;
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)
    {





        ((void)__h);

        return try_emplace(std::__1::move(__k), std::__1::forward<_Args>(__args)...).first;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)
    {
        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,
            __k, std::__1::forward<_Vp>(__v));
        if (!__res.second) {
            __res.first->second = std::__1::forward<_Vp>(__v);
        }
        return __res;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)
    {
        pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k,
            std::__1::move(__k), std::__1::forward<_Vp>(__v));
        if (!__res.second) {
            __res.first->second = std::__1::forward<_Vp>(__v);
        }
        return __res;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v)
     {
          // FIXME: Add debug mode checking for the iterator input
          return insert_or_assign(__k, std::__1::forward<_Vp>(__v)).first;
     }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)
     {
        // FIXME: Add debug mode checking for the iterator input
        return insert_or_assign(std::__1::move(__k), std::__1::forward<_Vp>(__v)).first;
     }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void clear() noexcept {__table_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_unique<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(const_iterator __it)
    {
        return __table_.template __node_handle_extract<node_type>(
            __it.__i_);
    }

    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_unique(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(unordered_map& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        { __table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 1367 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
# 1384 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}
# 1401 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


    mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_bucket_count() const noexcept {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1457 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
private:




};


template<class _InputIterator,
         class _Hash = hash<__iter_key_type<_InputIterator>>,
         class _Pred = equal_to<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Key, class _Tp, class _Hash = hash<remove_const_t<_Key>>,
         class _Pred = equal_to<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type = 0,
              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_map<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                   _Hash, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp,
                   hash<remove_const_t<_Key>>,
                   equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp,
                   hash<remove_const_t<_Key>>,
                   equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_map<remove_const_t<_Key>, _Tp, _Hash,
                   equal_to<remove_const_t<_Key>>, _Allocator>;


template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0) {
            __table_.__emplace_unique(
                __u.__table_.remove((__i++).__i_)->__value_.__move());
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        piecewise_construct, std::__1::forward_as_tuple(__k),
                             std::__1::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)
{
    return __table_.__emplace_unique_key_args(__k,
        piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__k)),
                             std::__1::forward_as_tuple()).first->__get_value().second;
}
# 1783 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        __throw_out_of_range("unordered_map::at: key not found");
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const
{
    const_iterator __i = find(__k);
    if (__i == end())
        __throw_out_of_range("unordered_map::at: key not found");
    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1824 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(__i->first);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) unordered_multimap
{
public:
    // types
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef typename __identity<_Hash>::type hasher;
    typedef typename __identity<_Pred>::type key_equal;
    typedef typename __identity<_Alloc>::type allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::_NodeTypes _NodeTypes;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;
    static_assert((is_same<typename __node_traits::size_type,
                          typename __alloc_traits::size_type>::value),
                 "Allocator uses different size_type for different types");
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __table::size_type size_type;
    typedef typename __table::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;


    typedef __map_node_handle<__node, allocator_type> node_type;


    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_map;
    template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) unordered_multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap()
        noexcept(is_nothrow_default_constructible<__table>::value)
        {



        }
    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multimap(size_type __n, const hasher& __hf,
                                const key_equal& __eql,
                                const allocator_type& __a);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit unordered_multimap(const allocator_type& __a);
    unordered_multimap(const unordered_multimap& __u);
    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap(unordered_multimap&& __u)
        noexcept(is_nothrow_move_constructible<__table>::value);
    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
    unordered_multimap(initializer_list<value_type> __il);
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~unordered_multimap() {
        static_assert(sizeof(__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap& operator=(const unordered_multimap& __u)
    {

        __table_ = __u.__table_;
# 1996 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap& operator=(unordered_multimap&& __u)
        noexcept(is_nothrow_move_assignable<__table>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unordered_multimap& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept
        {return allocator_type(__table_.__node_alloc());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __table_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator begin() noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator end() noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept {return __table_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept {return __table_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p.__i_, __x);}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void insert(_InputIterator __first, _InputIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(value_type&& __x) {return __table_.__insert_multi(std::__1::move(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, value_type&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::move(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(_Pp&& __x)
        {return __table_.__insert_multi(std::__1::forward<_Pp>(__x));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, _Pp&& __x)
        {return __table_.__insert_multi(__p.__i_, std::__1::forward<_Pp>(__x));}

    template <class... _Args>
    iterator emplace(_Args&&... __args) {
        return __table_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class... _Args>
    iterator emplace_hint(const_iterator __p, _Args&&... __args) {
        return __table_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept {__table_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __table_.template __node_handle_insert_multi<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(key_type const& __key)
    {
        return __table_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(const_iterator __it)
    {
        return __table_.template __node_handle_extract<node_type>(
            __it.__i_);
    }

    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }
    template <class _H2, class _P2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source)
    {
        ((void)0);

        return __table_.__node_handle_merge_multi(__source.__table_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(unordered_multimap& __u)
        noexcept(__is_nothrow_swappable<__table>::value)
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
# 2177 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
# 2194 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}
# 2211 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket_count() const noexcept {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_bucket_count() const noexcept
        {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float load_factor() const noexcept {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    float max_load_factor() const noexcept {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 2261 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
};


template<class _InputIterator,
         class _Hash = hash<__iter_key_type<_InputIterator>>,
         class _Pred = equal_to<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
                   _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Hash, _Pred, _Allocator>;

template<class _Key, class _Tp, class _Hash = hash<remove_const_t<_Key>>,
         class _Pred = equal_to<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<!__is_allocator<_Pred>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type = 0,
                   _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
  -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        hash<__iter_key_type<_InputIterator>>, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _InputIterator, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
                        _Hash, equal_to<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp,
                        hash<remove_const_t<_Key>>,
                        equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp,
                        hash<remove_const_t<_Key>>,
                        equal_to<remove_const_t<_Key>>, _Allocator>;

template<class _Key, class _Tp, class _Hash, class _Allocator,
         class = _EnableIf<!__is_allocator<_Hash>::value>,
         class = _EnableIf<!is_integral<_Hash>::value>,
         class = _EnableIf<__is_allocator<_Allocator>::value>>
unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
  -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash,
                        equal_to<remove_const_t<_Key>>, _Allocator>;


template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a))
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a))
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u)
    noexcept(is_nothrow_move_constructible<__table>::value)
    : __table_(std::__1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u, const allocator_type& __a)
    : __table_(std::__1::move(__u.__table_), typename __table::allocator_type(__a))
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __table_.__insert_multi(
                __u.__table_.remove((__i++).__i_)->__value_.__move());
        }
    }




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a))
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
    noexcept(is_nothrow_move_assignable<__table>::value)
{
    __table_ = std::__1::move(__u.__table_);
    return *this;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline
void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2557 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(__i->first);
        _EqRng __yeq = __y.equal_range(__i->first);
        if (std::__1::distance(__xeq.first, __xeq.second) !=
            std::__1::distance(__yeq.first, __yeq.second) ||
                  !std::__1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 11 "SEAL/native/src/seal/c/utilities.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 1
// -*- C++ -*-
//===------------------------------ vector --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    vector synopsis

namespace std
{

template <class T, class Allocator = allocator<T> >
class vector
{
public:
    typedef T                                        value_type;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    vector()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    explicit vector(const allocator_type&);
    explicit vector(size_type n);
    explicit vector(size_type n, const allocator_type&); // C++14
    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());
    template <class InputIterator>
        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());
    vector(const vector& x);
    vector(vector&& x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    vector(initializer_list<value_type> il);
    vector(initializer_list<value_type> il, const allocator_type& a);
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value); // C++17
    vector& operator=(initializer_list<value_type> il);
    template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type> il);

    allocator_type get_allocator() const noexcept;

    iterator               begin() noexcept;
    const_iterator         begin()   const noexcept;
    iterator               end() noexcept;
    const_iterator         end()     const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend()    const noexcept;

    const_iterator         cbegin()  const noexcept;
    const_iterator         cend()    const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend()   const noexcept;

    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    bool empty() const noexcept;
    void reserve(size_type n);
    void shrink_to_fit() noexcept;

    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    value_type*       data() noexcept;
    const value_type* data() const noexcept;

    void push_back(const value_type& x);
    void push_back(value_type&& x);
    template <class... Args>
        reference emplace_back(Args&&... args); // reference in C++17
    void pop_back();

    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
        iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<value_type> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);

    void clear() noexcept;

    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);

    void swap(vector&)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17

    bool __invariants() const;
};

template <class Allocator = allocator<T> >
class vector<bool, Allocator>
{
public:
    typedef bool                                     value_type;
    typedef Allocator                                allocator_type;
    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef iterator                                 pointer;
    typedef const_iterator                           const_pointer;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    class reference
    {
    public:
        reference(const reference&) noexcept;
        operator bool() const noexcept;
        reference& operator=(const bool x) noexcept;
        reference& operator=(const reference& x) noexcept;
        iterator operator&() const noexcept;
        void flip() noexcept;
    };

    class const_reference
    {
    public:
        const_reference(const reference&) noexcept;
        operator bool() const noexcept;
        const_iterator operator&() const noexcept;
    };

    vector()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    explicit vector(const allocator_type&);
    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14
    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());
    template <class InputIterator>
        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());
    vector(const vector& x);
    vector(vector&& x)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    vector(initializer_list<value_type> il);
    vector(initializer_list<value_type> il, const allocator_type& a);
    ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x)
        noexcept(
             allocator_type::propagate_on_container_move_assignment::value ||
             allocator_type::is_always_equal::value); // C++17
    vector& operator=(initializer_list<value_type> il);
    template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type> il);

    allocator_type get_allocator() const noexcept;

    iterator               begin() noexcept;
    const_iterator         begin()   const noexcept;
    iterator               end() noexcept;
    const_iterator         end()     const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend()    const noexcept;

    const_iterator         cbegin()  const noexcept;
    const_iterator         cend()    const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend()   const noexcept;

    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    bool empty() const noexcept;
    void reserve(size_type n);
    void shrink_to_fit() noexcept;

    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    void push_back(const value_type& x);
    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17
    void pop_back();

    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
        iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<value_type> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);

    void clear() noexcept;

    void resize(size_type sz);
    void resize(size_type sz, value_type x);

    void swap(vector&)
        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||
                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17
    void flip() noexcept;

    bool __invariants() const;
};

template <class InputIterator, class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
   vector(InputIterator, InputIterator, Allocator = Allocator())
   -> vector<typename iterator_traits<InputIterator>::value_type, Allocator>;

template <class Allocator> struct hash<std::vector<bool, Allocator>>;

template <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
template <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

template <class T, class Allocator>
void swap(vector<T,Allocator>& x, vector<T,Allocator>& y)
    noexcept(noexcept(x.swap(y)));

template <class T, class Allocator, class U>
typename vector<T, Allocator>::size_type
erase(vector<T, Allocator>& c, const U& value);       // C++20
template <class T, class Allocator, class Predicate>
typename vector<T, Allocator>::size_type
erase_if(vector<T, Allocator>& c, Predicate pred);    // C++20

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 275 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bit_reference" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bit_reference" 2
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bit_reference" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 23 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bit_reference" 2 3


namespace std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_reference(const __bit_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_const_reference(const __bit_const_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};

// find

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(*__first.__seg_)));
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

// count

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(*__first.__seg_);
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(~*__first.__seg_);
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

// fill_n

template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    // do last partial word
    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;
    // do first partial word
    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }
    // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    // do last partial word
    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            std::__1::__fill_n_true(__first, __n);
        else
            std::__1::__fill_n_false(__first, __n);
    }
}

// fill

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}

// copy

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;
        // do last word
        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return std::__1::__copy_aligned(__first, __last, __result);
    return std::__1::__copy_unaligned(__first, __last, __result);
}

// copy_backward

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);
            // __last.__ctz_ = 0
         }
        // __last.__ctz_ == 0 || __n == 0
        // __result.__ctz_ == 0 || __n == 0
        // do middle words
        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {
                // __result.__ctz_ == 0
                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }
            // __last.__ctz_ = 0
         }
        // __last.__ctz_ == 0 || __n == 0
        // __result.__ctz_ != 0 || __n == 0
        // do middle words
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                // __result.__ctz_ == 0
                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return std::__1::__copy_backward_aligned(__first, __last, __result);
    return std::__1::__copy_backward_unaligned(__first, __last, __result);
}

// move

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}

// move_backward

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy_backward(__first, __last, __result);
}

// swap_ranges

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {
        // do first word
        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;
            // __first.__ctz_ = 0;
        }
        // __first.__ctz_ == 0;
        // do middle words
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__swap_ranges_aligned(__first1, __last1, __first2);
    return std::__1::__swap_ranges_unaligned(__first1, __last1, __first2);
}

// rotate

template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}

// equal

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {
        // do first word
        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;
            // __first1.__ctz_ = 0;
        }
        // __first1.__ctz_ == 0;
        // do middle words
        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }
        // do last word
        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {
        // do first word
        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;
            // __first1.__ctz_ = 0;
            // __first2.__ctz_ = 0;
        }
        // __first1.__ctz_ == 0;
        // __first2.__ctz_ == 0;
        // do middle words
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;
        // do last word
        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__equal_aligned(__first1, __last1, __first2);
    return std::__1::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator() noexcept

    : __seg_(nullptr), __ctz_(0)

    {}

    // avoid re-declaring a copy constructor for the non-const version.
    using __type_for_copy_to_const =
      _If<_IsConst, __bit_iterator<_Cp, false>, struct __private_nat>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_iterator(const __type_for_copy_to_const& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    // The non-const __bit_iterator has historically had a non-trivial
    // copy constructor (as a quirk of its construction). We need to maintain
    // this for ABI purposes.
    using __type_for_abi_non_trivial_copy_ctor =
      _If<!_IsConst, __bit_iterator, struct __private_nat>;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_iterator(__type_for_abi_non_trivial_copy_ctor const& __it) noexcept
      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

    // Always declare the copy assignment operator since the implicit declaration
    // is deprecated.
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_iterator& operator=(__bit_iterator const&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 277 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/climits" 1
// -*- C++ -*-
//===--------------------------- climits ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    climits synopsis

Macros:

    CHAR_BIT
    SCHAR_MIN
    SCHAR_MAX
    UCHAR_MAX
    CHAR_MIN
    CHAR_MAX
    MB_LEN_MAX
    SHRT_MIN
    SHRT_MAX
    USHRT_MAX
    INT_MIN
    INT_MAX
    UINT_MAX
    LONG_MIN
    LONG_MAX
    ULONG_MAX
    LLONG_MIN   // C99
    LLONG_MAX   // C99
    ULLONG_MAX  // C99

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 41 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/climits" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits.h" 1
// -*- C++ -*-
//===--------------------------- limits.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    limits.h synopsis

Macros:

    CHAR_BIT
    SCHAR_MIN
    SCHAR_MAX
    UCHAR_MAX
    CHAR_MIN
    CHAR_MAX
    MB_LEN_MAX
    SHRT_MIN
    SHRT_MAX
    USHRT_MAX
    INT_MIN
    INT_MAX
    UINT_MAX
    LONG_MIN
    LONG_MAX
    ULONG_MAX
    LLONG_MIN   // C99
    LLONG_MAX   // C99
    ULLONG_MAX  // C99

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 41 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits.h" 2
# 44 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits.h" 3





// GCC header limits.h recursively includes itself through another header called
// syslimits.h for some reason. This setup breaks down if we directly
// #include_next GCC's limits.h (reasons not entirely clear to me). Therefore,
// we manually re-create the necessary include sequence below:

// Get the system limits.h defines (force recurse into the next level)



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 1 3
// -*- C++ -*-
//===--------------------------- limits.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 58 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits.h" 2 3

// Get the ISO C defines


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits.h" 1 3
// -*- C++ -*-
//===--------------------------- limits.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 62 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/limits.h" 2 3
# 42 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/climits" 2
# 45 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/climits" 3
# 279 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 2







# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__split_buffer" 1
// -*- C++ -*-




# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 6 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__split_buffer" 2
# 11 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__split_buffer" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 15 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__split_buffer" 2 3


namespace std { inline namespace __1 {

template <bool>
class __split_buffer_common
{
protected:
    void __throw_length_error() const;
    void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __alloc_rr& __alloc() noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const __alloc_rr& __alloc() const noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pointer& __end_cap() noexcept {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const pointer& __end_cap() const noexcept {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __split_buffer()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __split_buffer(__alloc_rr& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();

    __split_buffer(__split_buffer&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
    __split_buffer& operator=(__split_buffer&& __c)
        noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator begin() noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator begin() const noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator end() noexcept {return __end_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator end() const noexcept {return __end_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept
        {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference front() {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference front() const {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() noexcept;
    void push_front(const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void push_back(const_reference __x);
    void push_front(value_type&& __x);
    void push_back(value_type&& __x);
    template <class... _Args>
        void emplace_back(_Args&&... __args);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIter>::value &&
           !__is_cpp17_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __destruct_at_end(pointer __new_last) noexcept
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;

    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);


    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        {}

    struct _ConstructTransaction {
      explicit _ConstructTransaction(pointer* __p, size_type __n) noexcept
      : __pos_(*__p), __end_(*__p + __n), __dest_(__p) {
      }
      ~_ConstructTransaction() {
        *__dest_ = __pos_;
      }
      pointer __pos_;
     const pointer __end_;
    private:
     pointer *__dest_;
    };
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_));
    }
}

//  Copy constructs __n objects starting at __end_ from __x
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == old size() + __n
//  Postcondition:  [i] == __x for all i in [size() - __n, __n)
template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_cpp17_input_iterator<_InputIter>::value &&
    !__is_cpp17_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__1::__to_address(__buf.__end_), std::__1::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__1::__to_address(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    _ConstructTransaction __tx(&this->__end_, std::__1::distance(__first, __last));
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, ++__first) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), *__first);
    }
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)),
      __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)),
      __end_cap_(std::__1::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        size_type __cap = __c.size();
        __first_ = __alloc_traits::allocate(__alloc(), __cap);
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __cap;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::__1::swap(__first_, __x.__first_);
    std::__1::swap(__begin_, __x.__begin_);
    std::__1::swap(__end_, __x.__end_);
    std::__1::swap(__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__1::swap(__first_, __t.__first_);
        std::__1::swap(__begin_, __t.__begin_);
        std::__1::swap(__end_, __t.__end_);
        std::__1::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1), __x);
    --__begin_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1),
            std::__1::move(__x));
    --__begin_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_), __x);
    ++__end_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
            std::__1::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
                              std::__1::forward<_Args>(__args)...);
    ++__end_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 287 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 2
# 293 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 297 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 2 3


namespace std { inline namespace __1 {

template <bool>
class __attribute__ ((__type_visibility__("default"))) __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __vector_base_common() {}
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("vector");
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("vector");
}

extern template class __attribute__ ((__visibility__("default"))) __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type& __alloc() noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const allocator_type& __alloc() const noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer& __end_cap() noexcept
        {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const pointer& __end_cap() const noexcept
        {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __vector_base(const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __vector_base(allocator_type&& __a) noexcept;

    ~__vector_base();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __destruct_at_end(pointer __new_last) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept
{
    pointer __soon_to_be_end = __end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__soon_to_be_end));
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__vector_base<_Tp, _Allocator>::__vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __a)
{
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__vector_base<_Tp, _Allocator>::__vector_base(allocator_type&& __a) noexcept
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, std::__1::move(__a)) {}


template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator /* = allocator<_Tp> */>
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {



        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit vector(const allocator_type& __a)



        noexcept

        : __base(__a)
    {



    }
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __x);
    vector(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~vector()
    {
        __annotate_delete();



    }

    vector(const vector& __x);
    vector(const vector& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector& operator=(const vector& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector(vector&& __x)

        noexcept;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector(vector&& __x, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator end() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type capacity() const noexcept
        {return __base::capacity();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    size_type max_size() const noexcept;
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator[](size_type __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference operator[](size_type __n) const noexcept;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference front() noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference front() const noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference back() noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference back() const noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_type* data() noexcept
        {return std::__1::__to_address(this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_type* data() const noexcept
        {return std::__1::__to_address(this->__begin_);}





    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __emplace_back(_Arg&& __arg) {
      emplace_back(std::__1::forward<_Arg>(__arg));
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void push_back(const_reference __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void push_back(value_type&& __x);

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

        reference emplace_back(_Args&&... __args);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);


    iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);


    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)

        noexcept;





    bool __invariants() const;
# 801 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __invalidate_iterators_past(pointer __new_last);
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __make_iter(pointer __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator __make_iter(const_pointer __p) const noexcept;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        __invalidate_iterators_past(__new_last);
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }


    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    inline void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    inline void __emplace_back_slow_path(_Args&&... __args);






    // The following functions are no-ops outside of AddressSanitizer mode.
    // We call annotatations only for the default Allocator because other allocators
    // may not meet the AddressSanitizer alignment constraints.
    // See the documentation for __sanitizer_annotate_contiguous_container for more details.
# 867 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __annotate_contiguous_container(const void*, const void*, const void*,
                                         const void*) const noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __annotate_new(size_type __current_size) const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __annotate_delete() const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __annotate_increase(size_type __n) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __annotate_shrink(size_type __old_size) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }

  struct _ConstructTransaction {
    explicit _ConstructTransaction(vector &__v, size_type __n)
      : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {



    }
    ~_ConstructTransaction() {
      __v_.__end_ = __pos_;





    }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class ..._Args>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  void __construct_one_at_end(_Args&& ...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_),
        std::__1::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }
};


template<class _InputIterator,
         class _Alloc = allocator<typename iterator_traits<_InputIterator>::value_type>,
         class = typename enable_if<__is_allocator<_Alloc>::value, void>::type
         >
vector(_InputIterator, _InputIterator)
  -> vector<typename iterator_traits<_InputIterator>::value_type, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = typename enable_if<__is_allocator<_Alloc>::value, void>::type
         >
vector(_InputIterator, _InputIterator, _Alloc)
  -> vector<typename iterator_traits<_InputIterator>::value_type, _Alloc>;


template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{

    __annotate_delete();
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, __p, __v.__begin_);
    std::__1::__construct_forward_with_exception_guarantees(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}

//  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __end_cap() == 0
//  Precondition:  __n > 0
//  Postcondition:  capacity() == __n
//  Postcondition:  size() == 0
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}

//  Precondition:  __new_size > capacity()
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max<size_type>(2*__cap, __new_size);
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos));
    }
}

//  Copy constructs __n objects starting at __end_ from __x
//  throws if construction throws
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == old size() + __n
//  Postcondition:  [i] == __x for all i in [size() - __n, __n)
template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    std::__1::__construct_range_forward(this->__alloc(), __first, __last, __tx.__pos_);
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Postcondition:  size() == size() + __n
//  Exception safety: strong.
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}

//  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Postcondition:  size() == size() + __n
//  Exception safety: strong.
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>::vector(vector&& __x)

        noexcept



    : __base(std::__1::move(__x.__alloc()))
{




    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __base::__move_assign_alloc(__c); // this can throw
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __new_size = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__new_size <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (__new_size > size())
        {
            __growing = true;
            __mid = __first;
            std::__1::advance(__mid, size());
        }
        pointer __m = std::__1::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last, __new_size - size());
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
    // __v.push_back(_VSTD::forward<_Up>(__x));
    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __construct_one_at_end(__x);
    }
    else
        __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::move(__x));
    }
    else
        __push_back_slow_path(std::__1::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);
    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline

typename vector<_Tp, _Allocator>::reference



vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::forward<_Args>(__args)...);
    }
    else
        __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);

    return this->back();

}



template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
    this->__invalidate_iterators_past(__p-1);
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
# 1736 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
        this->__invalidate_iterators_past(__p - 1);
    }
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    {
      pointer __i = __from_s + __n;
      _ConstructTransaction __tx(*this, __from_e - __i);
      for (pointer __pos = __tx.__pos_; __i < __from_e;
           ++__i, ++__pos, __tx.__pos_ = __pos) {
          __alloc_traits::construct(this->__alloc(),
                                    std::__1::__to_address(__pos),
                                    std::__1::move(*__i));
      }
    }
    std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(__x);
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::move(__x));
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::__1::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::forward<_Args>(__args)...);
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__tmp.get());
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::__1::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__1::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __construct_one_at_end(*__first);
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {

        try
        {

            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;

        }
        catch (...)
        {
            erase(__make_iter(__old_last), end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), std::__1::make_move_iterator(__v.begin()),
                             std::__1::make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__1::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::__1::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                std::__1::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)

    noexcept




{
    ((void)0);



    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__end_, __x.__end_);
    std::__1::swap(this->__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2119 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2147 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
  ((void)__new_last);

}

// vector<bool>

template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) explicit vector(const allocator_type& __a)



        noexcept;

    ~vector();
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);


    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector(vector&& __v)

        noexcept;



    vector(vector&& __v, const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value &&
           !__is_cpp17_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept
        {return __size_;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference front() {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);

    template <class... _Args>

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference emplace_back(_Args&&... __args)



    {
        push_back ( value_type ( std::__1::forward<_Args>(__args)... ));

        return this->back();

    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void pop_back() {--__size_;}


    template <class... _Args>
   __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator emplace(const_iterator position, _Args&&... __args)
        { return insert ( position, value_type ( std::__1::forward<_Args>(__args)... )); }


    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept {__size_ = 0;}

    void swap(vector&)

        noexcept;




    static void swap(reference __x, reference __y) noexcept { std::__1::swap(__x, __y); }

    void resize(size_type __sz, value_type __x = false);
    void flip() noexcept;

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __invalidate_all_iterators();
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    static size_type __align_it(size_type __new_size) noexcept
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reference __make_ref(size_type __pos) const noexcept
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                __vdeallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}

//  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __cap() == 0
//  Precondition:  __n > 0
//  Postcondition:  capacity() == __n
//  Postcondition:  size() == 0
template <class _Allocator>
void
vector<bool, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2; // end() >= begin(), always
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}

//  Precondition:  __new_size > capacity()
template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max(2*__cap, __align_it(__new_size));
}

//  Default constructs __n objects starting at __end_
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__1::distance(__first, __last);
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<bool, _Allocator>::vector(const allocator_type& __a)



        noexcept

    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}



template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                __vdeallocate();
                __vallocate(__v.__size_);
            }
            std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}



template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) vector<bool, _Allocator>::vector(vector&& __v)

    noexcept



    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::__1::move(__v.__cap_alloc_)) {
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__1::fill_n(begin(), __n, __x);
    }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::__1::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            __vdeallocate();
            __vallocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.__vallocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {

        try
        {

            vector(*this, allocator_type(__alloc())).swap(*this);

        }
        catch (...)
        {
        }

    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {

        try
        {

            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;

        }
        catch (...)
        {
            erase(__old_end, end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::__1::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__1::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__1::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)

    noexcept




{
    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__size_, __x.__size_);
    std::__1::swap(this->__cap(), __x.__cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__1::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__1::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() noexcept
{
    // do middle whole words
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;
    // do middle whole words
    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;
    // do last partial word
    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 3410 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/vector" 3
} }
# 12 "SEAL/native/src/seal/c/utilities.h" 2

// SEALNet


// SEAL

# 1 "SEAL/native/src/seal/encryptionparams.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/memorymanager.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/util/defines.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



// Debugging help
# 15 "SEAL/native/src/seal/util/defines.h"
// String expansion



// Join



// Check that double is 64 bits
static_assert(sizeof(double) == 8, "Require sizeof(double) == 8");

// Check that int is 32 bits
static_assert(sizeof(int) == 4, "Require sizeof(int) == 4");

// Check that unsigned long long is 64 bits
static_assert(sizeof(unsigned long long) == 8, "Require sizeof(unsigned long long) == 8");

// Bounds for bit-length of all coefficient moduli



// Bit-length of internally used coefficient moduli, e.g., auxiliary base in BFV


// Bounds for bit-length of user-defined coefficient moduli



// Bounds for bit-length of the plaintext modulus



// Bounds for number of coefficient moduli (no hard requirement)



// Bounds for polynomial modulus degree (no hard requirement)



// Upper bound on the size of a ciphertext (cannot exceed 2^32 / poly_modulus_degree)






// How many pairs of modular integers can we multiply and accumulate in a 128-bit data type
# 73 "SEAL/native/src/seal/util/defines.h"
// Detect system
# 87 "SEAL/native/src/seal/util/defines.h"
// Detect compiler
# 102 "SEAL/native/src/seal/util/defines.h"
// MSVC support

# 1 "SEAL/native/src/seal/util/msvc.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 104 "SEAL/native/src/seal/util/defines.h" 2

// clang support

# 1 "SEAL/native/src/seal/util/clang.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.





// We require clang >= 5




// Read in config.h
# 23 "SEAL/native/src/seal/util/clang.h"
// Are intrinsics enabled?
# 107 "SEAL/native/src/seal/util/defines.h" 2

// gcc support

# 1 "SEAL/native/src/seal/util/gcc.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 110 "SEAL/native/src/seal/util/defines.h" 2

// Create a true/false value for indicating debug mode






// Use std::byte as byte type







namespace seal
{
    enum class seal_byte : unsigned char
    {
    };
} // namespace seal


// Force inline




// Use `if constexpr' from C++17






// Use [[maybe_unused]] from C++17






// Use [[nodiscard]] from C++17






// C++14 does not have std::for_each_n so we use a custom implementation






// Allocate "size" bytes in memory and returns a seal_byte pointer
// If SEAL_USE_ALIGNED_ALLOC is defined, use _aligned_malloc and ::aligned_alloc (or std::malloc)
// Use `new seal_byte[size]` as fallback




// Deallocate a pointer in memory
// If SEAL_USE_ALIGNED_ALLOC is defined, use _aligned_free or std::free
// Use `delete [] ptr` as fallback




// Which random number generator to use by default


// Which distribution to use for noise sampling: rounded Gaussian or Centered Binomial Distribution






// Use generic functions as (slower) fallback
# 218 "SEAL/native/src/seal/util/defines.h"
// Check whether an object is of expected type; this requires the type_traits header to be included
# 228 "SEAL/native/src/seal/util/defines.h"
// This macro can be used to allocate a temporary buffer and create a PtrIter<T *> object pointing to it. This is
// convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through the
// iterator.




// This macro can be used to allocate a temporary buffer and create a StrideIter<T *> object pointing to it. This is
// convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through the
// iterator.




// This macro can be used to allocate a temporary buffer and create a PolyIter object pointing to it. This is convenient
// when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through the iterator.





// This macro can be used to allocate a temporary buffer (set to zero) and create a PolyIter object pointing to it. This
// is convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through
// the iterator.





// This macro can be used to allocate a temporary buffer and create a RNSIter object pointing to it. This is convenient
// when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through the iterator.





// This macro can be used to allocate a temporary buffer (set to zero) and create a RNSIter object pointing to it. This
// is convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through
// the iterator.





// This macro can be used to allocate a temporary buffer and create a CoeffIter object pointing to it. This is
// convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed through the
// iterator.




// This macro can be used to allocate a temporary buffer (set to zero) and create a CoeffIter object pointing to it.
// This is convenient when the Pointer holding the buffer is not explicitly needed and the memory is only accessed
// through the iterator.




// Conditionally select the former if true and the latter if false
// This is a temporary solution that generates constant-time code with all compilers on all platforms.
# 7 "SEAL/native/src/seal/memorymanager.h" 2
# 1 "SEAL/native/src/seal/util/globals.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/util/hestdparms.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.






namespace seal
{
    namespace util
    {
        /**
        Largest allowed bit counts for coeff_modulus based on the security estimates from
        HomomorphicEncryption.org security standard. Microsoft SEAL samples the secret key
        from a ternary {-1, 0, 1} distribution.
        */
        // Ternary secret; 128 bits classical security
                       constexpr int seal_he_std_parms_128_tc(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 27;
            case std::size_t(2048):
                return 54;
            case std::size_t(4096):
                return 109;
            case std::size_t(8192):
                return 218;
            case std::size_t(16384):
                return 438;
            case std::size_t(32768):
                return 881;
            }
            return 0;
        }

        // Ternary secret; 192 bits classical security
                       constexpr int seal_he_std_parms_192_tc(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 19;
            case std::size_t(2048):
                return 37;
            case std::size_t(4096):
                return 75;
            case std::size_t(8192):
                return 152;
            case std::size_t(16384):
                return 305;
            case std::size_t(32768):
                return 611;
            }
            return 0;
        }

        // Ternary secret; 256 bits classical security
                       constexpr int seal_he_std_parms_256_tc(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 14;
            case std::size_t(2048):
                return 29;
            case std::size_t(4096):
                return 58;
            case std::size_t(8192):
                return 118;
            case std::size_t(16384):
                return 237;
            case std::size_t(32768):
                return 476;
            }
            return 0;
        }

        // Ternary secret; 128 bits quantum security
                       constexpr int seal_he_std_parms_128_tq(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 25;
            case std::size_t(2048):
                return 51;
            case std::size_t(4096):
                return 101;
            case std::size_t(8192):
                return 202;
            case std::size_t(16384):
                return 411;
            case std::size_t(32768):
                return 827;
            }
            return 0;
        }

        // Ternary secret; 192 bits quantum security
                       constexpr int seal_he_std_parms_192_tq(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 17;
            case std::size_t(2048):
                return 35;
            case std::size_t(4096):
                return 70;
            case std::size_t(8192):
                return 141;
            case std::size_t(16384):
                return 284;
            case std::size_t(32768):
                return 571;
            }
            return 0;
        }

        // Ternary secret; 256 bits quantum security
                       constexpr int seal_he_std_parms_256_tq(std::size_t poly_modulus_degree) noexcept
        {
            switch (poly_modulus_degree)
            {
            case std::size_t(1024):
                return 13;
            case std::size_t(2048):
                return 27;
            case std::size_t(4096):
                return 54;
            case std::size_t(8192):
                return 109;
            case std::size_t(16384):
                return 220;
            case std::size_t(32768):
                return 443;
            }
            return 0;
        }

        // Standard deviation for error distribution
        constexpr double seal_he_std_parms_error_std_dev = 3.2;
    } // namespace util
} // namespace seal
# 7 "SEAL/native/src/seal/util/globals.h" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 1
// -*- C++ -*-
//===----------------------------- map ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*

    map synopsis

namespace std
{

template <class Key, class T, class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class map
{
public:
    // types:
    typedef Key                                      key_type;
    typedef T                                        mapped_type;
    typedef pair<const key_type, mapped_type>        value_type;
    typedef Compare                                  key_compare;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;

    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;
    typedef unspecified                              node_type;              // C++17
    typedef INSERT_RETURN_TYPE<iterator, node_type>  insert_return_type;     // C++17

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        value_compare(key_compare c);
    public:
        bool operator()(const value_type& x, const value_type& y) const;
    };

    // construct/copy/destroy:
    map()
        noexcept(
            is_nothrow_default_constructible<allocator_type>::value &&
            is_nothrow_default_constructible<key_compare>::value &&
            is_nothrow_copy_constructible<key_compare>::value);
    explicit map(const key_compare& comp);
    map(const key_compare& comp, const allocator_type& a);
    template <class InputIterator>
        map(InputIterator first, InputIterator last,
            const key_compare& comp = key_compare());
    template <class InputIterator>
        map(InputIterator first, InputIterator last,
            const key_compare& comp, const allocator_type& a);
    map(const map& m);
    map(map&& m)
        noexcept(
            is_nothrow_move_constructible<allocator_type>::value &&
            is_nothrow_move_constructible<key_compare>::value);
    explicit map(const allocator_type& a);
    map(const map& m, const allocator_type& a);
    map(map&& m, const allocator_type& a);
    map(initializer_list<value_type> il, const key_compare& comp = key_compare());
    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);
    template <class InputIterator>
        map(InputIterator first, InputIterator last, const allocator_type& a)
            : map(first, last, Compare(), a) {}  // C++14
    map(initializer_list<value_type> il, const allocator_type& a)
        : map(il, Compare(), a) {}  // C++14
   ~map();

    map& operator=(const map& m);
    map& operator=(map&& m)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<key_compare>::value);
    map& operator=(initializer_list<value_type> il);

    // iterators:
          iterator begin() noexcept;
    const_iterator begin() const noexcept;
          iterator end() noexcept;
    const_iterator end()   const noexcept;

          reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
          reverse_iterator rend() noexcept;
    const_reverse_iterator rend()   const noexcept;

    const_iterator         cbegin()  const noexcept;
    const_iterator         cend()    const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend()   const noexcept;

    // capacity:
    bool      empty()    const noexcept;
    size_type size()     const noexcept;
    size_type max_size() const noexcept;

    // element access:
    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);

          mapped_type& at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    // modifiers:
    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& v);
    pair<iterator, bool> insert(      value_type&& v);                                // C++17
    template <class P>
        pair<iterator, bool> insert(P&& p);
    iterator insert(const_iterator position, const value_type& v);
    iterator insert(const_iterator position,       value_type&& v);                   // C++17
    template <class P>
        iterator insert(const_iterator position, P&& p);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type> il);

    node_type extract(const_iterator position);                                       // C++17
    node_type extract(const key_type& x);                                             // C++17
    insert_return_type insert(node_type&& nh);                                        // C++17
    iterator insert(const_iterator hint, node_type&& nh);                             // C++17

    template <class... Args>
        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17
    template <class... Args>
        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17
    template <class... Args>
        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17
    template <class... Args>
        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17
    template <class M>
        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17
    template <class M>
        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17
    template <class M>
        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17
    template <class M>
        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17

    iterator  erase(const_iterator position);
    iterator  erase(iterator position); // C++14
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class C2>
      void merge(map<Key, T, C2, Allocator>& source);         // C++17
    template<class C2>
      void merge(map<Key, T, C2, Allocator>&& source);        // C++17
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>& source);    // C++17
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>&& source);   // C++17

    void swap(map& m)
        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&
            is_nothrow_swappable<key_compare>::value); // C++17

    // observers:
    allocator_type get_allocator() const noexcept;
    key_compare    key_comp()      const;
    value_compare  value_comp()    const;

    // map operations:
          iterator find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++14
    template<typename K>
        const_iterator find(const K& x) const;  // C++14
    template<typename K>
      size_type count(const K& x) const;        // C++14
    size_type      count(const key_type& k) const;
        bool contains(const key_type& x) const; // C++20
          iterator lower_bound(const key_type& k);
    const_iterator lower_bound(const key_type& k) const;
    template<typename K>
        iterator lower_bound(const K& x);              // C++14
    template<typename K>
        const_iterator lower_bound(const K& x) const;  // C++14

          iterator upper_bound(const key_type& k);
    const_iterator upper_bound(const key_type& k) const;
    template<typename K>
        iterator upper_bound(const K& x);              // C++14
    template<typename K>
        const_iterator upper_bound(const K& x) const;  // C++14

    pair<iterator,iterator>             equal_range(const key_type& k);
    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator,iterator>             equal_range(const K& x);        // C++14
    template<typename K>
        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14
};

template <class Key, class T, class Compare, class Allocator>
bool
operator==(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator< (const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator!=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator> (const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator>=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator<=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>
void
swap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Compare, class Allocator, class Predicate>
typename map<Key, T, Compare, Allocator>::size_type
erase_if(map<Key, T, Compare, Allocator>& c, Predicate pred);  // C++20


template <class Key, class T, class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class multimap
{
public:
    // types:
    typedef Key                                      key_type;
    typedef T                                        mapped_type;
    typedef pair<const key_type,mapped_type>         value_type;
    typedef Compare                                  key_compare;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;

    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;
    typedef unspecified                              node_type;              // C++17

    class value_compare
        : public binary_function<value_type,value_type,bool>
    {
        friend class multimap;
    protected:
        key_compare comp;
        value_compare(key_compare c);
    public:
        bool operator()(const value_type& x, const value_type& y) const;
    };

    // construct/copy/destroy:
    multimap()
        noexcept(
            is_nothrow_default_constructible<allocator_type>::value &&
            is_nothrow_default_constructible<key_compare>::value &&
            is_nothrow_copy_constructible<key_compare>::value);
    explicit multimap(const key_compare& comp);
    multimap(const key_compare& comp, const allocator_type& a);
    template <class InputIterator>
        multimap(InputIterator first, InputIterator last, const key_compare& comp);
    template <class InputIterator>
        multimap(InputIterator first, InputIterator last, const key_compare& comp,
                 const allocator_type& a);
    multimap(const multimap& m);
    multimap(multimap&& m)
        noexcept(
            is_nothrow_move_constructible<allocator_type>::value &&
            is_nothrow_move_constructible<key_compare>::value);
    explicit multimap(const allocator_type& a);
    multimap(const multimap& m, const allocator_type& a);
    multimap(multimap&& m, const allocator_type& a);
    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());
    multimap(initializer_list<value_type> il, const key_compare& comp,
             const allocator_type& a);
    template <class InputIterator>
        multimap(InputIterator first, InputIterator last, const allocator_type& a)
            : multimap(first, last, Compare(), a) {} // C++14
    multimap(initializer_list<value_type> il, const allocator_type& a)
        : multimap(il, Compare(), a) {} // C++14
    ~multimap();

    multimap& operator=(const multimap& m);
    multimap& operator=(multimap&& m)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<key_compare>::value);
    multimap& operator=(initializer_list<value_type> il);

    // iterators:
          iterator begin() noexcept;
    const_iterator begin() const noexcept;
          iterator end() noexcept;
    const_iterator end()   const noexcept;

          reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
          reverse_iterator rend() noexcept;
    const_reverse_iterator rend()   const noexcept;

    const_iterator         cbegin()  const noexcept;
    const_iterator         cend()    const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend()   const noexcept;

    // capacity:
    bool      empty()    const noexcept;
    size_type size()     const noexcept;
    size_type max_size() const noexcept;

    // modifiers:
    template <class... Args>
        iterator emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& v);
    iterator insert(      value_type&& v);                                            // C++17
    template <class P>
        iterator insert(P&& p);
    iterator insert(const_iterator position, const value_type& v);
    iterator insert(const_iterator position,       value_type&& v);                   // C++17
    template <class P>
        iterator insert(const_iterator position, P&& p);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type> il);

    node_type extract(const_iterator position);                                       // C++17
    node_type extract(const key_type& x);                                             // C++17
    iterator insert(node_type&& nh);                                                  // C++17
    iterator insert(const_iterator hint, node_type&& nh);                             // C++17

    iterator  erase(const_iterator position);
    iterator  erase(iterator position); // C++14
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>& source);    // C++17
    template<class C2>
      void merge(multimap<Key, T, C2, Allocator>&& source);   // C++17
    template<class C2>
      void merge(map<Key, T, C2, Allocator>& source);         // C++17
    template<class C2>
      void merge(map<Key, T, C2, Allocator>&& source);        // C++17

    void swap(multimap& m)
        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&
            is_nothrow_swappable<key_compare>::value); // C++17

    // observers:
    allocator_type get_allocator() const noexcept;
    key_compare    key_comp()      const;
    value_compare  value_comp()    const;

    // map operations:
          iterator find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++14
    template<typename K>
        const_iterator find(const K& x) const;  // C++14
    template<typename K>
      size_type count(const K& x) const;        // C++14
    size_type      count(const key_type& k) const;
        bool contains(const key_type& x) const; // C++20
          iterator lower_bound(const key_type& k);
    const_iterator lower_bound(const key_type& k) const;
    template<typename K>
        iterator lower_bound(const K& x);              // C++14
    template<typename K>
        const_iterator lower_bound(const K& x) const;  // C++14

          iterator upper_bound(const key_type& k);
    const_iterator upper_bound(const key_type& k) const;
    template<typename K>
        iterator upper_bound(const K& x);              // C++14
    template<typename K>
        const_iterator upper_bound(const K& x) const;  // C++14

    pair<iterator,iterator>             equal_range(const key_type& k);
    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator,iterator>             equal_range(const K& x);        // C++14
    template<typename K>
        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14
};

template <class Key, class T, class Compare, class Allocator>
bool
operator==(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator< (const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator!=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator> (const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator>=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator<=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>
void
swap(multimap<Key, T, Compare, Allocator>& x,
     multimap<Key, T, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));

template <class Key, class T, class Compare, class Allocator, class Predicate>
typename multimap<Key, T, Compare, Allocator>::size_type
erase_if(multimap<Key, T, Compare, Allocator>& c, Predicate pred);  // C++20

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 481 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tree" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tree" 2
# 21 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tree" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 25 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tree" 2 3


namespace std { inline namespace __1 {
# 36 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

/*

_NodePtr algorithms

The algorithms taking _NodePtr are red black tree algorithms.  Those
algorithms taking a parameter named __root should assume that __root
points to a proper red black tree (unless otherwise specified).

Each algorithm herein assumes that __root->__parent_ points to a non-null
structure which has a member __left_ which points back to __root.  No other
member is read or written to at __root->__parent_.

__root->__parent_ will be referred to below (in comments only) as end_node.
end_node->__left_ is an externably accessible lvalue for __root, and can be
changed by node insertion and removal (without explicit reference to end_node).

All nodes (with the exception of end_node), even the node referred to as
__root, have a non-null __parent_ field.

*/

// Returns:  true if __x is a left child of its parent, else false
// Precondition:  __x != nullptr.
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
__tree_is_left_child(_NodePtr __x) noexcept
{
    return __x == __x->__parent_->__left_;
}

// Determines if the subtree rooted at __x is a proper red black subtree.  If
//    __x is a proper subtree, returns the black height (null counts as 1).  If
//    __x is an improper subtree, returns 0.
template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == nullptr)
        return 1;
    // parent consistency checked by caller
    // check __x->__left_ consistency
    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
        return 0;
    // check __x->__right_ consistency
    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
        return 0;
    // check __x->__left_ != __x->__right_ unless both are nullptr
    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
        return 0;
    // If this is red, neither child can be red
    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = std::__1::__tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0; // invalid left subtree
    if (__h != std::__1::__tree_sub_invariant(__x->__right_))
        return 0; // invalid or different height right subtree
    return __h + __x->__is_black_; // return black height of this node
}

// Determines if the red black tree rooted at __root is a proper red black tree.
//    __root == nullptr is a proper tree.  Returns true is __root is a proper
//    red black tree, else returns false.
template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == nullptr)
        return true;
    // check __x->__parent_ consistency
    if (__root->__parent_ == nullptr)
        return false;
    if (!std::__1::__tree_is_left_child(__root))
        return false;
    // root must be black
    if (!__root->__is_black_)
        return false;
    // do normal node checks
    return std::__1::__tree_sub_invariant(__root) != 0;
}

// Returns:  pointer to the left-most node under __x.
// Precondition:  __x != nullptr.
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodePtr
__tree_min(_NodePtr __x) noexcept
{
    while (__x->__left_ != nullptr)
        __x = __x->__left_;
    return __x;
}

// Returns:  pointer to the right-most node under __x.
// Precondition:  __x != nullptr.
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodePtr
__tree_max(_NodePtr __x) noexcept
{
    while (__x->__right_ != nullptr)
        __x = __x->__right_;
    return __x;
}

// Returns:  pointer to the next in-order node after __x.
// Precondition:  __x != nullptr.
template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return std::__1::__tree_min(__x->__right_);
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return static_cast<_EndNodePtr>(std::__1::__tree_min(__x->__right_));
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return static_cast<_EndNodePtr>(__x->__parent_);
}

// Returns:  pointer to the previous in-order node before __x.
// Precondition:  __x != nullptr.
// Note: __x may be the end node.
template <class _NodePtr, class _EndNodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept
{
    if (__x->__left_ != nullptr)
        return std::__1::__tree_max(__x->__left_);
    _NodePtr __xx = static_cast<_NodePtr>(__x);
    while (std::__1::__tree_is_left_child(__xx))
        __xx = __xx->__parent_unsafe();
    return __xx->__parent_unsafe();
}

// Returns:  pointer to a node which has no children
// Precondition:  __x != nullptr.
template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) noexcept
{
    while (true)
    {
        if (__x->__left_ != nullptr)
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != nullptr)
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}

// Effects:  Makes __x->__right_ the subtree root with __x as its left child
//           while preserving in-order order.
// Precondition:  __x->__right_ != nullptr
template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != nullptr)
        __x->__right_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __x;
    __x->__set_parent(__y);
}

// Effects:  Makes __x->__left_ the subtree root with __x as its right child
//           while preserving in-order order.
// Precondition:  __x->__left_ != nullptr
template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != nullptr)
        __x->__left_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__right_ = __x;
    __x->__set_parent(__y);
}

// Effects:  Rebalances __root after attaching __x to a leaf.
// Precondition:  __root != nulptr && __x != nullptr.
//                __x has no children.
//                __x == __root or == a direct or indirect child of __root.
//                If __x were to be unlinked from __root (setting __root to
//                  nullptr if __root == __x), __tree_invariant(__root) == true.
// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_
//                may be different than the value passed in as __root.
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_unsafe()->__is_black_)
    {
        // __x->__parent_ != __root because __x->__parent_->__is_black == false
        if (std::__1::__tree_is_left_child(__x->__parent_unsafe()))
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_left_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_right_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_left_rotate(__x);
                break;
            }
        }
    }
}

// Precondition:  __root != nullptr && __z != nullptr.
//                __tree_invariant(__root) == true.
//                __z == __root or == a direct or indirect child of __root.
// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.
// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_
//                nor any of its children refer to __z.  end_node->__left_
//                may be different than the value passed in as __root.
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) noexcept
{
    // __z will be removed from the tree.  Client still needs to destruct/deallocate it
    // __y is either __z, or if __z has two children, __tree_next(__z).
    // __y will have at most one child.
    // __y will be the initial hole in the tree (make the hole at a leaf)
    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?
                    __z : std::__1::__tree_next(__z);
    // __x is __y's possibly null single child
    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;
    // __w is __x's possibly null uncle (will become __x's sibling)
    _NodePtr __w = nullptr;
    // link __x to __y's parent, and find __w
    if (__x != nullptr)
        __x->__parent_ = __y->__parent_;
    if (std::__1::__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_unsafe()->__right_;
        else
            __root = __x; // __w == nullptr
    }
    else
    {
        __y->__parent_unsafe()->__right_ = __x;
        // __y can't be root if it is a right child
        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;
    // If we didn't remove __z, do so now by splicing in __y for __z,
    //    but copy __z's color.  This does not impact __x or __w.
    if (__y != __z)
    {
        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr
        __y->__parent_ = __z->__parent_;
        if (std::__1::__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__set_parent(__y);
        __y->__right_ = __z->__right_;
        if (__y->__right_ != nullptr)
            __y->__right_->__set_parent(__y);
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }
    // There is no need to rebalance if we removed a red, or if we removed
    //     the last node.
    if (__removed_black && __root != nullptr)
    {
        // Rebalance:
        // __x has an implicit black color (transferred from the removed __y)
        //    associated with it, no matter what its color is.
        // If __x is __root (in which case it can't be null), it is supposed
        //    to be black anyway, and if it is doubly black, then the double
        //    can just be ignored.
        // If __x is red (in which case it can't be null), then it can absorb
        //    the implicit black just by setting its color to black.
        // Since __y was black and only had one child (which __x points to), __x
        //   is either red with no children, else null, otherwise __y would have
        //   different black heights under left and right pointers.
        // if (__x == __root || __x != nullptr && !__x->__is_black_)
        if (__x != nullptr)
            __x->__is_black_ = true;
        else
        {
            //  Else __x isn't root, and is "doubly black", even though it may
            //     be null.  __w can not be null here, else the parent would
            //     see a black height >= 2 on the __x side and a black height
            //     of 1 on the __w side (__w must be a non-null black or a red
            //     with a non-null black child).
            while (true)
            {
                if (!std::__1::__tree_is_left_child(__w)) // if x is left child
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());
                        // __x is still valid
                        // reset __root only if necessary
                        if (__root == __w->__left_)
                            __root = __w;
                        // reset sibling, and it still can't be null
                        __w = __w->__left_->__right_;
                    }
                    // __w->__is_black_ is now true, __w may have null children
                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();
                        // __x can no longer be null
                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }
                        // reset sibling, and it still can't be null
                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;
                        // continue;
                    }
                    else // __w has a red child
                    {
                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)
                        {
                            // __w left child is non-null and red
                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_right_rotate(__w);
                            // __w is known not to be root, so root hasn't changed
                            // reset sibling, and it still can't be null
                            __w = __w->__parent_unsafe();
                        }
                        // __w has a right red child, left child may be null
                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());
                        // __x is still valid
                        // reset __root only if necessary
                        if (__root == __w->__right_)
                            __root = __w;
                        // reset sibling, and it still can't be null
                        __w = __w->__right_->__left_;
                    }
                    // __w->__is_black_ is now true, __w may have null children
                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();
                        // __x can no longer be null
                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }
                        // reset sibling, and it still can't be null
                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;
                        // continue;
                    }
                    else // __w has a red child
                    {
                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)
                        {
                            // __w right child is non-null and red
                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_left_rotate(__w);
                            // __w is known not to be root, so root hasn't changed
                            // reset sibling, and it still can't be null
                            __w = __w->__parent_unsafe();
                        }
                        // __w has a left red child, right child may be null
                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
            }
        }
    }
}

// node traits


template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};

template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static key_type const&
  __get_key(__node_value_type const& __t) {
    return __t.__get_value().first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      key_type const&>::type
  __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type const&
  __get_value(__node_value_type const& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__get_value());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;



  typedef typename conditional<
      is_pointer<__end_node_pointer>::value,
        __end_node_pointer,
        __node_base_pointer>::type __parent_pointer;


private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;



  typedef typename conditional<
      is_pointer<__node_pointer>::value,
        typename __base::__end_node_pointer,
        __node_pointer>::type __iter_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};

// node

template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __set_parent(pointer __p) {
        __parent_ = static_cast<__parent_pointer>(__p);
    }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;

    __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};


template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;


public:
    bool __value_constructed;


    __tree_node_destructor(const __tree_node_destructor &) = default;
    __tree_node_destructor& operator=(const __tree_node_destructor&) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
        : __na_(__na),
          __value_constructed(__val)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;
template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc>
    : __tree_node_destructor<_Alloc>
{
    using __tree_node_destructor<_Alloc>::__tree_node_destructor;
};


template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __tree_iterator() noexcept

    : __ptr_(nullptr)

    {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __tree_const_iterator() noexcept

    : __ptr_(nullptr)

    {}

private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_const_iterator(__non_const_iterator __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_const_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_const_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __tree_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __tree_const_iterator(__end_node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

};

template<class _Tp, class _Compare>

    __attribute__((diagnose_if(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;

    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;

    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;

    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;

private:
    // check for sane allocator pointer rebinding semantics. Rebinding the
    // allocator for a new pointer type should be exactly the same as rebinding
    // the pointer using 'pointer_traits'.
    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __iter_pointer __end_node() noexcept
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __iter_pointer __end_node() const noexcept
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          __node_allocator& __node_alloc() noexcept {return __pair1_.second();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const __node_allocator& __node_alloc() const noexcept
        {return __pair1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          __iter_pointer& __begin_node() noexcept {return __begin_node_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const __iter_pointer& __begin_node() const noexcept {return __begin_node_;}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type __alloc() const noexcept
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          size_type& size() noexcept {return __pair3_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const size_type& size() const noexcept {return __pair3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          value_compare& value_comp() noexcept {return __pair3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_compare& value_comp() const noexcept
        {return __pair3_.second();}
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __node_pointer __root() const noexcept
        {return static_cast<__node_pointer>(__end_node()->__left_);}

    __node_base_pointer* __root_ptr() const noexcept {
        return std::__1::addressof(__end_node()->__left_);
    }

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value);


    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _ForwardIterator>
        void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
    __tree(__tree&& __t)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value);


    __tree(__tree&& __t, const allocator_type& __a);
    __tree& operator=(__tree&& __t)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);



    ~__tree();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator begin() noexcept {return iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept {return const_iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator end() noexcept {return iterator(__end_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept {return const_iterator(__end_node());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept
        {return std::__1::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type >::max());}

    void clear() noexcept;

    void swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value);


    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_unique_key_args(_Key const&, _Args&&... __args);
    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

    template <class... _Args>
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

    template <class... _Args>
    iterator __emplace_multi(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
        return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
        return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_unique_extract_key(__p, std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        iterator
    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
        return __emplace_hint_unique_key_args(__p, __f,
                                              std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s)).first;
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
        return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
      return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
      return __emplace_hint_unique_key_args(__p, __x, std::__1::forward<_Pp>(__x)).first;
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
      return __emplace_hint_unique_key_args(__p, __x.first, std::__1::forward<_Pp>(__x)).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::__1::move(__v)).first;
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __insert_unique(_Vp&& __v) {
        return __emplace_unique(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_unique(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(__container_value_type&& __v) {
        return __emplace_multi(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_multi(__p, std::__1::move(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(_Vp&& __v) {
        return __emplace_multi(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __insert_multi(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> __node_assign_unique(const __container_value_type& __v, __node_pointer __dest);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator
    __remove_node_pointer(__node_pointer) noexcept;


    template <class _NodeHandle, class _InsertReturnType>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_handle_merge_unique(_Tree& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_multi(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __node_handle_merge_multi(_Tree& __source);


    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _NodeHandle __node_handle_extract(key_type const&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _NodeHandle __node_handle_extract(const_iterator);


    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__parent_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node) noexcept;

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) noexcept;
private:
    __node_base_pointer&
        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf(const_iterator __hint,
                    __parent_pointer& __parent, const key_type& __v);
    // FIXME: Make this function const qualified. Unfortunately doing so
    // breaks existing code which uses non-const callable comparators.
    template <class _Key>
    __node_base_pointer&
        __find_equal(__parent_pointer& __parent, const _Key& __v);
    template <class _Key>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __node_base_pointer&
    __find_equal(__parent_pointer& __parent, const _Key& __v) const {
      return const_cast<__tree*>(this)->__find_equal(__parent, __v);
    }
    template <class _Key>
    __node_base_pointer&
        __find_equal(const_iterator __hint, __parent_pointer& __parent,
                     __node_base_pointer& __dummy,
                     const _Key& __v);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    void destroy(__node_pointer __nd) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {
        if (__node_alloc() != __t.__node_alloc())
            clear();
        __node_alloc() = __t.__node_alloc();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __copy_assign_alloc(const __tree&, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__tree& __t)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__node_alloc() = std::__1::move(__t.__node_alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __move_assign_alloc(__tree&, false_type) noexcept {}

    struct _DetachedTreeCache {
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      explicit _DetachedTreeCache(__tree *__t) noexcept : __t_(__t),
        __cache_root_(__detach_from_tree(__t)) {
          __advance();
        }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      __node_pointer __get() const noexcept {
        return __cache_elem_;
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      void __advance() noexcept {
        __cache_elem_ = __cache_root_;
        if (__cache_root_) {
          __cache_root_ = __detach_next(__cache_root_);
        }
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      ~_DetachedTreeCache() {
        __t_->destroy(__cache_elem_);
        if (__cache_root_) {
          while (__cache_root_->__parent_ != nullptr)
            __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
          __t_->destroy(__cache_root_);
        }
      }

       _DetachedTreeCache(_DetachedTreeCache const&) = delete;
       _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

    private:
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      static __node_pointer __detach_from_tree(__tree *__t) noexcept;
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
      static __node_pointer __detach_next(__node_pointer) noexcept;

      __tree *__t_;
      __node_pointer __cache_root_;
      __node_pointer __cache_elem_;
    };


    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value)


    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

// Precondition:  size() != 0
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree *__t) noexcept
{
    __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
    __t->__begin_node() = __t->__end_node();
    __t->__end_node()->__left_->__parent_ = nullptr;
    __t->__end_node()->__left_ = nullptr;
    __t->size() = 0;
    // __cache->__left_ == nullptr
    if (__cache->__right_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__right_);
    // __cache->__left_ == nullptr
    // __cache->__right_ == nullptr
    return __cache;
}

// Precondition:  __cache != nullptr
//    __cache->left_ == nullptr
//    __cache->right_ == nullptr
//    This is no longer a red-black tree
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) noexcept
{
    if (__cache->__parent_ == nullptr)
        return nullptr;
    if (std::__1::__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == nullptr)
            return __cache;
        return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__right_));
    }
    // __cache is right child
    __cache->__parent_unsafe()->__right_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == nullptr)
        return __cache;
    return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef iterator_traits<_ForwardIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "__assign_unique requires a forward iterator");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
          for (; __cache.__get() != nullptr && __first != __last; ++__first) {
              if (__node_assign_unique(*__first, __cache.__get()).second)
                  __cache.__advance();
            }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
        for (; __cache.__get() && __first != __last; ++__first) {
            __cache.__get()->__value_ = *__first;
            __node_insert_multi(__cache.__get());
            __cache.__advance();
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value)


    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)),
      __pair3_(std::__1::move(__t.__pair3_))
{
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp()))
{
    if (__a == __t.__alloc())
    {
        if (__t.size() == 0)
            __begin_node() = __end_node();
        else
        {
            __begin_node() = __t.__begin_node();
            __end_node()->__left_ = __t.__end_node()->__left_;
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            size() = __t.size();
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = nullptr;
            __t.size() = 0;
        }
    }
    else
    {
        __begin_node() = __end_node();
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)

{
    destroy(static_cast<__node_pointer>(__end_node()->__left_));
    __begin_node_ = __t.__begin_node_;
    __pair1_.first() = __t.__pair1_.first();
    __move_assign_alloc(__t);
    __pair3_ = std::__1::move(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)
{
    if (__node_alloc() == __t.__node_alloc())
        __move_assign(__t, true_type());
    else
    {
        value_comp() = std::__1::move(__t.value_comp());
        const_iterator __e = end();
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            while (__cache.__get() != nullptr && __t.size() != 0) {
              __cache.__get()->__value_ = std::__1::move(__t.remove(__t.begin())->__value_);
              __node_insert_multi(__cache.__get());
              __cache.__advance();
            }
        }
        while (__t.size() != 0)
            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)




{
    __move_assign(__t, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value)

{
    using std::__1::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    std::__1::__swap_allocator(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() noexcept
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = nullptr;
}

// Find lower_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,
                                                   const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}

// Find upper_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,
                                                    const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}

// Find leaf place to insert closest to __hint
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer& __parent,
                                               const key_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v)) // check before
    {
        // __v <= *__hint
        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {
            // *prev(__hint) <= __v <= *__hint
            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }
        // __v < *prev(__hint)
        return __find_leaf_high(__parent, __v);
    }
    // else __v > *__hint
    return __find_leaf_low(__parent, __v);
}

// Find place to insert if __v doesn't exist
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    __node_base_pointer* __nd_ptr = __root_ptr();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__left_);
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__right_);
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__nd);
                return *__nd_ptr;
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}

// Find place to insert if __v doesn't exist
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer& __parent,
                                                __node_base_pointer& __dummy,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint)) // check before
    {
        // __v < *__hint
        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {
            // *prev(__hint) < __v < *__hint
            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }
        // __v <= *prev(__hint)
        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v)) // check after
    {
        // *__hint < __v
        const_iterator __next = std::__1::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {
            // *__hint < __v < *_VSTD::next(__hint)
            if (__hint.__get_np()->__right_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }
        // *next(__hint) <= __v
        return __find_equal(__parent, __v);
    }
    // else __v == *__hint
    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer& __child,
    __node_base_pointer __new_node) noexcept
{
    __new_node->__left_ = nullptr;
    __new_node->__right_ = nullptr;
    __new_node->__parent_ = __parent;
    // __new_node->__is_black_ is initialized in __tree_balance_after_insert
    __child = __new_node;
    if (__begin_node()->__left_ != nullptr)
        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
    std::__1::__tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class ..._Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_tree_value_type<_Args...>::value,
                  "Cannot construct from __value_type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    return __h;
}


template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type& __v, __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__v));
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __nd->__value_ = __v;
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) noexcept
{
    iterator __r(__ptr);
    ++__r;
    if (__begin_node() == __ptr)
        __begin_node() = __r.__ptr_;
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__ptr));
    return __r;
}


template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle, class _InsertReturnType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_InsertReturnType
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return _InsertReturnType{end(), false, _NodeHandle()};

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent,
                                                __ptr->__value_);
    if (__child != nullptr)
        return _InsertReturnType{
            iterator(static_cast<__node_pointer>(__child)),
            false, std::__1::move(__nh)};

    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy,
                                                __ptr->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__ptr));
        __r = __ptr;
        __nh.__release_ptr();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key)
{
    iterator __it = find(__key);
    if (__it == end())
        return _NodeHandle();
    return __node_handle_extract<_NodeHandle>(__it);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    __remove_node_pointer(__np);
    return _NodeHandle(__np, __alloc());
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child =
            __find_equal(__parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        if (__child != nullptr)
            continue;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(
        __parent, _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__hint, __parent,
                                               _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child = __find_leaf_high(
            __parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}



template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    iterator __r = __remove_node_pointer(__np);
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(
        const_cast<__node_value_type&>(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return std::__1::distance(
                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept
{
    __node_pointer __np = __p.__get_np();
    if (__begin_node() == __p.__ptr_)
    {
        if (__np->__right_ != nullptr)
            __begin_node() = static_cast<__iter_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
    }
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 482 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 2
# 493 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3


namespace std { inline namespace __1 {

template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : _Compare() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _Compare(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Compare& key_comp() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      using std::__1::swap;
      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return static_cast<const _Compare&>(*this) (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return static_cast<const _Compare&>(*this) (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : comp() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : comp(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const _Compare& key_comp() const noexcept {return comp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
        using std::__1::swap;
        swap(comp, __y.comp);
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return comp (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return comp (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,
     __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;

private:
    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp>
struct __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_type& __get_value()
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const value_type& __get_value() const
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__1::move(const_cast<key_type&>(__v.first)),
            std::__1::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_type& operator=(const __value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_type& operator=(__value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__1::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __value_type() = delete;
    ~__value_type() = delete;
    __value_type(const __value_type& __v) = delete;
    __value_type(__value_type&& __v) = delete;
};
# 767 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator(__map_iterator<
        typename _TreeIterator::__non_const_iterator> __i) noexcept
        : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:
    // types:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef typename __identity<_Compare>::type key_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit map(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : map(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map& operator=(const map& __m)
        {

            __tree_ = __m.__tree_;
# 1025 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(map&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map& operator=(map&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(initializer_list<value_type> __il, const allocator_type& __a)
        : map(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit map(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~map() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool> emplace(_Args&& ...__args) {
        return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_unique(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert(_Pp&& __p)
            {return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator, bool>
    insert(value_type&& __v) {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, value_type&& __v)
    {return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, __k, std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, std::__1::move(__k), std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator insert_or_assign(const_iterator __h,
                                                        const key_type& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, __k, std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator insert_or_assign(const_iterator __h,
                                                        key_type&& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, std::__1::move(__k), std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(map& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;




};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Allocator)
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> map<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(__k),
        std::__1::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(std::__1::move(__k)),
        std::__1::forward_as_tuple()).first->__get_value().second;
}
# 1570 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __parent_pointer __parent;
    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1668 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:
    // types:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef typename __identity<_Compare>::type key_compare;
    typedef typename __identity<_Allocator>::type allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    class __attribute__ ((__type_visibility__("default"))) value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        value_compare(key_compare c) : comp(c) {}
    public:
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit multimap(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : multimap(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap& operator=(const multimap& __m)
        {

            __tree_ = __m.__tree_;
# 1796 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(multimap&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap& operator=(multimap&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(initializer_list<value_type> __il, const allocator_type& __a)
        : multimap(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit multimap(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~multimap() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
          reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type max_size() const noexcept {return __tree_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}



    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator emplace(_Args&& ...__args) {
        return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert(_Pp&& __p)
            {return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(
            __it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(multimap& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Allocator)
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> multimap<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
    }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2253 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/map" 3
} }
# 9 "SEAL/native/src/seal/util/globals.h" 2



namespace seal
{
    class Modulus;

    namespace util
    {
        class MemoryPool;

        namespace global_variables
        {
            extern std::shared_ptr<MemoryPool> const global_memory_pool;

/*
For .NET Framework wrapper support (C++/CLI) we need to
    (1) compile the MemoryManager class as thread-unsafe because C++
        mutexes cannot be brought through C++/CLI layer;
    (2) disable thread-safe memory pools.
*/

            extern thread_local std::shared_ptr<MemoryPool> const tls_memory_pool;

            /**
            Default value for the standard deviation of the noise (error) distribution.
            */
            constexpr double noise_standard_deviation = seal_he_std_parms_error_std_dev;

            constexpr double noise_distribution_width_multiplier = 6;

            constexpr double noise_max_deviation = noise_standard_deviation * noise_distribution_width_multiplier;

            /**
            This data structure is a key-value storage that maps degrees of the polynomial modulus
            to vectors of Modulus elements so that when used with the default value for the
            standard deviation of the noise distribution (noise_standard_deviation), the security
            level is at least 128 bits according to https://HomomorphicEncryption.org. This makes
            it easy for non-expert users to select secure parameters.
            */
            const std::map<std::size_t, std::vector<Modulus>> &GetDefaultCoeffModulus128();

            /**
            This data structure is a key-value storage that maps degrees of the polynomial modulus
            to vectors of Modulus elements so that when used with the default value for the
            standard deviation of the noise distribution (noise_standard_deviation), the security
            level is at least 192 bits according to https://HomomorphicEncryption.org. This makes
            it easy for non-expert users to select secure parameters.
            */
            const std::map<std::size_t, std::vector<Modulus>> &GetDefaultCoeffModulus192();

            /**
            This data structure is a key-value storage that maps degrees of the polynomial modulus
            to vectors of Modulus elements so that when used with the default value for the
            standard deviation of the noise distribution (noise_standard_deviation), the security
            level is at least 256 bits according to https://HomomorphicEncryption.org. This makes
            it easy for non-expert users to select secure parameters.
            */
            const std::map<std::size_t, std::vector<Modulus>> &GetDefaultCoeffModulus256();
        } // namespace global_variables
    } // namespace util
} // namespace seal
# 8 "SEAL/native/src/seal/memorymanager.h" 2
# 1 "SEAL/native/src/seal/util/mempool.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/util/common.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 17 "SEAL/native/src/seal/util/common.h"
namespace seal
{
    namespace util
    {
        template <typename... Ts>
        struct VoidType
        {
            using type = void;
        };

        template <typename... Ts>
        using seal_void_t = typename VoidType<Ts...>::type;

        template <typename ForwardIt, typename Size, typename Func>
        inline ForwardIt seal_for_each_n(ForwardIt first, Size size, Func &&func)
        {
            for (; size--; (void)++first)
            {
                func(*first);
            }
            return first;
        }

        template <typename Func, typename Tuple, std::size_t... Is>
        inline decltype(auto) seal_apply_impl(Func &&func, Tuple &&tp, std::index_sequence<Is...>)
        {
            return func(std::get<Is>(std::forward<Tuple>(tp))...);
        }

        template <typename Func, typename Tuple, std::size_t... Is>
        inline decltype(auto) seal_apply(Func &&func, Tuple &&tp)
        {
            using iseq_t = std::make_index_sequence<std::tuple_size<std::decay_t<Tuple>>::value>;
            return seal_apply_impl(std::forward<Func>(func), std::forward<Tuple>(tp), iseq_t{});
        }

        template <typename T, typename...>
        struct IsUInt64
            : std::conditional<
                  std::is_integral<T>::value && std::is_unsigned<T>::value && (sizeof(T) == sizeof(std::uint64_t)),
                  std::true_type, std::false_type>::type
        {};

        template <typename T, typename U, typename... Rest>
        struct IsUInt64<T, U, Rest...>
            : std::conditional<IsUInt64<T>::value && IsUInt64<U, Rest...>::value, std::true_type, std::false_type>::type
        {};

        template <typename T, typename... Rest>
        constexpr bool is_uint64_v = IsUInt64<T, Rest...>::value;

        template <typename T, typename...>
        struct IsUInt32
            : std::conditional<
                  std::is_integral<T>::value && std::is_unsigned<T>::value && (sizeof(T) == sizeof(std::uint32_t)),
                  std::true_type, std::false_type>::type
        {};

        template <typename T, typename U, typename... Rest>
        struct IsUInt32<T, U, Rest...>
            : std::conditional<IsUInt32<T>::value && IsUInt32<U, Rest...>::value, std::true_type, std::false_type>::type
        {};

        template <typename T, typename... Rest>
        constexpr bool is_uint32_v = IsUInt32<T, Rest...>::value;

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_lt(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) < static_cast<std::uint64_t>(in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_leq(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) <= static_cast<std::uint64_t>(in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_gt(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) > static_cast<std::uint64_t>(in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_geq(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) >= static_cast<std::uint64_t>(in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_eq(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) == static_cast<std::uint64_t>(in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_integral<T>::value>,
            typename = std::enable_if_t<std::is_integral<S>::value>>
                       inline constexpr bool unsigned_neq(T in1, S in2) noexcept
        {
            return static_cast<std::uint64_t>(in1) != static_cast<std::uint64_t>(in2);
        }

        template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
                       inline constexpr T mul_safe(T in1) noexcept
        {
            return in1;
        }

        template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
                       inline constexpr T mul_safe(T in1, T in2)
        {
            if(std::is_unsigned<T>::value)
            {
                if (in1 && (in2 > (std::numeric_limits<T>::max)() / in1))
                {
                    throw std::logic_error("unsigned overflow");
                }
            }
            else
            {
                // Positive inputs
                if ((in1 > 0) && (in2 > 0) && (in2 > (std::numeric_limits<T>::max)() / in1))
                {
                    throw std::logic_error("signed overflow");
                }




                // Negative inputs
                else if ((in1 < 0) && (in2 < 0) && ((-in2) > (std::numeric_limits<T>::max)() / (-in1)))
                {
                    throw std::logic_error("signed overflow");
                }
                // Negative in1; positive in2
                else if ((in1 < 0) && (in2 > 0) && (in2 > (std::numeric_limits<T>::max)() / (-in1)))
                {
                    throw std::logic_error("signed underflow");
                }



                // Positive in1; negative in2
                else if ((in1 > 0) && (in2 < 0) && (in2 < (std::numeric_limits<T>::min)() / in1))
                {
                    throw std::logic_error("signed underflow");
                }
            }
            return static_cast<T>(in1 * in2);
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_integral<T>::value>>
                       inline constexpr T mul_safe(T in1, T in2, Args &&... args)
        {
            return mul_safe(mul_safe(in1, in2), mul_safe(std::forward<Args>(args)...));
        }

        template <typename T, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr T add_safe(T in1) noexcept
        {
            return in1;
        }

        template <typename T, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr T add_safe(T in1, T in2)
        {
            if(std::is_unsigned<T>::value)
            {
                if (in2 > (std::numeric_limits<T>::max)() - in1)
                {
                    throw std::logic_error("unsigned overflow");
                }
            }
            else
            {
                if (in1 > 0 && (in2 > (std::numeric_limits<T>::max)() - in1))
                {
                    throw std::logic_error("signed overflow");
                }
                else if (in1 < 0 && (in2 < (std::numeric_limits<T>::min)() - in1))
                {
                    throw std::logic_error("signed underflow");
                }
            }
            return static_cast<T>(in1 + in2);
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr T add_safe(T in1, T in2, Args &&... args)
        {
            return add_safe(add_safe(in1, in2), add_safe(std::forward<Args>(args)...));
        }

        template <typename T, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline T sub_safe(T in1, T in2)
        {
            if(std::is_unsigned<T>::value)
            {
                if (in1 < in2)
                {
                    throw std::logic_error("unsigned underflow");
                }
            }
            else
            {
                if (in1 < 0 && (in2 > (std::numeric_limits<T>::max)() + in1))
                {
                    throw std::logic_error("signed underflow");
                }
                else if (in1 > 0 && (in2 < (std::numeric_limits<T>::min)() + in1))
                {
                    throw std::logic_error("signed overflow");
                }
            }
            return static_cast<T>(in1 - in2);
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_arithmetic<T>::value>,
            typename = std::enable_if_t<std::is_arithmetic<S>::value>>
                       inline constexpr bool fits_in(S value ) noexcept
        {
            bool result = false;

            if(std::is_same<T, S>::value)
            {
                // Same type
                result = true;
            }
            else if(sizeof(S) <= sizeof(T))
            {
                // Converting to bigger type
                if(std::is_integral<T>::value && std::is_integral<S>::value)
                {
                    // Converting to at least equally big integer type
                    if(
                        (std::is_unsigned<T>::value && std::is_unsigned<S>::value) ||
                        (!std::is_unsigned<T>::value && !std::is_unsigned<S>::value))
                    {
                        // Both either signed or unsigned
                        result = true;
                    }
                    else if(std::is_unsigned<T>::value && std::is_signed<S>::value)
                    {
                        // Converting from signed to at least equally big unsigned type
                        result = value >= 0;
                    }
                }
                else if(std::is_floating_point<T>::value && std::is_floating_point<S>::value)
                {
                    // Both floating-point
                    result = true;
                }

                // Still need to consider integer-float conversions and all
                // unsigned to signed conversions
            }

            if(std::is_integral<T>::value && std::is_integral<S>::value)
            {
                // Both integer types
                if (value >= 0)
                {
                    // Non-negative number; compare as std::uint64_t
                    // Cannot use unsigned_leq with C++14 for lack of `if constexpr'
                    result = static_cast<std::uint64_t>(value) <=
                             static_cast<std::uint64_t>((std::numeric_limits<T>::max)());
                }
                else
                {
                    // Negative number; compare as std::int64_t
                    result =
                        static_cast<std::int64_t>(value) >= static_cast<std::int64_t>((std::numeric_limits<T>::min)());
                }
            }
            else if(std::is_floating_point<T>::value)
            {
                // Converting to floating-point
                result = (static_cast<double>(value) <= static_cast<double>((std::numeric_limits<T>::max)())) &&
                         (static_cast<double>(value) >= -static_cast<double>((std::numeric_limits<T>::max)()));
            }
            else
            {
                // Converting from floating-point
                result = (static_cast<double>(value) <= static_cast<double>((std::numeric_limits<T>::max)())) &&
                         (static_cast<double>(value) >= static_cast<double>((std::numeric_limits<T>::min)()));
            }

            return result;
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr bool sum_fits_in(Args &&... args)
        {
            return fits_in<T>(add_safe(std::forward<Args>(args)...));
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr bool sum_fits_in(T in1, Args &&... args)
        {
            return fits_in<T>(add_safe(in1, std::forward<Args>(args)...));
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr bool product_fits_in(Args &&... args)
        {
            return fits_in<T>(mul_safe(std::forward<Args>(args)...));
        }

        template <typename T, typename... Args, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
                       inline constexpr bool product_fits_in(T in1, Args &&... args)
        {
            return fits_in<T>(mul_safe(in1, std::forward<Args>(args)...));
        }

        template <
            typename T, typename S, typename = std::enable_if_t<std::is_arithmetic<T>::value>,
            typename = std::enable_if_t<std::is_arithmetic<S>::value>>
                       inline T safe_cast(S value)
        {
            if(!std::is_same<T, S>::value)
            {
                if (!fits_in<T>(value))
                {
                    throw std::logic_error("cast failed");
                }
            }
            return static_cast<T>(value);
        }

        constexpr int bytes_per_uint64 = sizeof(std::uint64_t);

        constexpr int bits_per_nibble = 4;

        constexpr int bits_per_byte = 8;

        constexpr int bits_per_uint64 = bytes_per_uint64 * bits_per_byte;

        constexpr int nibbles_per_byte = 2;

        constexpr int nibbles_per_uint64 = bytes_per_uint64 * nibbles_per_byte;

                       inline constexpr int hamming_weight(unsigned char value)
        {
            int t = static_cast<int>(value);
            t -= (t >> 1) & 0x55;
            t = (t & 0x33) + ((t >> 2) & 0x33);
            return (t + (t >> 4)) & 0x0F;
        }

        template <typename T, typename = std::enable_if_t<is_uint32_v<T> || is_uint64_v<T>>>
                       inline constexpr T reverse_bits(T operand) noexcept
        {
            if(is_uint32_v<T>)
            {
                operand = (((operand & T(0xaaaaaaaa)) >> 1) | ((operand & T(0x55555555)) << 1));
                operand = (((operand & T(0xcccccccc)) >> 2) | ((operand & T(0x33333333)) << 2));
                operand = (((operand & T(0xf0f0f0f0)) >> 4) | ((operand & T(0x0f0f0f0f)) << 4));
                operand = (((operand & T(0xff00ff00)) >> 8) | ((operand & T(0x00ff00ff)) << 8));
                return static_cast<T>(operand >> 16) | static_cast<T>(operand << 16);
            }
            else if(is_uint64_v<T>)
            {
// Temporarily disable UB warnings when `if constexpr` is not available.








#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshift-count-overflow"


 return static_cast<T>(reverse_bits(static_cast<std::uint32_t>(operand >> 32))) |
                       (static_cast<T>(reverse_bits(static_cast<std::uint32_t>(operand & T(0xFFFFFFFF)))) << 32);






#pragma clang diagnostic pop


 }
        }

        template <typename T, typename = std::enable_if_t<is_uint32_v<T> || is_uint64_v<T>>>
                       inline T reverse_bits(T operand, int bit_count)
        {







            // Just return zero if bit_count is zero
            return (bit_count == 0) ? T(0)
                                    : reverse_bits(operand) >> (sizeof(T) * static_cast<std::size_t>(bits_per_byte) -
                                                                static_cast<std::size_t>(bit_count));
        }

        inline void get_msb_index_generic(unsigned long *result, std::uint64_t value)
        {






            static const unsigned long deBruijnTable64[64] = { 63, 0, 58, 1, 59, 47, 53, 2, 60, 39, 48, 27, 54,
                                                               33, 42, 3, 61, 51, 37, 40, 49, 18, 28, 20, 55, 30,
                                                               34, 11, 43, 14, 22, 4, 62, 57, 46, 52, 38, 26, 32,
                                                               41, 50, 36, 17, 19, 29, 10, 13, 21, 56, 45, 25, 31,
                                                               35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5 };

            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value |= value >> 32;

            *result = deBruijnTable64[((value - (value >> 1)) * std::uint64_t(0x07EDD5E59A4E28C2)) >> 58];
        }

                       inline int get_significant_bit_count(std::uint64_t value)
        {
            if (value == 0)
            {
                return 0;
            }

            unsigned long result = 0;
            get_msb_index_generic(&result, value);
            return static_cast<int>(result + 1);
        }

                       inline bool is_hex_char(char hex)
        {
            if (hex >= '0' && hex <= '9')
            {
                return true;
            }
            if (hex >= 'A' && hex <= 'F')
            {
                return true;
            }
            if (hex >= 'a' && hex <= 'f')
            {
                return true;
            }
            return false;
        }

                       inline char nibble_to_upper_hex(int nibble)
        {






            if (nibble < 10)
            {
                return static_cast<char>(nibble + static_cast<int>('0'));
            }
            return static_cast<char>(nibble + static_cast<int>('A') - 10);
        }

                       inline int hex_to_nibble(char hex)
        {
            if (hex >= '0' && hex <= '9')
            {
                return static_cast<int>(hex) - static_cast<int>('0');
            }
            if (hex >= 'A' && hex <= 'F')
            {
                return static_cast<int>(hex) - static_cast<int>('A') + 10;
            }
            if (hex >= 'a' && hex <= 'f')
            {
                return static_cast<int>(hex) - static_cast<int>('a') + 10;
            }



            return -1;
        }

                       inline int get_hex_string_bit_count(const char *hex_string, int char_count)
        {
# 535 "SEAL/native/src/seal/util/common.h"
            for (int i = 0; i < char_count; i++)
            {
                char hex = *hex_string++;
                int nibble = hex_to_nibble(hex);
                if (nibble != 0)
                {
                    int nibble_bits = get_significant_bit_count(static_cast<std::uint64_t>(nibble));
                    int remaining_nibbles = (char_count - i - 1) * bits_per_nibble;
                    return nibble_bits + remaining_nibbles;
                }
            }
            return 0;
        }

        template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
                       inline T divide_round_up(T value, T divisor)
        {
# 562 "SEAL/native/src/seal/util/common.h"
            return (add_safe(value, divisor - 1)) / divisor;
        }

        template <typename T>
        constexpr double epsilon = std::numeric_limits<T>::epsilon();

        template <typename T, typename = std::enable_if_t<std::is_floating_point<T>::value>>
                       inline bool are_close(T value1, T value2) noexcept
        {
            double scale_factor = std::max<T>({ std::fabs(value1), std::fabs(value2), T{ 1.0 } });
            return std::fabs(value1 - value2) < epsilon<T> * scale_factor;
        }

        template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
                       inline constexpr bool is_zero(T value) noexcept
        {
            return value == T{ 0 };
        }

        void seal_memzero(void *data, std::size_t size);
    } // namespace util
} // namespace seal
# 7 "SEAL/native/src/seal/util/mempool.h" 2


# 1 "SEAL/native/src/seal/util/locks.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 55 "SEAL/native/src/seal/util/locks.h"
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 1
// -*- C++ -*-
//===--------------------------- atomic -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    atomic synopsis

namespace std
{

// feature test macro [version.syn]

#define __cpp_lib_atomic_is_always_lock_free
#define __cpp_lib_atomic_flag_test
#define __cpp_lib_atomic_lock_free_type_aliases
#define __cpp_lib_atomic_wait

 // order and consistency

 enum memory_order: unspecified // enum class in C++20
 {
    relaxed,
    consume, // load-consume
    acquire, // load-acquire
    release, // store-release
    acq_rel, // store-release load-acquire
    seq_cst // store-release load-acquire
 };

 inline constexpr auto memory_order_relaxed = memory_order::relaxed;
 inline constexpr auto memory_order_consume = memory_order::consume;
 inline constexpr auto memory_order_acquire = memory_order::acquire;
 inline constexpr auto memory_order_release = memory_order::release;
 inline constexpr auto memory_order_acq_rel = memory_order::acq_rel;
 inline constexpr auto memory_order_seq_cst = memory_order::seq_cst;

template <class T> T kill_dependency(T y) noexcept;

// lock-free property

#define ATOMIC_BOOL_LOCK_FREE unspecified
#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR8_T_LOCK_FREE unspecified // C++20
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_POINTER_LOCK_FREE unspecified

template <class T>
struct atomic
{
    using value_type = T;

    static constexpr bool is_always_lock_free;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;

    atomic() noexcept = default;
    constexpr atomic(T desr) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;

    T load(memory_order m = memory_order_seq_cst) const volatile noexcept;
    T load(memory_order m = memory_order_seq_cst) const noexcept;
    operator T() const volatile noexcept;
    operator T() const noexcept;
    void store(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
    void store(T desr, memory_order m = memory_order_seq_cst) noexcept;
    T operator=(T) volatile noexcept;
    T operator=(T) noexcept;

    T exchange(T desr, memory_order m = memory_order_seq_cst) volatile noexcept;
    T exchange(T desr, memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T& expc, T desr,
                               memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_weak(T& expc, T desr, memory_order s, memory_order f) noexcept;
    bool compare_exchange_strong(T& expc, T desr,
                                 memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_strong(T& expc, T desr,
                                 memory_order s, memory_order f) noexcept;
    bool compare_exchange_weak(T& expc, T desr,
                               memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T& expc, T desr,
                               memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T& expc, T desr,
                                memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T& expc, T desr,
                                 memory_order m = memory_order_seq_cst) noexcept;

    void wait(T, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(T, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
};

template <>
struct atomic<integral>
{
    using value_type = integral;
    using difference_type = value_type;

    static constexpr bool is_always_lock_free;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;

    atomic() noexcept = default;
    constexpr atomic(integral desr) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;

    integral load(memory_order m = memory_order_seq_cst) const volatile noexcept;
    integral load(memory_order m = memory_order_seq_cst) const noexcept;
    operator integral() const volatile noexcept;
    operator integral() const noexcept;
    void store(integral desr, memory_order m = memory_order_seq_cst) volatile noexcept;
    void store(integral desr, memory_order m = memory_order_seq_cst) noexcept;
    integral operator=(integral desr) volatile noexcept;
    integral operator=(integral desr) noexcept;

    integral exchange(integral desr,
                      memory_order m = memory_order_seq_cst) volatile noexcept;
    integral exchange(integral desr, memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(integral& expc, integral desr,
                               memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_weak(integral& expc, integral desr,
                               memory_order s, memory_order f) noexcept;
    bool compare_exchange_strong(integral& expc, integral desr,
                                 memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_strong(integral& expc, integral desr,
                                 memory_order s, memory_order f) noexcept;
    bool compare_exchange_weak(integral& expc, integral desr,
                               memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(integral& expc, integral desr,
                               memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(integral& expc, integral desr,
                                memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(integral& expc, integral desr,
                                 memory_order m = memory_order_seq_cst) noexcept;

    integral fetch_add(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
    integral fetch_add(integral op, memory_order m = memory_order_seq_cst) noexcept;
    integral fetch_sub(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
    integral fetch_sub(integral op, memory_order m = memory_order_seq_cst) noexcept;
    integral fetch_and(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
    integral fetch_and(integral op, memory_order m = memory_order_seq_cst) noexcept;
    integral fetch_or(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
    integral fetch_or(integral op, memory_order m = memory_order_seq_cst) noexcept;
    integral fetch_xor(integral op, memory_order m = memory_order_seq_cst) volatile noexcept;
    integral fetch_xor(integral op, memory_order m = memory_order_seq_cst) noexcept;

    integral operator++(int) volatile noexcept;
    integral operator++(int) noexcept;
    integral operator--(int) volatile noexcept;
    integral operator--(int) noexcept;
    integral operator++() volatile noexcept;
    integral operator++() noexcept;
    integral operator--() volatile noexcept;
    integral operator--() noexcept;
    integral operator+=(integral op) volatile noexcept;
    integral operator+=(integral op) noexcept;
    integral operator-=(integral op) volatile noexcept;
    integral operator-=(integral op) noexcept;
    integral operator&=(integral op) volatile noexcept;
    integral operator&=(integral op) noexcept;
    integral operator|=(integral op) volatile noexcept;
    integral operator|=(integral op) noexcept;
    integral operator^=(integral op) volatile noexcept;
    integral operator^=(integral op) noexcept;

    void wait(integral, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(integral, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
};

template <class T>
struct atomic<T*>
{
    using value_type = T*;
    using difference_type = ptrdiff_t;

    static constexpr bool is_always_lock_free;
    bool is_lock_free() const volatile noexcept;
    bool is_lock_free() const noexcept;

    atomic() noexcept = default;
    constexpr atomic(T* desr) noexcept;
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;

    T* load(memory_order m = memory_order_seq_cst) const volatile noexcept;
    T* load(memory_order m = memory_order_seq_cst) const noexcept;
    operator T*() const volatile noexcept;
    operator T*() const noexcept;
    void store(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
    void store(T* desr, memory_order m = memory_order_seq_cst) noexcept;
    T* operator=(T*) volatile noexcept;
    T* operator=(T*) noexcept;

    T* exchange(T* desr, memory_order m = memory_order_seq_cst) volatile noexcept;
    T* exchange(T* desr, memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_weak(T*& expc, T* desr,
                               memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_weak(T*& expc, T* desr,
                               memory_order s, memory_order f) noexcept;
    bool compare_exchange_strong(T*& expc, T* desr,
                                 memory_order s, memory_order f) volatile noexcept;
    bool compare_exchange_strong(T*& expc, T* desr,
                                 memory_order s, memory_order f) noexcept;
    bool compare_exchange_weak(T*& expc, T* desr,
                               memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_weak(T*& expc, T* desr,
                               memory_order m = memory_order_seq_cst) noexcept;
    bool compare_exchange_strong(T*& expc, T* desr,
                                memory_order m = memory_order_seq_cst) volatile noexcept;
    bool compare_exchange_strong(T*& expc, T* desr,
                                 memory_order m = memory_order_seq_cst) noexcept;
    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
    T* fetch_add(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;
    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) volatile noexcept;
    T* fetch_sub(ptrdiff_t op, memory_order m = memory_order_seq_cst) noexcept;

    T* operator++(int) volatile noexcept;
    T* operator++(int) noexcept;
    T* operator--(int) volatile noexcept;
    T* operator--(int) noexcept;
    T* operator++() volatile noexcept;
    T* operator++() noexcept;
    T* operator--() volatile noexcept;
    T* operator--() noexcept;
    T* operator+=(ptrdiff_t op) volatile noexcept;
    T* operator+=(ptrdiff_t op) noexcept;
    T* operator-=(ptrdiff_t op) volatile noexcept;
    T* operator-=(ptrdiff_t op) noexcept;

    void wait(T*, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(T*, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
};


template <class T>
  bool atomic_is_lock_free(const volatile atomic<T>* obj) noexcept;

template <class T>
  bool atomic_is_lock_free(const atomic<T>* obj) noexcept;

template <class T>
  void atomic_store(volatile atomic<T>* obj, T desr) noexcept;

template <class T>
  void atomic_store(atomic<T>* obj, T desr) noexcept;

template <class T>
  void atomic_store_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;

template <class T>
  void atomic_store_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;

template <class T>
  T atomic_load(const volatile atomic<T>* obj) noexcept;

template <class T>
  T atomic_load(const atomic<T>* obj) noexcept;

template <class T>
  T atomic_load_explicit(const volatile atomic<T>* obj, memory_order m) noexcept;

template <class T>
  T atomic_load_explicit(const atomic<T>* obj, memory_order m) noexcept;

template <class T>
  T atomic_exchange(volatile atomic<T>* obj, T desr) noexcept;

template <class T>
  T atomic_exchange(atomic<T>* obj, T desr) noexcept;

template <class T>
  T atomic_exchange_explicit(volatile atomic<T>* obj, T desr, memory_order m) noexcept;

template <class T>
  T atomic_exchange_explicit(atomic<T>* obj, T desr, memory_order m) noexcept;

template <class T>
  bool atomic_compare_exchange_weak(volatile atomic<T>* obj, T* expc, T desr) noexcept;

template <class T>
  bool atomic_compare_exchange_weak(atomic<T>* obj, T* expc, T desr) noexcept;

template <class T>
  bool atomic_compare_exchange_strong(volatile atomic<T>* obj, T* expc, T desr) noexcept;

template <class T>
  bool atomic_compare_exchange_strong(atomic<T>* obj, T* expc, T desr) noexcept;

template <class T>
  bool atomic_compare_exchange_weak_explicit(volatile atomic<T>* obj, T* expc,
                                             T desr,
                                             memory_order s, memory_order f) noexcept;

template <class T>
  bool atomic_compare_exchange_weak_explicit(atomic<T>* obj, T* expc, T desr,
                                             memory_order s, memory_order f) noexcept;

template <class T>
  bool atomic_compare_exchange_strong_explicit(volatile atomic<T>* obj,
                                               T* expc, T desr,
                                               memory_order s, memory_order f) noexcept;

template <class T>
  bool atomic_compare_exchange_strong_explicit(atomic<T>* obj, T* expc,
                                               T desr,
                                               memory_order s, memory_order f) noexcept;

template <class T>
  void atomic_wait(const volatile atomic<T>* obj, T old) noexcept;

template <class T>
  void atomic_wait(const atomic<T>* obj, T old) noexcept;

template <class T>
  void atomic_wait_explicit(const volatile atomic<T>* obj, T old, memory_order m) noexcept;

template <class T>
  void atomic_wait_explicit(const atomic<T>* obj, T old, memory_order m) noexcept;

template <class T>
  void atomic_one(volatile atomic<T>* obj) noexcept;

template <class T>
  void atomic_one(atomic<T>* obj) noexcept;

template <class T>
  void atomic_all(volatile atomic<T>* obj) noexcept;

template <class T>
  void atomic_all(atomic<T>* obj) noexcept;

template <class Integral>
  Integral atomic_fetch_add(volatile atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_add(atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_add_explicit(volatile atomic<Integral>* obj, Integral op,
                              memory_order m) noexcept;
template <class Integral>
  Integral atomic_fetch_add_explicit(atomic<Integral>* obj, Integral op,
                              memory_order m) noexcept;
template <class Integral>
  Integral atomic_fetch_sub(volatile atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_sub(atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_sub_explicit(volatile atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_sub_explicit(atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_and(volatile atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_and(atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_and_explicit(volatile atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_and_explicit(atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_or(volatile atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_or(atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_or_explicit(volatile atomic<Integral>* obj, Integral op,
                             memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_or_explicit(atomic<Integral>* obj, Integral op,
                             memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_xor(volatile atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_xor(atomic<Integral>* obj, Integral op) noexcept;

template <class Integral>
  Integral atomic_fetch_xor_explicit(volatile atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class Integral>
  Integral atomic_fetch_xor_explicit(atomic<Integral>* obj, Integral op,
                                     memory_order m) noexcept;

template <class T>
  T* atomic_fetch_add(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;

template <class T>
  T* atomic_fetch_add(atomic<T*>* obj, ptrdiff_t op) noexcept;

template <class T>
  T* atomic_fetch_add_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
                               memory_order m) noexcept;

template <class T>
  T* atomic_fetch_add_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;

template <class T>
  T* atomic_fetch_sub(volatile atomic<T*>* obj, ptrdiff_t op) noexcept;

template <class T>
  T* atomic_fetch_sub(atomic<T*>* obj, ptrdiff_t op) noexcept;

template <class T>
  T* atomic_fetch_sub_explicit(volatile atomic<T*>* obj, ptrdiff_t op,
                               memory_order m) noexcept;

template <class T>
  T* atomic_fetch_sub_explicit(atomic<T*>* obj, ptrdiff_t op, memory_order m) noexcept;

// Atomics for standard typedef types

typedef atomic<bool>               atomic_bool;
typedef atomic<char>               atomic_char;
typedef atomic<signed char>        atomic_schar;
typedef atomic<unsigned char>      atomic_uchar;
typedef atomic<short>              atomic_short;
typedef atomic<unsigned short>     atomic_ushort;
typedef atomic<int>                atomic_int;
typedef atomic<unsigned int>       atomic_uint;
typedef atomic<long>               atomic_long;
typedef atomic<unsigned long>      atomic_ulong;
typedef atomic<long long>          atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char8_t>            atomic_char8_t; // C++20
typedef atomic<char16_t>           atomic_char16_t;
typedef atomic<char32_t>           atomic_char32_t;
typedef atomic<wchar_t>            atomic_wchar_t;

typedef atomic<int_least8_t>   atomic_int_least8_t;
typedef atomic<uint_least8_t>  atomic_uint_least8_t;
typedef atomic<int_least16_t>  atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t>  atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t>  atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t>   atomic_int_fast8_t;
typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
typedef atomic<int_fast16_t>  atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t>  atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t>  atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic<int8_t>   atomic_int8_t;
typedef atomic<uint8_t>  atomic_uint8_t;
typedef atomic<int16_t>  atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic<int32_t>  atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic<int64_t>  atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t>  atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t>    atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t>  atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;

// flag type and operations

typedef struct atomic_flag
{
    atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;

    bool test(memory_order m = memory_order_seq_cst) volatile noexcept;
    bool test(memory_order m = memory_order_seq_cst) noexcept;
    bool test_and_set(memory_order m = memory_order_seq_cst) volatile noexcept;
    bool test_and_set(memory_order m = memory_order_seq_cst) noexcept;
    void clear(memory_order m = memory_order_seq_cst) volatile noexcept;
    void clear(memory_order m = memory_order_seq_cst) noexcept;

    void wait(bool, memory_order = memory_order::seq_cst) const volatile noexcept;
    void wait(bool, memory_order = memory_order::seq_cst) const noexcept;
    void notify_one() volatile noexcept;
    void notify_one() noexcept;
    void notify_all() volatile noexcept;
    void notify_all() noexcept;
} atomic_flag;

bool atomic_flag_test(volatile atomic_flag* obj) noexcept;
bool atomic_flag_test(atomic_flag* obj) noexcept;
bool atomic_flag_test_explicit(volatile atomic_flag* obj,
                               memory_order m) noexcept;
bool atomic_flag_test_explicit(atomic_flag* obj, memory_order m) noexcept;
bool atomic_flag_test_and_set(volatile atomic_flag* obj) noexcept;
bool atomic_flag_test_and_set(atomic_flag* obj) noexcept;
bool atomic_flag_test_and_set_explicit(volatile atomic_flag* obj,
                                       memory_order m) noexcept;
bool atomic_flag_test_and_set_explicit(atomic_flag* obj, memory_order m) noexcept;
void atomic_flag_clear(volatile atomic_flag* obj) noexcept;
void atomic_flag_clear(atomic_flag* obj) noexcept;
void atomic_flag_clear_explicit(volatile atomic_flag* obj, memory_order m) noexcept;
void atomic_flag_clear_explicit(atomic_flag* obj, memory_order m) noexcept;

void atomic_wait(const volatile atomic_flag* obj, T old) noexcept;
void atomic_wait(const atomic_flag* obj, T old) noexcept;
void atomic_wait_explicit(const volatile atomic_flag* obj, T old, memory_order m) noexcept;
void atomic_wait_explicit(const atomic_flag* obj, T old, memory_order m) noexcept;
void atomic_one(volatile atomic_flag* obj) noexcept;
void atomic_one(atomic_flag* obj) noexcept;
void atomic_all(volatile atomic_flag* obj) noexcept;
void atomic_all(atomic_flag* obj) noexcept;

// fences

void atomic_thread_fence(memory_order m) noexcept;
void atomic_signal_fence(memory_order m) noexcept;

// deprecated

template <class T>
  void atomic_init(volatile atomic<T>* obj, typename atomic<T>::value_type desr) noexcept;

template <class T>
  void atomic_init(atomic<T>* obj, typename atomic<T>::value_type desr) noexcept;

#define ATOMIC_VAR_INIT(value) see below

#define ATOMIC_FLAG_INIT see below

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 578 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 1
// -*- C++ -*-
//===---------------------------- chrono ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    chrono synopsis

namespace std
{
namespace chrono
{

template <class ToDuration, class Rep, class Period>
constexpr
ToDuration
duration_cast(const duration<Rep, Period>& fd);

template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};

template <class Rep> inline constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<Rep>::value;                       // C++17

template <class Rep>
struct duration_values
{
public:
    static constexpr Rep zero(); // noexcept in C++20
    static constexpr Rep max();  // noexcept in C++20
    static constexpr Rep min();  // noexcept in C++20
};

// duration

template <class Rep, class Period = ratio<1>>
class duration
{
    static_assert(!__is_duration<Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(Period::num > 0, "duration period must be positive");
public:
    typedef Rep rep;
    typedef typename _Period::type period;

    constexpr duration() = default;
    template <class Rep2>
        constexpr explicit duration(const Rep2& r,
            typename enable_if
            <
               is_convertible<Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value)
            >::type* = 0);

    // conversions
    template <class Rep2, class Period2>
        constexpr duration(const duration<Rep2, Period2>& d,
            typename enable_if
            <
                treat_as_floating_point<rep>::value ||
                ratio_divide<Period2, period>::type::den == 1
            >::type* = 0);

    // observer

    constexpr rep count() const;

    // arithmetic

    constexpr common_type<duration>::type  operator+() const;
    constexpr common_type<duration>::type  operator-() const;
    constexpr duration& operator++();    // constexpr in C++17
    constexpr duration  operator++(int); // constexpr in C++17
    constexpr duration& operator--();    // constexpr in C++17
    constexpr duration  operator--(int); // constexpr in C++17

    constexpr duration& operator+=(const duration& d);  // constexpr in C++17
    constexpr duration& operator-=(const duration& d);  // constexpr in C++17

    duration& operator*=(const rep& rhs);       // constexpr in C++17
    duration& operator/=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const rep& rhs);       // constexpr in C++17
    duration& operator%=(const duration& rhs);  // constexpr in C++17

    // special values

    static constexpr duration zero(); // noexcept in C++20
    static constexpr duration min();  // noexcept in C++20
    static constexpr duration max();  // noexcept in C++20
};

typedef duration<long long,         nano> nanoseconds;
typedef duration<long long,        micro> microseconds;
typedef duration<long long,        milli> milliseconds;
typedef duration<long long              > seconds;
typedef duration<     long, ratio<  60> > minutes;
typedef duration<     long, ratio<3600> > hours;

template <class Clock, class Duration = typename Clock::duration>
class time_point
{
public:
    typedef Clock                     clock;
    typedef Duration                  duration;
    typedef typename duration::rep    rep;
    typedef typename duration::period period;
private:
    duration d_;  // exposition only

public:
    time_point();  // has value "epoch" // constexpr in C++14
    explicit time_point(const duration& d);  // same as time_point() + d // constexpr in C++14

    // conversions
    template <class Duration2>
       time_point(const time_point<clock, Duration2>& t); // constexpr in C++14

    // observer

    duration time_since_epoch() const; // constexpr in C++14

    // arithmetic

    time_point& operator+=(const duration& d); // constexpr in C++17
    time_point& operator-=(const duration& d); // constexpr in C++17

    // special values

    static constexpr time_point min();  // noexcept in C++20
    static constexpr time_point max();  // noexcept in C++20
};

} // chrono

// common_type traits
template <class Rep1, class Period1, class Rep2, class Period2>
  struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;

template <class Clock, class Duration1, class Duration2>
  struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;

namespace chrono {


template<class T> struct is_clock;  // C++20
template<class T> inline constexpr bool is_clock_v = is_clock<T>::value;   // C++20


// duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
  operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator*(const Rep1& s, const duration<Rep2, Period>& d);
template <class Rep1, class Period, class Rep2>
  constexpr
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator/(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
  constexpr
  typename common_type<Rep1, Rep2>::type
  operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
   constexpr
   bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

// duration_cast
template <class ToDuration, class Rep, class Period>
  ToDuration duration_cast(const duration<Rep, Period>& d);

template <class ToDuration, class Rep, class Period>
    constexpr ToDuration floor(const duration<Rep, Period>& d);    // C++17
template <class ToDuration, class Rep, class Period>
    constexpr ToDuration ceil(const duration<Rep, Period>& d);     // C++17
template <class ToDuration, class Rep, class Period>
    constexpr ToDuration round(const duration<Rep, Period>& d);    // C++17

// duration I/O is elsewhere

// time_point arithmetic (all constexpr in C++14)
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Clock, class Duration2>
  time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
  operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Rep2, class Period2>
  time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
  operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Clock, class Duration1, class Duration2>
  typename common_type<Duration1, Duration2>::type
  operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point comparisons (all constexpr in C++14)
template <class Clock, class Duration1, class Duration2>
   bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
   bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

// time_point_cast (constexpr in C++14)

template <class ToDuration, class Clock, class Duration>
  time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    floor(const time_point<Clock, Duration>& tp);                  // C++17

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    ceil(const time_point<Clock, Duration>& tp);                   // C++17

template <class ToDuration, class Clock, class Duration>
    constexpr time_point<Clock, ToDuration>
    round(const time_point<Clock, Duration>& tp);                  // C++17

template <class Rep, class Period>
    constexpr duration<Rep, Period> abs(duration<Rep, Period> d);  // C++17

// Clocks

class system_clock
{
public:
    typedef microseconds                     duration;
    typedef duration::rep                    rep;
    typedef duration::period                 period;
    typedef chrono::time_point<system_clock> time_point;
    static const bool is_steady =            false; // constexpr in C++14

    static time_point now() noexcept;
    static time_t     to_time_t  (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};

template <class Duration>
  using sys_time  = time_point<system_clock, Duration>; // C++20
using sys_seconds = sys_time<seconds>;                  // C++20
using sys_days    = sys_time<days>;                     // C++20

class utc_clock;                                        // C++20

template <class Duration>
  using utc_time  = time_point<utc_clock, Duration>;    // C++20
using utc_seconds = utc_time<seconds>;                  // C++20

class tai_clock;                                        // C++20

template <class Duration>
  using tai_time  = time_point<tai_clock, Duration>;    // C++20
using tai_seconds = tai_time<seconds>;                  // C++20

class file_clock;                                       // C++20

template<class Duration>
  using file_time = time_point<file_clock, Duration>;   // C++20

class steady_clock
{
public:
    typedef nanoseconds                                   duration;
    typedef duration::rep                                 rep;
    typedef duration::period                              period;
    typedef chrono::time_point<steady_clock, duration>    time_point;
    static const bool is_steady =                         true; // constexpr in C++14

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;

// 25.7.8, local time           // C++20
struct local_t {};
template<class Duration>
  using local_time  = time_point<local_t, Duration>;
using local_seconds = local_time<seconds>;
using local_days    = local_time<days>;

// 25.7.9, time_point conversions template<class DestClock, class SourceClock>    // C++20
struct clock_time_conversion;

template<class DestClock, class SourceClock, class Duration>
  auto clock_cast(const time_point<SourceClock, Duration>& t);

// 25.8.2, class last_spec    // C++20
struct last_spec;

// 25.8.3, class day          // C++20

class day;
constexpr bool operator==(const day& x, const day& y) noexcept;
constexpr bool operator!=(const day& x, const day& y) noexcept;
constexpr bool operator< (const day& x, const day& y) noexcept;
constexpr bool operator> (const day& x, const day& y) noexcept;
constexpr bool operator<=(const day& x, const day& y) noexcept;
constexpr bool operator>=(const day& x, const day& y) noexcept;
constexpr day  operator+(const day&  x, const days& y) noexcept;
constexpr day  operator+(const days& x, const day&  y) noexcept;
constexpr day  operator-(const day&  x, const days& y) noexcept;
constexpr days operator-(const day&  x, const day&  y) noexcept;

// 25.8.4, class month    // C++20
class month;
constexpr bool operator==(const month& x, const month& y) noexcept;
constexpr bool operator!=(const month& x, const month& y) noexcept;
constexpr bool operator< (const month& x, const month& y) noexcept;
constexpr bool operator> (const month& x, const month& y) noexcept;
constexpr bool operator<=(const month& x, const month& y) noexcept;
constexpr bool operator>=(const month& x, const month& y) noexcept;
constexpr month  operator+(const month&  x, const months& y) noexcept;
constexpr month  operator+(const months& x,  const month& y) noexcept;
constexpr month  operator-(const month&  x, const months& y) noexcept;
constexpr months operator-(const month&  x,  const month& y) noexcept;

// 25.8.5, class year    // C++20
class year;
constexpr bool operator==(const year& x, const year& y) noexcept;
constexpr bool operator!=(const year& x, const year& y) noexcept;
constexpr bool operator< (const year& x, const year& y) noexcept;
constexpr bool operator> (const year& x, const year& y) noexcept;
constexpr bool operator<=(const year& x, const year& y) noexcept;
constexpr bool operator>=(const year& x, const year& y) noexcept;
constexpr year  operator+(const year&  x, const years& y) noexcept;
constexpr year  operator+(const years& x, const year&  y) noexcept;
constexpr year  operator-(const year&  x, const years& y) noexcept;
constexpr years operator-(const year&  x, const year&  y) noexcept;

// 25.8.6, class weekday    // C++20
class weekday;

constexpr bool operator==(const weekday& x, const weekday& y) noexcept;
constexpr bool operator!=(const weekday& x, const weekday& y) noexcept;
constexpr weekday operator+(const weekday& x, const days&    y) noexcept;
constexpr weekday operator+(const days&    x, const weekday& y) noexcept;
constexpr weekday operator-(const weekday& x, const days&    y) noexcept;
constexpr days    operator-(const weekday& x, const weekday& y) noexcept;

// 25.8.7, class weekday_indexed    // C++20

class weekday_indexed;
constexpr bool operator==(const weekday_indexed& x, const weekday_indexed& y) noexcept;
constexpr bool operator!=(const weekday_indexed& x, const weekday_indexed& y) noexcept;

// 25.8.8, class weekday_last    // C++20
class weekday_last;

constexpr bool operator==(const weekday_last& x, const weekday_last& y) noexcept;
constexpr bool operator!=(const weekday_last& x, const weekday_last& y) noexcept;

// 25.8.9, class month_day    // C++20
class month_day;

constexpr bool operator==(const month_day& x, const month_day& y) noexcept;
constexpr bool operator!=(const month_day& x, const month_day& y) noexcept;
constexpr bool operator< (const month_day& x, const month_day& y) noexcept;
constexpr bool operator> (const month_day& x, const month_day& y) noexcept;
constexpr bool operator<=(const month_day& x, const month_day& y) noexcept;
constexpr bool operator>=(const month_day& x, const month_day& y) noexcept;


// 25.8.10, class month_day_last    // C++20
class month_day_last;

constexpr bool operator==(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator!=(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator< (const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator> (const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator<=(const month_day_last& x, const month_day_last& y) noexcept;
constexpr bool operator>=(const month_day_last& x, const month_day_last& y) noexcept;

// 25.8.11, class month_weekday    // C++20
class month_weekday;

constexpr bool operator==(const month_weekday& x, const month_weekday& y) noexcept;
constexpr bool operator!=(const month_weekday& x, const month_weekday& y) noexcept;

// 25.8.12, class month_weekday_last    // C++20
class month_weekday_last;

constexpr bool operator==(const month_weekday_last& x, const month_weekday_last& y) noexcept;
constexpr bool operator!=(const month_weekday_last& x, const month_weekday_last& y) noexcept;


// 25.8.13, class year_month    // C++20
class year_month;

constexpr bool operator==(const year_month& x, const year_month& y) noexcept;
constexpr bool operator!=(const year_month& x, const year_month& y) noexcept;
constexpr bool operator< (const year_month& x, const year_month& y) noexcept;
constexpr bool operator> (const year_month& x, const year_month& y) noexcept;
constexpr bool operator<=(const year_month& x, const year_month& y) noexcept;
constexpr bool operator>=(const year_month& x, const year_month& y) noexcept;

constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
constexpr months operator-(const year_month& x, const year_month& y) noexcept;
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;

// 25.8.14, class year_month_day class    // C++20
year_month_day;

constexpr bool operator==(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator!=(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator< (const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator> (const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator<=(const year_month_day& x, const year_month_day& y) noexcept;
constexpr bool operator>=(const year_month_day& x, const year_month_day& y) noexcept;

constexpr year_month_day operator+(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator+(const months& dm, const year_month_day& ymd) noexcept;
constexpr year_month_day operator+(const year_month_day& ymd, const years& dy) noexcept;
constexpr year_month_day operator+(const years& dy, const year_month_day& ymd) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const months& dm) noexcept;
constexpr year_month_day operator-(const year_month_day& ymd, const years& dy) noexcept;


// 25.8.15, class year_month_day_last    // C++20
class year_month_day_last;

constexpr bool operator==(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator!=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator< (const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator> (const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator<=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;
constexpr bool operator>=(const year_month_day_last& x,
                          const year_month_day_last& y) noexcept;

constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
  operator+(const months& dm, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
  operator+(const year_month_day_last& ymdl, const years& dy) noexcept;
constexpr year_month_day_last
  operator+(const years& dy, const year_month_day_last& ymdl) noexcept;
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const months& dm) noexcept;
constexpr year_month_day_last
  operator-(const year_month_day_last& ymdl, const years& dy) noexcept;

// 25.8.16, class year_month_weekday    // C++20
class year_month_weekday;

constexpr bool operator==(const year_month_weekday& x,
                          const year_month_weekday& y) noexcept;
constexpr bool operator!=(const year_month_weekday& x,
                          const year_month_weekday& y) noexcept;

constexpr year_month_weekday
  operator+(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
  operator+(const months& dm, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
  operator+(const year_month_weekday& ymwd, const years& dy) noexcept;
constexpr year_month_weekday
  operator+(const years& dy, const year_month_weekday& ymwd) noexcept;
constexpr year_month_weekday
  operator-(const year_month_weekday& ymwd, const months& dm) noexcept;
constexpr year_month_weekday
  operator-(const year_month_weekday& ymwd, const years& dy) noexcept;

// 25.8.17, class year_month_weekday_last    // C++20
class year_month_weekday_last;

constexpr bool operator==(const year_month_weekday_last& x,
                          const year_month_weekday_last& y) noexcept;
constexpr bool operator!=(const year_month_weekday_last& x,
                          const year_month_weekday_last& y) noexcept;
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
  operator+(const months& dm, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
  operator+(const year_month_weekday_last& ymwdl, const years& dy) noexcept;
constexpr year_month_weekday_last
  operator+(const years& dy, const year_month_weekday_last& ymwdl) noexcept;
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const months& dm) noexcept;
constexpr year_month_weekday_last
  operator-(const year_month_weekday_last& ymwdl, const years& dy) noexcept;

// 25.8.18, civil calendar conventional syntax operators    // C++20
constexpr year_month
  operator/(const year& y, const month& m) noexcept;
constexpr year_month
  operator/(const year& y, int m) noexcept;
constexpr month_day
  operator/(const month& m, const day& d) noexcept;
constexpr month_day
  operator/(const month& m, int d) noexcept;
constexpr month_day
  operator/(int m, const day& d) noexcept;
constexpr month_day
  operator/(const day& d, const month& m) noexcept;
constexpr month_day
  operator/(const day& d, int m) noexcept;
constexpr month_day_last
  operator/(const month& m, last_spec) noexcept;
constexpr month_day_last
  operator/(int m, last_spec) noexcept;
constexpr month_day_last
  operator/(last_spec, const month& m) noexcept;
constexpr month_day_last
  operator/(last_spec, int m) noexcept;
constexpr month_weekday
  operator/(const month& m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
  operator/(int m, const weekday_indexed& wdi) noexcept;
constexpr month_weekday
  operator/(const weekday_indexed& wdi, const month& m) noexcept;
constexpr month_weekday
  operator/(const weekday_indexed& wdi, int m) noexcept;
constexpr month_weekday_last
  operator/(const month& m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
  operator/(int m, const weekday_last& wdl) noexcept;
constexpr month_weekday_last
  operator/(const weekday_last& wdl, const month& m) noexcept;
constexpr month_weekday_last
  operator/(const weekday_last& wdl, int m) noexcept;
constexpr year_month_day
  operator/(const year_month& ym, const day& d) noexcept;
constexpr year_month_day
  operator/(const year_month& ym, int d) noexcept;
constexpr year_month_day
  operator/(const year& y, const month_day& md) noexcept;
constexpr year_month_day
  operator/(int y, const month_day& md) noexcept;
constexpr year_month_day
  operator/(const month_day& md, const year& y) noexcept;
constexpr year_month_day
  operator/(const month_day& md, int y) noexcept;
constexpr year_month_day_last
  operator/(const year_month& ym, last_spec) noexcept;
constexpr year_month_day_last
  operator/(const year& y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
  operator/(int y, const month_day_last& mdl) noexcept;
constexpr year_month_day_last
  operator/(const month_day_last& mdl, const year& y) noexcept;
constexpr year_month_day_last
  operator/(const month_day_last& mdl, int y) noexcept;
constexpr year_month_weekday
  operator/(const year_month& ym, const weekday_indexed& wdi) noexcept;
constexpr year_month_weekday
  operator/(const year& y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
  operator/(int y, const month_weekday& mwd) noexcept;
constexpr year_month_weekday
  operator/(const month_weekday& mwd, const year& y) noexcept;
constexpr year_month_weekday
  operator/(const month_weekday& mwd, int y) noexcept;
constexpr year_month_weekday_last
  operator/(const year_month& ym, const weekday_last& wdl) noexcept;
constexpr year_month_weekday_last
  operator/(const year& y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
  operator/(int y, const month_weekday_last& mwdl) noexcept;
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, const year& y) noexcept;
constexpr year_month_weekday_last
  operator/(const month_weekday_last& mwdl, int y) noexcept;

// 26.9, class template hh_mm_ss
template <class Duration>
class hh_mm_ss
{
    bool            is_neg; // exposition only
    chrono::hours   h;      // exposition only
    chrono::minutes m;      // exposition only
    chrono::seconds s;      // exposition only
    precision       ss;     // exposition only

public:
    static unsigned constexpr fractional_width = see below;
    using precision                            = see below;

    constexpr hh_mm_ss() noexcept : hh_mm_ss{Duration::zero()} {}
    constexpr explicit hh_mm_ss(Duration d) noexcept;

    constexpr bool is_negative() const noexcept;
    constexpr chrono::hours hours() const noexcept;
    constexpr chrono::minutes minutes() const noexcept;
    constexpr chrono::seconds seconds() const noexcept;
    constexpr precision subseconds() const noexcept;

    constexpr explicit operator  precision()   const noexcept;
    constexpr          precision to_duration() const noexcept;
};

template <class charT, class traits, class Duration>
  basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>& os, hh_mm_ss<Duration> const& hms);

// 26.10, 12/24 hour functions
constexpr bool is_am(hours const& h) noexcept;
constexpr bool is_pm(hours const& h) noexcept;
constexpr hours make12(const hours& h) noexcept;
constexpr hours make24(const hours& h, bool is_pm) noexcept;


// 25.10.2, time zone database     // C++20
struct tzdb;
class tzdb_list;

// 25.10.2.3, time zone database access    // C++20
const tzdb& get_tzdb();
tzdb_list& get_tzdb_list();
const time_zone* locate_zone(string_view tz_name);
const time_zone* current_zone();

// 25.10.2.4, remote time zone database support    // C++20
const tzdb& reload_tzdb();
string remote_version();

// 25.10.3, exception classes    // C++20
class nonexistent_local_time;
class ambiguous_local_time;

// 25.10.4, information classes    // C++20
struct sys_info;
struct local_info;

// 25.10.5, class time_zone    // C++20
enum class choose {earliest, latest};
class time_zone;
bool operator==(const time_zone& x, const time_zone& y) noexcept;
bool operator!=(const time_zone& x, const time_zone& y) noexcept;
bool operator<(const time_zone& x, const time_zone& y) noexcept;
bool operator>(const time_zone& x, const time_zone& y) noexcept;
bool operator<=(const time_zone& x, const time_zone& y) noexcept;
bool operator>=(const time_zone& x, const time_zone& y) noexcept;

// 25.10.6, class template zoned_traits    // C++20
template<class T> struct zoned_traits;

// 25.10.7, class template zoned_time    // C++20
template<class Duration, class TimeZonePtr = const time_zone*> class zoned_time;
using zoned_seconds = zoned_time<seconds>;

template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator==(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);
template<class Duration1, class Duration2, class TimeZonePtr>
  bool operator!=(const zoned_time<Duration1, TimeZonePtr>& x,
                  const zoned_time<Duration2, TimeZonePtr>& y);

// 25.10.8, leap second support    // C++20
class leap;

bool operator==(const leap& x, const leap& y);
bool operator!=(const leap& x, const leap& y);
bool operator< (const leap& x, const leap& y);
bool operator> (const leap& x, const leap& y);
bool operator<=(const leap& x, const leap& y);
bool operator>=(const leap& x, const leap& y);
template<class Duration>
  bool operator==(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator==(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator!=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator!=(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator< (const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator< (const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator> (const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator> (const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator<=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator<=(const sys_time<Duration>& x, const leap& y);
template<class Duration>
  bool operator>=(const leap& x, const sys_time<Duration>& y);
template<class Duration>
  bool operator>=(const sys_time<Duration>& x, const leap& y);

// 25.10.9, class link    // C++20
class link;
bool operator==(const link& x, const link& y);
bool operator!=(const link& x, const link& y);
bool operator< (const link& x, const link& y);
bool operator> (const link& x, const link& y);
bool operator<=(const link& x, const link& y);
bool operator>=(const link& x, const link& y);

// 25.11, formatting    // C++20
template<class charT, class Streamable>
  basic_string<charT>
    format(const charT* fmt, const Streamable& s);

template<class charT, class Streamable>
  basic_string<charT>
    format(const locale& loc, const charT* fmt, const Streamable& s);

template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const basic_string<charT, traits, Alloc>& fmt, const Streamable& s);

template<class charT, class traits, class Alloc, class Streamable>
  basic_string<charT, traits, Alloc>
    format(const locale& loc, const basic_string<charT, traits, Alloc>& fmt,
           const Streamable& s);

// 25.12, parsing    // C++20
template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          minutes& offset);

template<class charT, class traits, class Alloc, class Parsable>
unspecified
    parse(const basic_string<charT, traits, Alloc>& format, Parsable& tp,
          basic_string<charT, traits, Alloc>& abbrev, minutes& offset);

// calendrical constants
inline constexpr last_spec                              last{};       // C++20
inline constexpr chrono::weekday                        Sunday{0};    // C++20
inline constexpr chrono::weekday                        Monday{1};    // C++20
inline constexpr chrono::weekday                        Tuesday{2};   // C++20
inline constexpr chrono::weekday                        Wednesday{3}; // C++20
inline constexpr chrono::weekday                        Thursday{4};  // C++20
inline constexpr chrono::weekday                        Friday{5};    // C++20
inline constexpr chrono::weekday                        Saturday{6};  // C++20

inline constexpr chrono::month                          January{1};   // C++20
inline constexpr chrono::month                          February{2};  // C++20
inline constexpr chrono::month                          March{3};     // C++20
inline constexpr chrono::month                          April{4};     // C++20
inline constexpr chrono::month                          May{5};       // C++20
inline constexpr chrono::month                          June{6};      // C++20
inline constexpr chrono::month                          July{7};      // C++20
inline constexpr chrono::month                          August{8};    // C++20
inline constexpr chrono::month                          September{9}; // C++20
inline constexpr chrono::month                          October{10};  // C++20
inline constexpr chrono::month                          November{11}; // C++20
inline constexpr chrono::month                          December{12}; // C++20
}  // chrono

inline namespace literals {
  inline namespace chrono_literals {
constexpr chrono::hours                                 operator ""h(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<3600,1>> operator ""h(long double); // C++14
constexpr chrono::minutes                               operator ""min(unsigned long long); // C++14
constexpr chrono::duration<unspecified , ratio<60,1>>   operator ""min(long double); // C++14
constexpr chrono::seconds                               operator ""s(unsigned long long); // C++14
constexpr chrono::duration<unspecified >                operator ""s(long double); // C++14
constexpr chrono::milliseconds                          operator ""ms(unsigned long long); // C++14
constexpr chrono::duration<unspecified , milli>         operator ""ms(long double); // C++14
constexpr chrono::microseconds                          operator ""us(unsigned long long); // C++14
constexpr chrono::duration<unspecified , micro>         operator ""us(long double); // C++14
constexpr chrono::nanoseconds                           operator ""ns(unsigned long long); // C++14
constexpr chrono::duration<unspecified , nano>          operator ""ns(long double); // C++14
constexpr chrono::day                                   operator ""d(unsigned long long d) noexcept; // C++20
constexpr chrono::year                                  operator ""y(unsigned long long y) noexcept; // C++20
}  // chrono_literals
}  // literals

}  // std
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 827 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctime" 1
// -*- C++ -*-
//===---------------------------- ctime -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    ctime synopsis

Macros:

    NULL
    CLOCKS_PER_SEC
    TIME_UTC // C++17

namespace std
{

Types:

    clock_t
    size_t
    time_t
    tm
    timespec // C++17

clock_t clock();
double difftime(time_t time1, time_t time0);
time_t mktime(tm* timeptr);
time_t time(time_t* timer);
char* asctime(const tm* timeptr);
char* ctime(const time_t* timer);
tm*    gmtime(const time_t* timer);
tm* localtime(const time_t* timer);
size_t strftime(char* restrict s, size_t maxsize, const char* restrict format,
                const tm* restrict timeptr);
int timespec_get( struct timespec *ts, int base); // C++17
}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 49 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctime" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 1 3 4
/*
 * Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 1 3 4
/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 1 3 4
/*
 * Copyright (c) 2000-2018 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright 1995 NeXT Computer, Inc. All rights reserved. */
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 */
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/* This SDK is designed to work with clang and specific versions of
 * gcc >= 4.0 with Apple's patch sets */




/*
 * Compatibility with compilers and environments that don't support compiler
 * feature checking function-like macros.
 */
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky -- make sure you don't put spaces
 * in between its arguments.  __CONCAT can also concatenate double-quoted
 * strings produced by the __STRING macro, but this only works with ANSI C.
 */
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * __pure2 can be used for functions that are only a function of their scalar
 * arguments (meaning they can't dereference pointers).
 *
 * __stateful_pure can be used for functions that have no side effects,
 * but depend on the state of the memory.
 */




/* __unused denotes variables and functions that may not be used, preventing
 * the compiler from warning about it if not used.
 */


/* __used forces variables and functions to be included even if it appears
 * to the compiler that they are not used (and would thust be discarded).
 */


/* __cold marks code used for debugging or that is rarely taken
 * and tells the compiler to optimize for size and outline code.
 */






/* __exported denotes symbols that should be exported even when symbols
 * are hidden by default.
 * __exported_push/_exported_pop are pragmas used to delimit a range of
 *  symbols that should be exported even when symbols are hidden by default.
 */




/* __deprecated causes the compiler to produce a warning when encountering
 * code using the deprecated functionality.
 * __deprecated_msg() does the same, and compilers that support it will print
 * a message along with the deprecation warning.
 * This may require turning on such warning with the -Wdeprecated flag.
 * __deprecated_enum_msg() should be used on enums, and compilers that support
 * it will print the deprecation warning.
 * __kpi_deprecated() specifically indicates deprecation of kernel programming
 * interfaces in Kernel.framework used by KEXTs.
 */
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/* __unavailable causes the compiler to error out when encountering
 * code using the tagged function
 */
# 234 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/* Delete pseudo-keywords wherever they are not available or needed. */





/*
 * We use `__restrict' as a way to define the `restrict' type qualifier
 * without disturbing older software that is unaware of C99 keywords.
 */






/* Compatibility with compilers and environments that don't support the
 * nullability feature.
 */
# 275 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * __disable_tail_calls causes the compiler to not perform tail call
 * optimization inside the marked function.
 */






/*
 * __not_tail_called causes the compiler to prevent tail call optimization
 * on statically bound calls to the function.  It has no effect on indirect
 * calls.  Virtual functions, objective-c methods, and functions marked as
 * "always_inline" cannot be marked as __not_tail_called.
 */






/*
 * __result_use_check warns callers of a function that not using the function
 * return value is a bug, i.e. dismissing malloc() return value results in a
 * memory leak.
 */






/*
 * __swift_unavailable causes the compiler to mark a symbol as specifically
 * unavailable in Swift, regardless of any other availability in C.
 */






/*
 * __abortlike is the attribute to put on functions like abort() that are
 * typically used to mark assertions. These optimize the codegen
 * for outlining while still maintaining debugability.
 */




/* Declaring inline functions within headers is error-prone due to differences
 * across various versions of the C language and extensions.  __header_inline
 * can be used to declare inline functions within system headers.  In cases
 * where you want to force inlining instead of letting the compiler make
 * the decision, you can use __header_always_inline.
 *
 * Be aware that using inline for functions which compilers may also provide
 * builtins can behave differently under various compilers.  If you intend to
 * provide an inline version of such a function, you may want to use a macro
 * instead.
 *
 * The check for !__GNUC__ || __clang__ is because gcc doesn't correctly
 * support c99 inline in some cases:
 * http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55965
 */
# 368 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros that bracket portions of code where the
 * "-Wunreachable-code" warning should be ignored. Please use sparingly.
 */
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly.  Functions declared
 * with these attributes will cause compilation warnings if there is a
 * mismatch between the format string and subsequent function parameter
 * types.
 */
# 422 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/* Source compatibility only, ID string not emitted in object file */
# 439 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * __alloc_size can be used to label function arguments that represent the
 * size of memory that the function allocates and returns. The one-argument
 * form labels a single argument that gives the allocation size (where the
 * arguments are numbered from 1):
 *
 * void	*malloc(size_t __size) __alloc_size(1);
 *
 * The two-argument form handles the case where the size is calculated as the
 * product of two arguments:
 *
 * void	*calloc(size_t __count, size_t __size) __alloc_size(1,2);
 */
# 460 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * COMPILATION ENVIRONMENTS -- see compat(5) for additional detail
 *
 * DEFAULT	By default newly complied code will get POSIX APIs plus
 *		Apple API extensions in scope.
 *
 *		Most users will use this compilation environment to avoid
 *		behavioral differences between 32 and 64 bit code.
 *
 * LEGACY	Defining _NONSTD_SOURCE will get pre-POSIX APIs plus Apple
 *		API extensions in scope.
 *
 *		This is generally equivalent to the Tiger release compilation
 *		environment, except that it cannot be applied to 64 bit code;
 *		its use is discouraged.
 *
 *		We expect this environment to be deprecated in the future.
 *
 * STRICT	Defining _POSIX_C_SOURCE or _XOPEN_SOURCE restricts the
 *		available APIs to exactly the set of APIs defined by the
 *		corresponding standard, based on the value defined.
 *
 *		A correct, portable definition for _POSIX_C_SOURCE is 200112L.
 *		A correct, portable definition for _XOPEN_SOURCE is 600L.
 *
 *		Apple API extensions are not visible in this environment,
 *		which can cause Apple specific code to fail to compile,
 *		or behave incorrectly if prototypes are not in scope or
 *		warnings about missing prototypes are not enabled or ignored.
 *
 * In any compilation environment, for correct symbol resolution to occur,
 * function prototypes must be in scope.  It is recommended that all Apple
 * tools users add either the "-Wall" or "-Wimplicit-function-declaration"
 * compiler flags to their projects to be warned when a function is being
 * used without a prototype in scope.
 */

/* These settings are particular to each product. */
/* Platform: MacOSX */
# 513 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * The __DARWIN_ALIAS macros are used to do symbol renaming; they allow
 * legacy code to use the old symbol, thus maintaining binary compatibility
 * while new code can use a standards compliant version of the same function.
 *
 * __DARWIN_ALIAS is used by itself if the function signature has not
 * changed, it is used along with a #ifdef check for __DARWIN_UNIX03
 * if the signature has changed.  Because the __LP64__ environment
 * only supports UNIX03 semantics it causes __DARWIN_UNIX03 to be
 * defined, but causes __DARWIN_ALIAS to do no symbol mangling.
 *
 * As a special case, when XCode is used to target a specific version of the
 * OS, the manifest constant __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
 * will be defined by the compiler, with the digits representing major version
 * time 100 + minor version times 10 (e.g. 10.5 := 1050).  If we are targeting
 * pre-10.5, and it is the default compilation environment, revert the
 * compilation environment to pre-__DARWIN_UNIX03.
 */
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * symbol suffixes used for symbol versioning
 */
# 636 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * symbol versioning macros
 */
# 654 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * symbol release macros
 */

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
/* Copyright (c) 2010 Apple Inc. All rights reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 658 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 668 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * POSIX.1 requires that the macros we test be defined before any standard
 * header file is included.  This permits us to convert values for feature
 * testing, as necessary, using only _POSIX_C_SOURCE.
 *
 * Here's a quick run-down of the versions:
 *  defined(_POSIX_SOURCE)		1003.1-1988
 *  _POSIX_C_SOURCE == 1L		1003.1-1990
 *  _POSIX_C_SOURCE == 2L		1003.2-1992 C Language Binding Option
 *  _POSIX_C_SOURCE == 199309L		1003.1b-1993
 *  _POSIX_C_SOURCE == 199506L		1003.1c-1995, 1003.1i-1995,
 *					and the omnibus ISO/IEC 9945-1: 1996
 *  _POSIX_C_SOURCE == 200112L		1003.1-2001
 *  _POSIX_C_SOURCE == 200809L		1003.1-2008
 *
 * In addition, the X/Open Portability Guide, which is now the Single UNIX
 * Specification, defines a feature-test macro which indicates the version of
 * that specification, and which subsumes _POSIX_C_SOURCE.
 */

/* Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1L. */





/* Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2L. */





/* Deal with various X/Open Portability Guides and Single UNIX Spec. */
# 714 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * Deal with all versions of POSIX.  The ordering relative to the tests above is
 * important.
 */




/* POSIX C deprecation macros */

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h" 1 3 4
/* Copyright (c) 2010 Apple Inc. All rights reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 724 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4



/*
 * Set a single macro which will always be defined and can be used to determine
 * the appropriate namespace.  For POSIX, these values will correspond to
 * _POSIX_C_SOURCE value.  Currently there are two additional levels corresponding
 * to ANSI (_ANSI_SOURCE) and Darwin extensions (_DARWIN_C_SOURCE)
 */
# 744 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/* If the developer has neither requested a strict language mode nor a version
 * of POSIX, turn on functionality provided by __STDC_WANT_LIB_EXT1__ as part
 * of __DARWIN_C_FULL.
 */




/*
 * long long is not supported in c89 (__STRICT_ANSI__), but g++ -ansi and
 * c99 still want long longs.  While not perfect, we allow long longs for
 * g++.
 */






/*****************************************
*  Public darwin-specific feature macros
*****************************************/

/*
 * _DARWIN_FEATURE_64_BIT_INODE indicates that the ino_t type is 64-bit, and
 * structures modified for 64-bit inodes (like struct stat) will be used.
 */




/*
 * _DARWIN_FEATURE_64_ONLY_BIT_INODE indicates that the ino_t type may only
 * be 64-bit; there is no support for 32-bit ino_t when this macro is defined
 * (and non-zero).  There is no struct stat64 either, as the regular
 * struct stat will already be the 64-bit version.
 */




/*
 * _DARWIN_FEATURE_ONLY_VERS_1050 indicates that only those APIs updated
 * in 10.5 exists; no pre-10.5 variants are available.
 */




/*
 * _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE indicates only UNIX conforming API
 * are available (the legacy BSD APIs are not available)
 */




/*
 * _DARWIN_FEATURE_UNIX_CONFORMANCE indicates whether UNIX conformance is on,
 * and specifies the conformance level (3 is SUSv3)
 */





/*
 * This macro casts away the qualifier from the variable
 *
 * Note: use at your own risk, removing qualifiers can result in
 * catastrophic run-time failures.
 */




/*
 * __XNU_PRIVATE_EXTERN is a linkage decoration indicating that a symbol can be
 * used from other compilation units, but not other libraries or executables.
 */





/*
 * Architecture validation for current SDK
 */
# 858 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
/*
 * Similar to OS_ENUM/OS_CLOSED_ENUM/OS_OPTIONS/OS_CLOSED_OPTIONS
 *
 * This provides more advanced type checking on compilers supporting
 * the proper extensions, even in C.
 */
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 1 3 4
/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 */





/*
 * This header file contains integer types.  It's intended to also contain
 * flotaing point and other arithmetic types, as needed, later.
 */


typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;

/*
 * The rune type below is declared to be an ``int'' instead of the more natural
 * ``unsigned long'' or ``long''.  Two things are happening here.  It is not
 * unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
 * it looks like 10646 will be a 31 bit standard.  This means that if your
 * ints cannot hold 32 bits, you will be in trouble.  The reason an int was
 * chosen over a long is that the is*() and to*() routines take ints (says
 * ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
 * here, you lose a bit of ANSI conformance, but your programs will still
 * work.
 *
 * NOTE: rune_t is not covered by ANSI nor other standards, and should not
 * be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
 * rune_t must be the same type.  Also wint_t must be no narrower than
 * wchar_t, and should also be able to hold all members of the largest
 * character set plus one extra value (WEOF). wint_t must be at least 16 bits.
 */

typedef int __darwin_ct_rune_t; /* ct_rune_t */

/*
 * mbstate_t is an opaque object to keep conversion state, during multibyte
 * stream conversions.  The content must not be referenced by user programs.
 */
typedef union {
 char __mbstate8[128];
 long long _mbstateL; /* for alignment */
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t; /* mbstate_t */


typedef long int __darwin_ptrdiff_t; /* ptr1 - ptr2 */







typedef long unsigned int __darwin_size_t; /* sizeof() */





typedef __builtin_va_list __darwin_va_list; /* va_list */





typedef int __darwin_wchar_t; /* wchar_t */




typedef __darwin_wchar_t __darwin_rune_t; /* rune_t */


typedef int __darwin_wint_t; /* wint_t */




typedef unsigned long __darwin_clock_t; /* clock() */
typedef __uint32_t __darwin_socklen_t; /* socklen_t (duh) */
typedef long __darwin_ssize_t; /* byte count or error */
typedef long __darwin_time_t; /* time() */
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4

/*
 * Type definitions; takes common type definitions that must be used
 * in multiple header files due to [XSI], removes them from the system
 * space, and puts them in the implementation space.
 */
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t; /* total blocks */
typedef __int32_t __darwin_blksize_t; /* preferred block size */
typedef __int32_t __darwin_dev_t; /* dev_t */
typedef unsigned int __darwin_fsblkcnt_t; /* Used by statvfs and fstatvfs */
typedef unsigned int __darwin_fsfilcnt_t; /* Used by statvfs and fstatvfs */
typedef __uint32_t __darwin_gid_t; /* [???] process and group IDs */
typedef __uint32_t __darwin_id_t; /* [XSI] pid_t, uid_t, or gid_t*/
typedef __uint64_t __darwin_ino64_t; /* [???] Used for 64 bit inodes */

typedef __darwin_ino64_t __darwin_ino_t; /* [???] Used for inodes */



typedef __darwin_natural_t __darwin_mach_port_name_t; /* Used by mach */
typedef __darwin_mach_port_name_t __darwin_mach_port_t; /* Used by mach */
typedef __uint16_t __darwin_mode_t; /* [???] Some file attributes */
typedef __int64_t __darwin_off_t; /* [???] Used for file sizes */
typedef __int32_t __darwin_pid_t; /* [???] process and group IDs */
typedef __uint32_t __darwin_sigset_t; /* [???] signal set */
typedef __int32_t __darwin_suseconds_t; /* [???] microseconds */
typedef __uint32_t __darwin_uid_t; /* [???] user IDs */
typedef __uint32_t __darwin_useconds_t; /* [???] microseconds */
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
/*
 * Copyright (c) 2003-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






// pthread opaque structures
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *); // Routine to call
 void *__arg; // Argument to pass
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
/*
 * Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */



 /*     
    These macros are for use in OS header files. They enable function prototypes
    and Objective-C methods to be tagged with the OS version in which they
    were first available; and, if applicable, the OS version in which they 
    became deprecated.  
     
    The desktop Mac OS X and iOS each have different version numbers.
    The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
    and iOS version numbers.  For instance:
        __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
    means the function/method was first available on Mac OS X 10.2 on the desktop
    and first available in iOS 2.0 on the iPhone.
    
    If a function is available on one platform, but not the other a _NA (not
    applicable) parameter is used.  For instance:
            __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
    means that the function/method was first available on Mac OS X 10.3, and it
    currently not implemented on the iPhone.

    At some point, a function/method may be deprecated.  That means Apple
    recommends applications stop using the function, either because there is a 
    better replacement or the functionality is being phased out.  Deprecated
    functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
    macro which specifies the OS version where the function became available
    as well as the OS version in which it became deprecated.  For instance:
        __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
    means that the function/method was introduced in Mac OS X 10.0, then
    became deprecated beginning in Mac OS X 10.5.  On iOS the function 
    has never been available.  
    
    For these macros to function properly, a program must specify the OS version range 
    it is targeting.  The min OS version is specified as an option to the compiler:
    -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
    when building for the iPhone.  The upper bound for the OS version is rarely needed,
    but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
    Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.  
    
    Examples:

        A function available in Mac OS X 10.5 and later, but not on the phone:
        
            extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);


        An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
        
            @interface MyClass : NSObject
            -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
            @end

        
        An enum available on the phone, but not available on Mac OS X:
        
            #if __IPHONE_OS_VERSION_MIN_REQUIRED
                enum { myEnum = 1 };
            #endif
           Note: this works when targeting the Mac OS X platform because 
           __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero. 
        

        An enum with values added in different iPhoneOS versions:
		
			enum {
			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
				...
		      Note: you do not want to use #if with enumeration values
			  when a client needs to see all values at compile time
			  and use runtime logic to only use the viable values.
			  

    It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
    source base that can be compiled to target a range of OS versions.  It is best
    to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
    That is because you might get compiled on an old OS that does not define a later
    OS version macro, and in the C preprocessor undefined values evaluate to zero
    in expresssions, which could cause the #if expression to evaluate in an unexpected
    way.
    
        #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
            // code only compiled when targeting Mac OS X and not iPhone
            // note use of 1050 instead of __MAC_10_5
            #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
                // code in here might run on pre-Leopard OS
            #else
                // code here can assume Leopard or later
            #endif
        #endif


*/

/* 
 * __API_TO_BE_DEPRECATED is used as a version number in API that will be deprecated 
 * in an upcoming release. This soft deprecation is an intermediate step before formal 
 * deprecation to notify developers about the API before compiler warnings are generated.
 * You can find all places in your code that use soft deprecated API by redefining the 
 * value of this macro to your current minimum deployment target, for example:
 * (macOS)
 *   clang -D__API_TO_BE_DEPRECATED=10.12 <other compiler flags>
 * (iOS)
 *   clang -D__API_TO_BE_DEPRECATED=11.0 <other compiler flags>
 */






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 1 3 4
/*
 * Copyright (c) 2019 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 3 4
/* __MAC_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable */
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 3 4
/* __IPHONE_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable */
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 3 4
/*
 * Set up standard Mac OS X versions
 */
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 1 3 4
/*
 * Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
    File:       AvailabilityInternal.h
 
    Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>

*/
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
    /* make sure a default max version is set */
# 2921 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
            /* use better attributes if possible */
# 4435 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
/*
 Macros for defining which versions/platform a given symbol can be used.
 
 @see http://clang.llvm.org/docs/AttributeReference.html#availability
 */
# 4566 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
    /*
     * API Unavailability
     * Use to specify that an API is unavailable for a particular platform.
     *
     * Example:
     *    __API_UNAVAILABLE(macos)
     *    __API_UNAVAILABLE(watchos, tvos)
     */
# 4647 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
/*
 * Swift compiler version
 * Allows for project-agnostic "epochs" for frameworks imported into Swift via the Clang importer, like #if _compiler_version for Swift
 * Example:
 *
 *  #if __swift_compiler_version_at_least(800, 2, 20)
 *  - (nonnull NSString *)description;
 *  #else
 *  - (NSString *)description;
 *  #endif
 */
# 4667 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
/*
 * If __SPI_AVAILABLE has not been defined elsewhere, disable it.
 */
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use to document app extension usage */
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use marking APIs available info for Mac OSX */
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use marking APIs available info for iOS */
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use marking APIs available info for tvOS */
# 307 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use marking APIs available info for Watch OS */
# 334 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/* for use marking APIs unavailable for swift */
# 350 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/*
 Macros for defining which versions/platform a given symbol can be used.
 
 @see http://clang.llvm.org/docs/AttributeReference.html#availability
 
 * Note that these macros are only compatible with clang compilers that
 * support the following target selection options:
 *
 * -mmacosx-version-min
 * -miphoneos-version-min
 * -mwatchos-version-min
 * -mtvos-version-min
 */




    /*
     * API Introductions
     *
     * Use to specify the release that a particular API became available.
     *
     * Platform names:
     *   macos, ios, tvos, watchos
     *
     * Examples:
     *    __API_AVAILABLE(macos(10.10))
     *    __API_AVAILABLE(macos(10.9), ios(10.0))
     *    __API_AVAILABLE(macos(10.4), ios(8.0), watchos(2.0), tvos(10.0))
     *    __API_AVAILABLE(driverkit(19.0))
     */





    /*
     * API Deprecations
     *
     * Use to specify the release that a particular API became unavailable.
     *
     * Platform names:
     *   macos, ios, tvos, watchos
     *
     * Examples:
     *
     *    __API_DEPRECATED("No longer supported", macos(10.4, 10.8))
     *    __API_DEPRECATED("No longer supported", macos(10.4, 10.8), ios(2.0, 3.0), watchos(2.0, 3.0), tvos(9.0, 10.0))
     *
     *    __API_DEPRECATED_WITH_REPLACEMENT("-setName:", tvos(10.0, 10.4), ios(9.0, 10.0))
     *    __API_DEPRECATED_WITH_REPLACEMENT("SomeClassName", macos(10.4, 10.6), watchos(2.0, 3.0))
     */
# 411 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
    /*
     * API Unavailability
     * Use to specify that an API is unavailable for a particular platform.
     *
     * Example:
     *    __API_UNAVAILABLE(macos)
     *    __API_UNAVAILABLE(watchos, tvos)
     */
# 466 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
/*
 * If SPI decorations have not been defined elsewhere, disable them.
 */
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 1 3 4
/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.3 (Berkeley) 1/5/94
 */
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
/*
 * Basic integral types.  Omit the typedef if
 * not possible for a machine/compiler combination.
 */

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef signed char int8_t;
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef short int16_t;
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef int int32_t;
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef long long int64_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
/*
 * Copyright (c) 2016 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned char u_int8_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned short u_int16_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned int u_int32_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned long long u_int64_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4


typedef int64_t register_t;





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






typedef unsigned long uintptr_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4


/* These types are used for reserving the largest possible size. */

typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
/* This defines the size of syscall arguments after copying into the kernel: */



typedef u_int64_t syscall_arg_t;
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 2 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 2 3 4
typedef __darwin_clock_t clock_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_time_t time_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec; /* seconds after the minute [0-60] */
 int tm_min; /* minutes after the hour [0-59] */
 int tm_hour; /* hours since midnight [0-23] */
 int tm_mday; /* day of the month [1-31] */
 int tm_mon; /* months since January [0-11] */
 int tm_year; /* years since 1900 */
 int tm_wday; /* days since Sunday [0-6] */
 int tm_yday; /* days since January 1 [0-365] */
 int tm_isdst; /* Daylight Savings Time flag */
 long tm_gmtoff; /* offset from UTC in seconds */
 char *tm_zone; /* timezone abbreviation */
};
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);


/* [TSF] Thread safe functions */
char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,

_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,


_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,

_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,

_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,

_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,


_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,

_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16

} clockid_t;

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
/* ISO/IEC 9899:201x 7.27.2.5 The timespec_get function */

__attribute__((availability(macosx,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)))
int timespec_get(struct timespec *ts, int base);


}
# 50 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctime" 2
# 53 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ctime" 3


// FIXME:
// Apple SDKs don't define ::timespec_get unconditionally in C++ mode. This
// should be fixed in future SDKs, but for the time being we need to avoid
// trying to use that declaration when the SDK doesn't provide it. Note that
// we're detecting this here instead of in <__config> because we can't include
// system headers from <__config>, since it leads to circular module dependencies.
// This is also meant to be a very temporary workaround until the SDKs are fixed.







namespace std { inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;

using ::timespec;

using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;

using ::timespec_get;


} }
# 829 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 1
// -*- C++ -*-
//===---------------------------- ratio -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    ratio synopsis

namespace std
{

template <intmax_t N, intmax_t D = 1>
class ratio
{
public:
    static constexpr intmax_t num;
    static constexpr intmax_t den;
    typedef ratio<num, den> type;
};

// ratio arithmetic
template <class R1, class R2> using ratio_add = ...;
template <class R1, class R2> using ratio_subtract = ...;
template <class R1, class R2> using ratio_multiply = ...;
template <class R1, class R2> using ratio_divide = ...;

// ratio comparison
template <class R1, class R2> struct ratio_equal;
template <class R1, class R2> struct ratio_not_equal;
template <class R1, class R2> struct ratio_less;
template <class R1, class R2> struct ratio_less_equal;
template <class R1, class R2> struct ratio_greater;
template <class R1, class R2> struct ratio_greater_equal;

// convenience SI typedefs
typedef ratio<1, 1000000000000000000000000> yocto;  // not supported
typedef ratio<1,    1000000000000000000000> zepto;  // not supported
typedef ratio<1,       1000000000000000000> atto;
typedef ratio<1,          1000000000000000> femto;
typedef ratio<1,             1000000000000> pico;
typedef ratio<1,                1000000000> nano;
typedef ratio<1,                   1000000> micro;
typedef ratio<1,                      1000> milli;
typedef ratio<1,                       100> centi;
typedef ratio<1,                        10> deci;
typedef ratio<                       10, 1> deca;
typedef ratio<                      100, 1> hecto;
typedef ratio<                     1000, 1> kilo;
typedef ratio<                  1000000, 1> mega;
typedef ratio<               1000000000, 1> giga;
typedef ratio<            1000000000000, 1> tera;
typedef ratio<         1000000000000000, 1> peta;
typedef ratio<      1000000000000000000, 1> exa;
typedef ratio<   1000000000000000000000, 1> zetta;  // not supported
typedef ratio<1000000000000000000000000, 1> yotta;  // not supported

  // 20.11.5, ratio comparison
  template <class R1, class R2> inline constexpr bool ratio_equal_v
    = ratio_equal<R1, R2>::value;                                       // C++17
  template <class R1, class R2> inline constexpr bool ratio_not_equal_v
    = ratio_not_equal<R1, R2>::value;                                   // C++17
  template <class R1, class R2> inline constexpr bool ratio_less_v
    = ratio_less<R1, R2>::value;                                        // C++17
  template <class R1, class R2> inline constexpr bool ratio_less_equal_v
    = ratio_less_equal<R1, R2>::value;                                  // C++17
  template <class R1, class R2> inline constexpr bool ratio_greater_v
    = ratio_greater<R1, R2>::value;                                     // C++17
  template <class R1, class R2> inline constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<R1, R2>::value;                               // C++17
}
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 81 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 2
# 87 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 91 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 2 3


namespace std { inline namespace __1 {

// __static_gcd

template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};

// __static_lcm

template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
    static const intmax_t max = -min;

    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;

    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};

// Not actually used but left here in case needed in future maintenance
template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;

    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__ ((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;

    typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
# 317 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};



template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
# 344 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
# 379 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};



template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
# 414 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ratio" 3
// ratio_equal

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_equal
    : public bool_constant<((_R1::num == _R2::num && _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_not_equal
    : public bool_constant<((!ratio_equal<_R1, _R2>::value))> {};

// ratio_less

template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less
    : public bool_constant<((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_less_equal
    : public bool_constant<((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater
    : public bool_constant<((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__ ((__type_visibility__("default"))) ratio_greater_equal
    : public bool_constant<((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};


template <class _R1, class _R2>
inline constexpr bool ratio_equal_v
    = ratio_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_not_equal_v
    = ratio_not_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_v
    = ratio_less<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_less_equal_v
    = ratio_less_equal<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_v
    = ratio_greater<_R1, _R2>::value;

template <class _R1, class _R2>
inline constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<_R1, _R2>::value;


} }
# 831 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 2
# 836 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 840 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 2 3


namespace std { inline namespace __1 { inline namespace __fs { namespace filesystem {
struct _FilesystemClock;
} } } }


namespace std { inline namespace __1 {

namespace chrono
{

template <class _Rep, class _Period = ratio<1> > class __attribute__ ((__type_visibility__("default"))) duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

} // chrono

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};

namespace chrono {

// duration_cast

template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};


template <class _Rep>
inline constexpr bool treat_as_floating_point_v
    = treat_as_floating_point<_Rep>::value;


template <class _Rep>
struct __attribute__ ((__type_visibility__("default"))) duration_values
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr _Rep zero() noexcept {return _Rep(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr _Rep max() noexcept {return numeric_limits<_Rep>::max();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr _Rep min() noexcept {return numeric_limits<_Rep>::lowest();}
};


template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
floor(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t > __d)
        __t = __t - _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
ceil(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = duration_cast<_ToDuration>(__d);
    if (__t < __d)
        __t = __t + _ToDuration{1};
    return __t;
}

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
round(const duration<_Rep, _Period>& __d)
{
    _ToDuration __lower = floor<_ToDuration>(__d);
    _ToDuration __upper = __lower + _ToDuration{1};
    auto __lowerDiff = __d - __lower;
    auto __upperDiff = __upper - __d;
    if (__lowerDiff < __upperDiff)
        return __lower;
    if (__lowerDiff > __upperDiff)
        return __upper;
    return __lower.count() & 1 ? __upper : __lower;
}


// duration

template <class _Rep, class _Period>
class __attribute__ ((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");

    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);

        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul // __overflow == false
        {
            static const intmax_t value = _Xp * _Yp;
        };

        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };

    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };

public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr

        duration() = default;




    template <class _Rep2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<_Rep2, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = nullptr)
                : __rep_(__r) {}

    // conversions
    template <class _Rep2, class _Period2>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = nullptr)
                : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}

    // observer

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr rep count() const {return __rep_;}

    // arithmetic

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator++() {++__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration operator++(int) {return duration(__rep_++);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator--() {--__rep_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration operator--(int) {return duration(__rep_--);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator*=(const rep& rhs) {__rep_ *= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator/=(const rep& rhs) {__rep_ /= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator%=(const rep& rhs) {__rep_ %= rhs; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration& operator%=(const duration& rhs) {__rep_ %= rhs.count(); return *this;}

    // special values

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr duration zero() noexcept {return duration(duration_values<rep>::zero());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr duration min() noexcept {return duration(duration_values<rep>::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr duration max() noexcept {return duration(duration_values<rep>::max());}
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;






// Duration ==

template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}

// Duration !=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}

// Duration <

template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}

// Duration >

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}

// Duration <=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}

// Duration >=

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}

// Duration +

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}

// Duration -

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}

// Duration *

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}

// Duration /

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}

// Duration %

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}

//////////////////////////////////////////////////////////
///////////////////// time_point /////////////////////////
//////////////////////////////////////////////////////////

template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__ ((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr explicit time_point(const duration& __d) : __d_(__d) {}

    // conversions
    template <class _Duration2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    time_point(const time_point<clock, _Duration2>& t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = nullptr)
            : __d_(t.time_since_epoch()) {}

    // observer

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr duration time_since_epoch() const {return __d_;}

    // arithmetic

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}

    // special values

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr time_point min() noexcept {return time_point(duration::min());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) static constexpr time_point max() noexcept {return time_point(duration::max());}
};

} // chrono

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__ ((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}


template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
floor(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{floor<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
ceil(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{ceil<_ToDuration>(__t.time_since_epoch())};
}

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
round(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{round<_ToDuration>(__t.time_since_epoch())};
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename enable_if
<
    numeric_limits<_Rep>::is_signed,
    duration<_Rep, _Period>
>::type
abs(duration<_Rep, _Period> __d)
{
    return __d >= __d.zero() ? +__d : -__d;
}


// time_point ==

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}

// time_point !=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}

// time_point <

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}

// time_point >

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}

// time_point <=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}

// time_point >=

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}

// time_point operator+(time_point x, duration y);

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}

// time_point operator+(duration x, time_point y);

template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}

// time_point operator-(time_point x, duration y);

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}

// duration operator-(time_point x, time_point y);

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}

//////////////////////////////////////////////////////////
/////////////////////// clocks ///////////////////////////
//////////////////////////////////////////////////////////

class __attribute__ ((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;

    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};


class __attribute__ ((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;

    static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;
# 2835 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 3
} // chrono


// Suffixes for duration literals [time.duration.literals]
inline namespace literals
{
  inline namespace chrono_literals
  {

    constexpr chrono::hours operator""h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }

    constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }


    constexpr chrono::minutes operator""min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }

    constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }


    constexpr chrono::seconds operator""s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }

    constexpr chrono::duration<long double> operator""s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }


    constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }

    constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }


    constexpr chrono::microseconds operator""us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }

    constexpr chrono::duration<long double, micro> operator""us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }


    constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }

    constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }
# 2920 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/chrono" 3
}}

namespace chrono { // hoist the literals into namespace std::chrono
   using namespace literals::chrono_literals;
}



} }


namespace std { inline namespace __1 { inline namespace __fs { namespace filesystem {
struct _FilesystemClock {

  typedef __int128_t rep;
  typedef nano period;





  typedef chrono::duration<rep, period> duration;
  typedef chrono::time_point<_FilesystemClock> time_point;

  __attribute__((__visibility__("default")))
  static constexpr const bool is_steady = false;

                                  __attribute__ ((__visibility__("default"))) static time_point now() noexcept;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static time_t to_time_t(const time_point& __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_t(
          chrono::duration_cast<__secs>(__t.time_since_epoch()).count());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
  static time_point from_time_t(time_t __t) noexcept {
      typedef chrono::duration<rep> __secs;
      return time_point(__secs(__t));
  }
};
} } } }
# 16 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 1
// -*- C++ -*-
//===-------------------------- errno.h -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    errno.h synopsis

Macros:

    EDOM
    EILSEQ  // C99
    ERANGE
    errno

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 26 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 2
# 29 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 1 3
// -*- C++ -*-
//===-------------------------- errno.h -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 32 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 2 3
# 44 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 3
static const int __elast1 = 104;
static const int __elast2 = 105;
# 79 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 3
//  supply errno values likely to be missing, particularly on Windows
# 257 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/errno.h" 3
//  Windows Mobile doesn't appear to define these:
# 18 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 2
# 25 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 3
# 62 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 3
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 63 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 2 3

namespace std { inline namespace __1 {
# 808 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__threading_support" 3
} }
# 580 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 2
# 588 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
# 616 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
namespace std { inline namespace __1 {

// Figure out what the underlying type for `memory_order` would be if it were
// declared as an unscoped enum (accounting for -fshort-enums). Use this result
// to pin the underlying type in C++20.
enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};

typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
# 652 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
typedef enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
} memory_order;



template <typename _Tp> __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_nonatomic_compare_equal(_Tp const& __lhs, _Tp const& __rhs) {
    return std::__1::memcmp(&__lhs, &__rhs, sizeof(_Tp)) == 0;
}

static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
  "unexpected underlying type for std::memory_order");
# 948 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
template <typename _Tp>
struct __cxx_atomic_base_impl {

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))

    __cxx_atomic_base_impl() noexcept = default;



  constexpr explicit __cxx_atomic_base_impl(_Tp value) noexcept
    : __a_value(value) {}
  __extension__ _Atomic(_Tp) __a_value;
};



__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) inline
void __cxx_atomic_thread_fence(memory_order __order) noexcept {
    __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) inline
void __cxx_atomic_signal_fence(memory_order __order) noexcept {
    __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) noexcept {
    using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> * __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__failure));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}



template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp kill_dependency(_Tp __y) noexcept
{
    return __y;
}
# 1485 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp> >

struct __cxx_atomic_impl : public _Base {






  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __cxx_atomic_impl() noexcept = default;
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr explicit __cxx_atomic_impl(_Tp value) noexcept
    : _Base(value) {}
};




    using __cxx_contention_t = int64_t;


using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;



                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(void const volatile*);
                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(void const volatile*);
                          __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(void const volatile*);
                          __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(void const volatile*, __cxx_contention_t);

                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(__cxx_atomic_contention_t const volatile*);
                          __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(__cxx_atomic_contention_t const volatile*, __cxx_contention_t);

template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl {
    _Atp* __a;
    _Fn __test_fn;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool operator()(chrono::nanoseconds __elapsed) const
    {
        if(__elapsed > chrono::microseconds(64))
        {
            auto const __monitor = __libcpp_atomic_monitor(__a);
            if(__test_fn())
                return true;
            __libcpp_atomic_wait(__a, __monitor);
        }
        else if(__elapsed > chrono::microseconds(4))
            __libcpp_thread_yield();
        else
            {} // poll
        return false;
    }
};

template <class _Atp, class _Fn>

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool __cxx_atomic_wait(_Atp* __a, _Fn && __test_fn)
{
    __libcpp_atomic_wait_backoff_impl<_Atp, typename decay<_Fn>::type> __backoff_fn = {__a, __test_fn};
    return __libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
# 1564 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl {
    _Atp* __a;
    _Tp __val;
    memory_order __order;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool operator()() const
    {
        return !__cxx_nonatomic_compare_equal(__cxx_atomic_load(__a, __order), __val);
    }
};

template <class _Atp, class _Tp>

__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool __cxx_atomic_wait(_Atp* __a, _Tp const __val, memory_order __order)
{
    __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
    return __cxx_atomic_wait(__a, __test_fn);
}

// general atomic<T>

template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base // false
{
    mutable __cxx_atomic_impl<_Tp> __a_;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is_lock_free() const volatile noexcept
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    operator _Tp() const noexcept {return load();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {__cxx_atomic_wait(&__a_, __v, __m);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const noexcept
        {__cxx_atomic_wait(&__a_, __v, __m);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void notify_one() volatile noexcept
        {__cxx_atomic_notify_one(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void notify_one() noexcept
        {__cxx_atomic_notify_one(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void notify_all() volatile noexcept
        {__cxx_atomic_notify_all(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void notify_all() noexcept
        {__cxx_atomic_notify_all(&__a_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __atomic_base() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    __atomic_base(_Tp __d) noexcept : __a_(__d) {}


    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;
# 1695 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
};






// atomic<Integral>

template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __atomic_base() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};

// atomic<T>

template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    typedef _Tp value_type;
    typedef value_type difference_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}
};

// atomic<T*>

template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    typedef _Tp* value_type;
    typedef ptrdiff_t difference_type;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic() noexcept = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}
};

// atomic_is_lock_free

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}

// atomic_init

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_init(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_init(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __cxx_atomic_init(&__o->__a_, __d);
}

// atomic_store

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}

// atomic_store_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_store_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}

// atomic_load

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}

// atomic_load_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}

// atomic_exchange

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}

// atomic_exchange_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}

// atomic_compare_exchange_weak

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}

// atomic_compare_exchange_strong

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}

// atomic_compare_exchange_weak_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                      typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

// atomic_compare_exchange_strong_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                        typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((diagnose_if(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

// atomic_wait

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_wait(const volatile atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_wait(const atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}

// atomic_wait_explicit

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_wait_explicit(const volatile atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_wait_explicit(const atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((diagnose_if(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}

// atomic_notify_one

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_notify_one(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}
template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_notify_one(atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}

// atomic_notify_one

template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_notify_all(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}
template <class _Tp>
                          __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void atomic_notify_all(atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}

// atomic_fetch_add

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}

// atomic_fetch_add_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}

// atomic_fetch_sub

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}

// atomic_fetch_sub_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value && !is_const<_Tp>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, typename atomic<_Tp*>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}

// atomic_fetch_and

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}

// atomic_fetch_and_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}

// atomic_fetch_or

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}

// atomic_fetch_or_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}

// atomic_fetch_xor

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}

// atomic_fetch_xor_explicit

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}

// flag type and operations

typedef struct atomic_flag
{
    __cxx_atomic_impl<_LIBCPP_ATOMIC_FLAG_TYPE> __a_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test(memory_order __m = memory_order_seq_cst) const volatile noexcept
        {return _LIBCPP_ATOMIC_FLAG_TYPE(true) == __cxx_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test(memory_order __m = memory_order_seq_cst) const noexcept
        {return _LIBCPP_ATOMIC_FLAG_TYPE(true) == __cxx_atomic_load(&__a_, __m);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(true), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__cxx_atomic_store(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(false), __m);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__cxx_atomic_store(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(false), __m);}

                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {__cxx_atomic_wait(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(__v), __m);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const noexcept
        {__cxx_atomic_wait(&__a_, _LIBCPP_ATOMIC_FLAG_TYPE(__v), __m);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void notify_one() volatile noexcept
        {__cxx_atomic_notify_one(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void notify_one() noexcept
        {__cxx_atomic_notify_one(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void notify_all() volatile noexcept
        {__cxx_atomic_notify_all(&__a_);}
                              __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void notify_all() noexcept
        {__cxx_atomic_notify_all(&__a_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    atomic_flag() noexcept = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    atomic_flag(bool __b) noexcept : __a_(__b) {} // EXTENSION


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
# 2556 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
} atomic_flag;


inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test(const volatile atomic_flag* __o) noexcept
{
    return __o->test();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test(const atomic_flag* __o) noexcept
{
    return __o->test();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_explicit(const volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_explicit(const atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_wait(const volatile atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_wait(const atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_wait_explicit(const volatile atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_wait_explicit(const atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_notify_one(volatile atomic_flag* __o) noexcept
{
    __o->notify_one();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_notify_one(atomic_flag* __o) noexcept
{
    __o->notify_one();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_notify_all(volatile atomic_flag* __o) noexcept
{
    __o->notify_all();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_flag_notify_all(atomic_flag* __o) noexcept
{
    __o->notify_all();
}

// fences

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __cxx_atomic_thread_fence(__m);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __cxx_atomic_signal_fence(__m);
}

// Atomics for standard typedef types

typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;



typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;

// atomic_*_lock_free : prefer the contention type most highly, then the largest lock-free type
# 2781 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
typedef conditional<false, __cxx_contention_t, long long>::type __libcpp_signed_lock_free;
typedef conditional<false, __cxx_contention_t, unsigned long long>::type __libcpp_unsigned_lock_free;
# 2796 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/atomic" 3
typedef atomic<__libcpp_signed_lock_free> atomic_signed_lock_free;
typedef atomic<__libcpp_unsigned_lock_free> atomic_unsigned_lock_free;




} }
# 56 "SEAL/native/src/seal/util/locks.h" 2


namespace seal
{
    namespace util
    {
        struct try_to_lock_t
        {};

        constexpr try_to_lock_t try_to_lock{};

        class ReaderWriterLocker;

        class ReaderLock
        {
        public:
            ReaderLock() noexcept : locker_(nullptr)
            {}

            ReaderLock(ReaderLock &&move) noexcept : locker_(move.locker_)
            {
                move.locker_ = nullptr;
            }

            ReaderLock(ReaderWriterLocker &locker) noexcept : locker_(nullptr)
            {
                acquire(locker);
            }

            ReaderLock(ReaderWriterLocker &locker, try_to_lock_t) noexcept : locker_(nullptr)
            {
                try_acquire(locker);
            }

            ~ReaderLock() noexcept
            {
                unlock();
            }

                           inline bool owns_lock() const noexcept
            {
                return locker_ != nullptr;
            }

            void unlock() noexcept;

            inline void swap_with(ReaderLock &lock) noexcept
            {
                std::swap(locker_, lock.locker_);
            }

            inline ReaderLock &operator=(ReaderLock &&lock) noexcept
            {
                swap_with(lock);
                lock.unlock();
                return *this;
            }

        private:
            void acquire(ReaderWriterLocker &locker) noexcept;

            bool try_acquire(ReaderWriterLocker &locker) noexcept;

            ReaderWriterLocker *locker_;
        };

        class WriterLock
        {
        public:
            WriterLock() noexcept : locker_(nullptr)
            {}

            WriterLock(WriterLock &&move) noexcept : locker_(move.locker_)
            {
                move.locker_ = nullptr;
            }

            WriterLock(ReaderWriterLocker &locker) noexcept : locker_(nullptr)
            {
                acquire(locker);
            }

            WriterLock(ReaderWriterLocker &locker, try_to_lock_t) noexcept : locker_(nullptr)
            {
                try_acquire(locker);
            }

            ~WriterLock() noexcept
            {
                unlock();
            }

                           inline bool owns_lock() const noexcept
            {
                return locker_ != nullptr;
            }

            void unlock() noexcept;

            inline void swap_with(WriterLock &lock) noexcept
            {
                std::swap(locker_, lock.locker_);
            }

            inline WriterLock &operator=(WriterLock &&lock) noexcept
            {
                swap_with(lock);
                lock.unlock();
                return *this;
            }

        private:
            void acquire(ReaderWriterLocker &locker) noexcept;

            bool try_acquire(ReaderWriterLocker &locker) noexcept;

            ReaderWriterLocker *locker_;
        };

        class ReaderWriterLocker
        {
            friend class ReaderLock;

            friend class WriterLock;

        public:
            ReaderWriterLocker() noexcept : reader_locks_(0), writer_locked_(false)
            {}

                           inline ReaderLock acquire_read() noexcept
            {
                return ReaderLock(*this);
            }

                           inline WriterLock acquire_write() noexcept
            {
                return WriterLock(*this);
            }

                           inline ReaderLock try_acquire_read() noexcept
            {
                return ReaderLock(*this, try_to_lock);
            }

                           inline WriterLock try_acquire_write() noexcept
            {
                return WriterLock(*this, try_to_lock);
            }

        private:
            ReaderWriterLocker(const ReaderWriterLocker &copy) = delete;

            ReaderWriterLocker &operator=(const ReaderWriterLocker &assign) = delete;

            std::atomic<int> reader_locks_;

            std::atomic<bool> writer_locked_;
        };

        inline void ReaderLock::unlock() noexcept
        {
            if (locker_ == nullptr)
            {
                return;
            }
            locker_->reader_locks_.fetch_sub(1, std::memory_order_release);
            locker_ = nullptr;
        }

        inline void ReaderLock::acquire(ReaderWriterLocker &locker) noexcept
        {
            unlock();
            do
            {
                locker.reader_locks_.fetch_add(1, std::memory_order_acquire);
                locker_ = &locker;
                if (locker.writer_locked_.load(std::memory_order_acquire))
                {
                    unlock();
                    while (locker.writer_locked_.load(std::memory_order_acquire))
                        ;
                }
            } while (locker_ == nullptr);
        }

                       inline bool ReaderLock::try_acquire(ReaderWriterLocker &locker) noexcept
        {
            unlock();
            locker.reader_locks_.fetch_add(1, std::memory_order_acquire);
            locker_ = &locker;
            if (locker.writer_locked_.load(std::memory_order_acquire))
            {
                unlock();
                return false;
            }
            return true;
        }

        inline void WriterLock::acquire(ReaderWriterLocker &locker) noexcept
        {
            unlock();
            bool expected = false;
            while (!locker.writer_locked_.compare_exchange_strong(expected, true, std::memory_order_acquire))
            {
                expected = false;
            }
            locker_ = &locker;
            while (locker.reader_locks_.load(std::memory_order_acquire) != 0)
                ;
        }

                       inline bool WriterLock::try_acquire(ReaderWriterLocker &locker) noexcept
        {
            unlock();
            bool expected = false;
            if (!locker.writer_locked_.compare_exchange_strong(expected, true, std::memory_order_acquire))
            {
                return false;
            }
            locker_ = &locker;
            if (locker.reader_locks_.load(std::memory_order_acquire) != 0)
            {
                unlock();
                return false;
            }
            return true;
        }

        inline void WriterLock::unlock() noexcept
        {
            if (locker_ == nullptr)
            {
                return;
            }
            locker_->writer_locked_.store(false, std::memory_order_release);
            locker_ = nullptr;
        }
    } // namespace util
} // namespace seal
# 10 "SEAL/native/src/seal/util/mempool.h" 2
# 21 "SEAL/native/src/seal/util/mempool.h"
namespace seal
{
    namespace util
    {
        template <typename T = void, typename = std::enable_if_t<std::is_standard_layout<T>::value>>
        class ConstPointer;

        template <>
        class ConstPointer<seal_byte>;

        template <typename T = void, typename = std::enable_if_t<std::is_standard_layout<T>::value>>
        class Pointer;

        class MemoryPoolItem
        {
        public:
            MemoryPoolItem(seal_byte *data) noexcept : data_(data)
            {}

                           inline seal_byte *data() noexcept
            {
                return data_;
            }

                           inline const seal_byte *data() const noexcept
            {
                return data_;
            }

                           inline MemoryPoolItem *&next() noexcept
            {
                return next_;
            }

                           inline const MemoryPoolItem *next() const noexcept
            {
                return next_;
            }

        private:
            MemoryPoolItem(const MemoryPoolItem &copy) = delete;

            MemoryPoolItem &operator=(const MemoryPoolItem &assign) = delete;

            seal_byte *data_ = nullptr;

            MemoryPoolItem *next_ = nullptr;
        };

        class MemoryPoolHead
        {
        public:
            struct allocation
            {
                allocation() : size(0), data_ptr(nullptr), free(0), head_ptr(nullptr)
                {}

                // Size of the allocation (number of items it can hold)
                std::size_t size;

                // Pointer to start of the allocation
                seal_byte *data_ptr;

                // How much free space is left (number of items that still fit)
                std::size_t free;

                // Pointer to current head of allocation
                seal_byte *head_ptr;
            };

            // The overriding functions are noexcept(false)
            virtual ~MemoryPoolHead() = default;

            // Byte size of the allocations (items) owned by this pool
            virtual std::size_t item_byte_count() const noexcept = 0;

            // Total number of items allocated
            virtual std::size_t item_count() const noexcept = 0;

            virtual MemoryPoolItem *get() = 0;

            // Return item back to this pool
            virtual void add(MemoryPoolItem *new_first) noexcept = 0;
        };

        class MemoryPoolHeadMT : public MemoryPoolHead
        {
        public:
            // Creates a new MemoryPoolHeadMT with allocation for one single item.
            MemoryPoolHeadMT(std::size_t item_byte_count, bool clear_on_destruction = false);

            ~MemoryPoolHeadMT() noexcept override;

            // Byte size of the allocations (items) owned by this pool
                           inline std::size_t item_byte_count() const noexcept override
            {
                return item_byte_count_;
            }

            // Returns the total number of items allocated
                           inline std::size_t item_count() const noexcept override
            {
                return item_count_;
            }

            MemoryPoolItem *get() override;

            inline void add(MemoryPoolItem *new_first) noexcept override
            {
                bool expected = false;
                while (!locked_.compare_exchange_strong(expected, true, std::memory_order_acquire))
                {
                    expected = false;
                }
                MemoryPoolItem *old_first = first_item_;
                new_first->next() = old_first;
                first_item_ = new_first;
                locked_.store(false, std::memory_order_release);
            }

        private:
            MemoryPoolHeadMT(const MemoryPoolHeadMT &copy) = delete;

            MemoryPoolHeadMT &operator=(const MemoryPoolHeadMT &assign) = delete;

            const bool clear_on_destruction_;

            mutable std::atomic<bool> locked_;

            const std::size_t item_byte_count_;

            volatile std::size_t item_count_;

            std::vector<allocation> allocs_;

            MemoryPoolItem *volatile first_item_;
        };

        class MemoryPoolHeadST : public MemoryPoolHead
        {
        public:
            // Creates a new MemoryPoolHeadST with allocation for one single item.
            MemoryPoolHeadST(std::size_t item_byte_count, bool clear_on_destruction = false);

            ~MemoryPoolHeadST() noexcept override;

            // Byte size of the allocations (items) owned by this pool
                           inline std::size_t item_byte_count() const noexcept override
            {
                return item_byte_count_;
            }

            // Returns the total number of items allocated
                           inline std::size_t item_count() const noexcept override
            {
                return item_count_;
            }

                           MemoryPoolItem *get() override;

            inline void add(MemoryPoolItem *new_first) noexcept override
            {
                new_first->next() = first_item_;
                first_item_ = new_first;
            }

        private:
            MemoryPoolHeadST(const MemoryPoolHeadST &copy) = delete;

            MemoryPoolHeadST &operator=(const MemoryPoolHeadST &assign) = delete;

            const bool clear_on_destruction_;

            std::size_t item_byte_count_;

            std::size_t item_count_;

            std::vector<allocation> allocs_;

            MemoryPoolItem *first_item_;
        };

        class MemoryPool
        {
        public:
            static constexpr double alloc_size_multiplier = 1.05;

            // Largest size of single allocation that can be requested from memory pool
            static const std::size_t max_single_alloc_byte_count;

            // Number of different size allocations allowed by a single memory pool
            static constexpr std::size_t max_pool_head_count = (std::numeric_limits<std::size_t>::max)();

            // Largest allowed size of batch allocation
            static const std::size_t max_batch_alloc_byte_count;

            static constexpr std::size_t first_alloc_count = 1;

            virtual ~MemoryPool() = default;

            virtual Pointer<seal_byte> get_for_byte_count(std::size_t byte_count) = 0;

            virtual std::size_t pool_count() const = 0;

            virtual std::size_t alloc_byte_count() const = 0;
        };

        class MemoryPoolMT : public MemoryPool
        {
        public:
            MemoryPoolMT(bool clear_on_destruction = false) : clear_on_destruction_(clear_on_destruction){};

            ~MemoryPoolMT() noexcept override;

                           Pointer<seal_byte> get_for_byte_count(std::size_t byte_count) override;

                           inline std::size_t pool_count() const override
            {
                ReaderLock lock(pools_locker_.acquire_read());
                return pools_.size();
            }

                           std::size_t alloc_byte_count() const override;

        protected:
            MemoryPoolMT(const MemoryPoolMT &copy) = delete;

            MemoryPoolMT &operator=(const MemoryPoolMT &assign) = delete;

            const bool clear_on_destruction_;

            mutable ReaderWriterLocker pools_locker_;

            std::vector<MemoryPoolHead *> pools_;
        };

        class MemoryPoolST : public MemoryPool
        {
        public:
            MemoryPoolST(bool clear_on_destruction = false) : clear_on_destruction_(clear_on_destruction){};

            ~MemoryPoolST() noexcept override;

                           Pointer<seal_byte> get_for_byte_count(std::size_t byte_count) override;

                           inline std::size_t pool_count() const override
            {
                return pools_.size();
            }

            std::size_t alloc_byte_count() const override;

        protected:
            MemoryPoolST(const MemoryPoolST &copy) = delete;

            MemoryPoolST &operator=(const MemoryPoolST &assign) = delete;

            const bool clear_on_destruction_;

            std::vector<MemoryPoolHead *> pools_;
        };
    } // namespace util
} // namespace seal
# 9 "SEAL/native/src/seal/memorymanager.h" 2





/*
For .NET Framework wrapper support (C++/CLI) we need to
    (1) compile the MemoryManager class as thread-unsafe because C++
        mutexes cannot be brought through C++/CLI layer;
    (2) disable thread-safe memory pools.
*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 1
// -*- C++ -*-
//===--------------------------- mutex ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    mutex synopsis

namespace std
{

class mutex
{
public:
     constexpr mutex() noexcept;
     ~mutex();

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class recursive_mutex
{
public:
     recursive_mutex();
     ~recursive_mutex();

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle();
};

class timed_mutex
{
public:
     timed_mutex();
     ~timed_mutex();

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void lock();
    bool try_lock();
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

class recursive_timed_mutex
{
public:
     recursive_timed_mutex();
     ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void lock();
    bool try_lock() noexcept;
    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
};

struct defer_lock_t { explicit defer_lock_t() = default; };
struct try_to_lock_t { explicit try_to_lock_t() = default; };
struct adopt_lock_t { explicit adopt_lock_t() = default; };

inline constexpr defer_lock_t  defer_lock{};
inline constexpr try_to_lock_t try_to_lock{};
inline constexpr adopt_lock_t  adopt_lock{};

template <class Mutex>
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type& m);
    lock_guard(mutex_type& m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
};

template <class... MutexTypes>
class scoped_lock // C++17
{
public:
    using mutex_type = Mutex;  // If MutexTypes... consists of the single type Mutex

    explicit scoped_lock(MutexTypes&... m);
    scoped_lock(adopt_lock_t, MutexTypes&... m);
    ~scoped_lock();
    scoped_lock(scoped_lock const&) = delete;
    scoped_lock& operator=(scoped_lock const&) = delete;
private:
    tuple<MutexTypes&...> pm; // exposition only
};

template <class Mutex>
class unique_lock
{
public:
    typedef Mutex mutex_type;
    unique_lock() noexcept;
    explicit unique_lock(mutex_type& m);
    unique_lock(mutex_type& m, defer_lock_t) noexcept;
    unique_lock(mutex_type& m, try_to_lock_t);
    unique_lock(mutex_type& m, adopt_lock_t);
    template <class Clock, class Duration>
        unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
    template <class Rep, class Period>
        unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
    ~unique_lock();

    unique_lock(unique_lock const&) = delete;
    unique_lock& operator=(unique_lock const&) = delete;

    unique_lock(unique_lock&& u) noexcept;
    unique_lock& operator=(unique_lock&& u) noexcept;

    void lock();
    bool try_lock();

    template <class Rep, class Period>
        bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
        bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);

    void unlock();

    void swap(unique_lock& u) noexcept;
    mutex_type* release() noexcept;

    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;
};

template <class Mutex>
  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;

template <class L1, class L2, class... L3>
  int try_lock(L1&, L2&, L3&...);
template <class L1, class L2, class... L3>
  void lock(L1&, L2&, L3&...);

struct once_flag
{
    constexpr once_flag() noexcept;

    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
};

template<class Callable, class ...Args>
  void call_once(once_flag& flag, Callable&& func, Args&&... args);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 190 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/system_error" 1
// -*- C++ -*-
//===---------------------------- system_error ----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    system_error synopsis

namespace std
{

class error_category
{
public:
    virtual ~error_category() noexcept;

    constexpr error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    bool operator!=(const error_category& rhs) const noexcept;
    bool operator<(const error_category& rhs) const noexcept;
};

const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

template <class T> struct is_error_code_enum
    : public false_type {};

template <class T> struct is_error_condition_enum
    : public false_type {};

template <class _Tp>
inline constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value; // C++17

template <class _Tp>
inline constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value; // C++17

class error_code
{
public:
    // constructors:
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code(ErrorCodeEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;
};

// non-member functions:
bool operator<(const error_code& lhs, const error_code& rhs) noexcept;
template <class charT, class traits>
    basic_ostream<charT,traits>&
    operator<<(basic_ostream<charT,traits>& os, const error_code& ec);

class error_condition
{
public:
    // constructors:
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition(ErrorConditionEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const noexcept;
    explicit operator bool() const noexcept;
};

bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;

class system_error
    : public runtime_error
{
public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);

    const error_code& code() const noexcept;
    const char* what() const noexcept;
};

template <> struct is_error_condition_enum<errc>
    : true_type { }

error_code make_error_code(errc e) noexcept;
error_condition make_error_condition(errc e) noexcept;

// Comparison operators:
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;

template <> struct hash<std::error_code>;
template <> struct hash<std::error_condition>;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__errc" 1
// -*- C++ -*-
//===---------------------------- __errc ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    system_error synopsis

namespace std
{

enum class errc
{
    address_family_not_supported,       // EAFNOSUPPORT
    address_in_use,                     // EADDRINUSE
    address_not_available,              // EADDRNOTAVAIL
    already_connected,                  // EISCONN
    argument_list_too_long,             // E2BIG
    argument_out_of_domain,             // EDOM
    bad_address,                        // EFAULT
    bad_file_descriptor,                // EBADF
    bad_message,                        // EBADMSG
    broken_pipe,                        // EPIPE
    connection_aborted,                 // ECONNABORTED
    connection_already_in_progress,     // EALREADY
    connection_refused,                 // ECONNREFUSED
    connection_reset,                   // ECONNRESET
    cross_device_link,                  // EXDEV
    destination_address_required,       // EDESTADDRREQ
    device_or_resource_busy,            // EBUSY
    directory_not_empty,                // ENOTEMPTY
    executable_format_error,            // ENOEXEC
    file_exists,                        // EEXIST
    file_too_large,                     // EFBIG
    filename_too_long,                  // ENAMETOOLONG
    function_not_supported,             // ENOSYS
    host_unreachable,                   // EHOSTUNREACH
    identifier_removed,                 // EIDRM
    illegal_byte_sequence,              // EILSEQ
    inappropriate_io_control_operation, // ENOTTY
    interrupted,                        // EINTR
    invalid_argument,                   // EINVAL
    invalid_seek,                       // ESPIPE
    io_error,                           // EIO
    is_a_directory,                     // EISDIR
    message_size,                       // EMSGSIZE
    network_down,                       // ENETDOWN
    network_reset,                      // ENETRESET
    network_unreachable,                // ENETUNREACH
    no_buffer_space,                    // ENOBUFS
    no_child_process,                   // ECHILD
    no_link,                            // ENOLINK
    no_lock_available,                  // ENOLCK
    no_message_available,               // ENODATA
    no_message,                         // ENOMSG
    no_protocol_option,                 // ENOPROTOOPT
    no_space_on_device,                 // ENOSPC
    no_stream_resources,                // ENOSR
    no_such_device_or_address,          // ENXIO
    no_such_device,                     // ENODEV
    no_such_file_or_directory,          // ENOENT
    no_such_process,                    // ESRCH
    not_a_directory,                    // ENOTDIR
    not_a_socket,                       // ENOTSOCK
    not_a_stream,                       // ENOSTR
    not_connected,                      // ENOTCONN
    not_enough_memory,                  // ENOMEM
    not_supported,                      // ENOTSUP
    operation_canceled,                 // ECANCELED
    operation_in_progress,              // EINPROGRESS
    operation_not_permitted,            // EPERM
    operation_not_supported,            // EOPNOTSUPP
    operation_would_block,              // EWOULDBLOCK
    owner_dead,                         // EOWNERDEAD
    permission_denied,                  // EACCES
    protocol_error,                     // EPROTO
    protocol_not_supported,             // EPROTONOSUPPORT
    read_only_file_system,              // EROFS
    resource_deadlock_would_occur,      // EDEADLK
    resource_unavailable_try_again,     // EAGAIN
    result_out_of_range,                // ERANGE
    state_not_recoverable,              // ENOTRECOVERABLE
    stream_timeout,                     // ETIME
    text_file_busy,                     // ETXTBSY
    timed_out,                          // ETIMEDOUT
    too_many_files_open_in_system,      // ENFILE
    too_many_files_open,                // EMFILE
    too_many_links,                     // EMLINK
    too_many_symbolic_link_levels,      // ELOOP
    value_too_large,                    // EOVERFLOW
    wrong_protocol_type                 // EPROTOTYPE
};

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 104 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__errc" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cerrno" 1
// -*- C++ -*-
//===-------------------------- cerrno ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    cerrno synopsis

Macros:

    EDOM
    EILSEQ  // C99
    ERANGE
    errno

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 26 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cerrno" 2
# 30 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/cerrno" 3
# 105 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__errc" 2
# 108 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__errc" 3


namespace std { inline namespace __1 {

// Some error codes are not present on all platforms, so we provide equivalents
// for them:

//enum class errc
enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 9901,
    address_in_use = 9902,
    address_not_available = 9903,
    already_connected = 9904,
    argument_list_too_long = 9946,
    argument_out_of_domain = 9947,
    bad_address = 9948,
    bad_file_descriptor = 9949,
    bad_message = 9905,
    broken_pipe = 9950,
    connection_aborted = 9906,
    connection_already_in_progress = 9907,
    connection_refused = 9908,
    connection_reset = 9909,
    cross_device_link = 9951,
    destination_address_required = 9910,
    device_or_resource_busy = 9952,
    directory_not_empty = 9953,
    executable_format_error = 9954,
    file_exists = 9955,
    file_too_large = 9956,
    filename_too_long = 9957,
    function_not_supported = 9942,
    host_unreachable = 9911,
    identifier_removed = 9912,
    illegal_byte_sequence = 9945,
    inappropriate_io_control_operation = 9958,
    interrupted = 9959,
    invalid_argument = 9943,
    invalid_seek = 9960,
    io_error = 9961,
    is_a_directory = 9962,
    message_size = 9913,
    network_down = 9914,
    network_reset = 9915,
    network_unreachable = 9916,
    no_buffer_space = 9917,
    no_child_process = 9963,
    no_link = 9918,
    no_lock_available = 9964,

    no_message_available = 9919,



    no_message = 9920,
    no_protocol_option = 9921,
    no_space_on_device = 9965,

    no_stream_resources = 9922,



    no_such_device_or_address = 9966,
    no_such_device = 9967,
    no_such_file_or_directory = 9968,
    no_such_process = 9969,
    not_a_directory = 9970,
    not_a_socket = 9923,

    not_a_stream = 9924,



    not_connected = 9925,
    not_enough_memory = 9971,
    not_supported = 9926,
    operation_canceled = 9927,
    operation_in_progress = 9928,
    operation_not_permitted = 9972,
    operation_not_supported = 9929,
    operation_would_block = 9930,
    owner_dead = __elast1,
    permission_denied = 9973,
    protocol_error = 9932,
    protocol_not_supported = 9933,
    read_only_file_system = 9974,
    resource_deadlock_would_occur = 9975,
    resource_unavailable_try_again = 9976,
    result_out_of_range = 9944,
    state_not_recoverable = __elast2,

    stream_timeout = 9935,



    text_file_busy = 9936,
    timed_out = 9938,
    too_many_files_open_in_system = 9977,
    too_many_files_open = 9978,
    too_many_links = 9979,
    too_many_symbolic_link_levels = 9939,
    value_too_large = 9940,
    wrong_protocol_type = 9941
};


} }
# 146 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/system_error" 2
# 153 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/system_error" 3


namespace std { inline namespace __1 {

// is_error_code_enum

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;


// is_error_condition_enum

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };







class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;

// class error_category

class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__visibility__("default"))) error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr error_category() noexcept = default;

private:
    error_category(const error_category&);// = delete;
    error_category& operator=(const error_category&);// = delete;

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__ ((__visibility__("default"))) const error_category& system_category() noexcept;

class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

// error_code

class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

// system_error

class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    system_error(const system_error&) noexcept = default;
    ~system_error() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);

} }
# 16 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 2
# 22 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 26 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 2 3


namespace std { inline namespace __1 {
# 339 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 3
template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    _Rep __result_float = __d.count() * __ratio::num / __ratio::den;

    _Rep __result_max = numeric_limits<__ns_rep>::max();
    if (__result_float >= __result_max) {
        return nanoseconds::max();
    }

    _Rep __result_min = numeric_limits<__ns_rep>::min();
    if (__result_float <= __result_min) {
        return nanoseconds::min();
    }

    return nanoseconds(static_cast<__ns_rep>(__result_float));
}

template <class _Rep, class _Period>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    !is_floating_point<_Rep>::value,
    chrono::nanoseconds
>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d)
{
    using namespace chrono;
    if (__d.count() == 0) {
        return nanoseconds(0);
    }

    using __ratio = ratio_divide<_Period, nano>;
    using __ns_rep = nanoseconds::rep;
    __ns_rep __result_max = numeric_limits<__ns_rep>::max();
    if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
        return nanoseconds::max();
    }

    __ns_rep __result_min = numeric_limits<__ns_rep>::min();
    if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
        return nanoseconds::min();
    }

    __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
    if (__result == 0) {
        return nanoseconds(1);
    }

    return nanoseconds(__result);
}
# 525 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__mutex_base" 3
} }
# 191 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 2
# 202 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 206 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 2 3


namespace std { inline namespace __1 {
# 553 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag;



template<class _Callable, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void call_once(once_flag&, _Callable&&, _Args&&...);
# 573 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3
struct __attribute__ ((__type_visibility__("default"))) once_flag
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr
        once_flag() noexcept : __state_(0) {}




   typedef unsigned long _State_type;



private:
    once_flag(const once_flag&); // = delete;
    once_flag& operator=(const once_flag&); // = delete;

    _State_type __state_;


    template<class _Callable, class... _Args>
    friend
    void call_once(once_flag&, _Callable&&, _Args&&...);
# 605 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3
};



template <class _Fp>
class __call_once_param
{
    _Fp& __f_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit __call_once_param(_Fp& __f) : __f_(__f) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator()()
    {
        typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
        __execute(_Index());
    }

private:
    template <size_t ..._Indices>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __execute(__tuple_indices<_Indices...>)
    {
        std::__1::__invoke(std::__1::get<0>(std::__1::move(__f_)), std::__1::get<_Indices>(std::__1::move(__f_))...);
    }
};
# 652 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3
template <class _Fp>
void __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
__call_once_proxy(void* __vp)
{
    __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
    (*__p)();
}

__attribute__ ((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*,
                                  void (*)(void*));



template<class _Callable, class... _Args>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
{
    if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0))
    {
        typedef tuple<_Callable&&, _Args&&...> _Gp;
        _Gp __f(std::__1::forward<_Callable>(__func), std::__1::forward<_Args>(__args)...);
        __call_once_param<_Gp> __p(__f);
        __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
    }
}
# 707 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/mutex" 3
} }
# 22 "SEAL/native/src/seal/memorymanager.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/thread" 1
// -*- C++ -*-
//===--------------------------- thread -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*

    thread synopsis

namespace std
{

class thread
{
public:
    class id;
    typedef pthread_t native_handle_type;

    thread() noexcept;
    template <class F, class ...Args> explicit thread(F&& f, Args&&... args);
    ~thread();

    thread(const thread&) = delete;
    thread(thread&& t) noexcept;

    thread& operator=(const thread&) = delete;
    thread& operator=(thread&& t) noexcept;

    void swap(thread& t) noexcept;

    bool joinable() const noexcept;
    void join();
    void detach();
    id get_id() const noexcept;
    native_handle_type native_handle();

    static unsigned hardware_concurrency() noexcept;
};

void swap(thread& x, thread& y) noexcept;

class thread::id
{
public:
    id() noexcept;
};

bool operator==(thread::id x, thread::id y) noexcept;
bool operator!=(thread::id x, thread::id y) noexcept;
bool operator< (thread::id x, thread::id y) noexcept;
bool operator<=(thread::id x, thread::id y) noexcept;
bool operator> (thread::id x, thread::id y) noexcept;
bool operator>=(thread::id x, thread::id y) noexcept;

template<class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& out, thread::id id);

namespace this_thread
{

thread::id get_id() noexcept;

void yield() noexcept;

template <class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);

template <class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period>& rel_time);

}  // this_thread

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 86 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/thread" 2
# 103 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/thread" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 107 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/thread" 2 3
# 23 "SEAL/native/src/seal/memorymanager.h" 2


namespace seal
{
    /**
    Manages a shared pointer to a memory pool. Microsoft SEAL uses memory pools
    for improved performance due to the large number of memory allocations
    needed by the homomorphic encryption operations, and the underlying polynomial
    arithmetic. The library automatically creates a shared global memory pool
    that is used for all dynamic allocations by default, and the user can
    optionally create any number of custom memory pools to be used instead.

    @par Uses in Multi-Threaded Applications
    Sometimes the user might want to use specific memory pools for dynamic
    allocations in certain functions. For example, in heavily multi-threaded
    applications allocating concurrently from a shared memory pool might lead
    to significant performance issues due to thread contention. For these cases
    Microsoft SEAL provides overloads of the functions that take a MemoryPoolHandle
    as an additional argument, and uses the associated memory pool for all dynamic
    allocations inside the function. Whenever these functions are called, the
    user can then simply pass a thread-local MemoryPoolHandle to be used.

    @par Thread-Unsafe Memory Pools
    While memory pools are by default thread-safe, in some cases it suffices
    to have a memory pool be thread-unsafe. To get a little extra performance,
    the user can optionally create such thread-unsafe memory pools and use them
    just as they would use thread-safe memory pools.

    @par Initialized and Uninitialized Handles
    A MemoryPoolHandle has to be set to point either to the global memory pool,
    or to a new memory pool. If this is not done, the MemoryPoolHandle is
    said to be uninitialized, and cannot be used. Initialization simply means
    assigning MemoryPoolHandle::Global() or MemoryPoolHandle::New() to it.

    @par Managing Lifetime
    Internally, the MemoryPoolHandle wraps an std::shared_ptr pointing to
    a memory pool class. Thus, as long as a MemoryPoolHandle pointing to
    a particular memory pool exists, the pool stays alive. Classes such as
    Evaluator and Ciphertext store their own local copies of a MemoryPoolHandle
    to guarantee that the pool stays alive as long as the managing object
    itself stays alive. The global memory pool is implemented as a global
    std::shared_ptr to a memory pool class, and is thus expected to stay
    alive for the entire duration of the program execution. Note that it can
    be problematic to create other global objects that use the memory pool
    e.g. in their constructor, as one would have to ensure the initialization
    order of these global variables to be correct (i.e. global memory pool
    first).
    */
    class MemoryPoolHandle
    {
    public:
        /**
        Creates a new uninitialized MemoryPoolHandle.
        */
        MemoryPoolHandle() = default;

        /**
        Creates a MemoryPoolHandle pointing to a given MemoryPool object.
        */
        MemoryPoolHandle(std::shared_ptr<util::MemoryPool> pool) noexcept : pool_(std::move(pool))
        {}

        /**
        Creates a copy of a given MemoryPoolHandle. As a result, the created
        MemoryPoolHandle will point to the same underlying memory pool as the
        copied instance.


        @param[in] copy The MemoryPoolHandle to copy from
        */
        MemoryPoolHandle(const MemoryPoolHandle &copy) noexcept
        {
            operator=(copy);
        }

        /**
        Creates a new MemoryPoolHandle by moving a given one. As a result, the
        moved MemoryPoolHandle will become uninitialized.


        @param[in] source The MemoryPoolHandle to move from
        */
        MemoryPoolHandle(MemoryPoolHandle &&source) noexcept
        {
            operator=(std::move(source));
        }

        /**
        Overwrites the MemoryPoolHandle instance with the specified instance. As
        a result, the current MemoryPoolHandle will point to the same underlying
        memory pool as the assigned instance.

        @param[in] assign The MemoryPoolHandle instance to assign to the current
        instance
        */
        inline MemoryPoolHandle &operator=(const MemoryPoolHandle &assign) noexcept
        {
            pool_ = assign.pool_;
            return *this;
        }

        /**
        Moves a specified MemoryPoolHandle instance to the current instance. As
        a result, the assigned MemoryPoolHandle will become uninitialized.

        @param[in] assign The MemoryPoolHandle instance to assign to the current
        instance
        */
        inline MemoryPoolHandle &operator=(MemoryPoolHandle &&assign) noexcept
        {
            pool_ = std::move(assign.pool_);
            return *this;
        }

        /**
        Returns a MemoryPoolHandle pointing to the global memory pool.
        */
                       inline static MemoryPoolHandle Global() noexcept
        {
            return util::global_variables::global_memory_pool;
        }

        /**
        Returns a MemoryPoolHandle pointing to the thread-local memory pool.
        */
                       inline static MemoryPoolHandle ThreadLocal() noexcept
        {
            return util::global_variables::tls_memory_pool;
        }

        /**
        Returns a MemoryPoolHandle pointing to a new thread-safe memory pool.

        @param[in] clear_on_destruction Indicates whether the memory pool data
        should be cleared when destroyed. This can be important when memory pools
        are used to store private data.
        */
                       inline static MemoryPoolHandle New(bool clear_on_destruction = false)
        {
            return MemoryPoolHandle(std::make_shared<util::MemoryPoolMT>(clear_on_destruction));
        }

        /**
        Returns a reference to the internal memory pool that the MemoryPoolHandle
        points to. This function is mainly for internal use.

        @throws std::logic_error if the MemoryPoolHandle is uninitialized
        */
                       inline operator util::MemoryPool &() const
        {
            if (!pool_)
            {
                throw std::logic_error("pool not initialized");
            }
            return *pool_.get();
        }

        /**
        Returns the number of different allocation sizes. This function returns
        the number of different allocation sizes the memory pool pointed to by
        the current MemoryPoolHandle has made. For example, if the memory pool has
        only allocated two allocations of sizes 128 KB, this function returns 1.
        If it has instead allocated one allocation of size 64 KB and one of 128 KB,
        this function returns 2.
        */
                       inline std::size_t pool_count() const noexcept
        {
            return !pool_ ? std::size_t(0) : pool_->pool_count();
        }

        /**
        Returns the size of allocated memory. This functions returns the total
        amount of memory (in bytes) allocated by the memory pool pointed to by
        the current MemoryPoolHandle.
        */
                       inline std::size_t alloc_byte_count() const noexcept
        {
            return !pool_ ? std::size_t(0) : pool_->alloc_byte_count();
        }

        /**
        Returns the number of MemoryPoolHandle objects sharing this memory pool.
        */
                       inline long use_count() const noexcept
        {
            return !pool_ ? 0 : pool_.use_count();
        }

        /**
        Returns whether the MemoryPoolHandle is initialized.
        */
                       inline explicit operator bool() const noexcept
        {
            return pool_.operator bool();
        }

        /**
        Compares MemoryPoolHandles. This function returns whether the current
        MemoryPoolHandle points to the same memory pool as a given MemoryPoolHandle.
        */
        inline bool operator==(const MemoryPoolHandle &compare) noexcept
        {
            return pool_ == compare.pool_;
        }

        /**
        Compares MemoryPoolHandles. This function returns whether the current
        MemoryPoolHandle points to a different memory pool than a given
        MemoryPoolHandle.
        */
        inline bool operator!=(const MemoryPoolHandle &compare) noexcept
        {
            return pool_ != compare.pool_;
        }

    private:
        std::shared_ptr<util::MemoryPool> pool_ = nullptr;
    };

    using mm_prof_opt_t = std::uint64_t;

    /**
    Control options for MemoryManager::GetPool function. These force the MemoryManager
    to override the current MMProf and instead return a MemoryPoolHandle pointing
    to a memory pool of the indicated type.
    */
    enum mm_prof_opt : mm_prof_opt_t
    {
        mm_default = 0x0,
        mm_force_global = 0x1,
        mm_force_new = 0x2,
        mm_force_thread_local = 0x4
    };

    /**
    The MMProf is a pure virtual class that every profile for the MemoryManager
    should inherit from. The only functionality this class implements is the
    get_pool(mm_prof_opt_t) function that returns a MemoryPoolHandle pointing
    to a pool selected by internal logic optionally using the input parameter
    of type mm_prof_opt_t. The returned MemoryPoolHandle must point to a valid
    memory pool.
    */
    class MMProf
    {
    public:
        /**
        Creates a new MMProf.
        */
        MMProf() = default;

        /**
        Destroys the MMProf.
        */
        virtual ~MMProf() noexcept
        {}

        /**
        Returns a MemoryPoolHandle pointing to a pool selected by internal logic
        in a derived class and by the mm_prof_opt_t input parameter.

        */
        virtual MemoryPoolHandle get_pool(mm_prof_opt_t) = 0;

    private:
    };

    /**
    A memory manager profile that always returns a MemoryPoolHandle pointing to
    the global memory pool. Microsoft SEAL uses this memory manager profile by default.
    */
    class MMProfGlobal : public MMProf
    {
    public:
        /**
        Creates a new MMProfGlobal.
        */
        MMProfGlobal() = default;

        /**
        Destroys the MMProfGlobal.
        */
        virtual ~MMProfGlobal() noexcept override
        {}

        /**
        Returns a MemoryPoolHandle pointing to the global memory pool. The
        mm_prof_opt_t input parameter has no effect.
        */
                       inline virtual MemoryPoolHandle get_pool(mm_prof_opt_t) override
        {
            return MemoryPoolHandle::Global();
        }

    private:
    };

    /**
    A memory manager profile that always returns a MemoryPoolHandle pointing to
    the new thread-safe memory pool. This profile should not be used except in
    special circumstances, as it does not result in any reuse of allocated memory.
    */
    class MMProfNew : public MMProf
    {
    public:
        /**
        Creates a new MMProfNew.
        */
        MMProfNew() = default;

        /**
        Destroys the MMProfNew.
        */
        virtual ~MMProfNew() noexcept override
        {}

        /**
        Returns a MemoryPoolHandle pointing to a new thread-safe memory pool. The
        mm_prof_opt_t input parameter has no effect.
        */
                       inline virtual MemoryPoolHandle get_pool(mm_prof_opt_t) override
        {
            return MemoryPoolHandle::New();
        }

    private:
    };

    /**
    A memory manager profile that always returns a MemoryPoolHandle pointing to
    specific memory pool.
    */
    class MMProfFixed : public MMProf
    {
    public:
        /**
        Creates a new MMProfFixed. The MemoryPoolHandle given as argument is returned
        by every call to get_pool(mm_prof_opt_t).

        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if pool is uninitialized
        */
        MMProfFixed(MemoryPoolHandle pool) : pool_(std::move(pool))
        {
            if (!pool_)
            {
                throw std::invalid_argument("pool is uninitialized");
            }
        }

        /**
        Destroys the MMProfFixed.
        */
        virtual ~MMProfFixed() noexcept override
        {}

        /**
        Returns a MemoryPoolHandle pointing to the stored memory pool. The
        mm_prof_opt_t input parameter has no effect.
        */
                       inline virtual MemoryPoolHandle get_pool(mm_prof_opt_t) override
        {
            return pool_;
        }

    private:
        MemoryPoolHandle pool_;
    };

    /**
    A memory manager profile that always returns a MemoryPoolHandle pointing to
    the thread-local memory pool. This profile should be used with care, as any
    memory allocated by it will be released once the thread exits. In other words,
    the thread-local memory pool cannot be used to share memory across different
    threads. On the other hand, this profile can be useful when a very high number
    of threads doing simultaneous allocations would cause contention in the
    global memory pool.
    */
    class MMProfThreadLocal : public MMProf
    {
    public:
        /**
        Creates a new MMProfThreadLocal.
        */
        MMProfThreadLocal() = default;

        /**
        Destroys the MMProfThreadLocal.
        */
        virtual ~MMProfThreadLocal() noexcept override
        {}

        /**
        Returns a MemoryPoolHandle pointing to the thread-local memory pool. The
        mm_prof_opt_t input parameter has no effect.
        */
                       inline virtual MemoryPoolHandle get_pool(mm_prof_opt_t) override
        {
            return MemoryPoolHandle::ThreadLocal();
        }

    private:
    };

    /**
    The MemoryManager class can be used to create instances of MemoryPoolHandle
    based on a given "profile". A profile is implemented by inheriting from the
    MMProf class (pure virtual) and encapsulates internal logic for deciding which
    memory pool to use.
    */
    class MemoryManager
    {
        friend class MMProfGuard;

    public:
        MemoryManager() = delete;

        /**
        Sets the current profile to a given one and returns a unique_ptr pointing
        to the previously set profile.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::invalid_argument if mm_prof is nullptr
        */
        static inline std::unique_ptr<MMProf> SwitchProfile(MMProf *&&mm_prof) noexcept
        {

            std::lock_guard<std::mutex> switching_lock(switch_mutex_);

            return SwitchProfileThreadUnsafe(std::move(mm_prof));
        }

        /**
        Sets the current profile to a given one and returns a unique_ptr pointing
        to the previously set profile.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::invalid_argument if mm_prof is nullptr
        */
        static inline std::unique_ptr<MMProf> SwitchProfile(std::unique_ptr<MMProf> &&mm_prof) noexcept
        {

            std::lock_guard<std::mutex> switch_lock(switch_mutex_);

            return SwitchProfileThreadUnsafe(std::move(mm_prof));
        }

        /**
        Returns a MemoryPoolHandle according to the currently set memory manager
        profile and prof_opt. The following values for prof_opt have an effect
        independent of the current profile:

            mm_prof_opt::force_new: return MemoryPoolHandle::New()
            mm_prof_opt::force_global: return MemoryPoolHandle::Global()
            mm_prof_opt::force_thread_local: return MemoryPoolHandle::ThreadLocal()

        Other values for prof_opt are forwarded to the current profile and, depending
        on the profile, may or may not have an effect. The value mm_prof_opt::default
        will always invoke a default behavior for the current profile.

        @param[in] prof_opt A mm_prof_opt_t parameter used to provide additional
        instructions to the memory manager profile for internal logic.
        */
        template <typename... Args>
                       static inline MemoryPoolHandle GetPool(mm_prof_opt_t prof_opt, Args &&...args)
        {
            switch (prof_opt)
            {
            case mm_prof_opt::mm_force_global:
                return MemoryPoolHandle::Global();

            case mm_prof_opt::mm_force_new:
                return MemoryPoolHandle::New(std::forward<Args>(args)...);

            case mm_prof_opt::mm_force_thread_local:
                return MemoryPoolHandle::ThreadLocal();

            default:
# 510 "SEAL/native/src/seal/memorymanager.h"
                return GetMMProf()->get_pool(prof_opt);
            }
        }

                       static inline MemoryPoolHandle GetPool()
        {
            return GetPool(mm_prof_opt::mm_default);
        }

    private:
                       static inline std::unique_ptr<MMProf> SwitchProfileThreadUnsafe(MMProf *&&mm_prof)
        {
            if (!mm_prof)
            {
                throw std::invalid_argument("mm_prof cannot be null");
            }
            auto ret_mm_prof = std::move(GetMMProf());
            GetMMProf().reset(mm_prof);
            return ret_mm_prof;
        }

                       static inline std::unique_ptr<MMProf> SwitchProfileThreadUnsafe(
            std::unique_ptr<MMProf> &&mm_prof)
        {
            if (!mm_prof)
            {
                throw std::invalid_argument("mm_prof cannot be null");
            }
            std::swap(GetMMProf(), mm_prof);
            return std::move(mm_prof);
        }

                       static inline std::unique_ptr<MMProf> &GetMMProf()
        {
            static std::unique_ptr<MMProf> mm_prof{ new MMProfGlobal };
            return mm_prof;
        }

        static std::mutex switch_mutex_;

    };

    /**
    Class for a scoped switch of memory manager profile. This class acts as a scoped
    "guard" for changing the memory manager profile so that the programmer does
    not have to explicitly switch back afterwards and that other threads cannot
    change the MMProf. It can also help with exception safety by guaranteeing that
    the profile is switched back to the original if a function throws an exception
    after changing the profile for local use.
    */
    class MMProfGuard
    {
    public:
        /**
        Creates a new MMProfGuard. If start_locked is true, this function will
        attempt to lock the MemoryManager for profile switch to mm_prof, perform
        the switch, and keep the lock until unlocked or destroyed. If start_lock
        is false, mm_prof will be stored but the switch will not be performed and
        a lock will not be obtained until lock() is explicitly called.

        @param[in] mm_prof Pointer to a new memory manager profile
        @param[in] start_locked Bool indicating whether the lock should be
        immediately obtained (true by default)
        */
        MMProfGuard(std::unique_ptr<MMProf> &&mm_prof, bool start_locked = true) noexcept
            : mm_switch_lock_(MemoryManager::switch_mutex_, std::defer_lock)
        {
            if (start_locked)
            {
                lock(std::move(mm_prof));
            }
            else
            {
                old_prof_ = std::move(mm_prof);
            }
        }

        /**
        Creates a new MMProfGuard. If start_locked is true, this function will
        attempt to lock the MemoryManager for profile switch to mm_prof, perform
        the switch, and keep the lock until unlocked or destroyed. If start_lock
        is false, mm_prof will be stored but the switch will not be performed and
        a lock will not be obtained until lock() is explicitly called.

        @param[in] mm_prof Pointer to a new memory manager profile
        @param[in] start_locked Bool indicating whether the lock should be
        immediately obtained (true by default)
        */
        MMProfGuard(MMProf *&&mm_prof, bool start_locked = true) noexcept
            : mm_switch_lock_(MemoryManager::switch_mutex_, std::defer_lock)
        {
            if (start_locked)
            {
                lock(std::move(mm_prof));
            }
            else
            {
                old_prof_.reset(std::move(mm_prof));
            }
        }

        /**
        Attempts to lock the MemoryManager for profile switch, perform the switch
        to currently stored memory manager profile, store the previously held profile,
        and keep the lock until unlocked or destroyed. If the lock cannot be obtained
        on the first attempt, the function returns false; otherwise returns true.

        @throws std::runtime_error if the lock is already owned
        */
        inline bool try_lock()
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            if (!mm_switch_lock_.try_lock())
            {
                return false;
            }
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(old_prof_));
            return true;
        }

        /**
        Locks the MemoryManager for profile switch, performs the switch to currently
        stored memory manager profile, stores the previously held profile, and
        keep the lock until unlocked or destroyed. The calling thread will block
        until the lock can be obtained.

        @throws std::runtime_error if the lock is already owned
        */



            inline void lock()
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            mm_switch_lock_.lock();
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(old_prof_));
        }

        /**
        Attempts to lock the MemoryManager for profile switch, perform the switch
        to the given memory manager profile, store the previously held profile,
        and keep the lock until unlocked or destroyed. If the lock cannot be
        obtained on the first attempt, the function returns false; otherwise
        returns true.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::runtime_error if the lock is already owned
        */
        inline bool try_lock(std::unique_ptr<MMProf> &&mm_prof)
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            if (!mm_switch_lock_.try_lock())
            {
                return false;
            }
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(mm_prof));
            return true;
        }

        /**
        Locks the MemoryManager for profile switch, performs the switch to the given
        memory manager profile, stores the previously held profile, and keep the
        lock until unlocked or destroyed. The calling thread will block until the
        lock can be obtained.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::runtime_error if the lock is already owned
        */



            inline void lock(std::unique_ptr<MMProf> &&mm_prof)
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            mm_switch_lock_.lock();
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(mm_prof));
        }

        /**
        Attempts to lock the MemoryManager for profile switch, perform the switch
        to the given memory manager profile, store the previously held profile,
        and keep the lock until unlocked or destroyed. If the lock cannot be
        obtained on the first attempt, the function returns false; otherwise returns
        true.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::runtime_error if the lock is already owned
        */
        inline bool try_lock(MMProf *&&mm_prof)
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            if (!mm_switch_lock_.try_lock())
            {
                return false;
            }
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(mm_prof));
            return true;
        }

        /**
        Locks the MemoryManager for profile switch, performs the switch to the
        given memory manager profile, stores the previously held profile, and keep
        the lock until unlocked or destroyed. The calling thread will block until
        the lock can be obtained.

        @param[in] mm_prof Pointer to a new memory manager profile
        @throws std::runtime_error if the lock is already owned
        */



            inline void lock(MMProf *&&mm_prof)
        {
            if (mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is already owned");
            }
            mm_switch_lock_.lock();
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(mm_prof));
        }

        /**
        Releases the memory manager profile switch lock for MemoryManager, stores
        the current profile, and resets the profile to the one used before locking.

        @throws std::runtime_error if the lock is not owned
        */



            inline void unlock()
        {
            if (!mm_switch_lock_.owns_lock())
            {
                throw std::runtime_error("lock is not owned");
            }
            old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(old_prof_));
            mm_switch_lock_.unlock();
        }

        /**
        Destroys the MMProfGuard. If the memory manager profile switch lock is
        owned, releases the lock, and resets the profile to the one used before
        locking.
        */
        ~MMProfGuard()
        {
            if (mm_switch_lock_.owns_lock())
            {
                old_prof_ = MemoryManager::SwitchProfileThreadUnsafe(std::move(old_prof_));
                mm_switch_lock_.unlock();
            }
        }

        /**
        Returns whether the current MMProfGuard owns the memory manager profile
        switch lock.
        */
        inline bool owns_lock() noexcept
        {
            return mm_switch_lock_.owns_lock();
        }

    private:
        std::unique_ptr<MMProf> old_prof_;

        std::unique_lock<std::mutex> mm_switch_lock_;
    };

} // namespace seal
# 7 "SEAL/native/src/seal/encryptionparams.h" 2
# 1 "SEAL/native/src/seal/modulus.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/serialization.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/version.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.






namespace seal
{
    /**
    Holds Microsoft SEAL version information. A SEALVersion contains four values:

        1. The major version number;
        2. The minor version number;
        3. The patch version number;
        4. The tweak version number.

    Two versions of the library with the same major and minor versions are fully
    compatible with each other. They are guaranteed to have the same public API.
    Changes in the patch version number indicate totally internal changes, such
    as bug fixes that require no changes to the public API. The tweak version
    number is currently not used, and is expected to be 0.
    */
    struct SEALVersion
    {
        /**
        Holds the major version number.
        */
        std::uint8_t major = SEAL_VERSION_MAJOR;

        /**
        Holds the minor version number.
        */
        std::uint8_t minor = SEAL_VERSION_MINOR;

        /**
        Holds the patch version number.
        */
        std::uint8_t patch = SEAL_VERSION_PATCH;

        std::uint8_t tweak = 0;
    };
} // namespace seal
# 7 "SEAL/native/src/seal/serialization.h" 2




# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 1
// -*- C++ -*-
//===--------------------------- iostream ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    iostream synopsis

#include <ios>
#include <streambuf>
#include <istream>
#include <ostream>

namespace std {

extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;
extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 37 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 1
// -*- C++ -*-
//===---------------------------- ios -------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    ios synopsis

#include <iosfwd>

namespace std
{

typedef OFF_T streamoff;
typedef SZ_T streamsize;
template <class stateT> class fpos;

class ios_base
{
public:
    class failure;

    typedef T1 fmtflags;
    static constexpr fmtflags boolalpha;
    static constexpr fmtflags dec;
    static constexpr fmtflags fixed;
    static constexpr fmtflags hex;
    static constexpr fmtflags internal;
    static constexpr fmtflags left;
    static constexpr fmtflags oct;
    static constexpr fmtflags right;
    static constexpr fmtflags scientific;
    static constexpr fmtflags showbase;
    static constexpr fmtflags showpoint;
    static constexpr fmtflags showpos;
    static constexpr fmtflags skipws;
    static constexpr fmtflags unitbuf;
    static constexpr fmtflags uppercase;
    static constexpr fmtflags adjustfield;
    static constexpr fmtflags basefield;
    static constexpr fmtflags floatfield;

    typedef T2 iostate;
    static constexpr iostate badbit;
    static constexpr iostate eofbit;
    static constexpr iostate failbit;
    static constexpr iostate goodbit;

    typedef T3 openmode;
    static constexpr openmode app;
    static constexpr openmode ate;
    static constexpr openmode binary;
    static constexpr openmode in;
    static constexpr openmode out;
    static constexpr openmode trunc;

    typedef T4 seekdir;
    static constexpr seekdir beg;
    static constexpr seekdir cur;
    static constexpr seekdir end;

    class Init;

    // 27.5.2.2 fmtflags state:
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);

    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);

    // 27.5.2.3 locales:
    locale imbue(const locale& loc);
    locale getloc() const;

    // 27.5.2.5 storage:
    static int xalloc();
    long& iword(int index);
    void*& pword(int index);

    // destructor
    virtual ~ios_base();

    // 27.5.2.6 callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int index);
    void register_callback(event_callback fn, int index);

    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

    static bool sync_with_stdio(bool sync = true);

protected:
    ios_base();
};

template <class charT, class traits = char_traits<charT> >
class basic_ios
    : public ios_base
{
public:
    // types:
    typedef charT char_type;
    typedef typename traits::int_type int_type;  // removed in C++17
    typedef typename traits::pos_type pos_type;  // removed in C++17
    typedef typename traits::off_type off_type;  // removed in C++17
    typedef traits traits_type;

    operator unspecified-bool-type() const;
    bool operator!() const;
    iostate rdstate() const;
    void clear(iostate state = goodbit);
    void setstate(iostate state);
    bool good() const;
    bool eof() const;
    bool fail() const;
    bool bad() const;

    iostate exceptions() const;
    void exceptions(iostate except);

    // 27.5.4.1 Constructor/destructor:
    explicit basic_ios(basic_streambuf<charT,traits>* sb);
    virtual ~basic_ios();

    // 27.5.4.2 Members:
    basic_ostream<charT,traits>* tie() const;
    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

    basic_streambuf<charT,traits>* rdbuf() const;
    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

    basic_ios& copyfmt(const basic_ios& rhs);

    char_type fill() const;
    char_type fill(char_type ch);

    locale imbue(const locale& loc);

    char narrow(char_type c, char dfault) const;
    char_type widen(char c) const;

    basic_ios(const basic_ios& ) = delete;
    basic_ios& operator=(const basic_ios&) = delete;

protected:
    basic_ios();
    void init(basic_streambuf<charT,traits>* sb);
    void move(basic_ios& rhs);
    void swap(basic_ios& rhs) noexcept;
    void set_rdbuf(basic_streambuf<charT, traits>* sb);
};

// 27.5.5, manipulators:
ios_base& boolalpha (ios_base& str);
ios_base& noboolalpha(ios_base& str);
ios_base& showbase (ios_base& str);
ios_base& noshowbase (ios_base& str);
ios_base& showpoint (ios_base& str);
ios_base& noshowpoint(ios_base& str);
ios_base& showpos (ios_base& str);
ios_base& noshowpos (ios_base& str);
ios_base& skipws (ios_base& str);
ios_base& noskipws (ios_base& str);
ios_base& uppercase (ios_base& str);
ios_base& nouppercase(ios_base& str);
ios_base& unitbuf (ios_base& str);
ios_base& nounitbuf (ios_base& str);

// 27.5.5.2 adjustfield:
ios_base& internal (ios_base& str);
ios_base& left (ios_base& str);
ios_base& right (ios_base& str);

// 27.5.5.3 basefield:
ios_base& dec (ios_base& str);
ios_base& hex (ios_base& str);
ios_base& oct (ios_base& str);

// 27.5.5.4 floatfield:
ios_base& fixed (ios_base& str);
ios_base& scientific (ios_base& str);
ios_base& hexfloat (ios_base& str);
ios_base& defaultfloat(ios_base& str);

// 27.5.5.5 error reporting:
enum class io_errc
{
    stream = 1
};

concept_map ErrorCodeEnum<io_errc> { };
error_code make_error_code(io_errc e) noexcept;
error_condition make_error_condition(io_errc e) noexcept;
storage-class-specifier const error_category& iostream_category() noexcept;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 214 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 1
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 14 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 2







# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale.h" 1
// -*- C++ -*-
//===---------------------------- locale.h --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    locale.h synopsis

Macros:

    LC_ALL
    LC_COLLATE
    LC_CTYPE
    LC_MONETARY
    LC_NUMERIC
    LC_TIME

Types:

    lconv

Functions:

   setlocale
   localeconv

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 37 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale.h" 2
# 44 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale.h" 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 1 3
// -*- C++ -*-
//===---------------------------- locale.h --------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 47 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale.h" 2 3
# 22 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 2
# 40 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 1 3 4
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $
 */







struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 2 3 4

extern "C" {
struct lconv *localeconv(void);
}
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 1 3 4
/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */






struct _xlocale; /* forward reference */
typedef struct _xlocale * locale_t;

extern "C" {
int ___mb_cur_max(void);
int ___mb_cur_max_l(locale_t);
}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 1 3 4
/*
 * Copyright (c) 2005, 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 2 3 4



extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l" ) __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l" ) __attribute__((__format__ (__strftime__, 2, 0)));
}
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 41 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 2
# 52 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3


namespace std { inline namespace __1 {
# 113 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
class __attribute__ ((__visibility__("default"))) locale;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
has_facet(const locale&) noexcept;

template <class _Facet>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
const _Facet&
use_facet(const locale&);

class __attribute__ ((__visibility__("default"))) locale
{
public:
    // types:
    class __attribute__ ((__visibility__("default"))) facet;
    class __attribute__ ((__visibility__("default"))) id;

    typedef int category;

    static const category // values assigned here are for exposition only
        none = 0,
        collate = (1 << 0),
        ctype = (1 << 1),
        monetary = (1 << 3),
        numeric = (1 << 4),
        time = (1 << 5),
        messages = (1 << 2),
        all = collate | ctype | monetary | numeric | time | messages;

    // construct/copy/destroy:
    locale() noexcept;
    locale(const locale&) noexcept;
    explicit locale(const char*);
    explicit locale(const string&);
    locale(const locale&, const char*, category);
    locale(const locale&, const string&, category);
    template <class _Facet>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) locale(const locale&, _Facet*);
    locale(const locale&, const locale&, category);

    ~locale();

    const locale& operator=(const locale&) noexcept;

    template <class _Facet>
      inline __attribute__ ((__visibility__("hidden")))
      locale combine(const locale&) const;

    // locale operations:
    string name() const;
    bool operator==(const locale&) const;
    bool operator!=(const locale& __y) const {return !(*this == __y);}
    template <class _CharT, class _Traits, class _Allocator>
      inline __attribute__ ((__visibility__("hidden")))
      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,
                      const basic_string<_CharT, _Traits, _Allocator>&) const;

    // global locale objects:
    static locale global(const locale&);
    static const locale& classic();

private:
    class __imp;
    __imp* __locale_;

    void __install_ctor(const locale&, facet*, long);
    static locale& __global();
    bool has_facet(id&) const;
    const facet* use_facet(id&) const;

    template <class _Facet> friend bool has_facet(const locale&) noexcept;
    template <class _Facet> friend const _Facet& use_facet(const locale&);
};

class __attribute__ ((__visibility__("default"))) locale::facet
    : public __shared_count
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit facet(size_t __refs = 0)
        : __shared_count(static_cast<long>(__refs)-1) {}

    virtual ~facet();

//    facet(const facet&) = delete;     // effectively done in __shared_count
//    void operator=(const facet&) = delete;
private:
    virtual void __on_zero_shared() noexcept;
};

class __attribute__ ((__visibility__("default"))) locale::id
{
    once_flag __flag_;
    int32_t __id_;

    static int32_t __next_id;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr id() :__id_(0) {}
private:
    void __init();
    void operator=(const id&); // = delete;
    id(const id&); // = delete;
public: // only needed for tests
    long __get();

    friend class locale;
    friend class locale::__imp;
};

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
locale::locale(const locale& __other, _Facet* __f)
{
    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale
locale::combine(const locale& __other) const
{
    if (!std::__1::has_facet<_Facet>(__other))
        __throw_runtime_error("locale::combine: locale missing facet");

    return locale(*this, &const_cast<_Facet&>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
has_facet(const locale& __l) noexcept
{
    return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
const _Facet&
use_facet(const locale& __l)
{
    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}

// template <class _CharT> class collate;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) collate
    : public locale::facet
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit collate(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int compare(const char_type* __lo1, const char_type* __hi1,
                const char_type* __lo2, const char_type* __hi2) const
    {
        return do_compare(__lo1, __hi1, __lo2, __hi2);
    }

    // FIXME(EricWF): The _LIBCPP_ALWAYS_INLINE is needed on Windows to work
    // around a dllimport bug that expects an external instantiation.
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __attribute__ ((__always_inline__))
    string_type transform(const char_type* __lo, const char_type* __hi) const
    {
        return do_transform(__lo, __hi);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    long hash(const char_type* __lo, const char_type* __hi) const
    {
        return do_hash(__lo, __hi);
    }

    static locale::id id;

protected:
    ~collate();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const
        {return string_type(__lo, __hi);}
    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT> locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate()
{
}

template <class _CharT>
int
collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,
                            const char_type* __lo2, const char_type* __hi2) const
{
    for (; __lo2 != __hi2; ++__lo1, ++__lo2)
    {
        if (__lo1 == __hi1 || *__lo1 < *__lo2)
            return -1;
        if (*__lo2 < *__lo1)
            return 1;
    }
    return __lo1 != __hi1;
}

template <class _CharT>
long
collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const
{
    size_t __h = 0;
    const size_t __sr = 8 * sizeof(size_t) - 8;
    const size_t __mask = size_t(0xF) << (__sr + 4);
    for(const char_type* __p = __lo; __p != __hi; ++__p)
    {
        __h = (__h << 4) + static_cast<size_t>(*__p);
        size_t __g = __h & __mask;
        __h ^= __g | (__g >> __sr);
    }
    return static_cast<long>(__h);
}

extern template class __attribute__ ((__visibility__("default"))) collate<char>;
extern template class __attribute__ ((__visibility__("default"))) collate<wchar_t>;

// template <class CharT> class collate_byname;

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) collate_byname;

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<char>
    : public collate<char>
{
    locale_t __l;
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();
    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <>
class __attribute__ ((__visibility__("default"))) collate_byname<wchar_t>
    : public collate<wchar_t>
{
    locale_t __l;
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit collate_byname(const char* __n, size_t __refs = 0);
    explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
    ~collate_byname();

    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,
                           const char_type* __lo2, const char_type* __hi2) const;
    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool
locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                   const basic_string<_CharT, _Traits, _Allocator>& __y) const
{
    return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(
                                       __x.data(), __x.data() + __x.size(),
                                       __y.data(), __y.data() + __y.size()) < 0;
}

// template <class charT> class ctype

class __attribute__ ((__visibility__("default"))) ctype_base
{
public:
# 455 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
    typedef __uint32_t mask;





    static const mask space = _CTYPE_S;
    static const mask print = _CTYPE_R;
    static const mask cntrl = _CTYPE_C;
    static const mask upper = _CTYPE_U;
    static const mask lower = _CTYPE_L;
    static const mask alpha = _CTYPE_A;
    static const mask digit = _CTYPE_D;
    static const mask punct = _CTYPE_P;
    static const mask xdigit = _CTYPE_X;







    static const mask blank = _CTYPE_B;
    static const mask __regex_word = 0x80;
# 513 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
    static const mask alnum = alpha | digit;
    static const mask graph = alnum | punct;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ctype_base() {}
};

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype;

template <>
class __attribute__ ((__visibility__("default"))) ctype<wchar_t>
    : public locale::facet,
      public ctype_base
{
public:
    typedef wchar_t char_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit ctype(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is(mask __m, char_type __c) const
    {
        return do_is(__m, __c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        return do_is(__low, __high, __vec);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_is(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        return do_scan_not(__m, __low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;

protected:
    ~ctype();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype<char>
    : public locale::facet, public ctype_base
{
    const mask* __tab_;
    bool __del_;
public:
    typedef char char_type;

    explicit ctype(const mask* __tab = nullptr, bool __del = false, size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool is(mask __m, char_type __c) const
    {
        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const
    {
        for (; __low != __high; ++__low, ++__vec)
            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const
    {
        for (; __low != __high; ++__low)
            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
                break;
        return __low;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type toupper(char_type __c) const
    {
        return do_toupper(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* toupper(char_type* __low, const char_type* __high) const
    {
        return do_toupper(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type tolower(char_type __c) const
    {
        return do_tolower(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char_type* tolower(char_type* __low, const char_type* __high) const
    {
        return do_tolower(__low, __high);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type widen(char __c) const
    {
        return do_widen(__c);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char* widen(const char* __low, const char* __high, char_type* __to) const
    {
        return do_widen(__low, __high, __to);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char narrow(char_type __c, char __dfault) const
    {
        return do_narrow(__c, __dfault);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const
    {
        return do_narrow(__low, __high, __dfault, __to);
    }

    static locale::id id;




    static const size_t table_size = 256; // FIXME: Don't hardcode this.

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const mask* table() const noexcept {return __tab_;}
    static const mask* classic_table() noexcept;
# 732 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
protected:
    ~ctype();
    virtual char_type do_toupper(char_type __c) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type __c) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char __c) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
    virtual char do_narrow(char_type __c, char __dfault) const;
    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};

// template <class CharT> class ctype_byname;

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) ctype_byname;

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<char>
    : public ctype<char>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
};

template <>
class __attribute__ ((__visibility__("default"))) ctype_byname<wchar_t>
    : public ctype<wchar_t>
{
    locale_t __l;

public:
    explicit ctype_byname(const char*, size_t = 0);
    explicit ctype_byname(const string&, size_t = 0);

protected:
    ~ctype_byname();
    virtual bool do_is(mask __m, char_type __c) const;
    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
    virtual char_type do_toupper(char_type) const;
    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
    virtual char_type do_tolower(char_type) const;
    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
    virtual char_type do_widen(char) const;
    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
    virtual char do_narrow(char_type, char __dfault) const;
    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isspace(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isprint(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
iscntrl(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
islower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isalpha(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
ispunct(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isxdigit(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isalnum(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
isgraph(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_CharT
toupper(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_CharT
tolower(_CharT __c, const locale& __loc)
{
    return use_facet<ctype<_CharT> >(__loc).tolower(__c);
}

// codecvt_base

class __attribute__ ((__visibility__("default"))) codecvt_base
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) codecvt_base() {}
    enum result {ok, partial, error, noconv};
};

// template <class internT, class externT, class stateT> class codecvt;

template <class _InternT, class _ExternT, class _StateT> class __attribute__ ((__type_visibility__("default"))) codecvt;

// template <> class codecvt<char, char, mbstate_t>

template <>
class __attribute__ ((__visibility__("default"))) codecvt<char, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

// template <> class codecvt<wchar_t, char, mbstate_t>

template <>
class __attribute__ ((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
    locale_t __l;
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    explicit codecvt(const char*, size_t __refs = 0);

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};

// template <> class codecvt<char16_t, char, mbstate_t> // deprecated in C++20

template <>
class __attribute__ ((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1254 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
// template <> class codecvt<char32_t, char, mbstate_t> // deprecated in C++20

template <>
class __attribute__ ((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet,
      public codecvt_base
{
public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result out(state_type& __st,
               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result unshift(state_type& __st,
                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const
    {
        return do_unshift(__st, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    result in(state_type& __st,
              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const
    {
        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int encoding() const noexcept
    {
        return do_encoding();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool always_noconv() const noexcept
    {
        return do_always_noconv();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const
    {
        return do_length(__st, __frm, __end, __mx);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int max_length() const noexcept
    {
        return do_max_length();
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt(const char*, size_t __refs = 0)
        : locale::facet(__refs) {}

    ~codecvt();

    virtual result do_out(state_type& __st,
                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,
                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual result do_in(state_type& __st,
                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,
                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
    virtual result do_unshift(state_type& __st,
                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
    virtual int do_encoding() const noexcept;
    virtual bool do_always_noconv() const noexcept;
    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
    virtual int do_max_length() const noexcept;
};
# 1430 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname

template <class _InternT, class _ExternT, class _StateT>
class __attribute__ ((__type_visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt_byname(const char* __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit codecvt_byname(const string& __nm, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}
protected:
    ~codecvt_byname();
};

#pragma GCC diagnostic push
# 1447 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()
{
}
#pragma GCC diagnostic pop

extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char16_t, char, mbstate_t>; // deprecated in C++20
extern template class __attribute__ ((__visibility__("default"))) codecvt_byname<char32_t, char, mbstate_t>; // deprecated in C++20





template <size_t _Np>
struct __narrow_to_utf8
{
    template <class _OutputIterator, class _CharT>
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8>
{
    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        for (; __wb < __we; ++__wb, ++__s)
            *__s = *__wb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1485 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char16_t* __wn = (const char16_t*)__wb;
            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1521 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __narrow_to_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__narrow_to_utf8();

    template <class _OutputIterator, class _CharT>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__wb < __we && __r != error)
        {
            const int __sz = 32;
            char __buf[__sz];
            char* __bn;
            const char32_t* __wn = (const char32_t*)__wb;
            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,
                         __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
                __throw_runtime_error("locale not supported");
            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __wb = (const _CharT*)__wn;
        }
        return __s;
    }
};

template <size_t _Np>
struct __widen_from_utf8
{
    template <class _OutputIterator>
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8>
{
    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        for (; __nb < __ne; ++__nb, ++__s)
            *__s = *__nb;
        return __s;
    }
};

#pragma GCC diagnostic push
# 1579 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<16>
    : public codecvt<char16_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char16_t __buf[__sz];
            char16_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};

#pragma GCC diagnostic push
# 1615 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <>
struct __attribute__ ((__type_visibility__("default"))) __widen_from_utf8<32>
    : public codecvt<char32_t, char, mbstate_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

 __attribute__((__visibility__("default"))) ~__widen_from_utf8();

    template <class _OutputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _OutputIterator
    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const
    {
        result __r = ok;
        mbstate_t __mb;
        while (__nb < __ne && __r != error)
        {
            const int __sz = 32;
            char32_t __buf[__sz];
            char32_t* __bn;
            const char* __nn = __nb;
            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,
                        __buf, __buf+__sz, __bn);
            if (__r == codecvt_base::error || __nn == __nb)
                __throw_runtime_error("locale not supported");
            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
                *__s = *__p;
            __nb = __nn;
        }
        return __s;
    }
};

// template <class charT> class numpunct

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct;

template <>
class __attribute__ ((__visibility__("default"))) numpunct<char>
    : public locale::facet
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct<wchar_t>
    : public locale::facet
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct(size_t __refs = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type truename() const {return do_truename();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type falsename() const {return do_falsename();}

    static locale::id id;

protected:
    ~numpunct();
    virtual char_type do_decimal_point() const;
    virtual char_type do_thousands_sep() const;
    virtual string do_grouping() const;
    virtual string_type do_truename() const;
    virtual string_type do_falsename() const;

    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
};

// template <class charT> class numpunct_byname

template <class _CharT> class __attribute__ ((__type_visibility__("default"))) numpunct_byname;

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<char>
: public numpunct<char>
{
public:
    typedef char char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

template <>
class __attribute__ ((__visibility__("default"))) numpunct_byname<wchar_t>
: public numpunct<wchar_t>
{
public:
    typedef wchar_t char_type;
    typedef basic_string<char_type> string_type;

    explicit numpunct_byname(const char* __nm, size_t __refs = 0);
    explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
    ~numpunct_byname();

private:
    void __init(const char*);
};

} }
# 216 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 2
# 224 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 3


namespace std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__ ((__visibility__("default"))) ios_base
{
public:
    class __attribute__ ((__visibility__("default"))) failure;

    typedef unsigned int fmtflags;
    static const fmtflags boolalpha = 0x0001;
    static const fmtflags dec = 0x0002;
    static const fmtflags fixed = 0x0004;
    static const fmtflags hex = 0x0008;
    static const fmtflags internal = 0x0010;
    static const fmtflags left = 0x0020;
    static const fmtflags oct = 0x0040;
    static const fmtflags right = 0x0080;
    static const fmtflags scientific = 0x0100;
    static const fmtflags showbase = 0x0200;
    static const fmtflags showpoint = 0x0400;
    static const fmtflags showpos = 0x0800;
    static const fmtflags skipws = 0x1000;
    static const fmtflags unitbuf = 0x2000;
    static const fmtflags uppercase = 0x4000;
    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags basefield = dec | oct | hex;
    static const fmtflags floatfield = scientific | fixed;

    typedef unsigned int iostate;
    static const iostate badbit = 0x1;
    static const iostate eofbit = 0x2;
    static const iostate failbit = 0x4;
    static const iostate goodbit = 0x0;

    typedef unsigned int openmode;
    static const openmode app = 0x01;
    static const openmode ate = 0x02;
    static const openmode binary = 0x04;
    static const openmode in = 0x08;
    static const openmode out = 0x10;
    static const openmode trunc = 0x20;

    enum seekdir {beg, cur, end};
# 280 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 3
    class __attribute__ ((__visibility__("default"))) Init;

    // 27.5.2.2 fmtflags state:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fmtflags flags() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fmtflags flags(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fmtflags setf(fmtflags __fmtfl);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void unsetf(fmtflags __mask);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) streamsize precision() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) streamsize precision(streamsize __prec);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) streamsize width() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) streamsize width(streamsize __wide);

    // 27.5.2.3 locales:
    locale imbue(const locale& __loc);
    locale getloc() const;

    // 27.5.2.5 storage:
    static int xalloc();
    long& iword(int __index);
    void*& pword(int __index);

    // destructor
    virtual ~ios_base();

    // 27.5.2.6 callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int __index);
    void register_callback(event_callback __fn, int __index);

private:
    ios_base(const ios_base&); // = delete;
    ios_base& operator=(const ios_base&); // = delete;

public:
    static bool sync_with_stdio(bool __sync = true);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iostate rdstate() const;
    void clear(iostate __state = goodbit);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void setstate(iostate __state);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool good() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool eof() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool fail() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool bad() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iostate exceptions() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void exceptions(iostate __iostate);

    void __set_badbit_and_consider_rethrow();
    void __set_failbit_and_consider_rethrow();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __setstate_nothrow(iostate __state)
    {
        if (__rdbuf_)
            __rdstate_ |= __state;
        else
            __rdstate_ |= __state | ios_base::badbit;
    }

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ios_base() {// purposefully does no initialization
               }

    void init(void* __sb);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void* rdbuf() const {return __rdbuf_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
        clear();
    }

    void __call_callbacks(event);
    void copyfmt(const ios_base&);
    void move(ios_base&);
    void swap(ios_base&) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void set_rdbuf(void* __sb)
    {
        __rdbuf_ = __sb;
    }

private:
    // All data members must be scalars
    fmtflags __fmtflags_;
    streamsize __precision_;
    streamsize __width_;
    iostate __rdstate_;
    iostate __exceptions_;
    void* __rdbuf_;
    void* __loc_;
    event_callback* __fn_;
    int* __index_;
    size_t __event_size_;
    size_t __event_cap_;
// TODO(EricWF): Enable this for both Clang and GCC. Currently it is only
// enabled with clang.



    static int __xindex_;

    long* __iarray_;
    size_t __iarray_size_;
    size_t __iarray_cap_;
    void** __parray_;
    size_t __parray_size_;
    size_t __parray_cap_;
};

//enum class io_errc
enum class __attribute__ ((__type_visibility__("default"))) io_errc
{
    stream = 1
};


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum<io_errc> : public true_type { };






__attribute__ ((__visibility__("default")))
const error_category& iostream_category() noexcept;

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
error_code
make_error_code(io_errc __e) noexcept
{
    return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
error_condition
make_error_condition(io_errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__ ((__visibility__("default"))) ios_base::failure
    : public system_error
{
public:
    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
    failure(const failure&) noexcept = default;
    virtual ~failure() noexcept;
};

[[noreturn]] inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void __throw_failure(char const* __msg) {

    throw ios_base::failure(__msg);




}

class __attribute__ ((__visibility__("default"))) ios_base::Init
{
public:
    Init();
    ~Init();
};

// fmtflags

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::fmtflags
ios_base::flags() const
{
    return __fmtflags_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ = __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl)
{
    fmtflags __r = __fmtflags_;
    __fmtflags_ |= __fmtfl;
    return __r;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
ios_base::unsetf(fmtflags __mask)
{
    __fmtflags_ &= ~__mask;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask)
{
    fmtflags __r = __fmtflags_;
    unsetf(__mask);
    __fmtflags_ |= __fmtfl & __mask;
    return __r;
}

// precision

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
streamsize
ios_base::precision() const
{
    return __precision_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
streamsize
ios_base::precision(streamsize __prec)
{
    streamsize __r = __precision_;
    __precision_ = __prec;
    return __r;
}

// width

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
streamsize
ios_base::width() const
{
    return __width_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
streamsize
ios_base::width(streamsize __wide)
{
    streamsize __r = __width_;
    __width_ = __wide;
    return __r;
}

// iostate

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::iostate
ios_base::rdstate() const
{
    return __rdstate_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
ios_base::setstate(iostate __state)
{
    clear(__rdstate_ | __state);
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
ios_base::good() const
{
    return __rdstate_ == 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
ios_base::eof() const
{
    return (__rdstate_ & eofbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
ios_base::fail() const
{
    return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bool
ios_base::bad() const
{
    return (__rdstate_ & badbit) != 0;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
ios_base::iostate
ios_base::exceptions() const
{
    return __exceptions_;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
ios_base::exceptions(iostate __iostate)
{
    __exceptions_ = __iostate;
    clear(__rdstate_);
}
# 601 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ios" 3
template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ios
    : public ios_base
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

  // __true_value will generate undefined references when linking unless
  // we give it internal linkage.







    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit operator bool() const {return !fail();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool operator!() const {return fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iostate rdstate() const {return ios_base::rdstate();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void clear(iostate __state = goodbit) {ios_base::clear(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void setstate(iostate __state) {ios_base::setstate(__state);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool good() const {return ios_base::good();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool eof() const {return ios_base::eof();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool fail() const {return ios_base::fail();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool bad() const {return ios_base::bad();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iostate exceptions() const {return ios_base::exceptions();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}

    // 27.5.4.1 Constructor/destructor:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
    virtual ~basic_ios();

    // 27.5.4.2 Members:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream<char_type, traits_type>* tie() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_streambuf<char_type, traits_type>* rdbuf() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

    basic_ios& copyfmt(const basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type fill() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type fill(char_type __ch);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    locale imbue(const locale& __loc);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char narrow(char_type __c, char __dfault) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    char_type widen(char __c) const;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ios() {// purposefully does no initialization
                }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void init(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void move(basic_ios& __rhs);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void move(basic_ios&& __rhs) {move(__rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_ios& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
private:
    basic_ostream<char_type, traits_type>* __tie_;
    mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)
{
    init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios()
{
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::init(__sb);
    __tie_ = nullptr;
    __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie() const
{
    return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)
{
    basic_ostream<char_type, traits_type>* __r = __tie_;
    __tie_ = __tiestr;
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf() const
{
    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    basic_streambuf<char_type, traits_type>* __r = rdbuf();
    ios_base::rdbuf(__sb);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
locale
basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
    locale __r = getloc();
    ios_base::imbue(__loc);
    if (rdbuf())
        rdbuf()->pubimbue(__loc);
    return __r;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
{
    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
    return use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_CharT
basic_ios<_CharT, _Traits>::fill() const
{
    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
        __fill_ = widen(' ');
    return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch)
{
    char_type __r = __fill_;
    __fill_ = __ch;
    return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
{
    if (this != &__rhs)
    {
        __call_callbacks(erase_event);
        ios_base::copyfmt(__rhs);
        __tie_ = __rhs.__tie_;
        __fill_ = __rhs.__fill_;
        __call_callbacks(copyfmt_event);
        exceptions(__rhs.exceptions());
    }
    return *this;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
basic_ios<_CharT, _Traits>::move(basic_ios& __rhs)
{
    ios_base::move(__rhs);
    __tie_ = __rhs.__tie_;
    __rhs.__tie_ = nullptr;
    __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) noexcept
{
    ios_base::swap(__rhs);
    std::__1::swap(__tie_, __rhs.__tie_);
    std::__1::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::set_rdbuf(__sb);
}

inline
ios_base&
boolalpha(ios_base& __str)
{
    __str.setf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
noboolalpha(ios_base& __str)
{
    __str.unsetf(ios_base::boolalpha);
    return __str;
}

inline
ios_base&
showbase(ios_base& __str)
{
    __str.setf(ios_base::showbase);
    return __str;
}

inline
ios_base&
noshowbase(ios_base& __str)
{
    __str.unsetf(ios_base::showbase);
    return __str;
}

inline
ios_base&
showpoint(ios_base& __str)
{
    __str.setf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
noshowpoint(ios_base& __str)
{
    __str.unsetf(ios_base::showpoint);
    return __str;
}

inline
ios_base&
showpos(ios_base& __str)
{
    __str.setf(ios_base::showpos);
    return __str;
}

inline
ios_base&
noshowpos(ios_base& __str)
{
    __str.unsetf(ios_base::showpos);
    return __str;
}

inline
ios_base&
skipws(ios_base& __str)
{
    __str.setf(ios_base::skipws);
    return __str;
}

inline
ios_base&
noskipws(ios_base& __str)
{
    __str.unsetf(ios_base::skipws);
    return __str;
}

inline
ios_base&
uppercase(ios_base& __str)
{
    __str.setf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
nouppercase(ios_base& __str)
{
    __str.unsetf(ios_base::uppercase);
    return __str;
}

inline
ios_base&
unitbuf(ios_base& __str)
{
    __str.setf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
nounitbuf(ios_base& __str)
{
    __str.unsetf(ios_base::unitbuf);
    return __str;
}

inline
ios_base&
internal(ios_base& __str)
{
    __str.setf(ios_base::internal, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
left(ios_base& __str)
{
    __str.setf(ios_base::left, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
right(ios_base& __str)
{
    __str.setf(ios_base::right, ios_base::adjustfield);
    return __str;
}

inline
ios_base&
dec(ios_base& __str)
{
    __str.setf(ios_base::dec, ios_base::basefield);
    return __str;
}

inline
ios_base&
hex(ios_base& __str)
{
    __str.setf(ios_base::hex, ios_base::basefield);
    return __str;
}

inline
ios_base&
oct(ios_base& __str)
{
    __str.setf(ios_base::oct, ios_base::basefield);
    return __str;
}

inline
ios_base&
fixed(ios_base& __str)
{
    __str.setf(ios_base::fixed, ios_base::floatfield);
    return __str;
}

inline
ios_base&
scientific(ios_base& __str)
{
    __str.setf(ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
hexfloat(ios_base& __str)
{
    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __str;
}

inline
ios_base&
defaultfloat(ios_base& __str)
{
    __str.unsetf(ios_base::floatfield);
    return __str;
}

} }
# 38 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/streambuf" 1
// -*- C++ -*-
//===------------------------- streambuf ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    streambuf synopsis

namespace std
{

template <class charT, class traits = char_traits<charT> >
class basic_streambuf
{
public:
    // types:
    typedef charT char_type;
    typedef traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf();

    // 27.6.2.2.1 locales:
    locale pubimbue(const locale& loc);
    locale getloc() const;

    // 27.6.2.2.2 buffer and positioning:
    basic_streambuf* pubsetbuf(char_type* s, streamsize n);
    pos_type pubseekoff(off_type off, ios_base::seekdir way,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type sp,
                        ios_base::openmode which = ios_base::in | ios_base::out);
    int pubsync();

    // Get and put areas:
    // 27.6.2.2.3 Get area:
    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* s, streamsize n);

    // 27.6.2.2.4 Putback:
    int_type sputbackc(char_type c);
    int_type sungetc();

    // 27.6.2.2.5 Put area:
    int_type sputc(char_type c);
    streamsize sputn(const char_type* s, streamsize n);

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& rhs);
    basic_streambuf& operator=(const basic_streambuf& rhs);
    void swap(basic_streambuf& rhs);

    // 27.6.2.3.2 Get area:
    char_type* eback() const;
    char_type* gptr() const;
    char_type* egptr() const;
    void gbump(int n);
    void setg(char_type* gbeg, char_type* gnext, char_type* gend);

    // 27.6.2.3.3 Put area:
    char_type* pbase() const;
    char_type* pptr() const;
    char_type* epptr() const;
    void pbump(int n);
    void setp(char_type* pbeg, char_type* pend);

    // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& loc);

    // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
                             ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int sync();

    // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* s, streamsize n);
    virtual int_type underflow();
    virtual int_type uflow();

    // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type c = traits_type::eof());

    // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* s, streamsize n);
    virtual int_type overflow (int_type c = traits_type::eof());
};

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 111 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/streambuf" 2
# 116 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/streambuf" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 120 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/streambuf" 2 3

namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_streambuf
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                  "traits_type::char_type must be the same type as CharT");

    virtual ~basic_streambuf();

    // 27.6.2.2.1 locales:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    locale pubimbue(const locale& __loc) {
        imbue(__loc);
        locale __r = __loc_;
        __loc_ = __loc;
        return __r;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    locale getloc() const { return __loc_; }

    // 27.6.2.2.2 buffer and positioning:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)
    { return setbuf(__s, __n); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekoff(__off, __way, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __which = ios_base::in | ios_base::out)
    { return seekpos(__sp, __which); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int pubsync() { return sync(); }

    // Get and put areas:
    // 27.6.2.2.3 Get area:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streamsize in_avail() {
        if (__ninp_ < __einp_)
            return static_cast<streamsize>(__einp_ - __ninp_);
        return showmanyc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type snextc() {
        if (sbumpc() == traits_type::eof())
            return traits_type::eof();
        return sgetc();
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type sbumpc() {
        if (__ninp_ == __einp_)
            return uflow();
        return traits_type::to_int_type(*__ninp_++);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type sgetc() {
        if (__ninp_ == __einp_)
            return underflow();
        return traits_type::to_int_type(*__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streamsize sgetn(char_type* __s, streamsize __n)
    { return xsgetn(__s, __n); }

    // 27.6.2.2.4 Putback:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type sputbackc(char_type __c) {
        if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
            return pbackfail(traits_type::to_int_type(__c));
        return traits_type::to_int_type(*--__ninp_);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type sungetc() {
        if (__binp_ == __ninp_)
          return pbackfail();
        return traits_type::to_int_type(*--__ninp_);
    }

    // 27.6.2.2.5 Put area:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    int_type sputc(char_type __c) {
        if (__nout_ == __eout_)
            return overflow(traits_type::to_int_type(__c));
        *__nout_++ = __c;
        return traits_type::to_int_type(__c);
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streamsize sputn(const char_type* __s, streamsize __n)
    { return xsputn(__s, __n); }

protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& __rhs);
    basic_streambuf& operator=(const basic_streambuf& __rhs);
    void swap(basic_streambuf& __rhs);

    // 27.6.2.3.2 Get area:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* eback() const {return __binp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* gptr() const {return __ninp_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* egptr() const {return __einp_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void gbump(int __n) { __ninp_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
        __binp_ = __gbeg;
        __ninp_ = __gnext;
        __einp_ = __gend;
    }

    // 27.6.2.3.3 Put area:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* pbase() const {return __bout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* pptr() const {return __nout_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type* epptr() const {return __eout_;}

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void pbump(int __n) { __nout_ += __n; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void __pbump(streamsize __n) { __nout_ += __n; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void setp(char_type* __pbeg, char_type* __pend) {
        __bout_ = __nout_ = __pbeg;
        __eout_ = __pend;
    }

    // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& __loc);

    // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __which = ios_base::in | ios_base::out);
    virtual int sync();

    // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* __s, streamsize __n);
    virtual int_type underflow();
    virtual int_type uflow();

    // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type __c = traits_type::eof());

    // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* __s, streamsize __n);
    virtual int_type overflow(int_type __c = traits_type::eof());

private:
    locale __loc_;
    char_type* __binp_;
    char_type* __ninp_;
    char_type* __einp_;
    char_type* __bout_;
    char_type* __nout_;
    char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(nullptr),
      __ninp_(nullptr),
      __einp_(nullptr),
      __bout_(nullptr),
      __nout_(nullptr),
      __eout_(nullptr)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>&
basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)
{
    __loc_ = __sb.__loc_;
    __binp_ = __sb.__binp_;
    __ninp_ = __sb.__ninp_;
    __einp_ = __sb.__einp_;
    __bout_ = __sb.__bout_;
    __nout_ = __sb.__nout_;
    __eout_ = __sb.__eout_;
    return *this;
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)
{
    std::__1::swap(__loc_, __sb.__loc_);
    std::__1::swap(__binp_, __sb.__binp_);
    std::__1::swap(__ninp_, __sb.__ninp_);
    std::__1::swap(__einp_, __sb.__einp_);
    std::__1::swap(__bout_, __sb.__bout_);
    std::__1::swap(__nout_, __sb.__nout_);
    std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&)
{
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)
{
    return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{
    return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{
    return 0;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)
{
    const int_type __eof = traits_type::eof();
    int_type __c;
    streamsize __i = 0;
    while(__i < __n)
    {
        if (__ninp_ < __einp_)
        {
            const streamsize __len = std::__1::min(static_cast<streamsize>(INT_MAX),
                                std::__1::min(__einp_ - __ninp_, __n - __i));
            traits_type::copy(__s, __ninp_, __len);
            __s += __len;
            __i += __len;
            this->gbump(__len);
        }
        else if ((__c = uflow()) != __eof)
        {
            *__s = traits_type::to_char_type(__c);
            ++__s;
            ++__i;
        }
        else
            break;
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow()
{
    if (underflow() == traits_type::eof())
        return traits_type::eof();
    return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type)
{
    return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)
{
    streamsize __i = 0;
    int_type __eof = traits_type::eof();
    while( __i < __n)
    {
        if (__nout_ >= __eout_)
        {
            if (overflow(traits_type::to_int_type(*__s)) == __eof)
                break;
            ++__s;
            ++__i;
        }
        else
        {
            streamsize __chunk_size = std::__1::min(__eout_ - __nout_, __n - __i);
            traits_type::copy(__nout_, __s, __chunk_size);
            __nout_ += __chunk_size;
            __s += __chunk_size;
            __i += __chunk_size;
        }
    }
    return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type)
{
    return traits_type::eof();
}

extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_streambuf<wchar_t>;

extern template class __attribute__ ((__visibility__("default"))) basic_ios<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ios<wchar_t>;

} }
# 39 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 1
// -*- C++ -*-
//===--------------------------- istream ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    istream synopsis

template <class charT, class traits = char_traits<charT> >
class basic_istream
    : virtual public basic_ios<charT,traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.1.1.1 Constructor/destructor:
    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);
    basic_istream(basic_istream&& rhs);
    virtual ~basic_istream();

    // 27.7.1.1.2 Assign/swap:
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);

    // 27.7.1.1.3 Prefix/suffix:
    class sentry;

    // 27.7.1.2 Formatted input:
    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*pf)(basic_ios<char_type, traits_type>&));
    basic_istream& operator>>(ios_base& (*pf)(ios_base&));
    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);
    basic_istream& operator>>(bool& n);
    basic_istream& operator>>(short& n);
    basic_istream& operator>>(unsigned short& n);
    basic_istream& operator>>(int& n);
    basic_istream& operator>>(unsigned int& n);
    basic_istream& operator>>(long& n);
    basic_istream& operator>>(unsigned long& n);
    basic_istream& operator>>(long long& n);
    basic_istream& operator>>(unsigned long long& n);
    basic_istream& operator>>(float& f);
    basic_istream& operator>>(double& f);
    basic_istream& operator>>(long double& f);
    basic_istream& operator>>(void*& p);

    // 27.7.1.3 Unformatted input:
    streamsize gcount() const;
    int_type get();
    basic_istream& get(char_type& c);
    basic_istream& get(char_type* s, streamsize n);
    basic_istream& get(char_type* s, streamsize n, char_type delim);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);
    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);

    basic_istream& getline(char_type* s, streamsize n);
    basic_istream& getline(char_type* s, streamsize n, char_type delim);

    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* s, streamsize n);
    streamsize readsome(char_type* s, streamsize n);

    basic_istream& putback(char_type c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type);
    basic_istream& seekg(off_type, ios_base::seekdir);
protected:
    basic_istream(const basic_istream& rhs) = delete;
    basic_istream(basic_istream&& rhs);
    // 27.7.2.1.2 Assign/swap:
    basic_istream& operator=(const basic_istream& rhs) = delete;
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);
};

// 27.7.1.2.3 character extraction templates:
template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);

template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);

template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);

template <class charT, class traits>
  void
  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);

typedef basic_istream<char> istream;
typedef basic_istream<wchar_t> wistream;

template <class charT, class traits = char_traits<charT> >
class basic_iostream :
    public basic_istream<charT,traits>,
    public basic_ostream<charT,traits>
{
public:
    // types:
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // constructor/destructor
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);
    basic_iostream(basic_iostream&& rhs);
    virtual ~basic_iostream();

    // assign/swap
    basic_iostream& operator=(basic_iostream&& rhs);
    void swap(basic_iostream& rhs);
};

template <class charT, class traits>
  void
  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);

typedef basic_iostream<char> iostream;
typedef basic_iostream<wchar_t> wiostream;

template <class charT, class traits>
  basic_istream<charT,traits>&
  ws(basic_istream<charT,traits>& is);

// rvalue stream extraction
template <class Stream, class T>
  Stream&& operator>>(Stream&& is, T&& x);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 162 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ostream" 1
// -*- C++ -*-
//===-------------------------- ostream -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    ostream synopsis

template <class charT, class traits = char_traits<charT> >
class basic_ostream
    : virtual public basic_ios<charT,traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.2.2 Constructor/destructor:
    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
    basic_ostream(basic_ostream&& rhs);
    virtual ~basic_ostream();

    // 27.7.2.3 Assign/swap
    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14
    basic_ostream& operator=(basic_ostream&& rhs);
    void swap(basic_ostream& rhs);

    // 27.7.2.4 Prefix/suffix:
    class sentry;

    // 27.7.2.6 Formatted output:
    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));
    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));
    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));
    basic_ostream& operator<<(bool n);
    basic_ostream& operator<<(short n);
    basic_ostream& operator<<(unsigned short n);
    basic_ostream& operator<<(int n);
    basic_ostream& operator<<(unsigned int n);
    basic_ostream& operator<<(long n);
    basic_ostream& operator<<(unsigned long n);
    basic_ostream& operator<<(long long n);
    basic_ostream& operator<<(unsigned long long n);
    basic_ostream& operator<<(float f);
    basic_ostream& operator<<(double f);
    basic_ostream& operator<<(long double f);
    basic_ostream& operator<<(const void* p);
    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);
    basic_ostream& operator<<(nullptr_t);

    // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type c);
    basic_ostream& write(const char_type* s, streamsize n);
    basic_ostream& flush();

    // 27.7.2.5 seeks:
    pos_type tellp();
    basic_ostream& seekp(pos_type);
    basic_ostream& seekp(off_type, ios_base::seekdir);
protected:
    basic_ostream(const basic_ostream& rhs) = delete;
    basic_ostream(basic_ostream&& rhs);
    // 27.7.3.3 Assign/swap
    basic_ostream& operator=(basic_ostream& rhs) = delete;
    basic_ostream& operator=(const basic_ostream&& rhs);
    void swap(basic_ostream& rhs);
};

// 27.7.2.6.4 character inserters

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);

// signed and unsigned

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);

// NTBS
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);

template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);

// signed and unsigned
template<class traits>
basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);

template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);

// swap:
template <class charT, class traits>
  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);

template <class charT, class traits>
  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);

template <class charT, class traits>
  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);

template <class charT, class traits>
  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

// rvalue stream insertion
template <class Stream, class T>
  Stream&& operator<<(Stream&& os, const T& x);

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 137 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ostream" 2


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 1
// -*- C++ -*-
//===-------------------------- locale ------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    locale synopsis

namespace std
{

class locale
{
public:
    // types:
    class facet;
    class id;

    typedef int category;
    static const category // values assigned here are for exposition only
        none     = 0x000,
        collate  = 0x010,
        ctype    = 0x020,
        monetary = 0x040,
        numeric  = 0x080,
        time     = 0x100,
        messages = 0x200,
        all = collate | ctype | monetary | numeric | time | messages;

    // construct/copy/destroy:
    locale() noexcept;
    locale(const locale& other) noexcept;
    explicit locale(const char* std_name);
    explicit locale(const string& std_name);
    locale(const locale& other, const char* std_name, category);
    locale(const locale& other, const string& std_name, category);
    template <class Facet> locale(const locale& other, Facet* f);
    locale(const locale& other, const locale& one, category);

    ~locale(); // not virtual

    const locale& operator=(const locale& other) noexcept;

    template <class Facet> locale combine(const locale& other) const;

    // locale operations:
    basic_string<char> name() const;
    bool operator==(const locale& other) const;
    bool operator!=(const locale& other) const;
    template <class charT, class Traits, class Allocator>
      bool operator()(const basic_string<charT,Traits,Allocator>& s1,
                      const basic_string<charT,Traits,Allocator>& s2) const;

    // global locale objects:
    static locale global(const locale&);
    static const locale& classic();
};

template <class Facet> const Facet& use_facet(const locale&);
template <class Facet> bool has_facet(const locale&) noexcept;

// 22.3.3, convenience interfaces:
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> charT toupper(charT c, const locale& loc);
template <class charT> charT tolower(charT c, const locale& loc);

template<class Codecvt, class Elem = wchar_t,
         class Wide_alloc = allocator<Elem>,
         class Byte_alloc = allocator<char>>
class wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;
    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
    typedef typename Codecvt::state_type                      state_type;
    typedef typename wide_string::traits_type::int_type       int_type;

    wstring_convert(Codecvt* pcvt = new Codecvt);          // before C++14
    explicit wstring_convert(Codecvt* pcvt = new Codecvt); // before C++20
    wstring_convert() : wstring_convert(new Codecvt) {}    // C++20
    explicit wstring_convert(Codecvt* pcvt);               // C++20

    wstring_convert(Codecvt* pcvt, state_type state);
    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14
                    const wide_string& wide_err = wide_string());
    wstring_convert(const wstring_convert&) = delete;               // C++14
    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14
    ~wstring_convert();

    wide_string from_bytes(char byte);
    wide_string from_bytes(const char* ptr);
    wide_string from_bytes(const byte_string& str);
    wide_string from_bytes(const char* first, const char* last);

    byte_string to_bytes(Elem wchar);
    byte_string to_bytes(const Elem* wptr);
    byte_string to_bytes(const wide_string& wstr);
    byte_string to_bytes(const Elem* first, const Elem* last);

    size_t converted() const; // noexcept in C++14
    state_type state() const;
};

template <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>
class wbuffer_convert
    : public basic_streambuf<Elem, Tr>
{
public:
    typedef typename Tr::state_type state_type;

    wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,
                    state_type state = state_type());          // before C++14
    explicit wbuffer_convert(streambuf* bytebuf = nullptr, Codecvt* pcvt = new Codecvt,
                            state_type state = state_type()); // before C++20
    wbuffer_convert() : wbuffer_convert(nullptr) {} // C++20
    explicit wbuffer_convert(streambuf* bytebuf, Codecvt* pcvt = new Codecvt,
                            state_type state = state_type()); // C++20

    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14
    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14
    ~wbuffer_convert();                                             // C++14

    streambuf* rdbuf() const;
    streambuf* rdbuf(streambuf* bytebuf);

    state_type state() const;
};

// 22.4.1 and 22.4.1.3, ctype:
class ctype_base;
template <class charT> class ctype;
template <> class ctype<char>; // specialization
template <class charT> class ctype_byname;
template <> class ctype_byname<char>; // specialization

class codecvt_base;
template <class internT, class externT, class stateT> class codecvt;
template <class internT, class externT, class stateT> class codecvt_byname;

// 22.4.2 and 22.4.3, numeric:
template <class charT, class InputIterator> class num_get;
template <class charT, class OutputIterator> class num_put;
template <class charT> class numpunct;
template <class charT> class numpunct_byname;

// 22.4.4, col lation:
template <class charT> class collate;
template <class charT> class collate_byname;

// 22.4.5, date and time:
class time_base;
template <class charT, class InputIterator> class time_get;
template <class charT, class InputIterator> class time_get_byname;
template <class charT, class OutputIterator> class time_put;
template <class charT, class OutputIterator> class time_put_byname;

// 22.4.6, money:
class money_base;
template <class charT, class InputIterator> class money_get;
template <class charT, class OutputIterator> class money_put;
template <class charT, bool Intl> class moneypunct;
template <class charT, bool Intl> class moneypunct_byname;

// 22.4.7, message retrieval:
class messages_base;
template <class charT> class messages;
template <class charT> class messages_byname;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 191 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 2
# 207 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 1 3 4
/*	$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $
 */






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 1 3 4
/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)types.h	8.4 (Berkeley) 1/21/94
 */





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h" 1 3 4
/*
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




/* Machine type dependent parameters. */




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 1 3 4
/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 */
/*
 * Copyright 1995 NeXT Computer, Inc. All rights reserved.
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)endian.h	8.1 (Berkeley) 6/11/93
 */







/*
 * Define _NOQUAD if the compiler does NOT support 64-bit integers.
 */
/* #define _NOQUAD */

/*
 * Define the order of 32-bit words in 64-bit words.
 */



/*
 * Definitions for byte order, according to byte significance from low
 * address to high.
 */
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 1 3 4
/*
 * Copyright (c) 2004, 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * Copyright (c) 1995 NeXT Computer, Inc. All rights reserved.
 * Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */






/*
 * Macros for network/external number representation conversion.
 */
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */




/*
 * This header is normally included from <libkern/OSByteOrder.h>.  However,
 * <sys/_endian.h> also includes this in the case of little-endian
 * architectures, so that we can map OSByteOrder routines to the hton* and ntoh*
 * macros.  This results in the asymmetry below; we only include
 * <libkern/arch/_OSByteOrder.h> for little-endian architectures.
 */



/* Macros for swapping constant values in the preprocessing stage. */
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 1 3 4
/*
 * Copyright (c) 1999-2007 Apple Inc. All rights reserved.
 */






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/arch.h" 1 3 4
/*
 * Copyright (c) 2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */





/* Collect the __ARM_ARCH_*__ compiler flags into something easier to use. */
# 10 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 2 3 4

/* Generic byte swapping functions. */

static inline
uint16_t
_OSSwapInt16(
 uint16_t _data
 )
{
 /* Reduces to 'rev16' with clang */
 return (uint16_t)(_data << 8 | _data >> 8);
}

static inline
uint32_t
_OSSwapInt32(
 uint32_t _data
 )
{

 _data = __builtin_bswap32(_data);





 return _data;
}

static inline
uint64_t
_OSSwapInt64(
 uint64_t _data
 )
{

 return __builtin_bswap64(_data);
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
}

/* Functions for byte reversed loads. */

struct _OSUnalignedU16 {
 volatile uint16_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU32 {
 volatile uint32_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU64 {
 volatile uint64_t __val;
} __attribute__((__packed__));
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint16_t
OSReadSwapInt16(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt16(((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val);
}
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint32_t
OSReadSwapInt32(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt32(((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val);
}
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint64_t
OSReadSwapInt64(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt64(((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val);
}


/* Functions for byte reversed stores. */
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt16(
 volatile void * _base,
 uintptr_t _offset,
 uint16_t _data
 )
{
 ((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt16(_data);
}
# 180 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt32(
 volatile void * _base,
 uintptr_t _offset,
 uint32_t _data
 )
{
 ((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt32(_data);
}
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt64(
 volatile void * _base,
 uintptr_t _offset,
 uint64_t _data
 )
{
 ((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt64(_data);
}
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 2 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
/*
 * Copyright (c) 2017 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned char u_char;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
/*
 * Copyright (c) 2017 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned short u_short;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
/*
 * Copyright (c) 2017 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef unsigned int u_int;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;


typedef unsigned short ushort; /* Sys V compatibility */
typedef unsigned int uint; /* Sys V compatibility */


typedef u_int64_t u_quad_t; /* quads */
typedef int64_t quad_t;
typedef quad_t * qaddr_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
/*
 * Copyright (c) 2017 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef char * caddr_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t; /* disk address */


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_dev_t dev_t; /* device number */
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef u_int32_t fixpt_t; /* fixed point number */


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_blksize_t blksize_t;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_gid_t gid_t;
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __uint32_t in_addr_t; /* base type for internet address */
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __uint16_t in_port_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_ino_t ino_t; /* inode number */
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_ino64_t ino64_t; /* 64bit inode number */
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __int32_t key_t; /* IPC key (for Sys V IPC) */
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_mode_t mode_t;
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __uint16_t nlink_t; /* link count */
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_id_t id_t; /* can hold pid_t, gid_t, or uid_t */
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pid_t pid_t;
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_off_t off_t;
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t segsz_t; /* segment size */
typedef int32_t swblk_t; /* swap offset */


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_uid_t uid_t;
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


/* Major, minor numbers, dev_t's. */

/*
 * These lowercase macros tend to match member functions in some C++ code,
 * so for C++, we must use inline functions instead.
 */

static inline __int32_t
major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t
minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t
makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 166 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_ssize_t ssize_t;
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_useconds_t useconds_t;
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_suseconds_t suseconds_t;
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_size_t rsize_t;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */


typedef int errno_t;
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4



/*
 * This code is present here in order to maintain historical backward
 * compatability, and is intended to be removed at some point in the
 * future; please include <sys/select.h> instead.
 */

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */






/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) __attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));
}

inline __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"

 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }

#pragma clang diagnostic pop

}

/* This inline avoids argument side-effect issues with FD_ISSET() */
inline __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}







/*
 * Use the built-in bzero function instead of the library version so that
 * we do not pollute the namespace or introduce prototype warnings.
 */
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;

/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 199 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_attr_t pthread_attr_t;
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_cond_t pthread_cond_t;
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_once_t pthread_once_t;
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_t pthread_t;
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_pthread_key_t pthread_key_t;
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


/* statvfs and fstatvfs */


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 233 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */



typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 234 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_nl_item.h" 1 3 4
/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */




typedef __darwin_nl_item nl_item;
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 208 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 2



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bsd_locale_defaults.h" 1
// -*- C++ -*-
//===---------------------- __bsd_locale_defaults.h -----------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
// The BSDs have lots of *_l functions.  We don't want to define those symbols
// on other platforms though, for fear of conflicts with user code.  So here,
// we will define the mapping from an internal macro to the real BSD symbol.
//===----------------------------------------------------------------------===//
# 19 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__bsd_locale_defaults.h" 3
# 212 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 2
# 218 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 222 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 2 3


namespace std { inline namespace __1 {
# 237 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 3
// __scan_keyword
// Scans [__b, __e) until a match is found in the basic_strings range
//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
//  __b will be incremented (visibly), consuming CharT until a match is found
//  or proved to not exist.  A keyword may be "", in which will match anything.
//  If one keyword is a prefix of another, and the next CharT in the input
//  might match another keyword, the algorithm will attempt to find the longest
//  matching keyword.  If the longer matching keyword ends up not matching, then
//  no keyword match is found.  If no keyword match is found, __ke is returned
//  and failbit is set in __err.
//  Else an iterator pointing to the matching keyword is found.  If more than
//  one keyword matches, an iterator to the first matching keyword is returned.
//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,
//  __ct is used to force to lower case before comparing characters.
//  Examples:
//  Keywords:  "a", "abb"
//  If the input is "a", the first keyword matches and eofbit is set.
//  If the input is "abc", no match is found and "ab" are consumed.
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__ ((__visibility__("hidden")))
_ForwardIterator
__scan_keyword(_InputIterator& __b, _InputIterator __e,
               _ForwardIterator __kb, _ForwardIterator __ke,
               const _Ctype& __ct, ios_base::iostate& __err,
               bool __case_sensitive = true)
{
    typedef typename iterator_traits<_InputIterator>::value_type _CharT;
    size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
    const unsigned char __doesnt_match = '\0';
    const unsigned char __might_match = '\1';
    const unsigned char __does_match = '\2';
    unsigned char __statbuf[100];
    unsigned char* __status = __statbuf;
    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(nullptr, free);
    if (__nkw > sizeof(__statbuf))
    {
        __status = (unsigned char*)malloc(__nkw);
        if (__status == nullptr)
            __throw_bad_alloc();
        __stat_hold.reset(__status);
    }
    size_t __n_might_match = __nkw; // At this point, any keyword might match
    size_t __n_does_match = 0; // but none of them definitely do
    // Initialize all statuses to __might_match, except for "" keywords are __does_match
    unsigned char* __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
    {
        if (!__ky->empty())
            *__st = __might_match;
        else
        {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
        }
    }
    // While there might be a match, test keywords against the next CharT
    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)
    {
        // Peek at the next CharT but don't consume it
        _CharT __c = *__b;
        if (!__case_sensitive)
            __c = __ct.toupper(__c);
        bool __consume = false;
        // For each keyword which might match, see if the __indx character is __c
        // If a match if found, consume __c
        // If a match is found, and that is the last character in the keyword,
        //    then that keyword matches.
        // If the keyword doesn't match this character, then change the keyword
        //    to doesn't match
        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
        {
            if (*__st == __might_match)
            {
                _CharT __kc = (*__ky)[__indx];
                if (!__case_sensitive)
                    __kc = __ct.toupper(__kc);
                if (__c == __kc)
                {
                    __consume = true;
                    if (__ky->size() == __indx+1)
                    {
                        *__st = __does_match;
                        --__n_might_match;
                        ++__n_does_match;
                    }
                }
                else
                {
                    *__st = __doesnt_match;
                    --__n_might_match;
                }
            }
        }
        // consume if we matched a character
        if (__consume)
        {
            ++__b;
            // If we consumed a character and there might be a matched keyword that
            //   was marked matched on a previous iteration, then such keywords
            //   which are now marked as not matching.
            if (__n_might_match + __n_does_match > 1)
            {
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void) ++__st)
                {
                    if (*__st == __does_match && __ky->size() != __indx+1)
                    {
                        *__st = __doesnt_match;
                        --__n_does_match;
                    }
                }
            }
        }
    }
    // We've exited the loop because we hit eof and/or we have no more "might matches".
    if (__b == __e)
        __err |= ios_base::eofbit;
    // Return the first matching result
    for (__st = __status; __kb != __ke; ++__kb, (void) ++__st)
        if (*__st == __does_match)
            break;
    if (__kb == __ke)
        __err |= ios_base::failbit;
    return __kb;
}

struct __attribute__ ((__visibility__("default"))) __num_get_base
{
    static const int __num_get_buf_sz = 40;

    static int __get_base(ios_base&);
    static const char __src[33];
};

__attribute__ ((__visibility__("default")))
void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,
                      ios_base::iostate& __err);

template <class _CharT>
struct __num_get
    : protected __num_get_base
{
    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                                      _CharT& __thousands_sep);

    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,
                                   char* __a, char*& __a_end,
                                   _CharT __decimal_point, _CharT __thousands_sep,
                                   const string& __grouping, unsigned* __g,
                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);

    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
# 429 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 3
};


template <class _CharT>
string
__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}


template <class _CharT>
string
__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,
                    _CharT& __thousands_sep)
{
    locale __loc = __iob.getloc();
    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    __decimal_point = __np.decimal_point();
    __thousands_sep = __np.thousands_sep();
    return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))
    {
        *__a_end++ = __ct == __atoms[24] ? '+' : '-';
        __dc = 0;
        return 0;
    }
    if (__grouping.size() != 0 && __ct == __thousands_sep)
    {
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
    if (__f >= 24)
        return -1;
    switch (__base)
    {
    case 8:
    case 10:
        if (__f >= __base)
            return -1;
        break;
    case 16:
        if (__f < 22)
            break;
        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')
        {
            __dc = 0;
            *__a_end++ = __src[__f];
            return 0;
        }
        return -1;
    }
    *__a_end++ = __src[__f];
    ++__dc;
    return 0;
}

template <class _CharT>
int
__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,
                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,
                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)
{
    if (__ct == __decimal_point)
    {
        if (!__in_units)
            return -1;
        __in_units = false;
        *__a_end++ = '.';
        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
            *__g_end++ = __dc;
        return 0;
    }
    if (__ct == __thousands_sep && __grouping.size() != 0)
    {
        if (!__in_units)
            return -1;
        if (__g_end-__g < __num_get_buf_sz)
        {
            *__g_end++ = __dc;
            __dc = 0;
        }
        return 0;
    }
    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
    if (__f >= 32)
        return -1;
    char __x = __src[__f];
    if (__x == '-' || __x == '+')
    {
        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))
        {
            *__a_end++ = __x;
            return 0;
        }
        return -1;
    }
    if (__x == 'x' || __x == 'X')
        __exp = 'P';
    else if ((__x & 0x5F) == __exp)
    {
        __exp |= (char) 0x80;
        if (__in_units)
        {
            __in_units = false;
            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)
                *__g_end++ = __dc;
        }
    }
    *__a_end++ = __x;
    if (__f >= 22)
        return 0;
    ++__dc;
    return 0;
}

extern template struct __attribute__ ((__visibility__("default"))) __num_get<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_get
    : public locale::facet,
      private __num_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit num_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, bool& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned short& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned int& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, unsigned long long& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, float& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, void*& __v) const
    {
        return do_get(__b, __e, __iob, __err, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~num_get() {}

    template <class _Fp>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_floating_point
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Fp& __v) const;

    template <class _Signed>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_signed
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Signed& __v) const;

    template <class _Unsigned>
    inline __attribute__ ((__visibility__("hidden")))
    iter_type __do_get_unsigned
                            (iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, _Unsigned& __v) const;


    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, bool& __v) const;

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long long& __v) const
    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned short& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned int& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, unsigned long long& __v) const
    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, float& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, long double& __v) const
    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }

    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id
num_get<_CharT, _InputIterator>::id;

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_signed_integral(const char* __a, const char* __a_end,
                          ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype(errno)>::type __save_errno = errno;
        errno = 0;
        char *__p2;
        long long __ll = strtoll_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype(errno)>::type __current_errno = errno;
        if (__current_errno == 0)
            errno = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 9944 ||
                 __ll < numeric_limits<_Tp>::min() ||
                 numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            if (__ll > 0)
                return numeric_limits<_Tp>::max();
            else
                return numeric_limits<_Tp>::min();
        }
        return static_cast<_Tp>(__ll);
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) _Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end,
                            ios_base::iostate& __err, int __base)
{
    if (__a != __a_end)
    {
        const bool __negate = *__a == '-';
        if (__negate && ++__a == __a_end) {
          __err = ios_base::failbit;
          return 0;
        }
        typename remove_reference<decltype(errno)>::type __save_errno = errno;
        errno = 0;
        char *__p2;
        unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
        typename remove_reference<decltype(errno)>::type __current_errno = errno;
        if (__current_errno == 0)
            errno = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 9944 || numeric_limits<_Tp>::max() < __ll)
        {
            __err = ios_base::failbit;
            return numeric_limits<_Tp>::max();
        }
        _Tp __res = static_cast<_Tp>(__ll);
        if (__negate) __res = -__res;
        return __res;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
float __do_strtod<float>(const char* __a, char** __p2) {
    return strtof_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
double __do_strtod<double>(const char* __a, char** __p2) {
    return strtod_l(__a, __p2, 0);
}

template <>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
long double __do_strtod<long double>(const char* __a, char** __p2) {
    return strtold_l(__a, __p2, 0);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
_Tp
__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)
{
    if (__a != __a_end)
    {
        typename remove_reference<decltype(errno)>::type __save_errno = errno;
        errno = 0;
        char *__p2;
        _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
        typename remove_reference<decltype(errno)>::type __current_errno = errno;
        if (__current_errno == 0)
            errno = __save_errno;
        if (__p2 != __a_end)
        {
            __err = ios_base::failbit;
            return 0;
        }
        else if (__current_errno == 9944)
            __err = ios_base::failbit;
        return __ld;
    }
    __err = ios_base::failbit;
    return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        bool& __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
    {
        long __lv = -1;
        __b = do_get(__b, __e, __iob, __err, __lv);
        switch (__lv)
        {
        case 0:
            __v = false;
            break;
        case 1:
            __v = true;
            break;
        default:
            __v = true;
            __err = ios_base::failbit;
            break;
        }
        return __b;
    }
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
    typedef typename numpunct<_CharT>::string_type string_type;
    const string_type __names[2] = {__np.truename(), __np.falsename()};
    const string_type* __i = std::__1::__scan_keyword(__b, __e, __names, __names+2,
                                                   __ct, __err);
    __v = __i == __names;
    return __b;
}

// signed

template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Signed& __v) const
{
    // Stage 1
    int __base = this->__get_base(__iob);
    // Stage 2
    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

// unsigned

template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Unsigned& __v) const
{
    // Stage 1
    int __base = this->__get_base(__iob);
    // Stage 2
    char_type __thousands_sep;
    const int __atoms_size = 26;





    char_type __atoms[__atoms_size];
    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping, __g, __g_end,
                                    __atoms))
            break;
    }
    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

// floating point

template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator
num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        _Fp& __v) const
{
    // Stage 1, nothing to do
    // Stage 2
    char_type __atoms[32];
    char_type __decimal_point;
    char_type __thousands_sep;
    string __grouping = this->__stage2_float_prep(__iob, __atoms,
                                                  __decimal_point,
                                                  __thousands_sep);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    bool __in_units = true;
    char __exp = 'E';
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                      __decimal_point, __thousands_sep,
                                      __grouping, __g, __g_end,
                                      __dc, __atoms))
            break;
    }
    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)
        *__g_end++ = __dc;
    // Stage 3
    __v = __num_get_float<_Fp>(__a, __a_end, __err);
    // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                        ios_base& __iob,
                                        ios_base::iostate& __err,
                                        void*& __v) const
{
    // Stage 1
    int __base = 16;
    // Stage 2
    char_type __atoms[26];
    char_type __thousands_sep = 0;
    string __grouping;
    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,
                                                    __num_get_base::__src + 26, __atoms);
    string __buf;
    __buf.resize(__buf.capacity());
    char* __a = &__buf[0];
    char* __a_end = __a;
    unsigned __g[__num_get_base::__num_get_buf_sz];
    unsigned* __g_end = __g;
    unsigned __dc = 0;
    for (; __b != __e; ++__b)
    {
        if (__a_end == __a + __buf.size())
        {
            size_t __tmp = __buf.size();
            __buf.resize(2*__buf.size());
            __buf.resize(__buf.capacity());
            __a = &__buf[0];
            __a_end = __a + __tmp;
        }
        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                    __thousands_sep, __grouping,
                                    __g, __g_end, __atoms))
            break;
    }
    // Stage 3
    __buf.resize(__a_end - __a);
    if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
        __err = ios_base::failbit;
    // EOF checked
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) num_get<char>;
extern template class __attribute__ ((__visibility__("default"))) num_get<wchar_t>;

struct __attribute__ ((__visibility__("default"))) __num_put_base
{
protected:
    static void __format_int(char* __fmt, const char* __len, bool __signd,
                             ios_base::fmtflags __flags);
    static bool __format_float(char* __fmt, const char* __len,
                               ios_base::fmtflags __flags);
    static char* __identify_padding(char* __nb, char* __ne,
                                    const ios_base& __iob);
};

template <class _CharT>
struct __num_put
    : protected __num_put_base
{
    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,
                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                      const locale& __loc);
    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,
                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                        const locale& __loc);
};

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,
                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                         const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    if (__grouping.empty())
    {
        __ct.widen(__nb, __ne, __ob);
        __oe = __ob + (__ne - __nb);
    }
    else
    {
        __oe = __ob;
        char* __nf = __nb;
        if (*__nf == '-' || *__nf == '+')
            *__oe++ = __ct.widen(*__nf++);
        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                                   __nf[1] == 'X'))
        {
            *__oe++ = __ct.widen(*__nf++);
            *__oe++ = __ct.widen(*__nf++);
        }
        reverse(__nf, __ne);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ne; ++__p)
        {
            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
                __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

template <class _CharT>
void
__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,
                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,
                                           const locale& __loc)
{
    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> > (__loc);
    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
    string __grouping = __npt.grouping();
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
        *__oe++ = __ct.widen(*__nf++);
    char* __ns;
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||
                                               __nf[1] == 'X'))
    {
        *__oe++ = __ct.widen(*__nf++);
        *__oe++ = __ct.widen(*__nf++);
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isxdigit_l(*__ns, 0))
                break;
    }
    else
    {
        for (__ns = __nf; __ns < __ne; ++__ns)
            if (!isdigit_l(*__ns, 0))
                break;
    }
    if (__grouping.empty())
    {
        __ct.widen(__nf, __ns, __oe);
        __oe += __ns - __nf;
    }
    else
    {
        reverse(__nf, __ns);
        _CharT __thousands_sep = __npt.thousands_sep();
        unsigned __dc = 0;
        unsigned __dg = 0;
        for (char* __p = __nf; __p < __ns; ++__p)
        {
            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))
            {
                *__oe++ = __thousands_sep;
                __dc = 0;
                if (__dg < __grouping.size()-1)
                    ++__dg;
            }
            *__oe++ = __ct.widen(*__p);
            ++__dc;
        }
        reverse(__ob + (__nf - __nb), __oe);
    }
    for (__nf = __ns; __nf < __ne; ++__nf)
    {
        if (*__nf == '.')
        {
            *__oe++ = __npt.decimal_point();
            ++__nf;
            break;
        }
        else
            *__oe++ = __ct.widen(*__nf);
    }
    __ct.widen(__nf, __ne, __oe);
    __oe += __ne - __nf;
    if (__np == __ne)
        __op = __oe;
    else
        __op = __ob + (__np - __nb);
}

extern template struct __attribute__ ((__visibility__("default"))) __num_put<char>;
extern template struct __attribute__ ((__visibility__("default"))) __num_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) num_put
    : public locale::facet,
      private __num_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit num_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  bool __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  unsigned long long __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  long double __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const void* __v) const
    {
        return do_put(__s, __iob, __fl, __v);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~num_put() {}

    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             bool __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long long __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             unsigned long long) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             long double __v) const;
    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,
                             const void* __v) const;
};

template <class _CharT, class _OutputIterator>
locale::id
num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__ ((__visibility__("hidden")))
_OutputIterator
__pad_and_output(_OutputIterator __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    for (;__ob < __op; ++__ob, ++__s)
        *__s = *__ob;
    for (; __ns; --__ns, ++__s)
        *__s = __fl;
    for (; __ob < __oe; ++__ob, ++__s)
        *__s = *__ob;
    __iob.width(0);
    return __s;
}

template <class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden")))
ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,
                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,
                 ios_base& __iob, _CharT __fl)
{
    if (__s.__sbuf_ == nullptr)
        return __s;
    streamsize __sz = __oe - __ob;
    streamsize __ns = __iob.width();
    if (__ns > __sz)
        __ns -= __sz;
    else
        __ns = 0;
    streamsize __np = __op - __ob;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__ob, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    if (__ns > 0)
    {
        basic_string<_CharT, _Traits> __sp(__ns, __fl);
        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __np = __oe - __op;
    if (__np > 0)
    {
        if (__s.__sbuf_->sputn(__op, __np) != __np)
        {
            __s.__sbuf_ = nullptr;
            return __s;
        }
    }
    __iob.width(0);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, bool __v) const
{
    if ((__iob.flags() & ios_base::boolalpha) == 0)
        return do_put(__s, __iob, __fl, (unsigned long)__v);
    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());
    typedef typename numpunct<char_type>::string_type string_type;




    string_type __nm = __v ? __np.truename() : __np.falsename();

    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
        *__s = *__i;
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long>::digits / 3)
                          + ((numeric_limits<long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, true, __iob.flags());
    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)
                          + ((numeric_limits<long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 2;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[6] = {'%', 0};
    const char* __len = "l";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)
                          + ((numeric_limits<unsigned long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, unsigned long long __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "ll";
    this->__format_int(__fmt+1, __len, false, __iob.flags());
    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)
                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)
                          + ((__iob.flags() & ios_base::showbase) != 0)
                          + 1;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, double __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, long double __v) const
{
    // Stage 1 - Get number in narrow char
    char __fmt[8] = {'%', 0};
    const char* __len = "L";
    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
    const unsigned __nbuf = 30;
    char __nar[__nbuf];
    char* __nb = __nar;
    int __nc;
    if (__specify_precision)
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);

    else
        __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
    unique_ptr<char, void(*)(void*)> __nbh(nullptr, free);
    if (__nc > static_cast<int>(__nbuf-1))
    {
        if (__specify_precision)
            __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
        else
            __nc = asprintf_l(&__nb, 0, __fmt, __v);
        if (__nc == -1)
            __throw_bad_alloc();
        __nbh.reset(__nb);
    }
    char* __ne = __nb + __nc;
    char* __np = this->__identify_padding(__nb, __ne, __iob);
    // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __ob = __o;
    unique_ptr<char_type, void(*)(void*)> __obh(0, free);
    if (__nb != __nar)
    {
        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
        if (__ob == 0)
            __throw_bad_alloc();
        __obh.reset(__ob);
    }
    char_type* __op; // pad here
    char_type* __oe; // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
    // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,
                                         char_type __fl, const void* __v) const
{
    // Stage 1 - Get pointer in narrow char
    char __fmt[6] = "%p";
    const unsigned __nbuf = 20;
    char __nar[__nbuf];
    int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
    char* __ne = __nar + __nc;
    char* __np = this->__identify_padding(__nar, __ne, __iob);
    // Stage 2 - Widen __nar
    char_type __o[2*(__nbuf-1) - 1];
    char_type* __op; // pad here
    char_type* __oe; // end of output
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __ct.widen(__nar, __ne, __o);
    __oe = __o + (__ne - __nar);
    if (__np == __ne)
        __op = __oe;
    else
        __op = __o + (__np - __nar);
    // [__o, __oe) contains wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) num_put<char>;
extern template class __attribute__ ((__visibility__("default"))) num_put<wchar_t>;

template <class _CharT, class _InputIterator>
__attribute__ ((__visibility__("hidden")))
int
__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,
                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)
{
    // Precondition:  __n >= 1
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return 0;
    }
    // get first digit
    _CharT __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
    {
        __err |= ios_base::failbit;
        return 0;
    }
    int __r = __ct.narrow(__c, 0) - '0';
    for (++__b, (void) --__n; __b != __e && __n > 0; ++__b, (void) --__n)
    {
        // get next digit
        __c = *__b;
        if (!__ct.is(ctype_base::digit, __c))
            return __r;
        __r = __r * 10 + __ct.narrow(__c, 0) - '0';
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __r;
}

class __attribute__ ((__visibility__("default"))) time_base
{
public:
    enum dateorder {no_order, dmy, mdy, ymd, ydm};
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_c_storage
{
protected:
    typedef basic_string<_CharT> string_type;

    virtual const string_type* __weeks() const;
    virtual const string_type* __months() const;
    virtual const string_type* __am_pm() const;
    virtual const string_type& __c() const;
    virtual const string_type& __r() const;
    virtual const string_type& __x() const;
    virtual const string_type& __X() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~__time_get_c_storage() {}
};

template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;

template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <> __attribute__ ((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <> __attribute__ ((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get
    : public locale::facet,
      public time_base,
      private __time_get_c_storage<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef time_base::dateorder dateorder;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    dateorder date_order() const
    {
        return this->do_date_order();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_time(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_date(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                          ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_weekday(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                            ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_monthname(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,
                       ios_base::iostate& __err, tm* __tm) const
    {
        return do_get_year(__b, __e, __iob, __err, __tm);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm *__tm,
                  char __fmt, char __mod = 0) const
    {
        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
    }

    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,
                  ios_base::iostate& __err, tm* __tm,
                  const char_type* __fmtb, const char_type* __fmte) const;

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~time_get() {}

    virtual dateorder do_date_order() const;
    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,
                                     ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,
                                       ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,
                                  ios_base::iostate& __err, tm* __tm) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,
                             ios_base::iostate& __err, tm* __tm,
                             char __fmt, char __mod) const;
private:
    void __get_white_space(iter_type& __b, iter_type __e,
                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;
    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;

    void __get_weekdayname(int& __m,
                           iter_type& __b, iter_type __e,
                           ios_base::iostate& __err,
                           const ctype<char_type>& __ct) const;
    void __get_monthname(int& __m,
                         iter_type& __b, iter_type __e,
                         ios_base::iostate& __err,
                         const ctype<char_type>& __ct) const;
    void __get_day(int& __d,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_month(int& __m,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_year(int& __y,
                   iter_type& __b, iter_type __e,
                   ios_base::iostate& __err,
                   const ctype<char_type>& __ct) const;
    void __get_year4(int& __y,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_hour(int& __d,
                    iter_type& __b, iter_type __e,
                    ios_base::iostate& __err,
                    const ctype<char_type>& __ct) const;
    void __get_12_hour(int& __h,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_am_pm(int& __h,
                     iter_type& __b, iter_type __e,
                     ios_base::iostate& __err,
                     const ctype<char_type>& __ct) const;
    void __get_minute(int& __m,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_second(int& __s,
                      iter_type& __b, iter_type __e,
                      ios_base::iostate& __err,
                      const ctype<char_type>& __ct) const;
    void __get_weekday(int& __w,
                       iter_type& __b, iter_type __e,
                       ios_base::iostate& __err,
                       const ctype<char_type>& __ct) const;
    void __get_day_year_num(int& __w,
                            iter_type& __b, iter_type __e,
                            ios_base::iostate& __err,
                            const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id
time_get<_CharT, _InputIterator>::id;

// time_get primitives

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,
                                                    iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    // Note:  ignoring case comes from the POSIX strptime spec
    const string_type* __wk = this->__weeks();
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;
    if (__i < 14)
        __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_monthname(int& __m,
                                                  iter_type& __b, iter_type __e,
                                                  ios_base::iostate& __err,
                                                  const ctype<char_type>& __ct) const
{
    // Note:  ignoring case comes from the POSIX strptime spec
    const string_type* __month = this->__months();
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;
    if (__i < 24)
        __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day(int& __d,
                                            iter_type& __b, iter_type __e,
                                            ios_base::iostate& __err,
                                            const ctype<char_type>& __ct) const
{
    int __t = std::__1::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_month(int& __m,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
    if (!(__err & ios_base::failbit) && __t <= 11)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year(int& __y,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
    {
        if (__t < 69)
            __t += 2000;
        else if (69 <= __t && __t <= 99)
            __t += 1900;
        __y = __t - 1900;
    }
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_year4(int& __y,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
    if (!(__err & ios_base::failbit))
        __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_hour(int& __h,
                                             iter_type& __b, iter_type __e,
                                             ios_base::iostate& __err,
                                             const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 23)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
        __h = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_minute(int& __m,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 59)
        __m = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_second(int& __s,
                                               iter_type& __b, iter_type __e,
                                               ios_base::iostate& __err,
                                               const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
    if (!(__err & ios_base::failbit) && __t <= 60)
        __s = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_weekday(int& __w,
                                                iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
    if (!(__err & ios_base::failbit) && __t <= 6)
        __w = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,
                                                     iter_type& __b, iter_type __e,
                                                     ios_base::iostate& __err,
                                                     const ctype<char_type>& __ct) const
{
    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
    if (!(__err & ios_base::failbit) && __t <= 365)
        __d = __t;
    else
        __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,
                                                    ios_base::iostate& __err,
                                                    const ctype<char_type>& __ct) const
{
    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    if (__b == __e)
        __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_am_pm(int& __h,
                                              iter_type& __b, iter_type __e,
                                              ios_base::iostate& __err,
                                              const ctype<char_type>& __ct) const
{
    const string_type* __ap = this->__am_pm();
    if (__ap[0].size() + __ap[1].size() == 0)
    {
        __err |= ios_base::failbit;
        return;
    }
    ptrdiff_t __i = std::__1::__scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;
    if (__i == 0 && __h == 12)
        __h = 0;
    else if (__i == 1 && __h < 12)
        __h += 12;
}

template <class _CharT, class _InputIterator>
void
time_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,
                                                ios_base::iostate& __err,
                                                const ctype<char_type>& __ct) const
{
    if (__b == __e)
    {
        __err |= ios_base::eofbit | ios_base::failbit;
        return;
    }
    if (__ct.narrow(*__b, 0) != '%')
        __err |= ios_base::failbit;
    else if(++__b == __e)
        __err |= ios_base::eofbit;
}

// time_get end primitives

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,
                                      ios_base& __iob,
                                      ios_base::iostate& __err, tm* __tm,
                                      const char_type* __fmtb, const char_type* __fmte) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __err = ios_base::goodbit;
    while (__fmtb != __fmte && __err == ios_base::goodbit)
    {
        if (__b == __e)
        {
            __err = ios_base::failbit;
            break;
        }
        if (__ct.narrow(*__fmtb, 0) == '%')
        {
            if (++__fmtb == __fmte)
            {
                __err = ios_base::failbit;
                break;
            }
            char __cmd = __ct.narrow(*__fmtb, 0);
            char __opt = '\0';
            if (__cmd == 'E' || __cmd == '0')
            {
                if (++__fmtb == __fmte)
                {
                    __err = ios_base::failbit;
                    break;
                }
                __opt = __cmd;
                __cmd = __ct.narrow(*__fmtb, 0);
            }
            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
            ++__fmtb;
        }
        else if (__ct.is(ctype_base::space, *__fmtb))
        {
            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                ;
            for ( ; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
        }
        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))
        {
            ++__b;
            ++__fmtb;
        }
        else
            __err = ios_base::failbit;
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const
{
    return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const string_type& __fmt = this->__x();
    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,
                                                 ios_base& __iob,
                                                 ios_base::iostate& __err,
                                                 tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,
                                                   ios_base& __iob,
                                                   ios_base::iostate& __err,
                                                   tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,
                                              ios_base& __iob,
                                              ios_base::iostate& __err,
                                              tm* __tm) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                         ios_base& __iob,
                                         ios_base::iostate& __err, tm* __tm,
                                         char __fmt, char) const
{
    __err = ios_base::goodbit;
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    switch (__fmt)
    {
    case 'a':
    case 'A':
        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'b':
    case 'B':
    case 'h':
        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'c':
        {
        const string_type& __fm = this->__c();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'd':
    case 'e':
        __get_day(__tm->tm_mday, __b, __e, __err, __ct);
        break;
    case 'D':
        {
        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'F':
        {
        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'H':
        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'I':
        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'j':
        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
        break;
    case 'm':
        __get_month(__tm->tm_mon, __b, __e, __err, __ct);
        break;
    case 'M':
        __get_minute(__tm->tm_min, __b, __e, __err, __ct);
        break;
    case 'n':
    case 't':
        __get_white_space(__b, __e, __err, __ct);
        break;
    case 'p':
        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
        break;
    case 'r':
        {
        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'R':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'S':
        __get_second(__tm->tm_sec, __b, __e, __err, __ct);
        break;
    case 'T':
        {
        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
        }
        break;
    case 'w':
        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
        break;
    case 'x':
        return do_get_date(__b, __e, __iob, __err, __tm);
    case 'X':
        {
        const string_type& __fm = this->__X();
        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
        }
        break;
    case 'y':
        __get_year(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case 'Y':
        __get_year4(__tm->tm_year, __b, __e, __err, __ct);
        break;
    case '%':
        __get_percent(__b, __e, __err, __ct);
        break;
    default:
        __err |= ios_base::failbit;
    }
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) time_get<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_get
{
protected:
    locale_t __loc_;

    __time_get(const char* __nm);
    __time_get(const string& __nm);
    ~__time_get();
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) __time_get_storage
    : public __time_get
{
protected:
    typedef basic_string<_CharT> string_type;

    string_type __weeks_[14];
    string_type __months_[24];
    string_type __am_pm_[2];
    string_type __c_;
    string_type __r_;
    string_type __x_;
    string_type __X_;

    explicit __time_get_storage(const char* __nm);
    explicit __time_get_storage(const string& __nm);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) ~__time_get_storage() {}

    time_base::dateorder __do_date_order() const;

private:
    void init(const ctype<_CharT>&);
    string_type __analyze(char __fmt, const ctype<_CharT>&);
};
# 2424 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/locale" 3
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);
template <> __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__ ((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__ ((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT>
{
public:
    typedef time_base::dateorder dateorder;
    typedef _InputIterator iter_type;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_get_byname(const char* __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_get_byname(const string& __nm, size_t __refs = 0)
        : time_get<_CharT, _InputIterator>(__refs),
          __time_get_storage<_CharT>(__nm) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~time_get_byname() {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual dateorder do_date_order() const {return this->__do_date_order();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type* __weeks() const {return this->__weeks_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type* __months() const {return this->__months_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type* __am_pm() const {return this->__am_pm_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type& __c() const {return this->__c_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type& __r() const {return this->__r_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type& __x() const {return this->__x_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    virtual const string_type& __X() const {return this->__X_;}
};

extern template class __attribute__ ((__visibility__("default"))) time_get_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_get_byname<wchar_t>;

class __attribute__ ((__visibility__("default"))) __time_put
{
    locale_t __loc_;
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __time_put() : __loc_(0) {}
    __time_put(const char* __nm);
    __time_put(const string& __nm);
    ~__time_put();
    void __do_put(char* __nb, char*& __ne, const tm* __tm,
                  char __fmt, char __mod) const;
    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,
                  char __fmt, char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put
    : public locale::facet,
      private __time_put
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,
                  const char_type* __pb, const char_type* __pe) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,
                  const tm* __tm, char __fmt, char __mod = 0) const
    {
        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~time_put() {}
    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,
                             char __fmt, char __mod) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_put(const char* __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_put(const string& __nm, size_t __refs)
        : locale::facet(__refs),
          __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id
time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,
                                       char_type __fl, const tm* __tm,
                                       const char_type* __pb,
                                       const char_type* __pe) const
{
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
    for (; __pb != __pe; ++__pb)
    {
        if (__ct.narrow(*__pb, 0) == '%')
        {
            if (++__pb == __pe)
            {
                *__s++ = __pb[-1];
                break;
            }
            char __mod = 0;
            char __fmt = __ct.narrow(*__pb, 0);
            if (__fmt == 'E' || __fmt == 'O')
            {
                if (++__pb == __pe)
                {
                    *__s++ = __pb[-2];
                    *__s++ = __pb[-1];
                    break;
                }
                __mod = __fmt;
                __fmt = __ct.narrow(*__pb, 0);
            }
            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
        }
        else
            *__s++ = *__pb;
    }
    return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,
                                          char_type, const tm* __tm,
                                          char __fmt, char __mod) const
{
    char_type __nar[100];
    char_type* __nb = __nar;
    char_type* __ne = __nb + 100;
    __do_put(__nb, __ne, __tm, __fmt, __mod);
    return std::__1::copy(__nb, __ne, __s);
}

extern template class __attribute__ ((__visibility__("default"))) time_put<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator>
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_put_byname(const char* __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit time_put_byname(const string& __nm, size_t __refs = 0)
        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~time_put_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) time_put_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) time_put_byname<wchar_t>;

// money_base

class __attribute__ ((__visibility__("default"))) money_base
{
public:
    enum part {none, space, symbol, sign, value};
    struct pattern {char field[4];};

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) money_base() {}
};

// moneypunct

template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct
    : public locale::facet,
      public money_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit moneypunct(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type decimal_point() const {return do_decimal_point();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) char_type thousands_sep() const {return do_thousands_sep();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string grouping() const {return do_grouping();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type curr_symbol() const {return do_curr_symbol();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type positive_sign() const {return do_positive_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) string_type negative_sign() const {return do_negative_sign();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) int frac_digits() const {return do_frac_digits();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pattern pos_format() const {return do_pos_format();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) pattern neg_format() const {return do_neg_format();}

    static locale::id id;
    static const bool intl = _International;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~moneypunct() {}

    virtual char_type do_decimal_point() const {return numeric_limits<char_type>::max();}
    virtual char_type do_thousands_sep() const {return numeric_limits<char_type>::max();}
    virtual string do_grouping() const {return string();}
    virtual string_type do_curr_symbol() const {return string_type();}
    virtual string_type do_positive_sign() const {return string_type();}
    virtual string_type do_negative_sign() const {return string_type(1, '-');}
    virtual int do_frac_digits() const {return 0;}
    virtual pattern do_pos_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
    virtual pattern do_neg_format() const
        {pattern __p = {{symbol, sign, none, value}}; return __p;}
};

template <class _CharT, bool _International>
locale::id
moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool
moneypunct<_CharT, _International>::intl;

extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct<wchar_t, true>;

// moneypunct_byname

template <class _CharT, bool _International = false>
class __attribute__ ((__type_visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International>
{
public:
    typedef money_base::pattern pattern;
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~moneypunct_byname() {}

    virtual char_type do_decimal_point() const {return __decimal_point_;}
    virtual char_type do_thousands_sep() const {return __thousands_sep_;}
    virtual string do_grouping() const {return __grouping_;}
    virtual string_type do_curr_symbol() const {return __curr_symbol_;}
    virtual string_type do_positive_sign() const {return __positive_sign_;}
    virtual string_type do_negative_sign() const {return __negative_sign_;}
    virtual int do_frac_digits() const {return __frac_digits_;}
    virtual pattern do_pos_format() const {return __pos_format_;}
    virtual pattern do_neg_format() const {return __neg_format_;}

private:
    char_type __decimal_point_;
    char_type __thousands_sep_;
    string __grouping_;
    string_type __curr_symbol_;
    string_type __positive_sign_;
    string_type __negative_sign_;
    int __frac_digits_;
    pattern __pos_format_;
    pattern __neg_format_;

    void init(const char*);
};

template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template<> __attribute__ ((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);

extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<char, true>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__ ((__visibility__("default"))) moneypunct_byname<wchar_t, true>;

// money_get

template <class _CharT>
class __money_get
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __money_get() {}

    static void __gather_info(bool __intl, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __psn,
                              string_type& __nsn, int& __fd);
};

template <class _CharT>
void
__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __psn,
                                   string_type& __nsn, int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        __pat = __mp.neg_format();
        __nsn = __mp.negative_sign();
        __psn = __mp.positive_sign();
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

extern template class __attribute__ ((__visibility__("default"))) __money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_get<wchar_t>;

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_get
    : public locale::facet,
      private __money_get<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit money_get(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, long double& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,
                  ios_base::iostate& __err, string_type& __v) const
    {
        return do_get(__b, __e, __intl, __iob, __err, __v);
    }

    static locale::id id;

protected:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~money_get() {}

    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             long double& __v) const;
    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                             ios_base& __iob, ios_base::iostate& __err,
                             string_type& __v) const;

private:
    static bool __do_get(iter_type& __b, iter_type __e,
                         bool __intl, const locale& __loc,
                         ios_base::fmtflags __flags, ios_base::iostate& __err,
                         bool& __neg, const ctype<char_type>& __ct,
                         unique_ptr<char_type, void(*)(void*)>& __wb,
                         char_type*& __wn, char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id
money_get<_CharT, _InputIterator>::id;

__attribute__ ((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__ ((__visibility__("hidden")))
void
__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)
{
    bool __owns = __b.get_deleter() != __do_nothing;
    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?
                       2 * __cur_cap : numeric_limits<size_t>::max();
    if (__new_cap == 0)
        __new_cap = sizeof(_Tp);
    size_t __n_off = static_cast<size_t>(__n - __b.get());
    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
    if (__t == 0)
        __throw_bad_alloc();
    if (__owns)
        __b.release();
    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
    __new_cap /= sizeof(_Tp);
    __n = __b.get() + __n_off;
    __e = __b.get() + __new_cap;
}

// true == success
template <class _CharT, class _InputIterator>
bool
money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,
                                            bool __intl, const locale& __loc,
                                            ios_base::fmtflags __flags,
                                            ios_base::iostate& __err,
                                            bool& __neg,
                                            const ctype<char_type>& __ct,
                                            unique_ptr<char_type, void(*)(void*)>& __wb,
                                            char_type*& __wn, char_type* __we)
{
    const unsigned __bz = 100;
    unsigned __gbuf[__bz];
    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
    unsigned* __gn = __gb.get();
    unsigned* __ge = __gn + __bz;
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __psn;
    string_type __nsn;
    // Capture the spaces read into money_base::{space,none} so they
    // can be compared to initial spaces in __sym.
    string_type __spaces;
    int __fd;
    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                       __sym, __psn, __nsn, __fd);
    const string_type* __trailing_sign = 0;
    __wn = __wb.get();
    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::space:
            if (__p != 3)
            {
                if (__ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
                else
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            [[fallthrough]];
        case money_base::none:
            if (__p != 3)
            {
                while (__b != __e && __ct.is(ctype_base::space, *__b))
                    __spaces.push_back(*__b++);
            }
            break;
        case money_base::sign:
            if (__psn.size() + __nsn.size() > 0)
            {
                if (__psn.size() == 0 || __nsn.size() == 0)
                { // sign is optional
                    if (__psn.size() > 0)
                    { // __nsn.size() == 0
                        if (*__b == __psn[0])
                        {
                            ++__b;
                            if (__psn.size() > 1)
                                __trailing_sign = &__psn;
                        }
                        else
                            __neg = true;
                    }
                    else if (*__b == __nsn[0]) // __nsn.size() > 0 &&  __psn.size() == 0
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                }
                else // sign is required
                {
                    if (*__b == __psn[0])
                    {
                        ++__b;
                        if (__psn.size() > 1)
                            __trailing_sign = &__psn;
                    }
                    else if (*__b == __nsn[0])
                    {
                        ++__b;
                        __neg = true;
                        if (__nsn.size() > 1)
                            __trailing_sign = &__nsn;
                    }
                    else
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            break;
        case money_base::symbol:
            {
            bool __more_needed = __trailing_sign ||
                                 (__p < 2) ||
                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
            bool __sb = (__flags & ios_base::showbase) != 0;
            if (__sb || __more_needed)
            {
                typename string_type::const_iterator __sym_space_end = __sym.begin();
                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                                __pat.field[__p - 1] == money_base::space)) {
                    // Match spaces we've already read against spaces at
                    // the beginning of __sym.
                    while (__sym_space_end != __sym.end() &&
                           __ct.is(ctype_base::space, *__sym_space_end))
                        ++__sym_space_end;
                    const size_t __num_spaces = __sym_space_end - __sym.begin();
                    if (__num_spaces > __spaces.size() ||
                        !equal(__spaces.end() - __num_spaces, __spaces.end(),
                               __sym.begin())) {
                        // No match. Put __sym_space_end back at the
                        // beginning of __sym, which will prevent a
                        // match in the next loop.
                        __sym_space_end = __sym.begin();
                    }
                }
                typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                while (__sym_curr_char != __sym.end() && __b != __e &&
                       *__b == *__sym_curr_char) {
                    ++__b;
                    ++__sym_curr_char;
                }
                if (__sb && __sym_curr_char != __sym.end())
                {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            }
            break;
        case money_base::value:
            {
            unsigned __ng = 0;
            for (; __b != __e; ++__b)
            {
                char_type __c = *__b;
                if (__ct.is(ctype_base::digit, __c))
                {
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = __c;
                    ++__ng;
                }
                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)
                {
                    if (__gn == __ge)
                        __double_or_nothing(__gb, __gn, __ge);
                    *__gn++ = __ng;
                    __ng = 0;
                }
                else
                    break;
            }
            if (__gb.get() != __gn && __ng > 0)
            {
                if (__gn == __ge)
                    __double_or_nothing(__gb, __gn, __ge);
                *__gn++ = __ng;
            }
            if (__fd > 0)
            {
                if (__b == __e || *__b != __dp)
                {
                    __err |= ios_base::failbit;
                    return false;
                }
                for (++__b; __fd > 0; --__fd, ++__b)
                {
                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))
                    {
                        __err |= ios_base::failbit;
                        return false;
                    }
                    if (__wn == __we)
                        __double_or_nothing(__wb, __wn, __we);
                    *__wn++ = *__b;
                }
            }
            if (__wn == __wb.get())
            {
                __err |= ios_base::failbit;
                return false;
            }
            }
            break;
        }
    }
    if (__trailing_sign)
    {
        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)
        {
            if (__b == __e || *__b != (*__trailing_sign)[__i])
            {
                __err |= ios_base::failbit;
                return false;
            }
        }
    }
    if (__gb.get() != __gn)
    {
        ios_base::iostate __et = ios_base::goodbit;
        __check_grouping(__grp, __gb.get(), __gn, __et);
        if (__et)
        {
            __err |= ios_base::failbit;
            return false;
        }
    }
    return true;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          long double& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        const char __src[] = "0123456789";
        char_type __atoms[sizeof(__src)-1];
        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
        char __nbuf[__bz];
        char* __nc = __nbuf;
        unique_ptr<char, void(*)(void*)> __h(nullptr, free);
        if (__wn - __wb.get() > __bz-2)
        {
            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
            if (__h.get() == nullptr)
                __throw_bad_alloc();
            __nc = __h.get();
        }
        if (__neg)
            *__nc++ = '-';
        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
            *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
        *__nc = char();
        if (sscanf(__nbuf, "%Lf", &__v) != 1)
            __throw_runtime_error("money_get error");
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator
money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,
                                          bool __intl, ios_base& __iob,
                                          ios_base::iostate& __err,
                                          string_type& __v) const
{
    const int __bz = 100;
    char_type __wbuf[__bz];
    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
    char_type* __wn;
    char_type* __we = __wbuf + __bz;
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = false;
    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,
                 __wb, __wn, __we))
    {
        __v.clear();
        if (__neg)
            __v.push_back(__ct.widen('-'));
        char_type __z = __ct.widen('0');
        char_type* __w;
        for (__w = __wb.get(); __w < __wn-1; ++__w)
            if (*__w != __z)
                break;
        __v.append(__w, __wn);
    }
    if (__b == __e)
        __err |= ios_base::eofbit;
    return __b;
}

extern template class __attribute__ ((__visibility__("default"))) money_get<char>;
extern template class __attribute__ ((__visibility__("default"))) money_get<wchar_t>;

// money_put

template <class _CharT>
class __money_put
{
protected:
    typedef _CharT char_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) __money_put() {}

    static void __gather_info(bool __intl, bool __neg, const locale& __loc,
                              money_base::pattern& __pat, char_type& __dp,
                              char_type& __ts, string& __grp,
                              string_type& __sym, string_type& __sn,
                              int& __fd);
    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,
                         ios_base::fmtflags __flags,
                         const char_type* __db, const char_type* __de,
                         const ctype<char_type>& __ct, bool __neg,
                         const money_base::pattern& __pat, char_type __dp,
                         char_type __ts, const string& __grp,
                         const string_type& __sym, const string_type& __sn,
                         int __fd);
};

template <class _CharT>
void
__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,
                                   money_base::pattern& __pat, char_type& __dp,
                                   char_type& __ts, string& __grp,
                                   string_type& __sym, string_type& __sn,
                                   int& __fd)
{
    if (__intl)
    {
        const moneypunct<char_type, true>& __mp =
            use_facet<moneypunct<char_type, true> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
    else
    {
        const moneypunct<char_type, false>& __mp =
            use_facet<moneypunct<char_type, false> >(__loc);
        if (__neg)
        {
            __pat = __mp.neg_format();
            __sn = __mp.negative_sign();
        }
        else
        {
            __pat = __mp.pos_format();
            __sn = __mp.positive_sign();
        }
        __dp = __mp.decimal_point();
        __ts = __mp.thousands_sep();
        __grp = __mp.grouping();
        __sym = __mp.curr_symbol();
        __fd = __mp.frac_digits();
    }
}

template <class _CharT>
void
__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,
                              ios_base::fmtflags __flags,
                              const char_type* __db, const char_type* __de,
                              const ctype<char_type>& __ct, bool __neg,
                              const money_base::pattern& __pat, char_type __dp,
                              char_type __ts, const string& __grp,
                              const string_type& __sym, const string_type& __sn,
                              int __fd)
{
    __me = __mb;
    for (unsigned __p = 0; __p < 4; ++__p)
    {
        switch (__pat.field[__p])
        {
        case money_base::none:
            __mi = __me;
            break;
        case money_base::space:
            __mi = __me;
            *__me++ = __ct.widen(' ');
            break;
        case money_base::sign:
            if (!__sn.empty())
                *__me++ = __sn[0];
            break;
        case money_base::symbol:
            if (!__sym.empty() && (__flags & ios_base::showbase))
                __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
            break;
        case money_base::value:
            {
            // remember start of value so we can reverse it
            char_type* __t = __me;
            // find beginning of digits
            if (__neg)
                ++__db;
            // find end of digits
            const char_type* __d;
            for (__d = __db; __d < __de; ++__d)
                if (!__ct.is(ctype_base::digit, *__d))
                    break;
            // print fractional part
            if (__fd > 0)
            {
                int __f;
                for (__f = __fd; __d > __db && __f > 0; --__f)
                    *__me++ = *--__d;
                char_type __z = __f > 0 ? __ct.widen('0') : char_type();
                for (; __f > 0; --__f)
                    *__me++ = __z;
                *__me++ = __dp;
            }
            // print units part
            if (__d == __db)
            {
                *__me++ = __ct.widen('0');
            }
            else
            {
                unsigned __ng = 0;
                unsigned __ig = 0;
                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                              : static_cast<unsigned>(__grp[__ig]);
                while (__d != __db)
                {
                    if (__ng == __gl)
                    {
                        *__me++ = __ts;
                        __ng = 0;
                        if (++__ig < __grp.size())
                            __gl = __grp[__ig] == numeric_limits<char>::max() ?
                                        numeric_limits<unsigned>::max() :
                                        static_cast<unsigned>(__grp[__ig]);
                    }
                    *__me++ = *--__d;
                    ++__ng;
                }
            }
            // reverse it
            reverse(__t, __me);
            }
            break;
        }
    }
    // print rest of sign, if any
    if (__sn.size() > 1)
        __me = std::__1::copy(__sn.begin()+1, __sn.end(), __me);
    // set alignment
    if ((__flags & ios_base::adjustfield) == ios_base::left)
        __mi = __me;
    else if ((__flags & ios_base::adjustfield) != ios_base::internal)
        __mi = __mb;
}

extern template class __attribute__ ((__visibility__("default"))) __money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) __money_put<wchar_t>;

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class __attribute__ ((__type_visibility__("default"))) money_put
    : public locale::facet,
      private __money_put<_CharT>
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;
    typedef basic_string<char_type> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit money_put(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  long double __units) const
    {
        return do_put(__s, __intl, __iob, __fl, __units);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,
                  const string_type& __digits) const
    {
        return do_put(__s, __intl, __iob, __fl, __digits);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~money_put() {}

    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, long double __units) const;
    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,
                             char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id
money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           long double __units) const
{
    // convert to char
    const size_t __bs = 100;
    char __buf[__bs];
    char* __bb = __buf;
    char_type __digits[__bs];
    char_type* __db = __digits;
    int __n = snprintf(__bb, __bs, "%.0Lf", __units);
    unique_ptr<char, void(*)(void*)> __hn(nullptr, free);
    unique_ptr<char_type, void(*)(void*)> __hd(0, free);
    // secure memory for digit storage
    if (static_cast<size_t>(__n) > __bs-1)
    {
        __n = asprintf_l(&__bb, 0, "%.0Lf", __units);
        if (__n == -1)
            __throw_bad_alloc();
        __hn.reset(__bb);
        __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
        if (__hd == nullptr)
            __throw_bad_alloc();
        __db = __hd.get();
    }
    // gather info
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    __ct.widen(__bb, __bb + __n, __db);
    bool __neg = __n > 0 && __bb[0] == '-';
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    // secure memory for formatting
    char_type __mbuf[__bs];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __hw(0, free);
    size_t __exn = __n > __fd ?
                   (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > __bs)
    {
        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __hw.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }
    // format
    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __db, __db + __n, __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base& __iob, char_type __fl,
                                           const string_type& __digits) const
{
    // gather info
    locale __loc = __iob.getloc();
    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
    money_base::pattern __pat;
    char_type __dp;
    char_type __ts;
    string __grp;
    string_type __sym;
    string_type __sn;
    int __fd;
    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    // secure memory for formatting
    char_type __mbuf[100];
    char_type* __mb = __mbuf;
    unique_ptr<char_type, void(*)(void*)> __h(0, free);
    size_t __exn = static_cast<int>(__digits.size()) > __fd ?
                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +
                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1
                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
    if (__exn > 100)
    {
        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
        __mb = __h.get();
        if (__mb == 0)
            __throw_bad_alloc();
    }
    // format
    char_type* __mi;
    char_type* __me;
    this->__format(__mb, __mi, __me, __iob.flags(),
                   __digits.data(), __digits.data() + __digits.size(), __ct,
                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__ ((__visibility__("default"))) money_put<char>;
extern template class __attribute__ ((__visibility__("default"))) money_put<wchar_t>;

// messages

class __attribute__ ((__visibility__("default"))) messages_base
{
public:
    typedef ptrdiff_t catalog;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) messages_base() {}
};

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages
    : public locale::facet,
      public messages_base
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit messages(size_t __refs = 0)
        : locale::facet(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    catalog open(const basic_string<char>& __nm, const locale& __loc) const
    {
        return do_open(__nm, __loc);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    string_type get(catalog __c, int __set, int __msgid,
                    const string_type& __dflt) const
    {
        return do_get(__c, __set, __msgid, __dflt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void close(catalog __c) const
    {
        do_close(__c);
    }

    static locale::id id;

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~messages() {}

    virtual catalog do_open(const basic_string<char>&, const locale&) const;
    virtual string_type do_get(catalog, int __set, int __msgid,
                               const string_type& __dflt) const;
    virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id
messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const
{

    catalog __cat = (catalog)catopen(__nm.c_str(), 1);
    if (__cat != -1)
        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));
    return __cat;




}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type& __dflt) const
{

    string __ndflt;
    __narrow_to_utf8<sizeof(char_type)*8>()(back_inserter(__ndflt),
                                                       __dflt.c_str(),
                                                       __dflt.c_str() + __dflt.size());
    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
    string_type __w;
    __widen_from_utf8<sizeof(char_type)*8>()(back_inserter(__w),
                                                        __n, __n + std::__1::strlen(__n));
    return __w;






}

template <class _CharT>
void
messages<_CharT>::do_close(catalog __c) const
{

    if (__c != -1)
        __c <<= 1;
    nl_catd __cat = (nl_catd)__c;
    catclose(__cat);



}

extern template class __attribute__ ((__visibility__("default"))) messages<char>;
extern template class __attribute__ ((__visibility__("default"))) messages<wchar_t>;

template <class _CharT>
class __attribute__ ((__type_visibility__("default"))) messages_byname
    : public messages<_CharT>
{
public:
    typedef messages_base::catalog catalog;
    typedef basic_string<_CharT> string_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit messages_byname(const char*, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit messages_byname(const string&, size_t __refs = 0)
        : messages<_CharT>(__refs) {}

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    ~messages_byname() {}
};

extern template class __attribute__ ((__visibility__("default"))) messages_byname<char>;
extern template class __attribute__ ((__visibility__("default"))) messages_byname<wchar_t>;

template<class _Codecvt, class _Elem = wchar_t,
         class _Wide_alloc = allocator<_Elem>,
         class _Byte_alloc = allocator<char> >
class __attribute__ ((__type_visibility__("default"))) wstring_convert
{
public:
    typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
    typedef typename _Codecvt::state_type state_type;
    typedef typename wide_string::traits_type::int_type int_type;

private:
    byte_string __byte_err_string_;
    wide_string __wide_err_string_;
    _Codecvt* __cvtptr_;
    state_type __cvtstate_;
    size_t __cvtcount_;

    wstring_convert(const wstring_convert& __wc);
    wstring_convert& operator=(const wstring_convert& __wc);
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wstring_convert() : wstring_convert(new _Codecvt) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit wstring_convert(_Codecvt* __pcvt);






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wstring_convert(_Codecvt* __pcvt, state_type __state);
    explicit wstring_convert(const byte_string& __byte_err,
                    const wide_string& __wide_err = wide_string());

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wstring_convert(wstring_convert&& __wc);

    ~wstring_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wide_string from_bytes(char __byte)
        {return from_bytes(&__byte, &__byte+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wide_string from_bytes(const char* __ptr)
        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    wide_string from_bytes(const byte_string& __str)
        {return from_bytes(__str.data(), __str.data() + __str.size());}
    wide_string from_bytes(const char* __first, const char* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    byte_string to_bytes(_Elem __wchar)
        {return to_bytes(&__wchar, &__wchar+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    byte_string to_bytes(const _Elem* __wptr)
        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    byte_string to_bytes(const wide_string& __wstr)
        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}
    byte_string to_bytes(const _Elem* __first, const _Elem* __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t converted() const noexcept {return __cvtcount_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    state_type state() const {return __cvtstate_;}
};

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt)
        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(_Codecvt* __pcvt, state_type __state)
        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)
{
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)
        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
          __cvtstate_(), __cvtcount_(0)
{
    __cvtptr_ = new _Codecvt;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    wstring_convert(wstring_convert&& __wc)
        : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)),
          __wide_err_string_(std::__1::move(__wc.__wide_err_string_)),
          __cvtptr_(__wc.__cvtptr_),
          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtcount_)
{
    __wc.__cvtptr_ = nullptr;
}



template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()
{
    delete __cvtptr_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    from_bytes(const char* __frm, const char* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        wide_string __ws(2*(__frm_end - __frm), _Elem());
        if (__frm != __frm_end)
            __ws.resize(__ws.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            _Elem* __to = &__ws[0];
            _Elem* __to_end = __to + __ws.size();
            const char* __frm_nxt;
            do
            {
                _Elem* __to_nxt;
                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,
                                          __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __ws.resize(__to - &__ws[0]);
                    // This only gets executed if _Elem is char
                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __ws.resize(__to_nxt - &__ws[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__ws[0];
                    __ws.resize(2 * __s);
                    __to = &__ws[0] + __s;
                    __to_end = &__ws[0] + __ws.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
            return __ws;
    }

    if (__wide_err_string_.empty())
        __throw_range_error("wstring_convert: from_bytes error");

    return __wide_err_string_;
}

template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::
    to_bytes(const _Elem* __frm, const _Elem* __frm_end)
{
    __cvtcount_ = 0;
    if (__cvtptr_ != nullptr)
    {
        byte_string __bs(2*(__frm_end - __frm), char());
        if (__frm != __frm_end)
            __bs.resize(__bs.capacity());
        codecvt_base::result __r = codecvt_base::ok;
        state_type __st = __cvtstate_;
        if (__frm != __frm_end)
        {
            char* __to = &__bs[0];
            char* __to_end = __to + __bs.size();
            const _Elem* __frm_nxt;
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,
                                           __to, __to_end, __to_nxt);
                __cvtcount_ += __frm_nxt - __frm;
                if (__frm_nxt == __frm)
                {
                    __r = codecvt_base::error;
                }
                else if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    // This only gets executed if _Elem is char
                    __bs.append((const char*)__frm, (const char*)__frm_end);
                    __frm = __frm_nxt;
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                    __frm = __frm_nxt;
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __s = __to_nxt - &__bs[0];
                    __bs.resize(2 * __s);
                    __to = &__bs[0] + __s;
                    __to_end = &__bs[0] + __bs.size();
                    __frm = __frm_nxt;
                }
            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
        }
        if (__r == codecvt_base::ok)
        {
            size_t __s = __bs.size();
            __bs.resize(__bs.capacity());
            char* __to = &__bs[0] + __s;
            char* __to_end = __to + __bs.size();
            do
            {
                char* __to_nxt;
                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                if (__r == codecvt_base::noconv)
                {
                    __bs.resize(__to - &__bs[0]);
                    __r = codecvt_base::ok;
                }
                else if (__r == codecvt_base::ok)
                {
                    __bs.resize(__to_nxt - &__bs[0]);
                }
                else if (__r == codecvt_base::partial)
                {
                    ptrdiff_t __sp = __to_nxt - &__bs[0];
                    __bs.resize(2 * __sp);
                    __to = &__bs[0] + __sp;
                    __to_end = &__bs[0] + __bs.size();
                }
            } while (__r == codecvt_base::partial);
            if (__r == codecvt_base::ok)
                return __bs;
        }
    }

    if (__byte_err_string_.empty())
        __throw_range_error("wstring_convert: to_bytes error");

    return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class __attribute__ ((__type_visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr>
{
public:
    // types:
    typedef _Elem char_type;
    typedef _Tr traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef typename _Codecvt::state_type state_type;

private:
    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    char_type* __intbuf_;
    size_t __ibs_;
    streambuf* __bufptr_;
    _Codecvt* __cv_;
    state_type __st_;
    ios_base::openmode __cm_;
    bool __owns_eb_;
    bool __owns_ib_;
    bool __always_noconv_;

    wbuffer_convert(const wbuffer_convert&);
    wbuffer_convert& operator=(const wbuffer_convert&);

public:

    wbuffer_convert() : wbuffer_convert(nullptr) {}
    explicit wbuffer_convert(streambuf* __bytebuf,
                             _Codecvt* __pcvt = new _Codecvt,
                             state_type __state = state_type());







    ~wbuffer_convert();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streambuf* rdbuf() const {return __bufptr_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streambuf* rdbuf(streambuf* __bytebuf)
    {
        streambuf* __r = __bufptr_;
        __bufptr_ = __bytebuf;
        return __r;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    state_type state() const {return __st_;}

protected:
    virtual int_type underflow();
    virtual int_type pbackfail(int_type __c = traits_type::eof());
    virtual int_type overflow (int_type __c = traits_type::eof());
    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,
                                                            streamsize __n);
    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type __sp,
                             ios_base::openmode __wch = ios_base::in | ios_base::out);
    virtual int sync();

private:
    bool __read_mode();
    void __write_mode();
    wbuffer_convert* __close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::
    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(nullptr),
      __extbufnext_(nullptr),
      __extbufend_(nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)
{
    setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()
{
    __close();
    delete __cv_;
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    bool __initial = __read_mode();
    char_type __1buf;
    if (this->gptr() == 0)
        this->setg(&__1buf, &__1buf+1, &__1buf+1);
    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
    int_type __c = traits_type::eof();
    if (this->gptr() == this->egptr())
    {
        std::__1::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
            if (__nmemb != 0)
            {
                this->setg(this->eback(),
                           this->eback() + __unget_sz,
                           this->eback() + __unget_sz + __nmemb);
                __c = *this->gptr();
            }
        }
        else
        {
             ((void)0);
             if (__extbufend_ != __extbufnext_)
                std::__1::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
            streamsize __nmemb = std::__1::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));
            codecvt_base::result __r;
            // FIXME: Do we ever need to restore the state here?
            //state_type __svs = __st_;
            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
            if (__nr != 0)
            {
                __extbufend_ = __extbufnext_ + __nr;
                char_type* __inext;
                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                                       this->eback() + __unget_sz,
                                       this->egptr(), __inext);
                if (__r == codecvt_base::noconv)
                {
                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,
                               (char_type*) const_cast<char *>(__extbufend_));
                    __c = *this->gptr();
                }
                else if (__inext != this->eback() + __unget_sz)
                {
                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                    __c = *this->gptr();
                }
            }
        }
    }
    else
        __c = *this->gptr();
    if (this->eback() == &__1buf)
        this->setg(0, 0, 0);
    return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)
{
    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())
    {
        if (traits_type::eq_int_type(__c, traits_type::eof()))
        {
            this->gbump(-1);
            return traits_type::not_eof(__c);
        }
        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
        {
            this->gbump(-1);
            *this->gptr() = traits_type::to_char_type(__c);
            return __c;
        }
    }
    return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return traits_type::eof();
    __write_mode();
    char_type __1buf;
    char_type* __pb_save = this->pbase();
    char_type* __epb_save = this->epptr();
    if (!traits_type::eq_int_type(__c, traits_type::eof()))
    {
        if (this->pptr() == 0)
            this->setp(&__1buf, &__1buf+1);
        *this->pptr() = traits_type::to_char_type(__c);
        this->pbump(1);
    }
    if (this->pptr() != this->pbase())
    {
        if (__always_noconv_)
        {
            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                return traits_type::eof();
        }
        else
        {
            char* __extbe = __extbuf_;
            codecvt_base::result __r;
            do
            {
                const char_type* __e;
                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
                                        __extbuf_, __extbuf_ + __ebs_, __extbe);
                if (__e == this->pbase())
                    return traits_type::eof();
                if (__r == codecvt_base::noconv)
                {
                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                }
                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
                {
                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                        return traits_type::eof();
                    if (__r == codecvt_base::partial)
                    {
                        this->setp(const_cast<char_type *>(__e), this->pptr());
                        this->__pbump(this->epptr() - this->pbase());
                    }
                }
                else
                    return traits_type::eof();
            } while (__r == codecvt_base::partial);
        }
        this->setp(__pb_save, __epb_save);
    }
    return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)
{
    this->setg(0, 0, 0);
    this->setp(0, 0);
    if (__owns_eb_)
        delete [] __extbuf_;
    if (__owns_ib_)
        delete [] __intbuf_;
    __ebs_ = __n;
    if (__ebs_ > sizeof(__extbuf_min_))
    {
        if (__always_noconv_ && __s)
        {
            __extbuf_ = (char*)__s;
            __owns_eb_ = false;
        }
        else
        {
            __extbuf_ = new char[__ebs_];
            __owns_eb_ = true;
        }
    }
    else
    {
        __extbuf_ = __extbuf_min_;
        __ebs_ = sizeof(__extbuf_min_);
        __owns_eb_ = false;
    }
    if (!__always_noconv_)
    {
        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
        if (__s && __ibs_ >= sizeof(__extbuf_min_))
        {
            __intbuf_ = __s;
            __owns_ib_ = false;
        }
        else
        {
            __intbuf_ = new char_type[__ibs_];
            __owns_ib_ = true;
        }
    }
    else
    {
        __ibs_ = 0;
        __intbuf_ = 0;
        __owns_ib_ = false;
    }
    return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,
                                        ios_base::openmode __om)
{
    int __width = __cv_->encoding();
    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
        return pos_type(off_type(-1));
    // __width > 0 || __off == 0, now check __way
    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
        return pos_type(off_type(-1));
    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
    __r.state(__st_);
    return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)
{
    if (__cv_ == 0 || __bufptr_ == 0 || sync())
        return pos_type(off_type(-1));
    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
        return pos_type(off_type(-1));
    return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int
wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()
{
    if (__cv_ == 0 || __bufptr_ == 0)
        return 0;
    if (__cm_ & ios_base::out)
    {
        if (this->pptr() != this->pbase())
            if (overflow() == traits_type::eof())
                return -1;
        codecvt_base::result __r;
        do
        {
            char* __extbe;
            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
                return -1;
        } while (__r == codecvt_base::partial);
        if (__r == codecvt_base::error)
            return -1;
        if (__bufptr_->pubsync())
            return -1;
    }
    else if (__cm_ & ios_base::in)
    {
        off_type __c;
        if (__always_noconv_)
            __c = this->egptr() - this->gptr();
        else
        {
            int __width = __cv_->encoding();
            __c = __extbufend_ - __extbufnext_;
            if (__width > 0)
                __c += __width * (this->egptr() - this->gptr());
            else
            {
                if (this->gptr() != this->egptr())
                {
                    reverse(this->gptr(), this->egptr());
                    codecvt_base::result __r;
                    const char_type* __e = this->gptr();
                    char* __extbe;
                    do
                    {
                        __r = __cv_->out(__st_, __e, this->egptr(), __e,
                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                        switch (__r)
                        {
                        case codecvt_base::noconv:
                            __c += this->egptr() - this->gptr();
                            break;
                        case codecvt_base::ok:
                        case codecvt_base::partial:
                            __c += __extbe - __extbuf_;
                            break;
                        default:
                            return -1;
                        }
                    } while (__r == codecvt_base::partial);
                }
            }
        }
        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
            return -1;
        this->setg(0, 0, 0);
        __cm_ = 0;
    }
    return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool
wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()
{
    if (!(__cm_ & ios_base::in))
    {
        this->setp(0, 0);
        if (__always_noconv_)
            this->setg((char_type*)__extbuf_,
                       (char_type*)__extbuf_ + __ebs_,
                       (char_type*)__extbuf_ + __ebs_);
        else
            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
        __cm_ = ios_base::in;
        return true;
    }
    return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void
wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()
{
    if (!(__cm_ & ios_base::out))
    {
        this->setg(0, 0, 0);
        if (__ebs_ > sizeof(__extbuf_min_))
        {
            if (__always_noconv_)
                this->setp((char_type*)__extbuf_,
                           (char_type*)__extbuf_ + (__ebs_ - 1));
            else
                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
        }
        else
            this->setp(0, 0);
        __cm_ = ios_base::out;
    }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>*
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()
{
    wbuffer_convert* __rt = nullptr;
    if (__cv_ != nullptr && __bufptr_ != nullptr)
    {
        __rt = this;
        if ((__cm_ & ios_base::out) && sync())
            __rt = nullptr;
    }
    return __rt;
}

} }
# 140 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ostream" 2

# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 1
// -*- C++ -*-
//===---------------------------- bitset ----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    bitset synopsis

namespace std
{

namespace std {

template <size_t N>
class bitset
{
public:
    // bit reference:
    class reference
    {
        friend class bitset;
        reference() noexcept;
    public:
        ~reference() noexcept;
        reference& operator=(bool x) noexcept;           // for b[i] = x;
        reference& operator=(const reference&) noexcept; // for b[i] = b[j];
        bool operator~() const noexcept;                 // flips the bit
        operator bool() const noexcept;                  // for x = b[i];
        reference& flip() noexcept;                      // for b[i].flip();
    };

    // 23.3.5.1 constructors:
    constexpr bitset() noexcept;
    constexpr bitset(unsigned long long val) noexcept;
    template <class charT>
        explicit bitset(const charT* str,
                        typename basic_string<charT>::size_type n = basic_string<charT>::npos,
                        charT zero = charT('0'), charT one = charT('1'));
    template<class charT, class traits, class Allocator>
        explicit bitset(const basic_string<charT,traits,Allocator>& str,
                        typename basic_string<charT,traits,Allocator>::size_type pos = 0,
                        typename basic_string<charT,traits,Allocator>::size_type n =
                                 basic_string<charT,traits,Allocator>::npos,
                        charT zero = charT('0'), charT one = charT('1'));

    // 23.3.5.2 bitset operations:
    bitset& operator&=(const bitset& rhs) noexcept;
    bitset& operator|=(const bitset& rhs) noexcept;
    bitset& operator^=(const bitset& rhs) noexcept;
    bitset& operator<<=(size_t pos) noexcept;
    bitset& operator>>=(size_t pos) noexcept;
    bitset& set() noexcept;
    bitset& set(size_t pos, bool val = true);
    bitset& reset() noexcept;
    bitset& reset(size_t pos);
    bitset operator~() const noexcept;
    bitset& flip() noexcept;
    bitset& flip(size_t pos);

    // element access:
    constexpr bool operator[](size_t pos) const; // for b[i];
    reference operator[](size_t pos);            // for b[i];
    unsigned long to_ulong() const;
    unsigned long long to_ullong() const;
    template <class charT, class traits, class Allocator>
        basic_string<charT, traits, Allocator> to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT, class traits>
        basic_string<charT, traits, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    template <class charT>
        basic_string<charT, char_traits<charT>, allocator<charT> > to_string(charT zero = charT('0'), charT one = charT('1')) const;
    basic_string<char, char_traits<char>, allocator<char> > to_string(char zero = '0', char one = '1') const;
    size_t count() const noexcept;
    constexpr size_t size() const noexcept;
    bool operator==(const bitset& rhs) const noexcept;
    bool operator!=(const bitset& rhs) const noexcept;
    bool test(size_t pos) const;
    bool all() const noexcept;
    bool any() const noexcept;
    bool none() const noexcept;
    bitset operator<<(size_t pos) const noexcept;
    bitset operator>>(size_t pos) const noexcept;
};

// 23.3.5.3 bitset operators:
template <size_t N>
bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;

template <size_t N>
bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;

template <class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);

template <class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

template <size_t N> struct hash<std::bitset<N>>;

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 116 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 2
# 126 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 130 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 2 3


namespace std { inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * CHAR_BIT>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * CHAR_BIT>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 263 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}
# 278 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/bitset" 3
{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{
    // do middle whole words
    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * CHAR_BIT), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * CHAR_BIT), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * CHAR_BIT);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{
    // do middle whole words
    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{
    // do middle whole words
    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;
    // do last partial word
    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void flip() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long long to_ullong() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool any() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(
        _Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                 : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)
    )
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference __make_ref(size_t) noexcept
        {return reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) iterator __make_iter(size_t) noexcept
        {return iterator(nullptr, 0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(nullptr, 0);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) void flip() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool all() const noexcept {return true;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool any() const noexcept {return false;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;

    // 23.3.5.1 constructors:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr bitset() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value> >
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));

    // 23.3.5.2 bitset operations:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset operator~() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);

    // element access:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t count() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) bool none() const noexcept {return !any();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT, class>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        if (__c == __zero)
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        if (_Traits::eq(__c, __zero))
            (*this)[__i] = false;
        else
            (*this)[__i] = true;
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__1::__count_bool_true(base::__make_iter(0), _Size));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 142 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ostream" 2
# 146 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/ostream" 3


namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits>
{
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.2.2 Constructor/destructor:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)
    { this->init(__sb); }
    virtual ~basic_ostream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream(basic_ostream&& __rhs);

    // 27.7.2.3 Assign/swap
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& operator=(basic_ostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_ostream& __rhs)
    { basic_ios<char_type, traits_type>::swap(__rhs); }


    basic_ostream (const basic_ostream& __rhs) = delete;
    basic_ostream& operator=(const basic_ostream& __rhs) = delete;




public:

    // 27.7.2.4 Prefix/suffix:
    class __attribute__ ((__type_visibility__("default"))) sentry;

    // 27.7.2.6 Formatted output:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& operator<<(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type,traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_ostream& operator<<(bool __n);
    basic_ostream& operator<<(short __n);
    basic_ostream& operator<<(unsigned short __n);
    basic_ostream& operator<<(int __n);
    basic_ostream& operator<<(unsigned int __n);
    basic_ostream& operator<<(long __n);
    basic_ostream& operator<<(unsigned long __n);
    basic_ostream& operator<<(long long __n);
    basic_ostream& operator<<(unsigned long long __n);
    basic_ostream& operator<<(float __f);
    basic_ostream& operator<<(double __f);
    basic_ostream& operator<<(long double __f);
    basic_ostream& operator<<(const void* __p);
    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& operator<<(nullptr_t)
    { return *this << "nullptr"; }

    // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type __c);
    basic_ostream& write(const char_type* __s, streamsize __n);
    basic_ostream& flush();

    // 27.7.2.5 seeks:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    pos_type tellp();
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& seekp(pos_type __pos);
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_ostream() {} // extension, intentially does not initialize
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry
{
    bool __ok_;
    basic_ostream<_CharT, _Traits>& __os_;

    sentry(const sentry&); // = delete;
    sentry& operator=(const sentry&); // = delete;

public:
    explicit sentry(basic_ostream<_CharT, _Traits>& __os);
    ~sentry();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)
    : __ok_(false),
      __os_(__os)
{
    if (__os.good())
    {
        if (__os.tie())
            __os.tie()->flush();
        __ok_ = true;
    }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry()
{
    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)
                      && !uncaught_exception())
    {

        try
        {

            if (__os_.rdbuf()->pubsync() == -1)
                __os_.setstate(ios_base::badbit);

        }
        catch (...)
        {
        }

    }
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)
{
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            if (__sb)
            {

                try
                {

                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Ip __i(__sb);
                    _Ip __eof;
                    _Op __o(*this);
                    size_t __c = 0;
                    for (; __i != __eof; ++__i, ++__o, ++__c)
                    {
                        *__o = *__i;
                        if (__o.failed())
                            break;
                    }
                    if (__c == 0)
                        this->setstate(ios_base::failbit);

                }
                catch (...)
                {
                    this->__set_failbit_and_consider_rethrow();
                }

            }
            else
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(bool __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned short>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(),
                        __flags == ios_base::oct || __flags == ios_base::hex ?
                        static_cast<long>(static_cast<unsigned int>(__n)) :
                        static_cast<long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(float __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(long double __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
            const _Fp& __f = use_facet<_Fp>(this->getloc());
            if (__f.put(*this, *this, this->fill(), __n).failed())
                this->setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,
                          const _CharT* __str, size_t __len)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 __str,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __str + __len :
                                     __str,
                                 __str + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            _CharT __c = __os.widen(__cn);
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            if (__pad_and_output(_Ip(__os),
                                 &__c,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     &__c + 1 :
                                     &__c,
                                 &__c + 1,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c)
{
    return std::__1::__put_character_sequence(__os, &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)
{
    return std::__1::__put_character_sequence(__os, (char *) &__c, 1);
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)
{

    try
    {

        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
            size_t __len = char_traits<char>::length(__strn);
            const int __bs = 100;
            _CharT __wbb[__bs];
            _CharT* __wb = __wbb;
            unique_ptr<_CharT, void(*)(void*)> __h(0, free);
            if (__len > __bs)
            {
                __wb = (_CharT*)malloc(__len*sizeof(_CharT));
                if (__wb == 0)
                    __throw_bad_alloc();
                __h.reset(__wb);
            }
            for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
                *__p = __os.widen(*__strn);
            if (__pad_and_output(_Ip(__os),
                                 __wb,
                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?
                                     __wb + __len :
                                     __wb,
                                 __wb + __len,
                                 __os,
                                 __os.fill()).failed())
                __os.setstate(ios_base::badbit | ios_base::failbit);
        }

    }
    catch (...)
    {
        __os.__set_badbit_and_consider_rethrow();
    }

    return __os;
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __str)
{
    return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template<class _Traits>
basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)
{
    const char *__s = (const char *) __str;
    return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{

    try
    {

        sentry __s(*this);
        if (__s)
        {
            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
            _Op __o(*this);
            *__o = __c;
            if (__o.failed())
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{

    try
    {

        sentry __sen(*this);
        if (__sen && __n)
        {
            if (this->rdbuf()->sputn(__s, __n) != __n)
                this->setstate(ios_base::badbit);
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush()
{

    try
    {

        if (this->rdbuf())
        {
            sentry __s(*this);
            if (__s)
            {
                if (this->rdbuf()->pubsync() == -1)
                    this->setstate(ios_base::badbit);
            }
        }

    }
    catch (...)
    {
        this->__set_badbit_and_consider_rethrow();
    }

    return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp()
{
    if (this->fail())
        return pos_type(-1);
    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)
{
    sentry __s(*this);
    if (!this->fail())
    {
        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
            this->setstate(ios_base::failbit);
    }
    return *this;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(__os.widen('\n'));
    __os.flush();
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os)
{
    __os.put(_CharT());
    return __os;
}

template <class _CharT, class _Traits>
inline
basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os)
{
    __os.flush();
    return __os;
}



template <class _Stream, class _Tp, class = void>
struct __is_ostreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_ostreamable<_Stream, _Tp, decltype(
    std::__1::declval<_Stream>() << std::__1::declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_ostreamable<_Stream&, const _Tp&>>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Stream&& operator<<(_Stream&& __os, const _Tp& __x)
{
    __os << __x;
    return std::__1::move(__os);
}



template<class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           basic_string_view<_CharT, _Traits> __sv)
{
    return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)
{
    return __os << __ec.category().name() << ':' << __ec.value();
}

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)
{
    return __os << __p.get();
}

template<class _CharT, class _Traits, class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits>&>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
    basic_ostream<_CharT, _Traits>&
>::type
operator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)
{
    return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x.template to_string<_CharT, _Traits>
                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}

extern template class __attribute__ ((__visibility__("default"))) basic_ostream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_ostream<wchar_t>;

} }
# 164 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 2
# 167 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 171 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 2 3


namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
    streamsize __gc_;
public:
    // types (inherited from basic_ios (27.5.4)):
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // 27.7.1.1.1 Constructor/destructor:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)
    { this->init(__sb); }
    virtual ~basic_istream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream(basic_istream&& __rhs);

    // 27.7.1.1.2 Assign/swap:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& operator=(basic_istream&& __rhs);


    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_istream& __rhs) {
      std::__1::swap(__gc_, __rhs.__gc_);
      basic_ios<char_type, traits_type>::swap(__rhs);
    }


    basic_istream (const basic_istream& __rhs) = delete;
    basic_istream& operator=(const basic_istream& __rhs) = delete;

public:

    // 27.7.1.1.3 Prefix/suffix:
    class __attribute__ ((__type_visibility__("default"))) sentry;

    // 27.7.1.2 Formatted input:
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))
    { return __pf(*this); }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& operator>>(basic_ios<char_type, traits_type>&
                              (*__pf)(basic_ios<char_type, traits_type>&))
    { __pf(*this); return *this; }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& operator>>(ios_base& (*__pf)(ios_base&))
    { __pf(*this); return *this; }

    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
    basic_istream& operator>>(bool& __n);
    basic_istream& operator>>(short& __n);
    basic_istream& operator>>(unsigned short& __n);
    basic_istream& operator>>(int& __n);
    basic_istream& operator>>(unsigned int& __n);
    basic_istream& operator>>(long& __n);
    basic_istream& operator>>(unsigned long& __n);
    basic_istream& operator>>(long long& __n);
    basic_istream& operator>>(unsigned long long& __n);
    basic_istream& operator>>(float& __f);
    basic_istream& operator>>(double& __f);
    basic_istream& operator>>(long double& __f);
    basic_istream& operator>>(void*& __p);

    // 27.7.1.3 Unformatted input:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    streamsize gcount() const {return __gc_;}
    int_type get();

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& get(char_type& __c) {
      int_type __ch = get();
      if (__ch != traits_type::eof())
        __c = traits_type::to_char_type(__ch);
      return *this;
    }

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)
    { return get(__sb, this->widen('\n')); }

    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
    int_type peek();
    basic_istream& read (char_type* __s, streamsize __n);
    streamsize readsome(char_type* __s, streamsize __n);

    basic_istream& putback(char_type __c);
    basic_istream& unget();
    int sync();

    pos_type tellg();
    basic_istream& seekg(pos_type __pos);
    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_istream<_CharT, _Traits>::sentry
{
    bool __ok_;

    sentry(const sentry&); // = delete;
    sentry& operator=(const sentry&); // = delete;

public:
    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
//    ~sentry() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
        explicit
        operator bool() const {return __ok_;}
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,
                                               bool __noskipws)
    : __ok_(false)
{
    if (__is.good())
    {
        if (__is.tie())
            __is.tie()->flush();
        if (!__noskipws && (__is.flags() & ios_base::skipws))
        {
            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            _Ip __i(__is);
            _Ip __eof;
            for (; __i != __eof; ++__i)
                if (!__ct.is(__ct.space, *__i))
                    break;
            if (__i == __eof)
                __is.setstate(ios_base::failbit | ios_base::eofbit);
        }
        __ok_ = __is.good();
    }
    else
        __is.setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)
    : __gc_(__rhs.__gc_)
{
    __rhs.__gc_ = 0;
    this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
__input_arithmetic(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)
{
    return std::__1::__input_arithmetic<unsigned short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)
{
    return std::__1::__input_arithmetic<unsigned int>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long& __n)
{
    return std::__1::__input_arithmetic<long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)
{
    return std::__1::__input_arithmetic<unsigned long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long long& __n)
{
    return std::__1::__input_arithmetic<long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)
{
    return std::__1::__input_arithmetic<unsigned long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(float& __n)
{
    return std::__1::__input_arithmetic<float>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(double& __n)
{
    return std::__1::__input_arithmetic<double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(long double& __n)
{
    return std::__1::__input_arithmetic<long double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(bool& __n)
{
    return std::__1::__input_arithmetic<bool>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(void*& __n)
{
    return std::__1::__input_arithmetic<void*>(*this, __n);
}

template <class _Tp, class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __s(__is);
    if (__s)
    {

        try
        {

            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
            typedef num_get<_CharT, _Ip> _Fp;
            long __temp;
            use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
            if (__temp < numeric_limits<_Tp>::min())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::min();
            }
            else if (__temp > numeric_limits<_Tp>::max())
            {
                __state |= ios_base::failbit;
                __n = numeric_limits<_Tp>::max();
            }
            else
            {
                __n = static_cast<_Tp>(__temp);
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(short& __n)
{
    return std::__1::__input_arithmetic_with_numeric_limits<short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(int& __n)
{
    return std::__1::__input_arithmetic_with_numeric_limits<int>(*this, __n);
}

template<class _CharT, class _Traits>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
__input_c_string(basic_istream<_CharT, _Traits>& __is, _CharT* __p, size_t __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            _CharT* __s = __p;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__s != __p + (__n-1))
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                *__s++ = __ch;
                 __is.rdbuf()->sbumpc();
            }
            *__s = _CharT();
            __is.width(0);
            if (__s == __p)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}
# 612 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/istream" 3
template<class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)
{
    streamsize __n = __is.width();
    if (__n <= 0)
        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
    return std::__1::__input_c_string(__is, __s, size_t(__n));
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)
{
    return __is >> (char*)__s;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s)
{
    return __is >> (char*)__s;
}



template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
            if (_Traits::eq_int_type(__i, _Traits::eof()))
                __state |= ios_base::eofbit | ios_base::failbit;
            else
                __c = _Traits::to_char_type(__i);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)
{
    return __is >> (char&)__c;
}

template<class _Traits>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c)
{
    return __is >> (char&)__c;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __s(*this, true);
    if (__s)
    {
        if (__sb)
        {

            try
            {

                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, _Traits::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    if (traits_type::eq_int_type(
                            __sb->sputc(traits_type::to_char_type(__i)),
                            traits_type::eof()))
                        break;
                    ++__gc_;
                    this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                if (__gc_ == 0)
                    __state |= ios_base::failbit;

                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::failbit || this->exceptions() & ios_base::badbit)
                {
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __s(*this, true);
    if (__s)
    {

        try
        {

            __r = this->rdbuf()->sbumpc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
               __state |= ios_base::failbit | ios_base::eofbit;
            else
                __gc_ = 1;

        }
        catch (...)
        {
            this->__setstate_nothrow(this->rdstate() | ios_base::badbit);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {
        if (__n > 0)
        {

            try
            {

                while (__gc_ < __n-1)
                {
                    int_type __i = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    char_type __ch = traits_type::to_char_type(__i);
                    if (traits_type::eq(__ch, __dlm))
                        break;
                    *__s++ = __ch;
                    ++__gc_;
                     this->rdbuf()->sbumpc();
                }
                if (__gc_ == 0)
                   __state |= ios_base::failbit;

            }
            catch (...)
            {
                __state |= ios_base::badbit;
                this->__setstate_nothrow(__state);
                if (this->exceptions() & ios_base::badbit)
                {
                    if (__n > 0)
                        *__s = char_type();
                    throw;
                }
            }

        }
        else
        {
            __state |= ios_base::failbit;
        }

        if (__n > 0)
            *__s = char_type();
        this->setstate(__state);
    }
    if (__n > 0)
        *__s = char_type();
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,
                                    char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                    break;
                if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                    break;
                ++__gc_;
                this->rdbuf()->sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            // according to the spec, exceptions here are caught but not rethrown
        }

        if (__gc_ == 0)
           __state |= ios_base::failbit;
        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            while (true)
            {
                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__i, traits_type::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                char_type __ch = traits_type::to_char_type(__i);
                if (traits_type::eq(__ch, __dlm))
                {
                    this->rdbuf()->sbumpc();
                    ++__gc_;
                    break;
                }
                if (__gc_ >= __n-1)
                {
                    __state |= ios_base::failbit;
                    break;
                }
                *__s++ = __ch;
                this->rdbuf()->sbumpc();
                ++__gc_;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                if (__n > 0)
                    *__s = char_type();
                if (__gc_ == 0)
                    __state |= ios_base::failbit;
                throw;
            }
        }

    }
    if (__n > 0)
        *__s = char_type();
    if (__gc_ == 0)
        __state |= ios_base::failbit;
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (__n == numeric_limits<streamsize>::max())
            {
                while (true)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }
            else
            {
                while (__gc_ < __n)
                {
                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__i, traits_type::eof()))
                    {
                       __state |= ios_base::eofbit;
                       break;
                    }
                    ++__gc_;
                    if (traits_type::eq_int_type(__i, __dlm))
                        break;
                }
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    int_type __r = traits_type::eof();
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __r = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__r, traits_type::eof()))
                __state |= ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            __gc_ = this->rdbuf()->sgetn(__s, __n);
            if (__gc_ != __n)
                __state |= ios_base::failbit | ios_base::eofbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)
{
    ios_base::iostate __state = ios_base::goodbit;
    __gc_ = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            streamsize __c = this->rdbuf()->in_avail();
            switch (__c)
            {
            case -1:
                __state |= ios_base::eofbit;
                break;
            case 0:
                break;
            default:
                __n = std::__1::min(__c, __n);
                __gc_ = this->rdbuf()->sgetn(__s, __n);
                if (__gc_ != __n)
                    __state |= ios_base::failbit | ios_base::eofbit;
                break;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return __gc_;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(char_type __c)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget()
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    __gc_ = 0;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr || this->rdbuf()->sungetc() == traits_type::eof())
                __state |= ios_base::badbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

    }
    else
    {
        __state |= ios_base::failbit;
    }
    this->setstate(__state);
    return *this;
}

template<class _CharT, class _Traits>
int
basic_istream<_CharT, _Traits>::sync()
{
    ios_base::iostate __state = ios_base::goodbit;
    int __r = 0;
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf() == nullptr)
                return -1;
            if (this->rdbuf()->pubsync() == -1)
            {
                __state |= ios_base::badbit;
                return -1;
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg()
{
    ios_base::iostate __state = ios_base::goodbit;
    pos_type __r(-1);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

        __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return __r;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
    ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
    this->clear(__state);
    sentry __sen(*this, true);
    if (__sen)
    {

        try
        {

            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
                __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            this->__setstate_nothrow(__state);
            if (this->exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        this->setstate(__state);
    }
    return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {

        try
        {

            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                    break;
                __is.rdbuf()->sbumpc();
            }

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}



template <class _Stream, class _Tp, class = void>
struct __is_istreamable : false_type { };

template <class _Stream, class _Tp>
struct __is_istreamable<_Stream, _Tp, decltype(
    std::__1::declval<_Stream>() >> std::__1::declval<_Tp>(), void()
)> : true_type { };

template <class _Stream, class _Tp, class = typename enable_if<
    _And<is_base_of<ios_base, _Stream>,
         __is_istreamable<_Stream&, _Tp&&>>::value
>::type>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Stream&& operator>>(_Stream&& __is, _Tp&& __x)
{
    __is >> std::__1::forward<_Tp>(__x);
    return std::__1::move(__is);
}



template <class _CharT, class _Traits>
class __attribute__ ((__type_visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:
    // types:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    // constructor/destructor
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb)
    {}

    virtual ~basic_iostream();
protected:

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_iostream(basic_iostream&& __rhs);

    // assign/swap
    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    basic_iostream& operator=(basic_iostream&& __rhs);

    inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(basic_iostream& __rhs)
    { basic_istream<char_type, traits_type>::swap(__rhs); }
};



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs))
{
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>&
basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)
{
    swap(__rhs);
    return *this;
}



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT, _Traits, _Allocator>& __str)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize __n = __is.width();
            if (__n <= 0)
                __n = __str.max_size();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max();
            streamsize __c = 0;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            while (__c < __n)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (__ct.is(__ct.space, __ch))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __is.width(0);
            if (__c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen)
    {

        try
        {

            __str.clear();
            streamsize __extr = 0;
            while (true)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                ++__extr;
                _CharT __ch = _Traits::to_char_type(__i);
                if (_Traits::eq(__ch, __dlm))
                    break;
                __str.push_back(__ch);
                if (__str.size() == __str.max_size())
                {
                    __state |= ios_base::failbit;
                    break;
                }
            }
            if (__extr == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)
{
    return getline(__is, __str, __dlm);
}

template<class _CharT, class _Traits, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is,
        basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)
{
    ios_base::iostate __state = ios_base::goodbit;
    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen)
    {

        try
        {

            basic_string<_CharT, _Traits> __str;
            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());
            size_t __c = 0;
            _CharT __zero = __ct.widen('0');
            _CharT __one = __ct.widen('1');
            while (__c < _Size)
            {
                typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                if (_Traits::eq_int_type(__i, _Traits::eof()))
                {
                   __state |= ios_base::eofbit;
                   break;
                }
                _CharT __ch = _Traits::to_char_type(__i);
                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                    break;
                __str.push_back(__ch);
                ++__c;
                 __is.rdbuf()->sbumpc();
            }
            __x = bitset<_Size>(__str);
            if (_Size > 0 && __c == 0)
               __state |= ios_base::failbit;

        }
        catch (...)
        {
            __state |= ios_base::badbit;
            __is.__setstate_nothrow(__state);
            if (__is.exceptions() & ios_base::badbit)
            {
                throw;
            }
        }

        __is.setstate(__state);
    }
    return __is;
}

extern template class __attribute__ ((__visibility__("default"))) basic_istream<char>;
extern template class __attribute__ ((__visibility__("default"))) basic_istream<wchar_t>;
extern template class __attribute__ ((__visibility__("default"))) basic_iostream<char>;

} }
# 40 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 2
# 44 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/iostream" 3


namespace std { inline namespace __1 {


extern __attribute__ ((__visibility__("default"))) istream cin;
extern __attribute__ ((__visibility__("default"))) wistream wcin;


extern __attribute__ ((__visibility__("default"))) ostream cout;
extern __attribute__ ((__visibility__("default"))) wostream wcout;

extern __attribute__ ((__visibility__("default"))) ostream cerr;
extern __attribute__ ((__visibility__("default"))) wostream wcerr;
extern __attribute__ ((__visibility__("default"))) ostream clog;
extern __attribute__ ((__visibility__("default"))) wostream wclog;

} }
# 12 "SEAL/native/src/seal/serialization.h" 2

namespace seal
{
    /**
    A type to describe the compression algorithm applied to serialized data.
    Ciphertext and key data consist of a large number of 64-bit words storing
    integers modulo prime numbers much smaller than the word size, resulting in
    a large number of zero bytes in the output. Any compression algorithm should
    be able to clean up these zero bytes and hence compress both ciphertext and
    key data.
    */
    enum class compr_mode_type : std::uint8_t
    {
        // No compression is used.
        none = 0,
# 35 "SEAL/native/src/seal/serialization.h"
    };

    /**
    Class to provide functionality for serialization. Most users of the library
    should never have to call these functions explicitly, as they are called
    internally by functions such as Ciphertext::save and Ciphertext::load.
    */
    class Serialization
    {
    public:
        /**
        The compression mode used by default; prefer Zstandard
        */





        static constexpr compr_mode_type compr_mode_default = compr_mode_type::none;

        /**
        The magic value indicating a Microsoft SEAL header.
        */
        static constexpr std::uint16_t seal_magic = 0xA15E;

        /**
        The size in bytes of the SEALHeader.
        */
        static constexpr std::uint8_t seal_header_size = 0x10;

        /**
        Struct to contain metadata for serialization comprising the following fields:

        1. a magic number identifying this is a SEALHeader struct (2 bytes)
        2. size in bytes of the SEALHeader struct (1 byte)
        3. Microsoft SEAL's major version number (1 byte)
        4. Microsoft SEAL's minor version number (1 byte)
        5. a compr_mode_type indicating whether data after the header is compressed (1 byte)
        6. reserved for future use and data alignment (2 bytes)
        7. the size in bytes of the entire serialized object, including the header (8 bytes)
        */
        struct SEALHeader
        {
            std::uint16_t magic = seal_magic;

            std::uint8_t header_size = seal_header_size;

            std::uint8_t version_major = static_cast<std::uint8_t>(SEAL_VERSION_MAJOR);

            std::uint8_t version_minor = static_cast<std::uint8_t>(SEAL_VERSION_MINOR);

            compr_mode_type compr_mode = compr_mode_type::none;

            std::uint16_t reserved = 0;

            std::uint64_t size = 0;
        };

        static_assert(sizeof(SEALHeader) == seal_header_size, "");

        /**
        Returns true if the given byte corresponds to a supported compression mode.

        @param[in] compr_mode The compression mode to validate
        */
                       static bool IsSupportedComprMode(std::uint8_t compr_mode) noexcept
        {
            switch (compr_mode)
            {
            case static_cast<std::uint8_t>(compr_mode_type::none):
                /* fall through */







                return true;
            }
            return false;
        }

        /**
        Returns true if the given value corresponds to a supported compression mode.

        @param[in] compr_mode The compression mode to validate
        */
                       static inline bool IsSupportedComprMode(compr_mode_type compr_mode) noexcept
        {
            return IsSupportedComprMode(static_cast<uint8_t>(compr_mode));
        }

        /**
        Returns an upper bound on the output size of data compressed according to
        a given compression mode with given input size. If compr_mode is
        compr_mode_type::none, the return value is exactly in_size.

        @param[in] in_size The input size to a compression algorithm
        @param[in] in_size The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        */
                       static std::size_t ComprSizeEstimate(std::size_t in_size, compr_mode_type compr_mode);

        /**
        Returns true if the SEALHeader has a version number compatible with this version of Microsoft SEAL.

        @param[in] header The SEALHeader
        */
                       static bool IsCompatibleVersion(const SEALHeader &header) noexcept
        {
            // Exact same version
            if (header.version_major == SEAL_VERSION_MAJOR && header.version_minor == SEAL_VERSION_MINOR)
            {
                return true;
            }

            // Different major versions not supported
            if (header.version_major != SEAL_VERSION_MAJOR)
            {
                return false;
            }

            // Support Microsoft SEAL 3.4 and above
            if (header.version_major == 3 && header.version_minor >= 4)
            {
                return true;
            }

            return false;
        }

        /**
        Returns true if the given SEALHeader is valid for this version of Microsoft SEAL.

        @param[in] header The SEALHeader
        */
                       static bool IsValidHeader(const SEALHeader &header) noexcept
        {
            if (header.magic != seal_magic)
            {
                return false;
            }
            if (header.header_size != seal_header_size)
            {
                return false;
            }
            if (!IsCompatibleVersion(header))
            {
                return false;
            }
            if (!IsSupportedComprMode(static_cast<uint8_t>(header.compr_mode)))
            {
                return false;
            }
            return true;
        }

        /**
        Saves a SEALHeader to a given stream. The output is in binary format and
        not human-readable. The output stream must have the "binary" flag set.

        @param[in] header The SEALHeader to save to the stream
        @param[out] stream The stream to save the SEALHeader to
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff SaveHeader(const SEALHeader &header, std::ostream &stream);

        /**
        Loads a SEALHeader from a given stream.

        @param[in] stream The stream to load the SEALHeader from
        @param[in] header The SEALHeader to populate with the loaded data
        @param[in] try_upgrade_if_invalid If the loaded SEALHeader is invalid,
        attempt to identify its format and upgrade to the current SEALHeader version
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff LoadHeader(std::istream &stream, SEALHeader &header, bool try_upgrade_if_invalid = true);

        /**
        Saves a SEALHeader to a given memory location. The output is in binary
        format and is not human-readable.

        @param[out] out The memory location to write the SEALHeader to
        @param[in] size The number of bytes available in the given memory location
        @throws std::invalid_argument if out is null or if size is too small to
        contain a SEALHeader
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff SaveHeader(const SEALHeader &header, seal_byte *out, std::size_t size);

        /**
        Loads a SEALHeader from a given memory location.

        @param[in] in The memory location to load the SEALHeader from
        @param[in] size The number of bytes available in the given memory location
        @param[in] try_upgrade_if_invalid If the loaded SEALHeader is invalid,
        attempt to identify its format and upgrade to the current SEALHeader version
        @throws std::invalid_argument if in is null or if size is too small to
        contain a SEALHeader
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff LoadHeader(
            const seal_byte *in, std::size_t size, SEALHeader &header, bool try_upgrade_if_invalid = true);

        /**
        Evaluates save_members and compresses the output according to the given
        compr_mode_type. The resulting data is written to stream and is prepended
        by the given compr_mode_type and the total size of the data to facilitate
        deserialization. In typical use-cases save_members would be a function
        that serializes the member variables of an object to the given stream.

        For any given compression mode, raw_size must be the exact right size
        (in bytes) of what save_members writes to a stream in the uncompressed
        mode plus the size of SEALHeader. Otherwise the behavior of Save is
        unspecified.

        @param[in] save_members A function taking an std::ostream reference as an
        argument, possibly writing some number of bytes into it
        @param[in] raw_size The exact uncompressed output size of save_members
        plus the size of SEALHeader
        @param[out] stream The stream to write to
        @param[in] compr_mode The desired compression mode
        @param[in] clear_buffers Whether internal buffers should be cleared
        @throws std::invalid_argument if save_members is invalid
        @throws std::invalid_argument if raw_size is smaller than SEALHeader size
        @throws std::logic_error if the data to be saved is invalid, if compression
        mode is not supported, or if compression failed
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff Save(
            std::function<void(std::ostream &)> save_members, std::streamoff raw_size, std::ostream &stream,
            compr_mode_type compr_mode, bool clear_buffers);

        /**
        Deserializes data from stream that was serialized by Save. Once stream has
        been decompressed (depending on compression mode), load_members is applied
        to the decompressed stream. In typical use-cases load_members would be
        a function that deserializes the member variables of an object from the
        given stream.

        @param[in] load_members A function taking an std::istream reference and
        a SEALVersion struct as arguments, possibly reading some number of bytes
        from the std::istream, possibly depending on the SEALVersion object
        @param[in] stream The stream to read from
        @param[in] clear_buffers Whether internal buffers should be cleared
        @throws std::invalid_argument if load_members is invalid
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff Load(
            std::function<void(std::istream &, SEALVersion)> load_members, std::istream &stream, bool clear_buffers);

        /**
        Evaluates save_members and compresses the output according to the given
        compr_mode_type. The resulting data is written to a given memory location
        and is prepended by the given compr_mode_type and the total size of the
        data to facilitate deserialization. In typical use-cases save_members would
        be a function that serializes the member variables of an object to the
        given stream.

        For any given compression mode, raw_size must be the exact right size
        (in bytes) of what save_members writes to a stream in the uncompressed
        mode plus the size of SEALHeader. Otherwise the behavior of Save is
        unspecified.

        @param[in] save_members A function that takes an std::ostream reference as
        an argument and writes some number of bytes into it
        @param[in] raw_size The exact uncompressed output size of save_members
        plus the size of SEALHeader
        @param[out] out The memory location to write to
        @param[in] size The number of bytes available in the given memory location
        @param[in] compr_mode The desired compression mode
        @param[in] clear_buffers Whether internal buffers should be cleared
        @throws std::invalid_argument if save_members is invalid, if raw_size or
        size is smaller than SEALHeader size, or if out is null
        @throws std::logic_error if the data to be saved is invalid, if compression
        mode is not supported, or if compression failed
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff Save(
            std::function<void(std::ostream &)> save_members, std::streamoff raw_size, seal_byte *out, std::size_t size,
            compr_mode_type compr_mode, bool clear_buffers);

        /**
        Deserializes data from a memory location that was serialized by Save.
        Once the data has been decompressed (depending on compression mode),
        load_members is applied to the decompressed stream. In typical use-cases
        load_members would be a function that deserializes the member variables
        of an object from the given stream.

        @param[in] load_members A function that takes an std::istream reference as
        a SEALVersion struct as arguments, possibly reading some number of bytes
        from the std::istream, possibly depending on the SEALVersion object
        @param[in] in The memory location to read from
        @param[in] size The number of bytes available in the given memory location
        @param[in] clear_buffers Whether internal buffers should be cleared
        @throws std::invalid_argument if load_members is invalid, if in is null,
        or if size is too small to contain a SEALHeader
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        static std::streamoff Load(
            std::function<void(std::istream &, SEALVersion)> load_members, const seal_byte *in, std::size_t size,
            bool clear_buffers);

    private:
        Serialization() = delete;
    };

    namespace legacy_headers
    {
        /**
        Struct to enable compatibility with Microsoft SEAL 3.4 headers.
        */
        struct SEALHeader_3_4
        {
            std::uint16_t magic = Serialization::seal_magic;

            std::uint8_t zero_byte = 0x00;

            compr_mode_type compr_mode = compr_mode_type::none;

            std::uint32_t size = 0;

            std::uint64_t reserved = 0;

            SEALHeader_3_4 &operator=(const Serialization::SEALHeader assign)
            {
                std::memcpy(this, &assign, Serialization::seal_header_size);
                return *this;
            }

            SEALHeader_3_4() = default;

            SEALHeader_3_4(const Serialization::SEALHeader &copy)
            {
                operator=(copy);
            }
        };
    } // namespace legacy_headers
} // namespace seal
# 7 "SEAL/native/src/seal/modulus.h" 2



# 1 "SEAL/native/src/seal/util/uintcore.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.






# 1 "SEAL/native/src/seal/util/pointer.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 14 "SEAL/native/src/seal/util/pointer.h"
namespace seal
{
    namespace util
    {
        // Specialization for seal_byte
        template <>
        class Pointer<seal_byte>
        {
            friend class MemoryPoolST;
            friend class MemoryPoolMT;

        public:
            template <typename, typename>
            friend class Pointer;
            template <typename, typename>
            friend class ConstPointer;

            Pointer() = default;

            // Move of the same type
            Pointer(Pointer<seal_byte> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move of the same type
            Pointer(Pointer<seal_byte> &&source, seal_byte value) : Pointer(std::move(source))
            {
                std::fill_n(data_, head_->item_byte_count(), value);
            }

            // Copy a range of elements
            template <typename InputIt>
            Pointer(InputIt first, Pointer<seal_byte> &&source) : Pointer(std::move(source))
            {
                std::copy_n(first, head_->item_byte_count(), data_);
            }

                           inline seal_byte &operator[](std::size_t index)
            {
                return data_[index];
            }

                           inline const seal_byte &operator[](std::size_t index) const
            {
                return data_[index];
            }

            inline auto &operator=(Pointer<seal_byte> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

                           inline bool is_set() const noexcept
            {
                return data_ != nullptr;
            }

                           inline seal_byte *get() const noexcept
            {
                return data_;
            }

                           inline seal_byte *operator->() const noexcept
            {
                return data_;
            }

                           inline seal_byte &operator*() const
            {
                return *data_;
            }

                           inline bool is_alias() const noexcept
            {
                return alias_;
            }

            inline void release() noexcept
            {
                if (head_)
                {
                    // Return the memory to pool
                    head_->add(item_);
                }
                else if (data_ && !alias_)
                {
                    // Free the memory
                    delete[] data_;
                }

                data_ = nullptr;
                head_ = nullptr;
                item_ = nullptr;
                alias_ = false;
            }

            void acquire(Pointer<seal_byte> &other) noexcept
            {
                if (this == &other)
                {
                    return;
                }

                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<seal_byte> &&other) noexcept
            {
                acquire(other);
            }

            ~Pointer() noexcept
            {
                release();
            }

                           explicit operator bool() const noexcept
            {
                return (data_ != nullptr);
            }

                           inline static Pointer<seal_byte> Owning(seal_byte *pointer) noexcept
            {
                return { pointer, false };
            }

                           inline static auto Aliasing(seal_byte *pointer) noexcept -> Pointer<seal_byte>
            {
                return { pointer, true };
            }

        private:
            Pointer(const Pointer<seal_byte> &copy) = delete;

            Pointer<seal_byte> &operator=(const Pointer<seal_byte> &assign) = delete;

            Pointer(seal_byte *pointer, bool alias) noexcept : data_(pointer), alias_(alias)
            {}

            Pointer(class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = item_->data();
            }

            seal_byte *data_ = nullptr;

            MemoryPoolHead *head_ = nullptr;

            MemoryPoolItem *item_ = nullptr;

            bool alias_ = false;
        };

        template <typename T, typename>
        class Pointer
        {
            friend class MemoryPoolST;
            friend class MemoryPoolMT;

        public:
            friend class Pointer<seal_byte>;
            friend class ConstPointer<seal_byte>;
            friend class ConstPointer<T>;

            Pointer() = default;

            // Move of the same type
            Pointer(Pointer<T> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            Pointer(Pointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            template <typename... Args>
            Pointer(Pointer<seal_byte> &&source, Args &&... args)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    for (auto alloc_ptr = data_; count--; alloc_ptr++)
                    {
                        new (alloc_ptr) T(std::forward<Args>(args)...);
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Copy a range when T is not seal_byte
            template <typename InputIt>
            Pointer(InputIt first, Pointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    std::uninitialized_copy_n(first, count, data_);
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

                           inline T &operator[](std::size_t index)
            {
                return data_[index];
            }

                           inline const T &operator[](std::size_t index) const
            {
                return data_[index];
            }

            inline auto &operator=(Pointer<T> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

            inline auto &operator=(Pointer<seal_byte> &&assign)
            {
                acquire(std::move(assign));
                return *this;
            }

                           inline bool is_set() const noexcept
            {
                return data_ != nullptr;
            }

                           inline T *get() const noexcept
            {
                return data_;
            }

                           inline T *operator->() const noexcept
            {
                return data_;
            }

                           inline T &operator*() const
            {
                return *data_;
            }

                           inline bool is_alias() const noexcept
            {
                return alias_;
            }

            inline void release() noexcept
            {
                if (head_)
                {
                    if(!std::is_trivially_destructible<T>::value)
                    {
                        // Manual destructor calls
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            alloc_ptr->~T();
                        }
                    }

                    // Return the memory to pool
                    head_->add(item_);
                }
                else if (data_ && !alias_)
                {
                    // Free the memory
                    delete[] data_;
                }

                data_ = nullptr;
                head_ = nullptr;
                item_ = nullptr;
                alias_ = false;
            }

            void acquire(Pointer<T> &other) noexcept
            {
                if (this == &other)
                {
                    return;
                }

                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<T> &&other) noexcept
            {
                acquire(other);
            }

            void acquire(Pointer<seal_byte> &other)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!other.head_ && other.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                release();

                head_ = other.head_;
                item_ = other.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<seal_byte> &&other)
            {
                acquire(other);
            }

            ~Pointer() noexcept
            {
                release();
            }

                           explicit operator bool() const noexcept
            {
                return (data_ != nullptr);
            }

                           inline static Pointer<T> Owning(T *pointer) noexcept
            {
                return { pointer, false };
            }

                           inline static auto Aliasing(T *pointer) noexcept -> Pointer<T>
            {
                return { pointer, true };
            }

        private:
            Pointer(const Pointer<T> &copy) = delete;

            Pointer<T> &operator=(const Pointer<T> &assign) = delete;

            Pointer(T *pointer, bool alias) noexcept : data_(pointer), alias_(alias)
            {}

            Pointer(class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                if(!std::is_trivially_constructible<T>::value)
                {
                    auto count = head_->item_byte_count() / sizeof(T);
                    for (auto alloc_ptr = data_; count--; alloc_ptr++)
                    {
                        new (alloc_ptr) T;
                    }
                }
            }

            template <typename... Args>
            Pointer(class MemoryPoolHead *head, Args &&... args)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                auto count = head_->item_byte_count() / sizeof(T);
                for (auto alloc_ptr = data_; count--; alloc_ptr++)
                {
                    new (alloc_ptr) T(std::forward<Args>(args)...);
                }
            }

            template <typename InputIt>
            Pointer(InputIt first, class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                auto count = head_->item_byte_count() / sizeof(T);
                std::uninitialized_copy_n(first, count, data_);
            }

            T *data_ = nullptr;

            MemoryPoolHead *head_ = nullptr;

            MemoryPoolItem *item_ = nullptr;

            bool alias_ = false;
        };

        // Specialization for seal_byte
        template <>
        class ConstPointer<seal_byte>
        {
            friend class MemoryPoolST;
            friend class MemoryPoolMT;

        public:
            template <typename, typename>
            friend class ConstPointer;

            ConstPointer() = default;

            // Move of the same type
            ConstPointer(Pointer<seal_byte> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move of the same type
            ConstPointer(Pointer<seal_byte> &&source, seal_byte value) : ConstPointer(std::move(source))
            {
                std::fill_n(data_, head_->item_byte_count(), value);
            }

            // Move of the same type
            ConstPointer(ConstPointer<seal_byte> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move of the same type
            ConstPointer(ConstPointer<seal_byte> &&source, seal_byte value) : ConstPointer(std::move(source))
            {
                std::fill_n(data_, head_->item_byte_count(), value);
            }

            // Copy a range of elements
            template <typename InputIt>
            ConstPointer(InputIt first, ConstPointer<seal_byte> &&source) : ConstPointer(std::move(source))
            {
                std::copy_n(first, head_->item_byte_count(), data_);
            }

            inline auto &operator=(ConstPointer<seal_byte> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

            inline auto &operator=(Pointer<seal_byte> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

                           inline const seal_byte &operator[](std::size_t index) const
            {
                return data_[index];
            }

                           inline bool is_set() const noexcept
            {
                return data_ != nullptr;
            }

                           inline const seal_byte *get() const noexcept
            {
                return data_;
            }

                           inline const seal_byte *operator->() const noexcept
            {
                return data_;
            }

                           inline const seal_byte &operator*() const
            {
                return *data_;
            }

            inline void release() noexcept
            {
                if (head_)
                {
                    // Return the memory to pool
                    head_->add(item_);
                }
                else if (data_ && !alias_)
                {
                    // Free the memory
                    delete[] data_;
                }

                data_ = nullptr;
                head_ = nullptr;
                item_ = nullptr;
                alias_ = false;
            }

            void acquire(Pointer<seal_byte> &other) noexcept
            {
                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<seal_byte> &&other) noexcept
            {
                acquire(other);
            }

            void acquire(ConstPointer<seal_byte> &other) noexcept
            {
                if (this == &other)
                {
                    return;
                }

                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(ConstPointer<seal_byte> &&other) noexcept
            {
                acquire(other);
            }

            ~ConstPointer() noexcept
            {
                release();
            }

                           explicit operator bool() const
            {
                return (data_ != nullptr);
            }

                           inline static auto Owning(seal_byte *pointer) noexcept -> ConstPointer<seal_byte>
            {
                return { pointer, false };
            }

                           inline static auto Aliasing(const seal_byte *pointer) noexcept -> ConstPointer<seal_byte>
            {
                return { const_cast<seal_byte *>(pointer), true };
            }

        private:
            ConstPointer(const ConstPointer<seal_byte> &copy) = delete;

            ConstPointer &operator=(const ConstPointer<seal_byte> &assign) = delete;

            ConstPointer(seal_byte *pointer, bool alias) noexcept : data_(pointer), alias_(alias)
            {}

            ConstPointer(class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = item_->data();
            }

            seal_byte *data_ = nullptr;

            MemoryPoolHead *head_ = nullptr;

            MemoryPoolItem *item_ = nullptr;

            bool alias_ = false;
        };

        template <typename T, typename>
        class ConstPointer
        {
            friend class MemoryPoolST;
            friend class MemoryPoolMT;

        public:
            ConstPointer() = default;

            // Move of the same type
            ConstPointer(Pointer<T> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            ConstPointer(Pointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            template <typename... Args>
            ConstPointer(Pointer<seal_byte> &&source, Args &&... args)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    for (auto alloc_ptr = data_; count--; alloc_ptr++)
                    {
                        new (alloc_ptr) T(std::forward<Args>(args)...);
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Copy a range when T is not seal_byte
            template <typename InputIt>
            ConstPointer(InputIt first, Pointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    std::uninitialized_copy_n(first, count, data_);
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move of the same type
            ConstPointer(ConstPointer<T> &&source) noexcept
                : data_(source.data_), head_(source.head_), item_(source.item_), alias_(source.alias_)
            {
                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            ConstPointer(ConstPointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Move when T is not seal_byte
            template <typename... Args>
            ConstPointer(ConstPointer<seal_byte> &&source, Args &&... args)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    for (auto alloc_ptr = data_; count--; alloc_ptr++)
                    {
                        new (alloc_ptr) T(std::forward<Args>(args)...);
                    }
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            // Copy a range when T is not seal_byte
            template <typename InputIt>
            ConstPointer(InputIt first, ConstPointer<seal_byte> &&source)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!source.head_ && source.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                head_ = source.head_;
                item_ = source.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    auto count = head_->item_byte_count() / sizeof(T);
                    std::uninitialized_copy_n(first, count, data_);
                }
                alias_ = source.alias_;

                source.data_ = nullptr;
                source.head_ = nullptr;
                source.item_ = nullptr;
                source.alias_ = false;
            }

            inline auto &operator=(ConstPointer<T> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

            inline auto &operator=(ConstPointer<seal_byte> &&assign)
            {
                acquire(std::move(assign));
                return *this;
            }

            inline auto &operator=(Pointer<T> &&assign) noexcept
            {
                acquire(std::move(assign));
                return *this;
            }

            inline auto &operator=(Pointer<seal_byte> &&assign)
            {
                acquire(std::move(assign));
                return *this;
            }

                           inline const T &operator[](std::size_t index) const
            {
                return data_[index];
            }

                           inline bool is_set() const noexcept
            {
                return data_ != nullptr;
            }

                           inline const T *get() const noexcept
            {
                return data_;
            }

                           inline const T *operator->() const noexcept
            {
                return data_;
            }

                           inline const T &operator*() const
            {
                return *data_;
            }

            inline void release() noexcept
            {
                if (head_)
                {
                    if(!std::is_trivially_destructible<T>::value)
                    {
                        // Manual destructor calls
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            alloc_ptr->~T();
                        }
                    }

                    // Return the memory to pool
                    head_->add(item_);
                }
                else if (data_ && !alias_)
                {
                    // Free the memory
                    delete[] data_;
                }

                data_ = nullptr;
                head_ = nullptr;
                item_ = nullptr;
                alias_ = false;
            }

            void acquire(ConstPointer<T> &other) noexcept
            {
                if (this == &other)
                {
                    return;
                }

                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(ConstPointer<T> &&other) noexcept
            {
                acquire(other);
            }

            void acquire(ConstPointer<seal_byte> &other)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!other.head_ && other.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                release();

                head_ = other.head_;
                item_ = other.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(ConstPointer<seal_byte> &&other)
            {
                acquire(other);
            }

            void acquire(Pointer<T> &other) noexcept
            {
                release();

                data_ = other.data_;
                head_ = other.head_;
                item_ = other.item_;
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<T> &&other) noexcept
            {
                acquire(other);
            }

            void acquire(Pointer<seal_byte> &other)
            {
                // Cannot acquire a non-pool pointer of different type
                if (!other.head_ && other.data_)
                {
                    throw std::invalid_argument("cannot acquire a non-pool pointer of different type");
                }

                release();

                head_ = other.head_;
                item_ = other.item_;
                if (head_)
                {
                    data_ = reinterpret_cast<T *>(item_->data());
                    if(!std::is_trivially_constructible<T>::value)
                    {
                        auto count = head_->item_byte_count() / sizeof(T);
                        for (auto alloc_ptr = data_; count--; alloc_ptr++)
                        {
                            new (alloc_ptr) T;
                        }
                    }
                }
                alias_ = other.alias_;
                other.data_ = nullptr;
                other.head_ = nullptr;
                other.item_ = nullptr;
                other.alias_ = false;
            }

            inline void acquire(Pointer<seal_byte> &&other)
            {
                acquire(other);
            }

            ~ConstPointer() noexcept
            {
                release();
            }

                           explicit operator bool() const noexcept
            {
                return (data_ != nullptr);
            }

                           inline static ConstPointer<T> Owning(T *pointer) noexcept
            {
                return { pointer, false };
            }

                           inline static auto Aliasing(const T *pointer) noexcept -> ConstPointer<T>
            {
                return { const_cast<T *>(pointer), true };
            }

        private:
            ConstPointer(const ConstPointer<T> &copy) = delete;

            ConstPointer &operator=(const ConstPointer<T> &assign) = delete;

            ConstPointer(T *pointer, bool alias) noexcept : data_(pointer), alias_(alias)
            {}

            ConstPointer(class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                if(!std::is_trivially_constructible<T>::value)
                {
                    auto count = head_->item_byte_count() / sizeof(T);
                    for (auto alloc_ptr = data_; count--; alloc_ptr++)
                    {
                        new (alloc_ptr) T;
                    }
                }
            }

            template <typename... Args>
            ConstPointer(class MemoryPoolHead *head, Args &&... args)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                auto count = head_->item_byte_count() / sizeof(T);
                for (auto alloc_ptr = data_; count--; alloc_ptr++)
                {
                    new (alloc_ptr) T(std::forward<Args>(args)...);
                }
            }

            template <typename InputIt>
            ConstPointer(InputIt first, class MemoryPoolHead *head)
            {






                head_ = head;
                item_ = head->get();
                data_ = reinterpret_cast<T *>(item_->data());
                auto count = head_->item_byte_count() / sizeof(T);
                std::uninitialized_copy_n(first, count, data_);
            }

            T *data_ = nullptr;

            MemoryPoolHead *head_ = nullptr;

            MemoryPoolItem *item_ = nullptr;

            bool alias_ = false;
        };

        // Allocate single element
        template <
            typename T_, typename... Args,
            typename = std::enable_if_t<std::is_standard_layout<
                typename std::remove_cv<typename std::remove_reference<T_>::type>::type>::value>>
                       inline auto allocate(MemoryPool &pool, Args &&... args)
        {
            using T = typename std::remove_cv<typename std::remove_reference<T_>::type>::type;
            return Pointer<T>(pool.get_for_byte_count(sizeof(T)), std::forward<Args>(args)...);
        }

        // Allocate array of elements
        template <
            typename T_, typename... Args,
            typename = std::enable_if_t<std::is_standard_layout<
                typename std::remove_cv<typename std::remove_reference<T_>::type>::type>::value>>
                       inline auto allocate(std::size_t count, MemoryPool &pool, Args &&... args)
        {
            using T = typename std::remove_cv<typename std::remove_reference<T_>::type>::type;
            return Pointer<T>(pool.get_for_byte_count(mul_safe(count, sizeof(T))), std::forward<Args>(args)...);
        }

        // Allocate and copy a range of elements
        template <
            typename InputIt,
            typename T_ = typename std::iterator_traits<typename std::remove_reference<InputIt>::type>::value_type,
            typename = std::enable_if_t<std::is_standard_layout<
                typename std::remove_cv<typename std::remove_reference<T_>::type>::type>::value>>
                       inline auto allocate(InputIt &&first, std::size_t count, MemoryPool &pool)
        {
            using T = typename std::remove_cv<typename std::remove_reference<T_>::type>::type;
            return Pointer<T>(std::forward<InputIt>(first), pool.get_for_byte_count(mul_safe(count, sizeof(T))));
        }
    } // namespace util
} // namespace seal
# 9 "SEAL/native/src/seal/util/uintcore.h" 2






namespace seal
{
    namespace util
    {
                       std::string uint_to_hex_string(const std::uint64_t *value, std::size_t uint64_count);

                       std::string uint_to_dec_string(
            const std::uint64_t *value, std::size_t uint64_count, MemoryPool &pool);

        inline void hex_string_to_uint(
            const char *hex_string, int char_count, std::size_t uint64_count, std::uint64_t *result)
        {
# 43 "SEAL/native/src/seal/util/uintcore.h"
            const char *hex_string_ptr = hex_string + char_count;
            for (std::size_t uint64_index = 0; uint64_index < uint64_count; uint64_index++)
            {
                std::uint64_t value = 0;
                for (int bit_index = 0; bit_index < bits_per_uint64; bit_index += bits_per_nibble)
                {
                    if (hex_string_ptr == hex_string)
                    {
                        break;
                    }
                    char hex = *--hex_string_ptr;
                    int nibble = hex_to_nibble(hex);
                    if (nibble == -1)
                    {
                        throw std::invalid_argument("hex_value");
                    }
                    value |= static_cast<std::uint64_t>(nibble) << bit_index;
                }
                result[uint64_index] = value;
            }
        }

                       inline auto allocate_uint(std::size_t uint64_count, MemoryPool &pool)
        {
            return allocate<std::uint64_t>(uint64_count, pool);
        }

        inline void set_zero_uint(std::size_t uint64_count, std::uint64_t *result)
        {






            std::fill_n(result, uint64_count, std::uint64_t(0));
        }

                       inline auto allocate_zero_uint(std::size_t uint64_count, MemoryPool &pool)
        {
            auto result(allocate_uint(uint64_count, pool));
            set_zero_uint(uint64_count, result.get());
            return result;

            // The following looks better but seems to yield worse results.
            // return allocate<std::uint64_t>(uint64_count, pool, std::uint64_t(0));
        }

        inline void set_uint(std::uint64_t value, std::size_t uint64_count, std::uint64_t *result)
        {
# 103 "SEAL/native/src/seal/util/uintcore.h"
            *result++ = value;
            for (; --uint64_count; result++)
            {
                *result = 0;
            }
        }

        inline void set_uint(const std::uint64_t *value, std::size_t uint64_count, std::uint64_t *result)
        {
# 122 "SEAL/native/src/seal/util/uintcore.h"
            if ((value == result) || !uint64_count)
            {
                return;
            }
            std::copy_n(value, uint64_count, result);
        }

                       inline bool is_zero_uint(const std::uint64_t *value, std::size_t uint64_count)
        {






            return std::all_of(value, value + uint64_count, [](auto coeff) -> bool { return !coeff; });
        }

                       inline bool is_equal_uint(
            const std::uint64_t *value, std::size_t uint64_count, std::uint64_t scalar)
        {
# 153 "SEAL/native/src/seal/util/uintcore.h"
            if (*value++ != scalar)
            {
                return false;
            }
            return std::all_of(value, value + uint64_count - 1, [](auto coeff) -> bool { return !coeff; });
        }

                       inline bool is_high_bit_set_uint(const std::uint64_t *value, std::size_t uint64_count)
        {
# 172 "SEAL/native/src/seal/util/uintcore.h"
            return (value[uint64_count - 1] >> (bits_per_uint64 - 1)) != 0;
        }





#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"


 inline bool is_bit_set_uint(
            const std::uint64_t *value, std::size_t uint64_count , int bit_index)
        {
# 201 "SEAL/native/src/seal/util/uintcore.h"
            int uint64_index = bit_index / bits_per_uint64;
            int sub_bit_index = bit_index - uint64_index * bits_per_uint64;
            return ((value[static_cast<std::size_t>(uint64_index)] >> sub_bit_index) & 1) != 0;
        }

        inline void set_bit_uint(std::uint64_t *value, std::size_t uint64_count , int bit_index)
        {
# 223 "SEAL/native/src/seal/util/uintcore.h"
            int uint64_index = bit_index / bits_per_uint64;
            int sub_bit_index = bit_index % bits_per_uint64;
            value[static_cast<std::size_t>(uint64_index)] |= std::uint64_t(1) << sub_bit_index;
        }




#pragma clang diagnostic pop


 inline int get_significant_bit_count_uint(const std::uint64_t *value, std::size_t uint64_count)
        {
# 246 "SEAL/native/src/seal/util/uintcore.h"
            value += uint64_count - 1;
            for (; *value == 0 && uint64_count > 1; uint64_count--)
            {
                value--;
            }

            return static_cast<int>(uint64_count - 1) * bits_per_uint64 + get_significant_bit_count(*value);
        }

                       inline std::size_t get_significant_uint64_count_uint(
            const std::uint64_t *value, std::size_t uint64_count)
        {
# 268 "SEAL/native/src/seal/util/uintcore.h"
            value += uint64_count - 1;
            for (; uint64_count && !*value; uint64_count--)
            {
                value--;
            }

            return uint64_count;
        }

                       inline std::size_t get_nonzero_uint64_count_uint(
            const std::uint64_t *value, std::size_t uint64_count)
        {
# 290 "SEAL/native/src/seal/util/uintcore.h"
            std::size_t nonzero_count = uint64_count;

            value += uint64_count - 1;
            for (; uint64_count; uint64_count--)
            {
                if (*value-- == 0)
                {
                    nonzero_count--;
                }
            }

            return nonzero_count;
        }

        inline void set_uint(
            const std::uint64_t *value, std::size_t value_uint64_count, std::size_t result_uint64_count,
            std::uint64_t *result)
        {
# 318 "SEAL/native/src/seal/util/uintcore.h"
            if (value == result || !value_uint64_count)
            {
                // Fast path to handle self assignment.
                std::fill(result + value_uint64_count, result + result_uint64_count, std::uint64_t(0));
            }
            else
            {
                std::size_t min_uint64_count = std::min<>(value_uint64_count, result_uint64_count);
                std::copy_n(value, min_uint64_count, result);
                std::fill(result + min_uint64_count, result + result_uint64_count, std::uint64_t(0));
            }
        }

        /**
        If the value is a power of two, return the power; otherwise, return -1.
        */
                       inline int get_power_of_two(std::uint64_t value)
        {
            if (value == 0 || (value & (value - 1)) != 0)
            {
                return -1;
            }

            unsigned long result = 0;
            get_msb_index_generic(&result, value);
            return static_cast<int>(result);
        }

        inline void filter_highbits_uint(std::uint64_t *operand, std::size_t uint64_count, int bit_count)
        {
            std::size_t bits_per_uint64_sz = static_cast<std::size_t>(bits_per_uint64);
# 359 "SEAL/native/src/seal/util/uintcore.h"
            if (unsigned_eq(bit_count, mul_safe(uint64_count, bits_per_uint64_sz)))
            {
                return;
            }
            int uint64_index = bit_count / bits_per_uint64;
            int subbit_index = bit_count - uint64_index * bits_per_uint64;
            operand += uint64_index;
            *operand++ &= (std::uint64_t(1) << subbit_index) - 1;
            for (int long_index = uint64_index + 1; unsigned_lt(long_index, uint64_count); long_index++)
            {
                *operand++ = 0;
            }
        }

                       inline auto duplicate_uint_if_needed(
            const std::uint64_t *input, std::size_t uint64_count, std::size_t new_uint64_count, bool force,
            MemoryPool &pool)
        {






            if (!force && uint64_count >= new_uint64_count)
            {
                return ConstPointer<std::uint64_t>::Aliasing(input);
            }

            auto allocation(allocate_uint(new_uint64_count, pool));
            set_uint(input, uint64_count, new_uint64_count, allocation.get());
            return ConstPointer<std::uint64_t>(std::move(allocation));
        }

                       inline int compare_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
# 406 "SEAL/native/src/seal/util/uintcore.h"
            int result = 0;
            operand1 += uint64_count - 1;
            operand2 += uint64_count - 1;

            for (; (result == 0) && uint64_count--; operand1--, operand2--)
            {
                result = (*operand1 > *operand2) - (*operand1 < *operand2);
            }
            return result;
        }

                       inline int compare_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
# 431 "SEAL/native/src/seal/util/uintcore.h"
            int result = 0;
            operand1 += operand1_uint64_count - 1;
            operand2 += operand2_uint64_count - 1;

            std::size_t min_uint64_count = std::min<>(operand1_uint64_count, operand2_uint64_count);

            operand1_uint64_count -= min_uint64_count;
            for (; (result == 0) && operand1_uint64_count--; operand1--)
            {
                result = (*operand1 > 0);
            }

            operand2_uint64_count -= min_uint64_count;
            for (; (result == 0) && operand2_uint64_count--; operand2--)
            {
                result = -(*operand2 > 0);
            }

            for (; (result == 0) && min_uint64_count--; operand1--, operand2--)
            {
                result = (*operand1 > *operand2) - (*operand1 < *operand2);
            }
            return result;
        }

                       inline bool is_greater_than_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
            return compare_uint(operand1, operand2, uint64_count) > 0;
        }

                       inline bool is_greater_than_or_equal_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
            return compare_uint(operand1, operand2, uint64_count) >= 0;
        }

                       inline bool is_less_than_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
            return compare_uint(operand1, operand2, uint64_count) < 0;
        }

                       inline bool is_less_than_or_equal_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
            return compare_uint(operand1, operand2, uint64_count) <= 0;
        }

                       inline bool is_equal_uint(
            const std::uint64_t *operand1, const std::uint64_t *operand2, std::size_t uint64_count)
        {
            return compare_uint(operand1, operand2, uint64_count) == 0;
        }

                       inline bool is_greater_than_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
            return compare_uint(operand1, operand1_uint64_count, operand2, operand2_uint64_count) > 0;
        }

                       inline bool is_greater_than_or_equal_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
            return compare_uint(operand1, operand1_uint64_count, operand2, operand2_uint64_count) >= 0;
        }

                       inline bool is_less_than_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
            return compare_uint(operand1, operand1_uint64_count, operand2, operand2_uint64_count) < 0;
        }

                       inline bool is_less_than_or_equal_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
            return compare_uint(operand1, operand1_uint64_count, operand2, operand2_uint64_count) <= 0;
        }

                       inline bool is_equal_uint(
            const std::uint64_t *operand1, std::size_t operand1_uint64_count, const std::uint64_t *operand2,
            std::size_t operand2_uint64_count)
        {
            return compare_uint(operand1, operand1_uint64_count, operand2, operand2_uint64_count) == 0;
        }
    } // namespace util
} // namespace seal
# 11 "SEAL/native/src/seal/modulus.h" 2
# 1 "SEAL/native/src/seal/util/ztools.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 12 "SEAL/native/src/seal/modulus.h" 2
# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/array" 1
// -*- C++ -*-
//===---------------------------- array -----------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    array synopsis

namespace std
{
template <class T, size_t N >
struct array
{
    // types:
    typedef T & reference;
    typedef const T & const_reference;
    typedef implementation defined iterator;
    typedef implementation defined const_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // No explicit construct/copy/destroy for aggregate type
    void fill(const T& u);                                      // constexpr in C++20
    void swap(array& a) noexcept(is_nothrow_swappable_v<T>);    // constexpr in C++20

    // iterators:
    iterator begin() noexcept;                                  // constexpr in C++17
    const_iterator begin() const noexcept;                      // constexpr in C++17
    iterator end() noexcept;                                    // constexpr in C++17
    const_iterator end() const noexcept;                        // constexpr in C++17

    reverse_iterator rbegin() noexcept;                         // constexpr in C++17
    const_reverse_iterator rbegin() const noexcept;             // constexpr in C++17
    reverse_iterator rend() noexcept;                           // constexpr in C++17
    const_reverse_iterator rend() const noexcept;               // constexpr in C++17

    const_iterator cbegin() const noexcept;                     // constexpr in C++17
    const_iterator cend() const noexcept;                       // constexpr in C++17
    const_reverse_iterator crbegin() const noexcept;            // constexpr in C++17
    const_reverse_iterator crend() const noexcept;              // constexpr in C++17

    // capacity:
    constexpr size_type size() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr bool empty() const noexcept;

    // element access:
    reference operator[](size_type n);                          // constexpr in C++17
    const_reference operator[](size_type n) const;              // constexpr in C++14
    reference at(size_type n);                                  // constexpr in C++17
    const_reference at(size_type n) const;                      // constexpr in C++14

    reference front();                                          // constexpr in C++17
    const_reference front() const;                              // constexpr in C++14
    reference back();                                           // constexpr in C++17
    const_reference back() const;                               // constexpr in C++14

    T* data() noexcept;                                         // constexpr in C++17
    const T* data() const noexcept;                             // constexpr in C++17
};

template <class T, class... U>
  array(T, U...) -> array<T, 1 + sizeof...(U)>;                 // C++17

template <class T, size_t N>
  bool operator==(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator!=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator<(const array<T,N>& x, const array<T,N>& y);     // constexpr in C++20
template <class T, size_t N>
  bool operator>(const array<T,N>& x, const array<T,N>& y);     // constexpr in C++20
template <class T, size_t N>
  bool operator<=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20
template <class T, size_t N>
  bool operator>=(const array<T,N>& x, const array<T,N>& y);    // constexpr in C++20

template <class T, size_t N >
  void swap(array<T,N>& x, array<T,N>& y) noexcept(noexcept(x.swap(y))); // constexpr in C++20

template <class T, size_t N>
  constexpr array<remove_cv_t<T>, N> to_array(T (&a)[N]);  // C++20
template <class T, size_t N>
  constexpr array<remove_cv_t<T>, N> to_array(T (&&a)[N]); // C++20

template <class T> struct tuple_size;
template <size_t I, class T> struct tuple_element;
template <class T, size_t N> struct tuple_size<array<T, N>>;
template <size_t I, class T, size_t N> struct tuple_element<I, array<T, N>>;
template <size_t I, class T, size_t N> T& get(array<T, N>&) noexcept;               // constexpr in C++14
template <size_t I, class T, size_t N> const T& get(const array<T, N>&) noexcept;   // constexpr in C++14
template <size_t I, class T, size_t N> T&& get(array<T, N>&&) noexcept;             // constexpr in C++14
template <size_t I, class T, size_t N> const T&& get(const array<T, N>&&) noexcept; // constexpr in C++14

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 112 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/array" 2
# 124 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/array" 3




namespace std { inline namespace __1 {


template <class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) array
{
    // types:
    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    _Tp __elems_[_Size];

    // No explicit construct/copy/destroy for aggregate type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void fill(const value_type& __u) {
        std::__1::fill_n(data(), _Size, __u);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(array& __a) noexcept(__is_nothrow_swappable<_Tp>::value) {
        std::__1::swap_ranges(data(), data() + _Size, __a.data());
    }

    // iterators:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    iterator end() noexcept {return iterator(data() + _Size);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator end() const noexcept {return const_iterator(data() + _Size);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}

    // capacity:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr size_type size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr size_type max_size() const noexcept {return _Size;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr bool empty() const noexcept {return _Size == 0;}

    // element access:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator[](size_type __n) noexcept {
        ((void)0);
        return __elems_[__n];
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reference operator[](size_type __n) const noexcept {
        ((void)0);
        return __elems_[__n];
    }

    constexpr reference at(size_type __n)
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    constexpr const_reference at(size_type __n) const
    {
        if (__n >= _Size)
            __throw_out_of_range("array::at");
        return __elems_[__n];
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference front() noexcept {return (*this)[0];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const_reference front() const noexcept {return (*this)[0];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr reference back() noexcept {return (*this)[_Size - 1];}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr const_reference back() const noexcept {return (*this)[_Size - 1];}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    value_type* data() noexcept {return __elems_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const value_type* data() const noexcept {return __elems_;}
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) array<_Tp, 0>
{
    // types:
    typedef array __self;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    typedef typename conditional<is_const<_Tp>::value, const char,
                                char>::type _CharType;

    struct _ArrayInStructT { _Tp __data_[1]; };
    alignas(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    value_type* data() noexcept {return nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const value_type* data() const noexcept {return nullptr;}

    // No explicit construct/copy/destroy for aggregate type
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void fill(const value_type&) {
      static_assert(!is_const<_Tp>::value,
                    "cannot fill zero-sized array of type 'const T'");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    void swap(array&) noexcept {
      static_assert(!is_const<_Tp>::value,
                    "cannot swap zero-sized array of type 'const T'");
    }

    // iterators:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    iterator begin() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator begin() const noexcept {return const_iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    iterator end() noexcept {return iterator(data());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator end() const noexcept {return const_iterator(data());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator rbegin() const noexcept {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator rend() const noexcept {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reverse_iterator crend() const noexcept {return rend();}

    // capacity:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr size_type size() const noexcept {return 0; }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr size_type max_size() const noexcept {return 0;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    constexpr bool empty() const noexcept {return true;}

    // element access:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference operator[](size_type) noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reference operator[](size_type) const noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference at(size_type) {
      __throw_out_of_range("array<T, 0>::at");
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reference at(size_type) const {
      __throw_out_of_range("array<T, 0>::at");
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference front() noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reference front() const noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    reference back() noexcept {
      ((void)0);
      __builtin_unreachable();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
    const_reference back() const noexcept {
      ((void)0);
      __builtin_unreachable();
    }
};



template<class _Tp, class... _Args,
         class = _EnableIf<__all<_IsSame<_Tp, _Args>::value...>::value>
         >
array(_Tp, _Args...)
  -> array<_Tp, 1 + sizeof...(_Args)>;


template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x == __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(),
                                          __y.begin(), __y.end());
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return __y < __x;
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__y < __x);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
                              bool
operator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y)
{
    return !(__x < __y);
}

template <class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename enable_if
<
    _Size == 0 ||
    __is_swappable<_Tp>::value,
    void
>::type
swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
                                  noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) tuple_size<array<_Tp, _Size> >
    : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) tuple_element<_Ip, array<_Tp, _Size> >
{
    static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
    typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&
get(array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&
get(const array<_Tp, _Size>& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
    return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
_Tp&&
get(array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__)) constexpr
const _Tp&&
get(const array<_Tp, _Size>&& __a) noexcept
{
    static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
    return std::__1::move(__a.__elems_[_Ip]);
}
# 521 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/array" 3
} }
# 13 "SEAL/native/src/seal/modulus.h" 2





namespace seal
{
    /**
    Represent an integer modulus of up to 61 bits. An instance of the Modulus
    class represents a non-negative integer modulus up to 61 bits. In particular,
    the encryption parameter plain_modulus, and the primes in coeff_modulus, are
    represented by instances of Modulus. The purpose of this class is to
    perform and store the pre-computation required by Barrett reduction.

    @par Thread Safety
    In general, reading from Modulus is thread-safe as long as no other thread
    is concurrently mutating it.

    @see EncryptionParameters for a description of the encryption parameters.
    */
    class Modulus
    {
    public:
        /**
        Creates a Modulus instance. The value of the Modulus is set to
        the given value, or to zero by default.

        @param[in] value The integer modulus
        @throws std::invalid_argument if value is 1 or more than 61 bits
        */
        Modulus(std::uint64_t value = 0)
        {
            set_value(value);
        }

        /**
        Creates a new Modulus by copying a given one.

        @param[in] copy The Modulus to copy from
        */
        Modulus(const Modulus &copy) = default;

        /**
        Creates a new Modulus by copying a given one.

        @param[in] source The Modulus to move from
        */
        Modulus(Modulus &&source) = default;

        /**
        Copies a given Modulus to the current one.

        @param[in] assign The Modulus to copy from
        */
        Modulus &operator=(const Modulus &assign) = default;

        /**
        Moves a given Modulus to the current one.

        @param[in] assign The Modulus to move from
        */
        Modulus &operator=(Modulus &&assign) = default;

        /**
        Sets the value of the Modulus.

        @param[in] value The new integer modulus
        @throws std::invalid_argument if value is 1 or more than 61 bits
        */
        inline Modulus &operator=(std::uint64_t value)
        {
            set_value(value);
            return *this;
        }

        /**
        Returns the significant bit count of the value of the current Modulus.
        */
                       inline int bit_count() const noexcept
        {
            return bit_count_;
        }

        /**
        Returns the size (in 64-bit words) of the value of the current Modulus.
        */
                       inline std::size_t uint64_count() const noexcept
        {
            return uint64_count_;
        }

        /**
        Returns a const pointer to the value of the current Modulus.
        */
                       inline const uint64_t *data() const noexcept
        {
            return &value_;
        }

        /**
        Returns the value of the current Modulus.
        */
                       inline std::uint64_t value() const noexcept
        {
            return value_;
        }

        /**
        Returns the Barrett ratio computed for the value of the current Modulus.
        The first two components of the Barrett ratio are the floor of 2^128/value,
        and the third component is the remainder.
        */
                       inline auto &const_ratio() const noexcept
        {
            return const_ratio_;
        }

        /**
        Returns whether the value of the current Modulus is zero.
        */
                       inline bool is_zero() const noexcept
        {
            return value_ == 0;
        }

        /**
        Returns whether the value of the current Modulus is a prime number.
        */
                       inline bool is_prime() const noexcept
        {
            return is_prime_;
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator==(const Modulus &compare) const noexcept
        {
            return value_ == compare.value_;
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator==(std::uint64_t compare) const noexcept
        {
            return value_ == compare;
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator!=(const Modulus &compare) const noexcept
        {
            return !operator==(compare);
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator!=(std::uint64_t compare) const noexcept
        {
            return !operator==(compare);
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator<(const Modulus &compare) const noexcept
        {
            return value_ < compare.value_;
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator<(std::uint64_t compare) const noexcept
        {
            return value_ < compare;
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator<=(const Modulus &compare) const noexcept
        {
            return value_ <= compare.value_;
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator<=(std::uint64_t compare) const noexcept
        {
            return value_ <= compare;
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator>(const Modulus &compare) const noexcept
        {
            return value_ > compare.value_;
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator>(std::uint64_t compare) const noexcept
        {
            return value_ > compare;
        }

        /**
        Compares two Modulus instances.

        @param[in] compare The Modulus to compare against
        */
                       inline bool operator>=(const Modulus &compare) const noexcept
        {
            return value_ >= compare.value_;
        }

        /**
        Compares a Modulus value to an unsigned integer.

        @param[in] compare The unsigned integer to compare against
        */
                       inline bool operator>=(std::uint64_t compare) const noexcept
        {
            return value_ >= compare;
        }

        /**
        Returns an upper bound on the size of the Modulus, as if it was
        written to an output stream.

        @param[in] compr_mode The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the size does not fit in the return type
        */
                       inline std::streamoff save_size(
            compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            std::size_t members_size = Serialization::ComprSizeEstimate(util::add_safe(sizeof(value_)), compr_mode);

            return util::safe_cast<std::streamoff>(util::add_safe(sizeof(Serialization::SEALHeader), members_size));
        }

        /**
        Saves the Modulus to an output stream. The output is in binary format
        and not human-readable. The output stream must have the "binary" flag set.

        @param[out] stream The stream to save the Modulus to
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            std::ostream &stream, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&Modulus::save_members, this, _1), save_size(compr_mode_type::none), stream, compr_mode,
                false);
        }

        /**
        Loads a Modulus from an input stream overwriting the current Modulus.

        @param[in] stream The stream to load the Modulus from
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(std::istream &stream)
        {
            using namespace std::placeholders;
            return Serialization::Load(std::bind(&Modulus::load_members, this, _1, _2), stream, false);
        }

        /**
        Saves the Modulus to a given memory location. The output is in binary
        format and not human-readable.

        @param[out] out The memory location to write the Modulus to
        @param[in] size The number of bytes available in the given memory location
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if out is null or if size is too small to
        contain a SEALHeader, or if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            seal_byte *out, std::size_t size, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&Modulus::save_members, this, _1), save_size(compr_mode_type::none), out, size, compr_mode,
                false);
        }

        /**
        Loads a Modulus from a given memory location overwriting the current
        Modulus.

        @param[in] in The memory location to load the Modulus from
        @param[in] size The number of bytes available in the given memory location
        @throws std::invalid_argument if in is null or if size is too small to
        contain a SEALHeader
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(const seal_byte *in, std::size_t size)
        {
            using namespace std::placeholders;
            return Serialization::Load(std::bind(&Modulus::load_members, this, _1, _2), in, size, false);
        }

        /**
        Reduces a given unsigned integer modulo this modulus.

        @param[in] value The unsigned integer to reduce
        @throws std::logic_error if the Modulus is zero
        */
                       std::uint64_t reduce(std::uint64_t value) const;

    private:
        void set_value(std::uint64_t value);

        void save_members(std::ostream &stream) const;

        void load_members(std::istream &stream, SEALVersion version);

        std::uint64_t value_ = 0;

        std::array<std::uint64_t, 3> const_ratio_{ { 0, 0, 0 } };

        std::size_t uint64_count_ = 0;

        int bit_count_ = 0;

        bool is_prime_ = false;
    };

    /**
    Represents a standard security level according to the HomomorphicEncryption.org
    security standard. The value sec_level_type::none signals that no standard
    security level should be imposed. The value sec_level_type::tc128 provides
    a very high level of security and is the default security level enforced by
    Microsoft SEAL when constructing a SEALContext object. Normal users should not
    have to specify the security level explicitly anywhere.
    */
    enum class sec_level_type : int
    {
        /**
        No security level specified.
        */
        none = 0,

        /**
        128-bit security level according to HomomorphicEncryption.org standard.
        */
        tc128 = 128,

        /**
        192-bit security level according to HomomorphicEncryption.org standard.
        */
        tc192 = 192,

        /**
        256-bit security level according to HomomorphicEncryption.org standard.
        */
        tc256 = 256
    };

    /**
    This class contains static methods for creating a coefficient modulus easily.
    Note that while these functions take a sec_level_type argument, all security
    guarantees are lost if the output is used with encryption parameters with
    a mismatching value for the poly_modulus_degree.

    The default value sec_level_type::tc128 provides a very high level of security
    and is the default security level enforced by Microsoft SEAL when constructing
    a SEALContext object. Normal users should not have to specify the security
    level explicitly anywhere.
    */
    class CoeffModulus
    {
    public:
        CoeffModulus() = delete;

        /**
        Returns the largest bit-length of the coefficient modulus, i.e., bit-length
        of the product of the primes in the coefficient modulus, that guarantees
        a given security level when using a given poly_modulus_degree, according
        to the HomomorphicEncryption.org security standard.

        @param[in] poly_modulus_degree The value of the poly_modulus_degree
        encryption parameter
        @param[in] sec_level The desired standard security level
        */
                       static constexpr int MaxBitCount(
            std::size_t poly_modulus_degree, sec_level_type sec_level = sec_level_type::tc128) noexcept
        {
            switch (sec_level)
            {
            case sec_level_type::tc128:
                return util::seal_he_std_parms_128_tc(poly_modulus_degree);

            case sec_level_type::tc192:
                return util::seal_he_std_parms_192_tc(poly_modulus_degree);

            case sec_level_type::tc256:
                return util::seal_he_std_parms_256_tc(poly_modulus_degree);

            case sec_level_type::none:
                return (std::numeric_limits<int>::max)();

            default:
                return 0;
            }
        }

        /**
        Returns a default coefficient modulus for the BFV scheme that guarantees
        a given security level when using a given poly_modulus_degree, according
        to the HomomorphicEncryption.org security standard. Note that all security
        guarantees are lost if the output is used with encryption parameters with
        a mismatching value for the poly_modulus_degree.

        The coefficient modulus returned by this function will not perform well
        if used with the CKKS scheme.

        @param[in] poly_modulus_degree The value of the poly_modulus_degree
        encryption parameter
        @param[in] sec_level The desired standard security level
        @throws std::invalid_argument if poly_modulus_degree is not a power-of-two
        or is too large
        @throws std::invalid_argument if sec_level is sec_level_type::none
        */
                       static std::vector<Modulus> BFVDefault(
            std::size_t poly_modulus_degree, sec_level_type sec_level = sec_level_type::tc128);

        /**
        Returns a custom coefficient modulus suitable for use with the specified
        poly_modulus_degree. The return value will be a vector consisting of
        Modulus elements representing distinct prime numbers of bit-lengths
        as given in the bit_sizes parameter. The bit sizes of the prime numbers
        can be at most 60 bits.

        @param[in] poly_modulus_degree The value of the poly_modulus_degree
        encryption parameter
        @param[in] bit_sizes The bit-lengths of the primes to be generated
        @throws std::invalid_argument if poly_modulus_degree is not a power-of-two
        or is too large
        @throws std::invalid_argument if bit_sizes is too large or if its elements
        are out of bounds
        @throws std::logic_error if not enough suitable primes could be found
        */
                       static std::vector<Modulus> Create(std::size_t poly_modulus_degree, std::vector<int> bit_sizes);
    };

    /**
    This class contains static methods for creating a plaintext modulus easily.
    */
    class PlainModulus
    {
    public:
        PlainModulus() = delete;

        /**
        Creates a prime number Modulus for use as plain_modulus encryption
        parameter that supports batching with a given poly_modulus_degree.

        @param[in] poly_modulus_degree The value of the poly_modulus_degree
        encryption parameter
        @param[in] bit_size The bit-length of the prime to be generated
        @throws std::invalid_argument if poly_modulus_degree is not a power-of-two
        or is too large
        @throws std::invalid_argument if bit_size is out of bounds
        @throws std::logic_error if a suitable prime could not be found
        */
                       static inline Modulus Batching(std::size_t poly_modulus_degree, int bit_size)
        {
            return CoeffModulus::Create(poly_modulus_degree, { bit_size })[0];
        }

        /**
        Creates several prime number Modulus elements that can be used as
        plain_modulus encryption parameters, each supporting batching with a given
        poly_modulus_degree.

        @param[in] poly_modulus_degree The value of the poly_modulus_degree
        encryption parameter
        @param[in] bit_sizes The bit-lengths of the primes to be generated
        @throws std::invalid_argument if poly_modulus_degree is not a power-of-two
        or is too large
        @throws std::invalid_argument if bit_sizes is too large or if its elements
        are out of bounds
        @throws std::logic_error if not enough suitable primes could be found
        */
                       static inline std::vector<Modulus> Batching(
            std::size_t poly_modulus_degree, std::vector<int> bit_sizes)
        {
            return CoeffModulus::Create(poly_modulus_degree, bit_sizes);
        }
    };
} // namespace seal
# 8 "SEAL/native/src/seal/encryptionparams.h" 2
# 1 "SEAL/native/src/seal/randomgen.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/dynarray.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
# 20 "SEAL/native/src/seal/dynarray.h"
namespace seal
{
    class Ciphertext;

    // Forward-declaring the deflate_size_bound function
    namespace util
    {
        namespace ztools
        {
            template <typename SizeT>
                           SizeT deflate_size_bound(SizeT in_size);
        } // namespace ztools
    } // namespace util

    /**
    A dynamic array for storing objects allocated from a Microsoft SEAL memory
    pool. The DynArray class is mainly intended for internal use and provides
    the underlying data structure for Plaintext and Ciphertext classes.

    @par Size and Capacity
    DynArray allows the user to pre-allocate memory (capacity) for the array
    in cases where the array is known to be resized in the future and memory
    moves are to be avoided at the time of resizing. The size of the DynArray
    can never exceed its capacity. The capacity and size can be changed using
    the reserve and resize functions, respectively.

    @par Thread Safety
    In general, reading from DynArray is thread-safe as long as no other thread
    is concurrently mutating it.
    */
    template <typename T>
    class DynArray
    {
        friend class Ciphertext;

    public:
        using type = T;

        /**
        Creates a new DynArray. No memory is allocated by this constructor.

        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if pool is uninitialized
        */
        DynArray(MemoryPoolHandle pool = MemoryManager::GetPool()) : pool_(std::move(pool))
        {
            if (!pool_)
            {
                throw std::invalid_argument("pool is uninitialized");
            }
        }

        /**
        Creates a new DynArray with given size.

        @param[in] size The size of the array
        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if pool is uninitialized
        */
        explicit DynArray(std::size_t size, MemoryPoolHandle pool = MemoryManager::GetPool()) : pool_(std::move(pool))
        {
            if (!pool_)
            {
                throw std::invalid_argument("pool is uninitialized");
            }

            // Reserve memory, resize, and set to zero
            resize(size);
        }

        /**
        Creates a new DynArray with given capacity and size.

        @param[in] capacity The capacity of the array
        @param[in] size The size of the array
        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if capacity is less than size
        @throws std::invalid_argument if pool is uninitialized
        */
        explicit DynArray(std::size_t capacity, std::size_t size, MemoryPoolHandle pool = MemoryManager::GetPool())
            : pool_(std::move(pool))
        {
            if (!pool_)
            {
                throw std::invalid_argument("pool is uninitialized");
            }
            if (capacity < size)
            {
                throw std::invalid_argument("capacity cannot be smaller than size");
            }

            // Reserve memory, resize, and set to zero
            reserve(capacity);
            resize(size);
        }

        /**
        Creates a new DynArray with given size wrapping a given pointer. This
        constructor allocates no memory. If the DynArray goes out of scope, the
        Pointer object given here is destroyed. On resizing the DynArray to larger
        size, the data will be copied over to a new allocation from the memory pool
        pointer to by the given MemoryPoolHandle and the Pointer object given here
        will subsequently be destroyed. Unlike the other constructors, this one
        exposes the option of not automatically zero-filling the allocated memory.

        @param[in] ptr An initial Pointer object to wrap
        @param[in] capacity The capacity of the array
        @param[in] size The size of the array
        @param[in] fill_zero If true, fills ptr with zeros
        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if ptr is null and capacity is positive
        @throws std::invalid_argument if capacity is less than size
        @throws std::invalid_argument if pool is uninitialized
        */
        explicit DynArray(
            util::Pointer<T> &&ptr, std::size_t capacity, std::size_t size, bool fill_zero,
            MemoryPoolHandle pool = MemoryManager::GetPool())
            : pool_(std::move(pool)), capacity_(capacity)
        {
            if (!ptr && capacity)
            {
                throw std::invalid_argument("ptr cannot be null");
            }
            if (!pool_)
            {
                throw std::invalid_argument("pool is uninitialized");
            }
            if (capacity < size)
            {
                throw std::invalid_argument("capacity cannot be smaller than size");
            }

            // Grab the given Pointer
            data_ = std::move(ptr);

            // Resize, and optionally set to zero
            resize(size, fill_zero);
        }

        /**
        Creates a new DynArray with given size wrapping a given pointer. This
        constructor allocates no memory. If the DynArray goes out of scope, the
        Pointer object given here is destroyed. On resizing the DynArray to larger
        size, the data will be copied over to a new allocation from the memory pool
        pointer to by the given MemoryPoolHandle and the Pointer object given here
        will subsequently be destroyed. Unlike the other constructors, this one
        exposes the option of not automatically zero-filling the allocated memory.

        @param[in] ptr An initial Pointer object to wrap
        @param[in] size The size of the array
        @param[in] fill_zero If true, fills ptr with zeros
        @param[in] pool The MemoryPoolHandle pointing to a valid memory pool
        @throws std::invalid_argument if ptr is null and size is positive
        @throws std::invalid_argument if pool is uninitialized
        */
        explicit DynArray(
            util::Pointer<T> &&ptr, std::size_t size, bool fill_zero, MemoryPoolHandle pool = MemoryManager::GetPool())
            : DynArray(std::move(ptr), size, size, fill_zero, std::move(pool))
        {}
# 208 "SEAL/native/src/seal/dynarray.h"
        /**
        Creates a new DynArray by copying a given one.

        @param[in] copy The DynArray to copy from
        */
        DynArray(const DynArray<T> &copy)
            : pool_(MemoryManager::GetPool()), capacity_(copy.size_), size_(copy.size_),
              data_(util::allocate<T>(copy.size_, pool_))
        {
            // Copy over value
            std::copy(copy.cbegin(), copy.cend(), begin());
        }

        /**
        Creates a new DynArray by moving a given one.

        @param[in] source The DynArray to move from
        */
        DynArray(DynArray<T> &&source) noexcept
            : pool_(std::move(source.pool_)), capacity_(source.capacity_), size_(source.size_),
              data_(std::move(source.data_))
        {}

        /**
        Destroys the DynArray.
        */
        ~DynArray()
        {
            release();
        }

        /**
        Returns a pointer to the beginning of the array data.
        */
                       inline T *begin() noexcept
        {
            return data_.get();
        }

        /**
        Returns a constant pointer to the beginning of the array data.
        */
                       inline const T *begin() const noexcept
        {
            return cbegin();
        }

        /**
        Returns a constant pointer to the beginning of the array data.
        */
                       inline const T *cbegin() const noexcept
        {
            return data_.get();
        }

        /**
        Returns a pointer to the end of the array data.
        */
                       inline T *end() noexcept
        {
            return begin() + size_;
        }

        /**
        Returns a constant pointer to the end of the array data.
        */
                       inline const T *end() const noexcept
        {
            return cend();
        }

        /**
        Returns a constant pointer to the end of the array data.
        */
                       inline const T *cend() const noexcept
        {
            return cbegin() + size_;
        }
# 303 "SEAL/native/src/seal/dynarray.h"
        /**
        Returns a constant reference to the array element at a given index.
        This function performs bounds checking and will throw an error if
        the index is out of range.

        @param[in] index The index of the array element
        @throws std::out_of_range if index is out of range
        */
                       inline const T &at(std::size_t index) const
        {
            if (index >= size_)
            {
                throw std::out_of_range("index must be within [0, size)");
            }
            return data_[index];
        }

        /**
        Returns a reference to the array element at a given index. This
        function performs bounds checking and will throw an error if the
        index is out of range.

        @param[in] index The index of the array element
        @throws std::out_of_range if index is out of range
        */
                       inline T &at(std::size_t index)
        {
            if (index >= size_)
            {
                throw std::out_of_range("index must be within [0, size)");
            }
            return data_[index];
        }

        /**
        Returns a constant reference to the array element at a given index.
        This function does not perform bounds checking.

        @param[in] index The index of the array element
        */
                       inline const T &operator[](std::size_t index) const
        {
            return data_[index];
        }

        /**
        Returns a reference to the array element at a given index. This
        function does not perform bounds checking.

        @param[in] index The index of the array element
        */
                       inline T &operator[](std::size_t index)
        {
            return data_[index];
        }

        /**
        Returns whether the array has size zero.
        */
                       inline bool empty() const noexcept
        {
            return (size_ == 0);
        }

        /**
        Returns the largest possible array size.
        */
                       inline std::size_t max_size() const noexcept
        {
            return (std::numeric_limits<std::size_t>::max)();
        }

        /**
        Returns the size of the array.
        */
                       inline std::size_t size() const noexcept
        {
            return size_;
        }

        /**
        Returns the capacity of the array.
        */
                       inline std::size_t capacity() const noexcept
        {
            return capacity_;
        }

        /**
        Returns the currently used MemoryPoolHandle.
        */
                       inline MemoryPoolHandle pool() const noexcept
        {
            return pool_;
        }

        /**
        Releases any allocated memory to the memory pool and sets the size
        and capacity of the array to zero.
        */
        inline void release() noexcept
        {
            capacity_ = 0;
            size_ = 0;
            data_.release();
        }

        /**
        Sets the size of the array to zero. The capacity is not changed.
        */
        inline void clear() noexcept
        {
            size_ = 0;
        }

        /**
        Allocates enough memory for storing a given number of elements without
        changing the size of the array. If the given capacity is smaller than
        the current size, the size is automatically set to equal the new capacity.

        @param[in] capacity The capacity of the array
        */
        inline void reserve(std::size_t capacity)
        {
            std::size_t copy_size = std::min<>(capacity, size_);

            // Create new allocation and copy over value
            auto new_data(util::allocate<T>(capacity, pool_));
            std::copy_n(cbegin(), copy_size, new_data.get());
            std::swap(data_, new_data);

            // Set the coeff_count and capacity
            capacity_ = capacity;
            size_ = copy_size;
        }

        /**
        Reallocates the array so that its capacity exactly matches its size.
        */
        inline void shrink_to_fit()
        {
            reserve(size_);
        }

        /**
        Resizes the array to given size. When resizing to larger size the data
        in the array remains unchanged and any new space is initialized to zero
        if fill_zero is set to true; when resizing to smaller size the last
        elements of the array are dropped. If the capacity is not already large
        enough to hold the new size, the array is also reallocated.

        @param[in] size The size of the array
        @param[in] fill_zero If true, fills expanded space with zeros
        */
        inline void resize(std::size_t size, bool fill_zero = true)
        {
            if (size <= capacity_)
            {
                // Are we changing size to bigger within current capacity?
                // If so, need to set top terms to zero
                if (size > size_ && fill_zero)
                {
                    std::fill(end(), begin() + size, T(0));
                }

                // Set the size
                size_ = size;

                return;
            }

            // At this point we know for sure that size_ <= capacity_ < size so need
            // to reallocate to bigger
            auto new_data(util::allocate<T>(size, pool_));
            std::copy(cbegin(), cend(), new_data.get());
            if (fill_zero)
            {
                std::fill(new_data.get() + size_, new_data.get() + size, T(0));
            }
            std::swap(data_, new_data);

            // Set the coeff_count and capacity
            capacity_ = size;
            size_ = size;
        }
# 506 "SEAL/native/src/seal/dynarray.h"
        /**
        Copies a given DynArray to the current one.

        @param[in] assign The DynArray to copy from
        */
        inline DynArray<T> &operator=(const DynArray<T> &assign)
        {
            // Check for self-assignment
            if (this == &assign)
            {
                return *this;
            }

            // First resize to correct size
            resize(assign.size_);

            // Size is guaranteed to be OK now so copy over
            std::copy(assign.cbegin(), assign.cend(), begin());

            return *this;
        }

        /**
        Moves a given DynArray to the current one.

        @param[in] assign The DynArray to move from
        */
        DynArray<T> &operator=(DynArray<T> &&assign) noexcept
        {
            capacity_ = assign.capacity_;
            size_ = assign.size_;
            data_ = std::move(assign.data_);
            pool_ = std::move(assign.pool_);

            return *this;
        }

        /**
        Returns an upper bound on the size of the DynArray, as if it was written
        to an output stream.

        @param[in] compr_mode The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the size does not fit in the return type
        */
                       inline std::streamoff save_size(
            compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            std::size_t members_size = Serialization::ComprSizeEstimate(
                util::add_safe(
                    sizeof(std::uint64_t), // size_
                    util::mul_safe(size_, sizeof(T))), // data_
                compr_mode);

            return util::safe_cast<std::streamoff>(util::add_safe(sizeof(Serialization::SEALHeader), members_size));
        }

        /**
        Saves the DynArray to an output stream. The output is in binary format
        and not human-readable. The output stream must have the "binary" flag set.

        @param[out] stream The stream to save the DynArray to
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            std::ostream &stream, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&DynArray<T>::save_members, this, _1), save_size(compr_mode_type::none), stream, compr_mode,
                false);
        }

        /**
        Loads a DynArray from an input stream overwriting the current DynArray.
        This function takes optionally a bound on the size for the loaded DynArray
        and throws an exception if the size indicated by the loaded metadata exceeds
        the provided value. The check is omitted if in_size_bound is zero.

        @param[in] stream The stream to load the DynArray from
        @param[in] in_size_bound A bound on the size of the loaded DynArray
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, if decompression failed,
        or if the loaded size exceeds in_size_bound
        @throws std::logic_error if the loaded data is invalid, if the loaded size
        exceeds in_size_bound, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(std::istream &stream, std::size_t in_size_bound = 0)
        {
            using namespace std::placeholders;
            return Serialization::Load(
                std::bind(&DynArray<T>::load_members, this, _1, _2, in_size_bound), stream, false);
        }

        /**
        Saves the DynArray to a given memory location. The output is in binary
        format and not human-readable.

        @param[out] out The memory location to write the Modulus to
        @param[in] size The number of bytes available in the given memory location
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if out is null or if size is too small to
        contain a SEALHeader, or if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            seal_byte *out, std::size_t size, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&DynArray<T>::save_members, this, _1), save_size(compr_mode_type::none), out, size,
                compr_mode, false);
        }

        /**
        Loads a DynArray from a given memory location overwriting the current
        DynArray. This function takes optionally a bound on the size for the loaded
        DynArray and throws an exception if the size indicated by the loaded
        metadata exceeds the provided value. The check is omitted if in_size_bound
        is zero.

        @param[in] in The memory location to load the Modulus from
        @param[in] size The number of bytes available in the given memory location
        @param[in] in_size_bound A bound on the size of the loaded DynArray
        @throws std::invalid_argument if in is null or if size is too small to
        contain a SEALHeader
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, if decompression failed,
        or if the loaded size exceeds in_size_bound
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(const seal_byte *in, std::size_t size, std::size_t in_size_bound = 0)
        {
            using namespace std::placeholders;
            return Serialization::Load(
                std::bind(&DynArray<T>::load_members, this, _1, _2, in_size_bound), in, size, false);
        }

    private:
        void save_members(std::ostream &stream) const
        {
            auto old_except_mask = stream.exceptions();
            try
            {
                // Throw exceptions on std::ios_base::badbit and std::ios_base::failbit
                stream.exceptions(std::ios_base::badbit | std::ios_base::failbit);

                std::uint64_t size64 = size_;
                stream.write(reinterpret_cast<const char *>(&size64), sizeof(std::uint64_t));
                if (size_)
                {
                    stream.write(
                        reinterpret_cast<const char *>(cbegin()),
                        util::safe_cast<std::streamsize>(util::mul_safe(size_, sizeof(T))));
                }
            }
            catch (const std::ios_base::failure &)
            {
                stream.exceptions(old_except_mask);
                throw std::runtime_error("I/O error");
            }
            catch (...)
            {
                stream.exceptions(old_except_mask);
                throw;
            }
            stream.exceptions(old_except_mask);
        }

        void load_members(std::istream &stream, SEALVersion version, std::size_t in_size_bound)
        {
            auto old_except_mask = stream.exceptions();
            try
            {
                // Throw exceptions on std::ios_base::badbit and std::ios_base::failbit
                stream.exceptions(std::ios_base::badbit | std::ios_base::failbit);

                std::uint64_t size64 = 0;
                stream.read(reinterpret_cast<char *>(&size64), sizeof(std::uint64_t));

                // Check (optionally) that the size in the metadata does not exceed
                // in_size_bound
                if (in_size_bound && util::unsigned_gt(size64, in_size_bound))
                {
                    throw std::logic_error("unexpected size");
                }

                // Set new size; this is potentially unsafe if size64 was not checked
                // against expected_size
                resize(util::safe_cast<std::size_t>(size64));

                // Read data
                if (size_)
                {
                    stream.read(
                        reinterpret_cast<char *>(begin()),
                        util::safe_cast<std::streamsize>(util::mul_safe(size_, sizeof(T))));
                }
            }
            catch (const std::ios_base::failure &)
            {
                stream.exceptions(old_except_mask);
                throw std::runtime_error("I/O error");
            }
            catch (...)
            {
                stream.exceptions(old_except_mask);
                throw;
            }
            stream.exceptions(old_except_mask);
        }

        MemoryPoolHandle pool_;

        std::size_t capacity_ = 0;

        std::size_t size_ = 0;

        util::Pointer<T> data_;
    };
} // namespace seal
# 7 "SEAL/native/src/seal/randomgen.h" 2
# 18 "SEAL/native/src/seal/randomgen.h"
namespace seal
{
    constexpr std::size_t prng_seed_uint64_count = 8;

    constexpr std::size_t prng_seed_byte_count = prng_seed_uint64_count * util::bytes_per_uint64;

    using prng_seed_type = std::array<std::uint64_t, prng_seed_uint64_count>;

    /**
    A type indicating a specific pseud-random number generator.
    */
    enum class prng_type : std::uint8_t
    {
        unknown = 0,

        blake2xb = 1,

        shake256 = 2
    };

    /**
    Fills a buffer with random bytes.
    */
    void random_bytes(seal_byte *buf, std::size_t count);

    /**
    Returns a random 64-bit unsigned integer.
    */
                   inline std::uint64_t random_uint64()
    {
        std::uint64_t result;
        random_bytes(reinterpret_cast<seal_byte *>(&result), sizeof(result));
        return result;
    }

    class UniformRandomGenerator;

    class UniformRandomGeneratorInfo
    {
        friend class UniformRandomGenerator;

    public:
        /**
        Creates a new UniformRandomGeneratorInfo.
        */
        UniformRandomGeneratorInfo() = default;

        /**
        Creates a new UniformRandomGeneratorInfo.

        @param[in] type The PRNG type
        @param[in] seed The PRNG seed
        */
        UniformRandomGeneratorInfo(prng_type type, prng_seed_type seed) : type_(type), seed_(std::move(seed))
        {}

        /**
        Creates a new UniformRandomGeneratorInfo by copying a given one.

        @param[in] copy The UniformRandomGeneratorInfo to copy from
        */
        UniformRandomGeneratorInfo(const UniformRandomGeneratorInfo &copy) = default;

        /**
        Copies a given UniformRandomGeneratorInfo to the current one.

        @param[in] assign The UniformRandomGeneratorInfo to copy from
        */
        UniformRandomGeneratorInfo &operator=(const UniformRandomGeneratorInfo &assign) = default;

        /**
        Compares two UniformRandomGeneratorInfo instances.

        @param[in] compare The UniformRandomGeneratorInfo to compare against
        */
                       inline bool operator==(const UniformRandomGeneratorInfo &compare) const noexcept
        {
            return (seed_ == compare.seed_) && (type_ == compare.type_);
        }

        /**
        Compares two UniformRandomGeneratorInfo instances.

        @param[in] compare The UniformRandomGeneratorInfo to compare against
        */
                       inline bool operator!=(const UniformRandomGeneratorInfo &compare) const noexcept
        {
            return !operator==(compare);
        }

        /**
        Clears all data in the UniformRandomGeneratorInfo.
        */
        void clear() noexcept
        {
            type_ = prng_type::unknown;
            util::seal_memzero(seed_.data(), prng_seed_byte_count);
        }

        /**
        Destroys the UniformRandomGeneratorInfo.
        */
        ~UniformRandomGeneratorInfo()
        {
            clear();
        }

        /**
        Creates a new UniformRandomGenerator object of type indicated by the PRNG
        type and seeded with the current seed. If the current PRNG type is not
        an official Microsoft SEAL PRNG type, the return value is nullptr.
        */
        std::shared_ptr<UniformRandomGenerator> make_prng() const;

        /**
        Returns whether this object holds a valid PRNG type.
        */
                       inline bool has_valid_prng_type() const noexcept
        {
            switch (type_)
            {
            case prng_type::blake2xb:
                /* fall through */

            case prng_type::shake256:
                /* fall through */

            case prng_type::unknown:
                return true;
            }
            return false;
        }

        /**
        Returns the PRNG type.
        */
                       inline prng_type type() const noexcept
        {
            return type_;
        }

        /**
        Returns a reference to the PRNG type.
        */
                       inline prng_type &type() noexcept
        {
            return type_;
        }

        /**
        Returns a reference to the PRNG seed.
        */
                       inline const prng_seed_type &seed() const noexcept
        {
            return seed_;
        }

        /**
        Returns a reference to the PRNG seed.
        */
                       inline prng_seed_type &seed() noexcept
        {
            return seed_;
        }

        /**
        Returns an upper bound on the size of the UniformRandomGeneratorInfo, as
        if it was written to an output stream.

        @param[in] compr_mode The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the size does not fit in the return type
        */
                       static inline std::streamoff SaveSize(
            compr_mode_type compr_mode = Serialization::compr_mode_default)
        {
            std::size_t members_size =
                Serialization::ComprSizeEstimate(sizeof(prng_type) + prng_seed_byte_count, compr_mode);
            return static_cast<std::streamoff>(sizeof(Serialization::SEALHeader) + members_size);
        }

        /**
        Returns an upper bound on the size of the UniformRandomGeneratorInfo, as
        if it was written to an output stream.

        @param[in] compr_mode The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the size does not fit in the return type
        */
                       inline std::streamoff save_size(
            compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            return UniformRandomGeneratorInfo::SaveSize(compr_mode);
        }

        /**
        Saves the UniformRandomGeneratorInfo to an output stream. The output is
        in binary format and is not human-readable. The output stream must have
        the "binary" flag set.

        @param[out] stream The stream to save the UniformRandomGeneratorInfo to
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            std::ostream &stream, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&UniformRandomGeneratorInfo::save_members, this, _1), save_size(compr_mode_type::none),
                stream, compr_mode, true);
        }

        /**
        Loads a UniformRandomGeneratorInfo from an input stream overwriting the
        current UniformRandomGeneratorInfo.

        @param[in] stream The stream to load the UniformRandomGeneratorInfo from
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(std::istream &stream)
        {
            using namespace std::placeholders;
            UniformRandomGeneratorInfo new_info;
            auto in_size = Serialization::Load(
                std::bind(&UniformRandomGeneratorInfo::load_members, &new_info, _1, _2), stream, true);
            std::swap(*this, new_info);
            return in_size;
        }

        /**
        Saves the UniformRandomGeneratorInfo to a given memory location. The output
        is in binary format and is not human-readable.

        @param[out] out The memory location to write the UniformRandomGeneratorInfo to
        @param[in] size The number of bytes available in the given memory location
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if out is null or if size is too small to
        contain a SEALHeader, or if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            seal_byte *out, std::size_t size, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&UniformRandomGeneratorInfo::save_members, this, _1), save_size(compr_mode_type::none), out,
                size, compr_mode, true);
        }

        /**
        Loads a UniformRandomGeneratorInfo from a given memory location overwriting
        the current UniformRandomGeneratorInfo.

        @param[in] in The memory location to load the UniformRandomGeneratorInfo from
        @param[in] size The number of bytes available in the given memory location
        @throws std::invalid_argument if in is null or if size is too small to
        contain a SEALHeader
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(const seal_byte *in, std::size_t size)
        {
            using namespace std::placeholders;
            UniformRandomGeneratorInfo new_info;
            auto in_size = Serialization::Load(
                std::bind(&UniformRandomGeneratorInfo::load_members, &new_info, _1, _2), in, size, true);
            std::swap(*this, new_info);
            return in_size;
        }

    public:
        void save_members(std::ostream &stream) const;

        void load_members(std::istream &stream, SEALVersion version);

        prng_type type_ = prng_type::unknown;

        prng_seed_type seed_ = {};
    };

    /**
    Provides the base class for a seeded uniform random number generator. Instances
    of this class are meant to be created by an instance of the factory class
    UniformRandomGeneratorFactory. This class is meant for users to sub-class to
    implement their own random number generators.
    */
    class UniformRandomGenerator
    {
    public:
        /**
        Creates a new UniformRandomGenerator instance initialized with the given seed.

        @param[in] seed The seed for the random number generator
        */
        UniformRandomGenerator(prng_seed_type seed)
            : seed_([&seed]() {
                  // Create a new seed allocation
                  DynArray<std::uint64_t> new_seed(
                      seed.size(), MemoryManager::GetPool(mm_prof_opt::mm_force_new, true));

                  // Assign the given seed and return
                  std::copy(seed.cbegin(), seed.cend(), new_seed.begin());
                  return new_seed;
              }()),
              buffer_(buffer_size_, MemoryManager::GetPool(mm_prof_opt::mm_force_new, true)),
              buffer_begin_(buffer_.begin()), buffer_end_(buffer_.end()), buffer_head_(buffer_.end())
        {}

                       inline prng_seed_type seed() const noexcept
        {
            prng_seed_type ret{};
            std::copy(seed_.cbegin(), seed_.cend(), ret.begin());
            return ret;
        }

        /**
        Fills a given buffer with a given number of bytes of randomness.
        */
        void generate(std::size_t byte_count, seal_byte *destination);

        /**
        Generates a new unsigned 32-bit random number.
        */
                       inline std::uint32_t generate()
        {
            std::uint32_t result;
            generate(sizeof(result), reinterpret_cast<seal_byte *>(&result));
            return result;
        }

        /**
        Discards the contents of the current randomness buffer and refills it
        with fresh randomness.
        */
        inline void refresh()
        {
            std::lock_guard<std::mutex> lock(mutex_);
            refill_buffer();
            buffer_head_ = buffer_begin_;
        }

        /**
        Returns a UniformRandomGeneratorInfo object representing this PRNG.
        */
                       inline UniformRandomGeneratorInfo info() const noexcept
        {
            UniformRandomGeneratorInfo result;
            std::copy_n(seed_.cbegin(), prng_seed_uint64_count, result.seed_.begin());
            result.type_ = type();
            return result;
        }

        /**
        Destroys the random number generator.
        */
        virtual ~UniformRandomGenerator() = default;

    protected:
                       virtual prng_type type() const noexcept = 0;

        virtual void refill_buffer() = 0;

        const DynArray<std::uint64_t> seed_;

        const std::size_t buffer_size_ = 4096;

    private:
        DynArray<seal_byte> buffer_;

        std::mutex mutex_;

    protected:
        seal_byte *const buffer_begin_;

        seal_byte *const buffer_end_;

        seal_byte *buffer_head_;
    };

    /**
    Provides the base class for a factory instance that creates instances of
    UniformRandomGenerator. This class is meant for users to sub-class to implement
    their own random number generators.
    */
    class UniformRandomGeneratorFactory
    {
    public:
        /**
        Creates a new UniformRandomGeneratorFactory. The seed will be sampled
        randomly for each UniformRandomGenerator instance created by the factory
        instance, which is desirable in most normal use-cases.
        */
        UniformRandomGeneratorFactory() : use_random_seed_(true)
        {}

        /**
        Creates a new UniformRandomGeneratorFactory and sets the default seed to
        the given value. For debugging purposes it may sometimes be convenient to
        have the same randomness be used deterministically and repeatedly. Such
        randomness sampling is naturally insecure and must be strictly restricted
        to debugging situations. Thus, most users should never have a reason to
        use this constructor.

        @param[in] default_seed The default value for a seed to be used by all
        created instances of UniformRandomGenerator
        */
        UniformRandomGeneratorFactory(prng_seed_type default_seed)
            : default_seed_(default_seed), use_random_seed_(false)
        {}

        /**
        Creates a new uniform random number generator.
        */
                       auto create() -> std::shared_ptr<UniformRandomGenerator>
        {
            return use_random_seed_ ? create_impl([]() {
                prng_seed_type seed;
                random_bytes(reinterpret_cast<seal_byte *>(seed.data()), prng_seed_byte_count);
                return seed;
            }())
                                    : create_impl(default_seed_);
        }

        /**
        Creates a new uniform random number generator seeded with the given seed,
        overriding the default seed for this factory instance.

        @param[in] seed The seed to be used for the created random number generator
        */
                       auto create(prng_seed_type seed) -> std::shared_ptr<UniformRandomGenerator>
        {
            return create_impl(seed);
        }

        /**
        Destroys the random number generator factory.
        */
        virtual ~UniformRandomGeneratorFactory() = default;

        /**
        Returns the default random number generator factory. This instance should
        not be destroyed.
        */
        static auto DefaultFactory() -> std::shared_ptr<UniformRandomGeneratorFactory>;

        /**
        Returns whether the random number generator factory creates random number
        generators seeded with a random seed, or if a default seed is used.
        */
                       inline bool use_random_seed() noexcept
        {
            return use_random_seed_;
        }

        /**
        Returns the default seed used to seed every random number generator created
        by this random number generator factory. If use_random_seed() is false, then
        the returned seed has no meaning.
        */
                       inline prng_seed_type default_seed() noexcept
        {
            return default_seed_;
        }

    protected:
                       virtual auto create_impl(prng_seed_type seed) -> std::shared_ptr<UniformRandomGenerator> = 0;

    private:
        prng_seed_type default_seed_ = {};

        bool use_random_seed_ = false;
    };

    /**
    Provides an implementation of UniformRandomGenerator for using Blake2xb for
    generating randomness with given 128-bit seed.
    */
    class Blake2xbPRNG : public UniformRandomGenerator
    {
    public:
        /**
        Creates a new Blake2xbPRNG instance initialized with the given seed.

        @param[in] seed The seed for the random number generator
        */
        Blake2xbPRNG(prng_seed_type seed) : UniformRandomGenerator(seed)
        {}

        /**
        Destroys the random number generator.
        */
        ~Blake2xbPRNG() = default;

    protected:
                       prng_type type() const noexcept override
        {
            return prng_type::blake2xb;
        }

        void refill_buffer() override;

    private:
        std::uint64_t counter_ = 0;
    };

    class Blake2xbPRNGFactory : public UniformRandomGeneratorFactory
    {
    public:
        /**
        Creates a new Blake2xbPRNGFactory. The seed will be sampled randomly
        for each Blake2xbPRNG instance created by the factory instance, which is
        desirable in most normal use-cases.
        */
        Blake2xbPRNGFactory() : UniformRandomGeneratorFactory()
        {}

        /**
        Creates a new Blake2xbPRNGFactory and sets the default seed to the given
        value. For debugging purposes it may sometimes be convenient to have the
        same randomness be used deterministically and repeatedly. Such randomness
        sampling is naturally insecure and must be strictly restricted to debugging
        situations. Thus, most users should never use this constructor.

        @param[in] default_seed The default value for a seed to be used by all
        created instances of Blake2xbPRNG
        */
        Blake2xbPRNGFactory(prng_seed_type default_seed) : UniformRandomGeneratorFactory(default_seed)
        {}

        /**
        Destroys the random number generator factory.
        */
        ~Blake2xbPRNGFactory() = default;

    protected:
                       auto create_impl(prng_seed_type seed) -> std::shared_ptr<UniformRandomGenerator> override
        {
            return std::make_shared<Blake2xbPRNG>(seed);
        }

    private:
    };

    /**
    Provides an implementation of UniformRandomGenerator for using SHAKE-256 for
    generating randomness with given 128-bit seed.
    */
    class Shake256PRNG : public UniformRandomGenerator
    {
    public:
        /**
        Creates a new Shake256PRNG instance initialized with the given seed.

        @param[in] seed The seed for the random number generator
        */
        Shake256PRNG(prng_seed_type seed) : UniformRandomGenerator(seed)
        {}

        /**
        Destroys the random number generator.
        */
        ~Shake256PRNG() = default;

    protected:
                       prng_type type() const noexcept override
        {
            return prng_type::shake256;
        }

        void refill_buffer() override;

    private:
        std::uint64_t counter_ = 0;
    };

    class Shake256PRNGFactory : public UniformRandomGeneratorFactory
    {
    public:
        /**
        Creates a new Shake256PRNGFactory. The seed will be sampled randomly for
        each Shake256PRNG instance created by the factory instance, which is
        desirable in most normal use-cases.
        */
        Shake256PRNGFactory() : UniformRandomGeneratorFactory()
        {}

        /**
        Creates a new Shake256PRNGFactory and sets the default seed to the given
        value. For debugging purposes it may sometimes be convenient to have the
        same randomness be used deterministically and repeatedly. Such randomness
        sampling is naturally insecure and must be strictly restricted to debugging
        situations. Thus, most users should never use this constructor.

        @param[in] default_seed The default value for a seed to be used by all
        created instances of Shake256PRNG
        */
        Shake256PRNGFactory(prng_seed_type default_seed) : UniformRandomGeneratorFactory(default_seed)
        {}

        /**
        Destroys the random number generator factory.
        */
        ~Shake256PRNGFactory() = default;

    protected:
                       auto create_impl(prng_seed_type seed) -> std::shared_ptr<UniformRandomGenerator> override
        {
            return std::make_shared<Shake256PRNG>(seed);
        }

    private:
    };
} // namespace seal
# 9 "SEAL/native/src/seal/encryptionparams.h" 2




# 1 "SEAL/native/src/seal/util/hash.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.




# 1 "SEAL/native/src/seal/util/blake2.h" 1
/*
   BLAKE2 reference source code package - reference C implementations

   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
   your option.  The terms of these licenses can be found at:

   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
   - OpenSSL license   : https://www.openssl.org/source/license.html
   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0

   More information about the BLAKE2 hash function can be found at
   https://blake2.net.
*/

/*
Minor modifications to the original file have been made and marked
as `Microsoft SEAL edit: ...`. The sole purpose of these edits is to silence
misleading warnings in Visual Studio.
*/





# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/stddef.h" 1
// -*- C++ -*-
//===--------------------------- stddef.h ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 26 "SEAL/native/src/seal/util/blake2.h" 2
# 35 "SEAL/native/src/seal/util/blake2.h"
extern "C"
{


    enum blake2s_constant
    {
        BLAKE2S_BLOCKBYTES = 64,
        BLAKE2S_OUTBYTES = 32,
        BLAKE2S_KEYBYTES = 32,
        BLAKE2S_SALTBYTES = 8,
        BLAKE2S_PERSONALBYTES = 8
    };

    enum blake2b_constant
    {
        BLAKE2B_BLOCKBYTES = 128,
        BLAKE2B_OUTBYTES = 64,
        BLAKE2B_KEYBYTES = 64,
        BLAKE2B_SALTBYTES = 16,
        BLAKE2B_PERSONALBYTES = 16
    };

    typedef struct blake2s_state__
    {
        uint32_t h[8];
        uint32_t t[2];
        uint32_t f[2];
        uint8_t buf[BLAKE2S_BLOCKBYTES];
        size_t buflen;
        size_t outlen;
        uint8_t last_node;
    } blake2s_state;

    typedef struct blake2b_state__
    {
        uint64_t h[8];
        uint64_t t[2];
        uint64_t f[2];
        uint8_t buf[BLAKE2B_BLOCKBYTES];
        size_t buflen;
        size_t outlen;
        uint8_t last_node;
    } blake2b_state;

    typedef struct blake2sp_state__
    {
        blake2s_state S[8][1];
        blake2s_state R[1];
        uint8_t buf[8 * BLAKE2S_BLOCKBYTES];
        size_t buflen;
        size_t outlen;
    } blake2sp_state;

    typedef struct blake2bp_state__
    {
        blake2b_state S[4][1];
        blake2b_state R[1];
        uint8_t buf[4 * BLAKE2B_BLOCKBYTES];
        size_t buflen;
        size_t outlen;
    } blake2bp_state;

    struct blake2s_param__ { uint8_t digest_length; uint8_t key_length; uint8_t fanout; uint8_t depth; uint32_t leaf_length; uint32_t node_offset; uint16_t xof_length; uint8_t node_depth; uint8_t inner_length; uint8_t salt[BLAKE2S_SALTBYTES]; uint8_t personal[BLAKE2S_PERSONALBYTES]; } __attribute__((packed));
# 112 "SEAL/native/src/seal/util/blake2.h"
    typedef struct blake2s_param__ blake2s_param;

    struct blake2b_param__ { uint8_t digest_length; uint8_t key_length; uint8_t fanout; uint8_t depth; uint32_t leaf_length; uint32_t node_offset; uint32_t xof_length; uint8_t node_depth; uint8_t inner_length; uint8_t reserved[14]; uint8_t salt[BLAKE2B_SALTBYTES]; uint8_t personal[BLAKE2B_PERSONALBYTES]; } __attribute__((packed));
# 129 "SEAL/native/src/seal/util/blake2.h"
    typedef struct blake2b_param__ blake2b_param;

    typedef struct blake2xs_state__
    {
        blake2s_state S[1];
        blake2s_param P[1];
    } blake2xs_state;

    typedef struct blake2xb_state__
    {
        blake2b_state S[1];
        blake2b_param P[1];
    } blake2xb_state;

    /* Padded structs result in a compile-time error */
    enum
    {
        /* Microsoft SEAL edit: explicit cast to silence warnings. */
        BLAKE2_DUMMY_1 = 1 / (int)(sizeof(blake2s_param) == BLAKE2S_OUTBYTES),
        BLAKE2_DUMMY_2 = 1 / (int)(sizeof(blake2b_param) == BLAKE2B_OUTBYTES)
    };

    /* Streaming API */
    int blake2s_init(blake2s_state *S, size_t outlen);
    int blake2s_init_key(blake2s_state *S, size_t outlen, const void *key, size_t keylen);
    int blake2s_init_param(blake2s_state *S, const blake2s_param *P);
    int blake2s_update(blake2s_state *S, const void *in, size_t inlen);
    int blake2s_final(blake2s_state *S, void *out, size_t outlen);

    int blake2b_init(blake2b_state *S, size_t outlen);
    int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key, size_t keylen);
    int blake2b_init_param(blake2b_state *S, const blake2b_param *P);
    int blake2b_update(blake2b_state *S, const void *in, size_t inlen);
    int blake2b_final(blake2b_state *S, void *out, size_t outlen);

    int blake2sp_init(blake2sp_state *S, size_t outlen);
    int blake2sp_init_key(blake2sp_state *S, size_t outlen, const void *key, size_t keylen);
    int blake2sp_update(blake2sp_state *S, const void *in, size_t inlen);
    int blake2sp_final(blake2sp_state *S, void *out, size_t outlen);

    int blake2bp_init(blake2bp_state *S, size_t outlen);
    int blake2bp_init_key(blake2bp_state *S, size_t outlen, const void *key, size_t keylen);
    int blake2bp_update(blake2bp_state *S, const void *in, size_t inlen);
    int blake2bp_final(blake2bp_state *S, void *out, size_t outlen);

    /* Variable output length API */
    int blake2xs_init(blake2xs_state *S, const size_t outlen);
    int blake2xs_init_key(blake2xs_state *S, const size_t outlen, const void *key, size_t keylen);
    int blake2xs_update(blake2xs_state *S, const void *in, size_t inlen);
    int blake2xs_final(blake2xs_state *S, void *out, size_t outlen);

    int blake2xb_init(blake2xb_state *S, const size_t outlen);
    int blake2xb_init_key(blake2xb_state *S, const size_t outlen, const void *key, size_t keylen);
    int blake2xb_update(blake2xb_state *S, const void *in, size_t inlen);
    int blake2xb_final(blake2xb_state *S, void *out, size_t outlen);

    /* Simple API */
    int blake2s(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
    int blake2b(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);

    int blake2sp(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
    int blake2bp(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);

    int blake2xs(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
    int blake2xb(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);

    /* This is simply an alias for blake2b */
    int blake2(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);


}
# 7 "SEAL/native/src/seal/util/hash.h" 2






namespace seal
{
    namespace util
    {
        class HashFunction
        {
        public:
            HashFunction() = delete;

            static constexpr std::size_t hash_block_uint64_count = 4;

            static constexpr std::size_t hash_block_byte_count = hash_block_uint64_count * bytes_per_uint64;

            using hash_block_type = std::array<std::uint64_t, hash_block_uint64_count>;

            static constexpr hash_block_type hash_zero_block{ { 0, 0, 0, 0 } };

            inline static void hash(const std::uint64_t *input, std::size_t uint64_count, hash_block_type &destination)
            {
                if (blake2b(&destination, hash_block_byte_count, input, uint64_count * bytes_per_uint64, nullptr, 0) !=
                    0)
                {
                    throw std::runtime_error("blake2b failed");
                }
            }
        };
    } // namespace util
} // namespace seal
# 14 "SEAL/native/src/seal/encryptionparams.h" 2




# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/numeric" 1
// -*- C++ -*-
//===---------------------------- numeric ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//




/*
    numeric synopsis

namespace std
{

template <class InputIterator, class T>
    constexpr T  // constexpr since C++20
    accumulate(InputIterator first, InputIterator last, T init);

template <class InputIterator, class T, class BinaryOperation>
    constexpr T  // constexpr since C++20
    accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);

template<class InputIterator>
    constexpr typename iterator_traits<InputIterator>::value_type  // constexpr since C++20
    reduce(InputIterator first, InputIterator last);  // C++17

template<class InputIterator, class T>
    constexpr T  // constexpr since C++20
    reduce(InputIterator first, InputIterator last, T init);  // C++17

template<class InputIterator, class T, class BinaryOperation>
    constexpr T  // constexpr since C++20
    reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);  // C++17

template <class InputIterator1, class InputIterator2, class T>
    constexpr T  // constexpr since C++20
    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);

template <class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>
    constexpr T  // constexpr since C++20
    inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
                  T init, BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);


template<class InputIterator1, class InputIterator2, class T>
    constexpr T  // constexpr since C++20
    transform_reduce(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, T init);  // C++17

template<class InputIterator1, class InputIterator2, class T, class BinaryOperation1, class BinaryOperation2>
    constexpr T  // constexpr since C++20
    transform_reduce(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, T init,
                     BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);  // C++17

template<class InputIterator, class T, class BinaryOperation, class UnaryOperation>
    constexpr T  // constexpr since C++20
    transform_reduce(InputIterator first, InputIterator last, T init,
                     BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template <class InputIterator, class OutputIterator>
    constexpr OutputIterator  // constexpr since C++20
    partial_sum(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    partial_sum(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);

template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator  // constexpr since C++20
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init); // C++17

template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    exclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, T init, BinaryOperation binary_op); // C++17

template<class InputIterator, class OutputIterator>
    constexpr OutputIterator  // constexpr since C++20
    inclusive_scan(InputIterator first, InputIterator last, OutputIterator result);  // C++17

template<class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op);  // C++17

template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
    constexpr OutputIterator  // constexpr since C++20
    inclusive_scan(InputIterator first, InputIterator last,
                   OutputIterator result, BinaryOperation binary_op, T init);  // C++17

template<class InputIterator, class OutputIterator, class T,
         class BinaryOperation, class UnaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    transform_exclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result, T init,
                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op);  // C++17

template<class InputIterator, class OutputIterator,
         class BinaryOperation, class UnaryOperation, class T>
    constexpr OutputIterator  // constexpr since C++20
    transform_inclusive_scan(InputIterator first, InputIterator last,
                             OutputIterator result,
                             BinaryOperation binary_op, UnaryOperation unary_op,
                             T init);  // C++17

template <class InputIterator, class OutputIterator>
    constexpr OutputIterator  // constexpr since C++20
    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);

template <class InputIterator, class OutputIterator, class BinaryOperation>
    constexpr OutputIterator  // constexpr since C++20
    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result, BinaryOperation binary_op);

template <class ForwardIterator, class T>
    constexpr void  // constexpr since C++20
    iota(ForwardIterator first, ForwardIterator last, T value);

template <class M, class N>
    constexpr common_type_t<M,N> gcd(M m, N n);    // C++17

template <class M, class N>
    constexpr common_type_t<M,N> lcm(M m, N n);    // C++17

template<class T>
    constexpr T midpoint(T a, T b) noexcept;  // C++20

template<class T>
    constexpr T* midpoint(T* a, T* b);        // C++20

}  // std

*/


# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__config" 1
// XXX EMSCRIPTEN: macros that would ordinarily be added from __config_site.in


// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 148 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/numeric" 2
# 156 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/numeric" 3



# 1 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/__undef_macros" 1 3
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
# 160 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/numeric" 2 3

namespace std { inline namespace __1 {

template <class _InputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
{
    for (; __first != __last; ++__first)



        __init = __init + *__first;

    return __init;
}

template <class _InputIterator, class _Tp, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)
{
    for (; __first != __last; ++__first)



        __init = __binary_op(__init, *__first);

    return __init;
}


template <class _InputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
reduce(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOp __b)
{
    for (; __first != __last; ++__first)
        __init = __b(__init, *__first);
    return __init;
}

template <class _InputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
reduce(_InputIterator __first, _InputIterator __last, _Tp __init)
{
    return std::__1::reduce(__first, __last, __init, std::__1::plus<>());
}

template <class _InputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
typename iterator_traits<_InputIterator>::value_type
reduce(_InputIterator __first, _InputIterator __last)
{
    return std::__1::reduce(__first, __last,
       typename iterator_traits<_InputIterator>::value_type{});
}


template <class _InputIterator1, class _InputIterator2, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)



        __init = __init + *__first1 * *__first2;

    return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp, class _BinaryOperation1, class _BinaryOperation2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
              _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)



        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));

    return __init;
}


template <class _InputIterator, class _Tp, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
transform_reduce(_InputIterator __first, _InputIterator __last,
           _Tp __init, _BinaryOp __b, _UnaryOp __u)
{
    for (; __first != __last; ++__first)
        __init = __b(__init, __u(*__first));
    return __init;
}

template <class _InputIterator1, class _InputIterator2,
          class _Tp, class _BinaryOp1, class _BinaryOp2>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _Tp __init, _BinaryOp1 __b1, _BinaryOp2 __b2)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        __init = __b1(__init, __b2(*__first1, *__first2));
    return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_Tp
transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _Tp __init)
{
    return std::__1::transform_reduce(__first1, __last1, __first2, std::__1::move(__init),
                                   std::__1::plus<>(), std::__1::multiplies<>());
}


template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {



            __t = __t + *__first;

            *__result = __t;
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
              _BinaryOperation __binary_op)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {



            __t = __binary_op(__t, *__first);

            *__result = __t;
        }
    }
    return __result;
}


template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
exclusive_scan(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Tp __init, _BinaryOp __b)
{
    if (__first != __last)
    {
        _Tp __tmp(__b(__init, *__first));
        while (true)
        {
            *__result = std::__1::move(__init);
            ++__result;
            ++__first;
            if (__first == __last)
                break;
            __init = std::__1::move(__tmp);
            __tmp = __b(__init, *__first);
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
exclusive_scan(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Tp __init)
{
    return std::__1::exclusive_scan(__first, __last, __result, __init, std::__1::plus<>());
}

template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b, _Tp __init)
{
    for (; __first != __last; ++__first, (void) ++__result) {
        __init = __b(__init, *__first);
        *__result = __init;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b)
{
    if (__first != __last) {
        typename iterator_traits<_InputIterator>::value_type __init = *__first;
        *__result++ = __init;
        if (++__first != __last)
            return std::__1::inclusive_scan(__first, __last, __result, __b, __init);
    }

    return __result;
}

template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result)
{
    return std::__1::inclusive_scan(__first, __last, __result, std::__1::plus<>());
}

template <class _InputIterator, class _OutputIterator, class _Tp,
          class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
transform_exclusive_scan(_InputIterator __first, _InputIterator __last,
                           _OutputIterator __result, _Tp __init,
                           _BinaryOp __b, _UnaryOp __u)
{
    if (__first != __last)
    {
        _Tp __saved = __init;
        do
        {
            __init = __b(__init, __u(*__first));
            *__result = __saved;
            __saved = __init;
            ++__result;
        } while (++__first != __last);
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
                           _OutputIterator __result, _BinaryOp __b, _UnaryOp __u, _Tp __init)
{
    for (; __first != __last; ++__first, (void) ++__result) {
        __init = __b(__init, __u(*__first));
        *__result = __init;
        }

    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOp, class _UnaryOp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
                               _OutputIterator __result, _BinaryOp __b, _UnaryOp __u)
{
    if (__first != __last) {
        typename iterator_traits<_InputIterator>::value_type __init = __u(*__first);
        *__result++ = __init;
        if (++__first != __last)
            return std::__1::transform_inclusive_scan(__first, __last, __result, __b, __u, __init);
    }

    return __result;
}


template <class _InputIterator, class _OutputIterator>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __acc(*__first);
        *__result = __acc;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {
            typename iterator_traits<_InputIterator>::value_type __val(*__first);



            *__result = __val - __acc;

            __acc = std::__1::move(__val);
        }
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
_OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                      _BinaryOperation __binary_op)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __acc(*__first);
        *__result = __acc;
        for (++__first, (void) ++__result; __first != __last; ++__first, (void) ++__result)
        {
            typename iterator_traits<_InputIterator>::value_type __val(*__first);



            *__result = __binary_op(__val, __acc);

            __acc = std::__1::move(__val);
        }
    }
    return __result;
}

template <class _ForwardIterator, class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
void
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_)
{
    for (; __first != __last; ++__first, (void) ++__value_)
        *__first = __value_;
}



template <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value> struct __ct_abs;

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, true> {
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Result operator()(_Source __t) const noexcept
    {
        if (__t >= 0) return __t;
        if (__t == numeric_limits<_Source>::min()) return -static_cast<_Result>(__t);
        return -__t;
    }
};

template <typename _Result, typename _Source>
struct __ct_abs<_Result, _Source, false> {
    constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
    _Result operator()(_Source __t) const noexcept { return __t; }
};


template<class _Tp>
constexpr __attribute__ ((__visibility__("hidden")))
_Tp __gcd(_Tp __m, _Tp __n)
{
    static_assert((!is_signed<_Tp>::value), "");
    return __n == 0 ? __m : std::__1::__gcd<_Tp>(__n, __m % __n);
}


template<class _Tp, class _Up>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
common_type_t<_Tp,_Up>
gcd(_Tp __m, _Up __n)
{
    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to gcd must be integer types");
    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to gcd cannot be bool" );
    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to gcd cannot be bool" );
    using _Rp = common_type_t<_Tp,_Up>;
    using _Wp = make_unsigned_t<_Rp>;
    return static_cast<_Rp>(std::__1::__gcd(
        static_cast<_Wp>(__ct_abs<_Rp, _Tp>()(__m)),
        static_cast<_Wp>(__ct_abs<_Rp, _Up>()(__n))));
}

template<class _Tp, class _Up>
constexpr __attribute__ ((__visibility__("hidden"))) __attribute__ ((__exclude_from_explicit_instantiation__))
common_type_t<_Tp,_Up>
lcm(_Tp __m, _Up __n)
{
    static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to lcm must be integer types");
    static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to lcm cannot be bool" );
    static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to lcm cannot be bool" );
    if (__m == 0 || __n == 0)
        return 0;

    using _Rp = common_type_t<_Tp,_Up>;
    _Rp __val1 = __ct_abs<_Rp, _Tp>()(__m) / std::__1::gcd(__m, __n);
    _Rp __val2 = __ct_abs<_Rp, _Up>()(__n);
    ((void)0);
    return __val1 * __val2;
}
# 627 "/Users/rickweber/Projects/Sunscreen/emsdk/emsdk/upstream/emscripten/cache/sysroot/include/c++/v1/numeric" 3
} }
# 19 "SEAL/native/src/seal/encryptionparams.h" 2

namespace seal
{
    /**
    Describes the type of encryption scheme to be used.
    */
    enum class scheme_type : std::uint8_t
    {
        // No scheme set; cannot be used for encryption
        none = 0x0,

        // Brakerski/Fan-Vercauteren scheme
        bfv = 0x1,

        // Cheon-Kim-Kim-Song scheme
        ckks = 0x2
    };

    /**
    The data type to store unique identifiers of encryption parameters.
    */
    using parms_id_type = util::HashFunction::hash_block_type;

    /**
    A parms_id_type value consisting of zeros.
    */
    extern const parms_id_type parms_id_zero;

    /**
    Represents user-customizable encryption scheme settings. The parameters (most
    importantly poly_modulus, coeff_modulus, plain_modulus) significantly affect
    the performance, capabilities, and security of the encryption scheme. Once
    an instance of EncryptionParameters is populated with appropriate parameters,
    it can be used to create an instance of the SEALContext class, which verifies
    the validity of the parameters, and performs necessary pre-computations.

    Picking appropriate encryption parameters is essential to enable a particular
    application while balancing performance and security. Some encryption settings
    will not allow some inputs (e.g. attempting to encrypt a polynomial with more
    coefficients than poly_modulus or larger coefficients than plain_modulus) or,
    support the desired computations (with noise growing too fast due to too large
    plain_modulus and too small coeff_modulus).

    @par parms_id
    The EncryptionParameters class maintains at all times a 256-bit hash of the
    currently set encryption parameters called the parms_id. This hash acts as
    a unique identifier of the encryption parameters and is used by all further
    objects created for these encryption parameters. The parms_id is not intended
    to be directly modified by the user but is used internally for pre-computation
    data lookup and input validity checks. In modulus switching the user can use
    the parms_id to keep track of the chain of encryption parameters. The parms_id
    is not exposed in the public API of EncryptionParameters, but can be accessed
    through the SEALContext::ContextData class once the SEALContext has been created.

    @par Thread Safety
    In general, reading from EncryptionParameters is thread-safe, while mutating
    is not.

    @warning Choosing inappropriate encryption parameters may lead to an encryption
    scheme that is not secure, does not perform well, and/or does not support the
    input and computation of the desired application. We highly recommend consulting
    an expert in RLWE-based encryption when selecting parameters, as this is where
    inexperienced users seem to most often make critical mistakes.
    */
    class EncryptionParameters
    {
        friend class SEALContext;

        friend struct std::hash<EncryptionParameters>;

    public:
        /**
        Creates an empty set of encryption parameters.

        @param[in] scheme The encryption scheme to be used
        @see scheme_type for the supported schemes
        */
        EncryptionParameters(scheme_type scheme = scheme_type::none) : scheme_(scheme)
        {
            compute_parms_id();
        }

        /**
        Creates an empty set of encryption parameters.

        @param[in] scheme The encryption scheme to be used
        @throws std::invalid_argument if scheme is not supported
        */
        EncryptionParameters(std::uint8_t scheme)
        {
            // Check that a valid scheme is given
            if (!is_valid_scheme(scheme))
            {
                throw std::invalid_argument("unsupported scheme");
            }

            scheme_ = static_cast<scheme_type>(scheme);
            compute_parms_id();
        }

        /**
        Creates a copy of a given instance of EncryptionParameters.

        @param[in] copy The EncryptionParameters to copy from
        */
        EncryptionParameters(const EncryptionParameters &copy) = default;

        /**
        Overwrites the EncryptionParameters instance with a copy of a given instance.

        @param[in] assign The EncryptionParameters to copy from
        */
        EncryptionParameters &operator=(const EncryptionParameters &assign) = default;

        /**
        Creates a new EncryptionParameters instance by moving a given instance.

        @param[in] source The EncryptionParameters to move from
        */
        EncryptionParameters(EncryptionParameters &&source) = default;

        /**
        Overwrites the EncryptionParameters instance by moving a given instance.

        @param[in] assign The EncryptionParameters to move from
        */
        EncryptionParameters &operator=(EncryptionParameters &&assign) = default;

        /**
        Sets the degree of the polynomial modulus parameter to the specified value.
        The polynomial modulus directly affects the number of coefficients in
        plaintext polynomials, the size of ciphertext elements, the computational
        performance of the scheme (bigger is worse), and the security level (bigger
        is better). In Microsoft SEAL the degree of the polynomial modulus must be
        a power of 2 (e.g.  1024, 2048, 4096, 8192, 16384, or 32768).

        @param[in] poly_modulus_degree The new polynomial modulus degree
        @throws std::logic_error if a valid scheme is not set and poly_modulus_degree
        is non-zero
        */
        inline void set_poly_modulus_degree(std::size_t poly_modulus_degree)
        {
            if (scheme_ == scheme_type::none && poly_modulus_degree)
            {
                throw std::logic_error("poly_modulus_degree is not supported for this scheme");
            }

            // Set the degree
            poly_modulus_degree_ = poly_modulus_degree;

            // Re-compute the parms_id
            compute_parms_id();
        }

        /**
        Sets the coefficient modulus parameter. The coefficient modulus consists
        of a list of distinct prime numbers, and is represented by a vector of
        Modulus objects. The coefficient modulus directly affects the size
        of ciphertext elements, the amount of computation that the scheme can
        perform (bigger is better), and the security level (bigger is worse). In
        Microsoft SEAL each of the prime numbers in the coefficient modulus must
        be at most 60 bits, and must be congruent to 1 modulo 2*poly_modulus_degree.

        @param[in] coeff_modulus The new coefficient modulus
        @throws std::logic_error if a valid scheme is not set and coeff_modulus is
        is non-empty
        @throws std::invalid_argument if size of coeff_modulus is invalid
        */
        inline void set_coeff_modulus(const std::vector<Modulus> &coeff_modulus)
        {
            // Check that a scheme is set
            if (scheme_ == scheme_type::none)
            {
                if (!coeff_modulus.empty())
                {
                    throw std::logic_error("coeff_modulus is not supported for this scheme");
                }
            }
            else if (coeff_modulus.size() > 64 || coeff_modulus.size() < 1)
            {
                throw std::invalid_argument("coeff_modulus is invalid");
            }

            coeff_modulus_ = coeff_modulus;

            // Re-compute the parms_id
            compute_parms_id();
        }

        /**
        Sets the plaintext modulus parameter. The plaintext modulus is an integer
        modulus represented by the Modulus class. The plaintext modulus
        determines the largest coefficient that plaintext polynomials can represent.
        It also affects the amount of computation that the scheme can perform
        (bigger is worse). In Microsoft SEAL the plaintext modulus can be at most
        60 bits long, but can otherwise be any integer. Note, however, that some
        features (e.g. batching) require the plaintext modulus to be of a particular
        form.

        @param[in] plain_modulus The new plaintext modulus
        @throws std::logic_error if scheme is not scheme_type::BFV and plain_modulus
        is non-zero
        */
        inline void set_plain_modulus(const Modulus &plain_modulus)
        {
            // Check that scheme is BFV
            if (scheme_ != scheme_type::bfv && !plain_modulus.is_zero())
            {
                throw std::logic_error("plain_modulus is not supported for this scheme");
            }

            plain_modulus_ = plain_modulus;

            // Re-compute the parms_id
            compute_parms_id();
        }

        /**
        Sets the plaintext modulus parameter. The plaintext modulus is an integer
        modulus represented by the Modulus class. This constructor instead
        takes a std::uint64_t and automatically creates the Modulus object.
        The plaintext modulus determines the largest coefficient that plaintext
        polynomials can represent. It also affects the amount of computation that
        the scheme can perform (bigger is worse). In Microsoft SEAL the plaintext
        modulus can be at most 60 bits long, but can otherwise be any integer. Note,
        however, that some features (e.g. batching) require the plaintext modulus
        to be of a particular form.

        @param[in] plain_modulus The new plaintext modulus
        @throws std::invalid_argument if plain_modulus is invalid
        */
        inline void set_plain_modulus(std::uint64_t plain_modulus)
        {
            set_plain_modulus(Modulus(plain_modulus));
        }

        /**
        Sets the random number generator factory to use for encryption. By default,
        the random generator is set to UniformRandomGeneratorFactory::default_factory().
        Setting this value allows a user to specify a custom random number generator
        source.

        @param[in] random_generator Pointer to the random generator factory
        */
        inline void set_random_generator(std::shared_ptr<UniformRandomGeneratorFactory> random_generator) noexcept
        {
            random_generator_ = std::move(random_generator);
        }

        /**
        Returns the encryption scheme type.
        */
                       inline scheme_type scheme() const noexcept
        {
            return scheme_;
        }

        /**
        Returns the degree of the polynomial modulus parameter.
        */
                       inline std::size_t poly_modulus_degree() const noexcept
        {
            return poly_modulus_degree_;
        }

        /**
        Returns a const reference to the currently set coefficient modulus parameter.
        */
                       inline auto coeff_modulus() const noexcept -> const std::vector<Modulus> &
        {
            return coeff_modulus_;
        }

        /**
        Returns a const reference to the currently set plaintext modulus parameter.
        */
                       inline const Modulus &plain_modulus() const noexcept
        {
            return plain_modulus_;
        }

        /**
        Returns a pointer to the random number generator factory to use for encryption.
        */
                       inline auto random_generator() const noexcept -> std::shared_ptr<UniformRandomGeneratorFactory>
        {
            return random_generator_;
        }

        /**
        Compares a given set of encryption parameters to the current set of
        encryption parameters. The comparison is performed by comparing the
        parms_ids of the parameter sets rather than comparing the parameters
        individually.

        @parms[in] other The EncryptionParameters to compare against
        */
                       inline bool operator==(const EncryptionParameters &other) const noexcept
        {
            return (parms_id_ == other.parms_id_);
        }

        /**
        Compares a given set of encryption parameters to the current set of
        encryption parameters. The comparison is performed by comparing
        parms_ids of the parameter sets rather than comparing the parameters
        individually.

        @parms[in] other The EncryptionParameters to compare against
        */
                       inline bool operator!=(const EncryptionParameters &other) const noexcept
        {
            return (parms_id_ != other.parms_id_);
        }

        /**
        Returns an upper bound on the size of the EncryptionParameters, as if it
        was written to an output stream.

        @param[in] compr_mode The compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the size does not fit in the return type
        */
                       inline std::streamoff save_size(
            compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            std::size_t coeff_modulus_total_size =
                coeff_modulus_.empty()
                    ? std::size_t(0)
                    : util::safe_cast<std::size_t>(coeff_modulus_[0].save_size(compr_mode_type::none));
            coeff_modulus_total_size = util::mul_safe(coeff_modulus_total_size, coeff_modulus_.size());

            std::size_t members_size = Serialization::ComprSizeEstimate(
                util::add_safe(
                    sizeof(scheme_),
                    sizeof(std::uint64_t), // poly_modulus_degree_
                    sizeof(std::uint64_t), // coeff_modulus_size
                    coeff_modulus_total_size,
                    util::safe_cast<std::size_t>(plain_modulus_.save_size(compr_mode_type::none))),
                compr_mode);

            return util::safe_cast<std::streamoff>(util::add_safe(sizeof(Serialization::SEALHeader), members_size));
        }

        /**
        Saves EncryptionParameters to an output stream. The output is in binary
        format and is not human-readable. The output stream must have the "binary"
        flag set.

        @param[out] stream The stream to save the EncryptionParameters to
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            std::ostream &stream, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&EncryptionParameters::save_members, this, _1), save_size(compr_mode_type::none), stream,
                compr_mode, false);
        }

        /**
        Loads EncryptionParameters from an input stream overwriting the current
        EncryptionParameters.

        @param[in] stream The stream to load the EncryptionParameters from
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(std::istream &stream)
        {
            using namespace std::placeholders;
            EncryptionParameters new_parms(scheme_type::none);
            auto in_size =
                Serialization::Load(std::bind(&EncryptionParameters::load_members, &new_parms, _1, _2), stream, false);
            std::swap(*this, new_parms);
            return in_size;
        }

        /**
        Saves EncryptionParameters to a given memory location. The output is in
        binary format and is not human-readable.

        @param[out] out The memory location to write the EncryptionParameters to
        @param[in] size The number of bytes available in the given memory location
        @param[in] compr_mode The desired compression mode
        @throws std::invalid_argument if out is null or if size is too small to
        contain a SEALHeader, or if the compression mode is not supported
        @throws std::logic_error if the data to be saved is invalid, or if
        compression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff save(
            seal_byte *out, std::size_t size, compr_mode_type compr_mode = Serialization::compr_mode_default) const
        {
            using namespace std::placeholders;
            return Serialization::Save(
                std::bind(&EncryptionParameters::save_members, this, _1), save_size(compr_mode_type::none), out, size,
                compr_mode, false);
        }

        /**
        Loads EncryptionParameters from a given memory location overwriting the
        current EncryptionParameters.

        @param[in] in The memory location to load the EncryptionParameters from
        @param[in] size The number of bytes available in the given memory location
        @throws std::invalid_argument if in is null or if size is too small to
        contain a SEALHeader
        @throws std::logic_error if the data cannot be loaded by this version of
        Microsoft SEAL, if the loaded data is invalid, or if decompression failed
        @throws std::runtime_error if I/O operations failed
        */
        inline std::streamoff load(const seal_byte *in, std::size_t size)
        {
            using namespace std::placeholders;
            EncryptionParameters new_parms(scheme_type::none);
            auto in_size = Serialization::Load(
                std::bind(&EncryptionParameters::load_members, &new_parms, _1, _2), in, size, false);
            std::swap(*this, new_parms);
            return in_size;
        }

        /**
        Enables access to private members of seal::EncryptionParameters for SEAL_C.
        */
        struct EncryptionParametersPrivateHelper;

    private:
        /**
        Helper function to determine whether given std::uint8_t represents a valid
        value for scheme_type. The return value will be false is the scheme is set
        to scheme_type::none.
        */
                       bool is_valid_scheme(std::uint8_t scheme) const noexcept
        {
            switch (scheme)
            {
            case static_cast<std::uint8_t>(scheme_type::none):
                /* fall through */

            case static_cast<std::uint8_t>(scheme_type::bfv):
                /* fall through */

            case static_cast<std::uint8_t>(scheme_type::ckks):
                return true;
            }
            return false;
        }

        /**
        Returns the parms_id of the current parameters. This function is intended
        for internal use.
        */
                       inline auto &parms_id() const noexcept
        {
            return parms_id_;
        }

        void compute_parms_id();

        void save_members(std::ostream &stream) const;

        void load_members(std::istream &stream, SEALVersion version);

        MemoryPoolHandle pool_ = MemoryManager::GetPool();

        scheme_type scheme_;

        std::size_t poly_modulus_degree_ = 0;

        std::vector<Modulus> coeff_modulus_{};

        std::shared_ptr<UniformRandomGeneratorFactory> random_generator_{ nullptr };

        Modulus plain_modulus_{};

        parms_id_type parms_id_ = parms_id_zero;
    };
} // namespace seal

/**
Specializes the std::hash template for parms_id_type.
*/
namespace std
{
    template <>
    struct hash<seal::parms_id_type>
    {
        std::size_t operator()(const seal::parms_id_type &parms_id) const
        {
            std::uint64_t result = 17;
            result = 31 * result + parms_id[0];
            result = 31 * result + parms_id[1];
            result = 31 * result + parms_id[2];
            result = 31 * result + parms_id[3];
            return static_cast<std::size_t>(result);
        }
    };

    template <>
    struct hash<seal::EncryptionParameters>
    {
        std::size_t operator()(const seal::EncryptionParameters &parms) const
        {
            hash<seal::parms_id_type> parms_id_hash;
            return parms_id_hash(parms.parms_id_);
        }
    };
} // namespace std
# 18 "SEAL/native/src/seal/c/utilities.h" 2

namespace seal
{
    class Modulus;
    class SEALContext;
    class MemoryPoolHandle;
} // namespace seal

namespace seal
{
    namespace c
    {
        /**
        Return a pointer of the given type from a void pointer.
        */
        template <class T>
        inline T *FromVoid(void *voidptr)
        {
            T *result = reinterpret_cast<T *>(voidptr);
            return result;
        }

        /**
        Get MemoryPoolHandle from a void pointer.
        Returns a default if void pointer is null.
        */
        std::unique_ptr<seal::MemoryPoolHandle> MemHandleFromVoid(void *voidptr);

        /**
        Build and array of Modulus pointers from a vector
        */
        void BuildModulusPointers(const std::vector<seal::Modulus> &in_mods, uint64_t *length, void **out_mods);

        /**
        Get a parms_id_type from an uint64_t pointer
        */
        inline void CopyParmsId(const uint64_t *src, seal::parms_id_type &dest)
        {
            if (nullptr != src)
            {
                std::copy_n(src, dest.size(), std::begin(dest));
            }
        }

        /**
        Copy parms_id_type to a uint64_t pointer
        */
        inline void CopyParmsId(const seal::parms_id_type &src, uint64_t *dest)
        {
            if (nullptr != dest)
            {
                std::copy_n(std::cbegin(src), src.size(), dest);
            }
        }

        /**
        Convert std::string to char* with null terminator
        */
        long ToStringHelper(const std::string &str, char *outstr, uint64_t *length);

        /**
        Convert const char * to char* with null terminator
        */
        long ToStringHelper2(const char *str, char *outstr, uint64_t *length);
    } // namespace c
} // namespace seal
# 25 "./bindgen_wrapper.h" 2
# 1 "SEAL/native/src/seal/c/valcheck.h" 1
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.



///////////////////////////////////////////////////////////////////////////
//
// This API is provided as a simple interface for Microsoft SEAL library
// that can be PInvoked by .Net code.
//
///////////////////////////////////////////////////////////////////////////




extern "C" long ValCheck_Plaintext_IsValidFor(void *plaintext, void *context, bool *result);

extern "C" long ValCheck_Ciphertext_IsValidFor(void *ciphertext, void *context, bool *result);

extern "C" long ValCheck_SecretKey_IsValidFor(void *secret_key, void *context, bool *result);

extern "C" long ValCheck_PublicKey_IsValidFor(void *public_key, void *context, bool *result);

extern "C" long ValCheck_KSwitchKeys_IsValidFor(void *kswitch_keys, void *context, bool *result);

extern "C" long ValCheck_RelinKeys_IsValidFor(void *relin_keys, void *context, bool *result);

extern "C" long ValCheck_GaloisKeys_IsValidFor(void *galois_keys, void *context, bool *result);
# 26 "./bindgen_wrapper.h" 2
# 2 "__bindgen.cpp" 2

