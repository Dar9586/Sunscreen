import { DrawingGraph, ModifierKeysEnum } from '@msagl/drawing';
import { AttributeRegistry, buildRTreeWithInterpolatedEdges, Edge, EventHandler, GeomGraph, GeomLabel, GeomNode, GeomObject, getGeomIntersectedObjects, Graph, Point, Node, Label, } from '@msagl/core';
import { SvgCreator } from './svgCreator';
import { graphToJSON } from '@msagl/parser';
import { LayoutEditor, viewerObj, InsertionMode } from '@msagl/drawing';
import { default as panZoom } from 'panzoom';
import { TextMeasurer, layoutGraph, deepEqual } from '@msagl/renderer-common';
function svgViewerObj(ent) {
    return viewerObj(ent);
}
/**
 * This class renders an MSAGL graph with SVG and enables the graph editing.
 */
export class RendererSvg {
    constructor(container = document.body) {
        /** the distance in inches */
        this.mouseHitDistance = 0.05 / 2;
        /** The default is true and the value is reset to true after each call to setGraph */
        this.needCreateGeometry = true;
        /** The default is true and the value is reset to true after each call to setGraph */
        this.needCalculateLayout = true;
        this._layoutOptions = {};
        this.IncrementalDraggingModeAlways = false;
        this.GraphChanged = new EventHandler();
        this.objectUnderMouseCursorChanged = new EventHandler();
        this.modifierKeys = ModifierKeysEnum.None;
        this.LineThicknessForEditing = 2;
        /** controls if the layout can be changed by mouse or touch interactions */
        this.layoutEditingEnabled = true;
        this.container = container;
        this._textMeasurer = new TextMeasurer();
        this._svgCreator = new SvgCreator(container);
        this._svgCreator.getSmoothedPolylineRadius = () => this.smoothedPolylineCircleRadius;
        container.addEventListener('pointerdown', (e) => {
            if (this.layoutEditor.viewerMouseDown(this, e)) {
                this.panZoom.pause();
            }
        });
        container.addEventListener('pointermove', (e) => {
            this.processMouseMove(e);
            if (this.layoutEditingEnabled)
                this.layoutEditor.viewerMouseMove(this, e);
        });
        container.addEventListener('pointerup', (e) => {
            if (!this.layoutEditingEnabled)
                return;
            this.layoutEditor.viewerMouseUp(this, e);
            if (this.panZoom)
                this.panZoom.resume();
        });
        this.layoutEditor = new LayoutEditor(this);
    }
    addKeyDownListener(callback) {
        this.keyDownListener = callback;
    }
    *entitiesIter() {
        for (const n of this.graph.nodesBreadthFirst)
            yield svgViewerObj(n);
        for (const e of this.graph.deepEdges) {
            yield svgViewerObj(e);
            if (e.label) {
                yield svgViewerObj(e.label);
            }
        }
    }
    get smoothedPolylineRadiusWithNoScale() {
        return this.Dpi * 0.05;
    }
    getInterpolationSlack() {
        return this.mouseHitDistance;
    }
    get Dpi() {
        return 96 * window.devicePixelRatio;
    }
    getHitSlack() {
        const dpi = this.Dpi;
        const slackInPoints = dpi * this.mouseHitDistance;
        return slackInPoints / this.CurrentScale;
    }
    getSvgString() {
        return this._svgCreator.getSvgString();
    }
    getJSONString() {
        if (this.graph == null)
            return 'no graph';
        return JSON.stringify(graphToJSON(this.graph), null, 2);
    }
    // public get objectTree(): RTree<GeomHitTreeNodeType, Point> {
    //   if (this._objectTree == null || this._objectTree.RootNode == null) {
    //     this._objectTree = buildRTreeWithInterpolatedEdges(this.graph, this.getHitSlack())
    //   }
    //   return this._objectTree
    // }
    // public set objectTree(value: RTree<GeomHitTreeNodeType, Point>) {
    //   this._objectTree = value
    // }
    processMouseMove(e) {
        this.mousePosition = new Point(e.clientX, e.clientY);
        if (this == null || this._svgCreator == null) {
            return;
        }
        if (!this.layoutEditingEnabled) {
            return;
        }
        if (this.layoutEditor.dragging && this.insertingEdge == false) {
            return;
        }
        if (this.insertingNode) {
            this._svgCreator.positionNodeInsertionCircle(this.ScreenToSourceP(this.mousePosition.x, this.mousePosition.y));
            return;
        }
        if (this.insertingEdge) {
            this._svgCreator.positionEdgeInsertionElement(this.ScreenToSourceP(this.mousePosition.x, this.mousePosition.y), this.layoutEditor.hasEdgeInsertionPort);
        }
        this.setObjectUnderCursorFromEvent(e);
    }
    setObjectUnderCursorFromEvent(e) {
        if (this._objectTree == null) {
            this._objectTree = buildRTreeWithInterpolatedEdges(this.graph, this.getHitSlack());
        }
        const elems = Array.from(getGeomIntersectedObjects(this._objectTree, this.getHitSlack(), this.screenToSource(e)));
        if (elems.length == 0) {
            this.objectUnderMouseCursor = null;
            return;
        }
        sortElems();
        const favorite = elems[0];
        if (favorite instanceof GeomObject) {
            this.objectUnderMouseCursor = favorite.entity.getAttr(AttributeRegistry.ViewerIndex);
        }
        // end of the main function processMouseMove
        function sortElems() {
            elems.sort((a, b) => {
                const atype = a instanceof GeomGraph ? 3 : a instanceof GeomLabel ? 2 : a instanceof GeomNode ? 1 : 0; // 0 for GeomEdge
                const btype = b instanceof GeomGraph ? 3 : b instanceof GeomLabel ? 2 : b instanceof GeomNode ? 1 : 0; // 0 for GeomEdge
                if (atype != btype)
                    return atype - btype;
                if (atype == 2)
                    return 0; // both are GeomLabels
                return depth(b) - depth(a);
                function depth(a) {
                    let d = 0;
                    let p = a.entity.parent;
                    while (p) {
                        d++;
                        p = p.parent;
                    }
                    return d;
                }
            });
        }
    }
    get insertionMode() {
        return this._insertionMode;
    }
    set insertionMode(value) {
        if (value == this.insertionMode)
            return;
        switch (value) {
            case InsertionMode.Default:
                this._svgCreator.stopNodeInsertion();
                this._svgCreator.stopEdgeInsertion();
                break;
            case InsertionMode.Node:
                this._svgCreator.prepareToNodeInsertion(this.ScreenToSourceP(this.mousePosition.x, this.mousePosition.y));
                break;
            case InsertionMode.Edge:
                this._svgCreator.prepareToEdgeInsertion(this.ScreenToSourceP(this.mousePosition.x, this.mousePosition.y), this.layoutEditor.hasEdgeInsertionPort);
                break;
            default:
                throw new Error('not implemented');
        }
        this._insertionMode = value;
    }
    createUndoPoint() {
        this.layoutEditor.createUndoPoint();
    }
    selectedEntities() {
        const ret = Array.from(this.layoutEditor.dragGroup);
        if (this.objectUnderMouseCursor) {
            ret.push(this.objectUnderMouseCursor);
        }
        if (this.layoutEditor.edgeWithSmoothedPolylineExposed) {
            ret.push(this.layoutEditor.edgeWithSmoothedPolylineExposed);
        }
        return ret;
    }
    createIViewerNodeNPA(drawingNode, center, visualElement) {
        throw new Error('Method not implemented.');
    }
    createIViewerNodeN(node, center) {
        const drawingGraph = this.graph.getAttr(AttributeRegistry.DrawingObjectIndex);
        drawingGraph.createNodeGeometry(node, center);
        this._svgCreator.drawNode(node);
        return svgViewerObj(node);
    }
    undo() {
        this.layoutEditor.undo();
    }
    redo() {
        this.layoutEditor.redo();
    }
    /** when the graph is set : the geometry for it is created and the layout is done */
    setGraph(graph, options = this._layoutOptions) {
        if (this._graph === graph) {
            this.setOptions(options);
        }
        else {
            this._graph = graph;
            this._layoutOptions = options;
            this._textMeasurer.setOptions(options.label || {});
            const drawingGraph = DrawingGraph.getDrawingObj(graph) || new DrawingGraph(graph);
            if (this.needCreateGeometry) {
                drawingGraph.createGeometry(this._textMeasurer.measure);
            }
            else {
                // still need to measure the text sizes
                drawingGraph.measureLabelSizes(this._textMeasurer.measure);
            }
            if (this.needCalculateLayout) {
                layoutGraph(graph, this._layoutOptions, true);
            }
            this._update();
        }
        this.needCalculateLayout = this.needCreateGeometry = true;
    }
    setOptions(options) {
        const oldLabelSettings = this._layoutOptions.label;
        const newLabelSettings = options.label;
        const fontChanged = !deepEqual(oldLabelSettings, newLabelSettings);
        this._layoutOptions = options;
        if (!this._graph) {
            return;
        }
        const drawingGraph = DrawingGraph.getDrawingObj(this._graph);
        if (fontChanged) {
            this._textMeasurer.setOptions(options.label || {});
            drawingGraph.createGeometry(this._textMeasurer.measure);
        }
        const relayout = fontChanged;
        layoutGraph(this._graph, this._layoutOptions, relayout);
        this._update();
    }
    _update() {
        if (!this._graph)
            return;
        this._objectTree = null;
        this._svgCreator.setGraph(this._graph);
        if (this.panZoom) {
            this.panZoom.dispose();
        }
        this.panZoom = panZoom(this._svgCreator.superTransGroup, {
            onTouch: () => {
                // `e` - is the current touch event.
                return false; // tells the library to not preventDefault.
            },
        });
        this.panZoom.showRectangle(this._svgCreator.getShowRect());
        //   console.log(this._svgCreator.svg.getBoundingClientRect())
        this.layoutEditor.viewerGraphChanged();
        if (this.graph.deepEdgesCount > 2000 && this.graph.nodeCountDeep > 1000) {
            this.layoutEditingEnabled = false;
        }
    }
    /** maps the screen coordinates to the graph coordinates */
    screenToSource(e) {
        return this.ScreenToSourceP(e.clientX, e.clientY);
    }
    /** maps the screen coordinates to the graph coordinates */
    ScreenToSourceP(x, y) {
        // m is the reverse mapping : that is the mapping from the graph coords to the client's
        const m = this._svgCreator.getTransform();
        return m.inverse().multiplyPoint(new Point(x, y));
    }
    get CurrentScale() {
        return this._svgCreator.getScale();
    }
    get objectUnderMouseCursor() {
        return this._objectUnderMouse;
    }
    set objectUnderMouseCursor(value) {
        if (this._objectUnderMouse !== value) {
            this._objectUnderMouse = value;
            // if (value) {
            //   console.log(this._objectUnderMouse.entity)
            // } else {
            //   if (this.layoutEditor.insertingEdge) {
            //     console.log('no selection')
            //   } else {
            //     console.log('no sel: no insert')
            //   }
            // }
        }
    }
    invalidate(objectToInvalidate) {
        //  console.log('invalidate', objectToInvalidate.entity)
        this._objectTree = null;
        if (this.graph !== objectToInvalidate.entity && isRemoved(objectToInvalidate.entity)) {
            const svgElem = objectToInvalidate.entity.getAttr(AttributeRegistry.ViewerIndex).svgData;
            svgElem.remove();
        }
        else if (this.graph == objectToInvalidate.entity) {
            this.panZoom.showRectangle(this._svgCreator.getShowRect());
        }
        else {
            this._svgCreator.invalidate(objectToInvalidate);
        }
    }
    invalidateAll() {
        //TODO : implement
    }
    get entities() {
        return this.entitiesIter();
    }
    get DpiX() {
        return this.Dpi;
    }
    get DpiY() {
        return this.Dpi;
    }
    get insertingNode() {
        return this.insertionMode == InsertionMode.Node;
    }
    get insertingEdge() {
        return this.insertionMode == InsertionMode.Edge;
    }
    PopupMenus(menuItems) {
        throw new Error('Method not implemented.');
    }
    get smoothedPolylineCircleRadius() {
        return this.smoothedPolylineRadiusWithNoScale / this.CurrentScale;
    }
    addEdge(edge, registerForUndo) {
        this._objectTree = null;
        if (registerForUndo)
            this.layoutEditor.registerAdd(edge.entity);
    }
    createEdgeWithGivenGeometry(edge) {
        this._svgCreator.drawEdge(edge);
        return svgViewerObj(edge);
    }
    addNode(node, registerForUndo) {
        this._objectTree = null;
        if (registerForUndo) {
            this.layoutEditor.registerAdd(node.entity);
        }
    }
    remove(viewerObj, registerForUndo) {
        const ent = viewerObj.entity;
        this._objectTree = null;
        if (registerForUndo)
            this.layoutEditor.registerDelete(ent);
        if (this.objectUnderMouseCursor === viewerObj) {
            this.objectUnderMouseCursor = null;
        }
        const svgVO = viewerObj;
        svgVO.svgData.remove();
        this.layoutEditor.forget(viewerObj);
        if (ent instanceof Graph) {
            this.removeSubgraph(ent);
        }
        else {
            this.removeForNonSubgraph(ent, registerForUndo);
        }
    }
    removeForNonSubgraph(ent, registerForUndo) {
        if (ent instanceof Node) {
            if (registerForUndo) {
                for (const e of ent.edges) {
                    this.layoutEditor.registerDelete(e);
                    if (e.label)
                        this.layoutEditor.registerDelete(e.label);
                }
            }
            const graph = ent.parent;
            graph.removeNode(ent);
            for (const e of ent.edges) {
                removeEdge(e);
            }
        }
        else if (ent instanceof Edge) {
            ent.remove();
            if (registerForUndo)
                if (ent.label)
                    this.layoutEditor.registerDelete(ent.label);
            removeEdge(ent);
        }
        else if (ent instanceof Label) {
            const edge = ent.parent;
            edge.label = null;
        }
    }
    removeSubgraph(subgraph) {
        const elems = Array.from(subgraph.allElements());
        for (const e of elems) {
            svgViewerObj(e).svgData.remove();
        }
        subgraph.removeSubgraph();
        // we do net need to change the subgraph structure: just to remove all the visuals
        for (const e of elems) {
            const ve = svgViewerObj(e).svgData;
            ve.remove();
            if (e instanceof Edge && e.label) {
                svgViewerObj(e.label).svgData.remove();
            }
        }
    }
    RouteEdge(drawingEdge) {
        throw new Error('Method not implemented.');
    }
    SetSourcePortForEdgeRouting(portLocation) {
        this.sourcePortLocatiton = portLocation;
    }
    setTargetPortForEdgeRouting(portLocation) {
        this.targetPortLocatiton = portLocation;
    }
    RemoveSourcePortEdgeRouting() {
        //throw new Error('Method not implemented.')
    }
    RemoveTargetPortEdgeRouting() {
        // throw new Error('Method not implemented.')
    }
    drawRubberEdge(edgeGeometry) {
        this._svgCreator.drawRubberEdge(edgeGeometry);
    }
    stopDrawingRubberEdge() {
        this._svgCreator.removeRubberEdge();
    }
    get graph() {
        return this._graph;
    }
    get Transform() {
        return this._svgCreator.getTransform();
    }
}
function removeEdge(e) {
    e.remove();
    svgViewerObj(e).svgData.remove();
    if (e.label) {
        svgViewerObj(e.label).svgData.remove();
    }
}
function isRemoved(entity) {
    if (entity instanceof Edge) {
        if (entity.source !== entity.target) {
            if (!entity.source.outEdges.has(entity))
                return true;
            if (!entity.target.inEdges.has(entity))
                return true;
            return nodeIsRemoved(entity.source) || nodeIsRemoved(entity.target);
        }
        else
            return !entity.source.selfEdges.has(entity) || nodeIsRemoved(entity.source);
    }
    if (entity instanceof Node) {
        return nodeIsRemoved(entity);
    }
    if (entity instanceof Label) {
        if (entity.parent == null)
            return true;
        return isRemoved(entity.parent);
    }
    return false;
    /** the only proof that the node is removed is
     * a) the node has a valid parent
     * and
     * b) the parent does not have the node in its node collection
     * or a) and be hods for one of the node ancestors
     *
     **/
    function nodeIsRemoved(node) {
        let parent = node.parent;
        while (parent) {
            if (parent.findNode(node.id) !== node)
                return true;
            node = parent;
            parent = parent.parent;
        }
        return false;
    }
}
//# sourceMappingURL=rendererSvg.js.map