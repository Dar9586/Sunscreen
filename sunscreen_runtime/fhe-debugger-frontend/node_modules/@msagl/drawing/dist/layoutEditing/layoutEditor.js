import { Node, Arrowhead, Assert, AttributeRegistry, Curve, Edge, EdgeLabelPlacement, EdgeRoutingMode, GeomEdge, GeomGraph, GeomNode, GeomObject, Graph, Label, LineSegment, Point, Rectangle, RectilinearInteractiveEditor, Size, SmoothedPolyline, StraightLineEdges, layoutGeomGraph, InteractiveEdgeRouter, FloatingPort, PointLocation, CurvePort, } from '@msagl/core';
import { DraggingMode, GeometryGraphEditor } from './geomGraphEditor';
import { InsertionMode } from './iViewer';
import { ArrowTypeEnum } from '../arrowTypeEnum';
import { DrawingEdge } from '../drawingEdge';
import { DrawingNode } from '../drawingNode';
import { DrawingObject } from '../drawingObject';
import { ModifierKeysEnum } from './modifierKeys';
export function viewerObj(entity) {
    return entity.getAttr(AttributeRegistry.ViewerIndex);
}
function geomObjFromIViewerObj(obj) {
    return GeomObject.getGeom(obj.entity);
}
function isIViewerNode(obj) {
    return obj && obj.entity instanceof Node;
}
export class LayoutEditor {
    //  Constructor
    constructor(viewerPar) {
        this.RadiusOfPolylineCorner = 10;
        this.geomEdge = new GeomEdge(null); // keep it to hold the geometry only
        this.EdgeAttr = new DrawingEdge(null, true);
        this.arrowheadLength = Arrowhead.defaultArrowheadLength;
        this.dragGroup = new Set();
        this.geomGraphEditor = new GeometryGraphEditor();
        this.mouseMoveThreshold = 0.05;
        this.sourceLoosePolylineWrap = { loosePolyline: null };
        this.sourceOfInsertedEdgeWrap = { node: null };
        this.sourcePortWrap = { port: null };
        this.targetOfInsertedEdgeWrap = { node: null };
        this.targetPortWrap = { port: null };
        this.dragging = false;
        this.edgeAttr = new DrawingEdge(null, true);
        this.viewer = viewerPar;
        this.decorateObjectForDragging = this.defaultObjectDecorator;
        this.removeObjDraggingDecorations = this.defaultObjectDecoratorRemover;
        this.DecorateEdgeForDragging = LayoutEditor.TheDefaultEdgeDecoratorStub;
        this.decorateEdgeLabelForDragging = this.defaultEdgeLabelDecorator;
        this.RemoveEdgeDraggingDecorations = LayoutEditor.TheDefaultEdgeDecoratorStub;
        this.geomGraphEditor.graph = () => GeomGraph.getGeom(this._graph);
    }
    resizeLabel(innerText, objectWithEditedLabel) {
        const dro = objectWithEditedLabel.getAttr(AttributeRegistry.DrawingObjectIndex);
        dro.labelText = innerText;
        this.viewer.invalidate(objectWithEditedLabel.getAttr(AttributeRegistry.ViewerIndex));
    }
    get hasEdgeInsertionPort() {
        return this.SourcePort != null || this.TargetPort != null;
    }
    get insertingEdge() {
        return this.insertionMode == InsertionMode.Edge;
    }
    createUndoPoint() {
        this.geomGraphEditor.createUndoPoint();
    }
    registerDelete(entity) {
        this.geomGraphEditor.registerDelete(entity);
    }
    registerAdd(entity) {
        this.geomGraphEditor.registerAdd(entity);
    }
    /** unregister the element from everywhere */
    forget(ent) {
        this.dragGroup.delete(ent);
        if (this.edgeWithSmoothedPolylineExposed === ent) {
            this.edgeWithSmoothedPolylineExposed = null;
        }
    }
    get edgeWithSmoothedPolylineExposed() {
        return this._edgeWithSmoothedPolylineExposed;
    }
    set edgeWithSmoothedPolylineExposed(value) {
        if (this._edgeWithSmoothedPolylineExposed !== value) {
            if (this._edgeWithSmoothedPolylineExposed) {
                this._edgeWithSmoothedPolylineExposed.selectedForEditing = false;
            }
        }
        this._edgeWithSmoothedPolylineExposed = value;
        if (value) {
            value.selectedForEditing = true;
            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = GeomEdge.getGeom(value.edge);
        }
        else {
            this.geomGraphEditor.geomEdgeWithSmoothedPolylineExposed = null;
        }
    }
    get ActiveDraggedObject() {
        return this.aActiveDraggedObject;
    }
    set ActiveDraggedObject(value) {
        this.aActiveDraggedObject = value;
    }
    get interactiveEdgeRouter() {
        return this._interactiveEdgeRouter;
    }
    set interactiveEdgeRouter(value) {
        this._interactiveEdgeRouter = value;
    }
    ViewerObjectUnderMouseCursorChanged(sender, e) {
        if (this.TargetPort != null) {
            this.viewer.RemoveTargetPortEdgeRouting();
            this.TargetPort = null;
        }
    }
    ViewChangeEventHandler(sender, e) {
        if (this._graph == null) {
            return;
        }
    }
    /**  current graph under editing */
    get graph() {
        return this._graph;
    }
    set graph(value) {
        this._graph = value;
        this.geomGraphEditor.clear();
    }
    //  If the distance between the mouse down point and the mouse up point is greater than the threshold
    //  then we have a mouse move. Otherwise we have a click.
    get MouseMoveThreshold() {
        return this.mouseMoveThreshold;
    }
    set MouseMoveThreshold(value) {
        this.mouseMoveThreshold = value;
    }
    get DecorateEdgeForDragging() {
        return this.decorateEdgeForDragging;
    }
    set DecorateEdgeForDragging(value) {
        this.decorateEdgeForDragging = value;
    }
    //  a delegate to remove edge decorations
    get RemoveEdgeDraggingDecorations() {
        return this.removeEdgeDraggingDecorations;
    }
    set RemoveEdgeDraggingDecorations(value) {
        this.removeEdgeDraggingDecorations = value;
    }
    get NodeInsertPredicate() {
        return this.nodeInsertPredicate;
    }
    set NodeInsertPredicate(value) {
        this.nodeInsertPredicate = value;
    }
    get SourceOfInsertedEdge() {
        return this.sourceOfInsertedEdgeWrap.node;
    }
    set SourceOfInsertedEdge(value) {
        this.sourceOfInsertedEdgeWrap.node = value;
    }
    get TargetOfInsertedEdge() {
        return this.targetOfInsertedEdgeWrap.node;
    }
    set TargetOfInsertedEdge(value) {
        this.targetOfInsertedEdgeWrap.node = value;
    }
    /** gets the port from the wrapper */
    get SourcePort() {
        return this.sourcePortWrap.port;
    }
    /** set the port for the wrapper */
    set SourcePort(value) {
        this.sourcePortWrap.port = value;
    }
    /** gets the port from the wrapper */
    get TargetPort() {
        return this.targetPortWrap.port;
    }
    /** sets the port for the wrapper */
    set TargetPort(value) {
        this.targetPortWrap.port = value;
    }
    //  returns true if Undo is available
    get CanUndo() {
        return this.geomGraphEditor.canUndo;
    }
    //  return true if Redo is available
    get CanRedo() {
        return this.geomGraphEditor.canRedo;
    }
    get insertionMode() {
        if (this.viewer == null)
            return InsertionMode.Default;
        return this.viewer.insertionMode;
    }
    set insertionMode(value) {
        if (this.viewer == null)
            return;
        this.viewer.insertionMode = value;
    }
    viewerGraphChanged() {
        this._graph = this.viewer.graph;
        this.geomGraphEditor.clear();
        if (this._graph != null && GeomGraph.getGeom(this._graph) != null) {
            this.geomGraphEditor.clear();
        }
        this.ActiveDraggedObject = null;
        this.dragGroup.clear();
        this.cleanObstacles();
    }
    cleanObstacles() {
        this.interactiveEdgeRouter = null;
        this.looseObstaclesToTheirViewerNodes = null;
        this.SourceOfInsertedEdge = null;
        this.TargetOfInsertedEdge = null;
        this.SourcePort = null;
        this.TargetPort = null;
        this.viewer.RemoveSourcePortEdgeRouting();
        this.viewer.RemoveTargetPortEdgeRouting();
    }
    RelayoutOnIsCollapsedChanged(iCluster) {
        this.geomGraphEditor.PrepareForClusterCollapseChange([iCluster]);
        const geomGraph = GeomGraph.getGeom(iCluster.node);
        if (geomGraph.isCollapsed) {
            this.CollapseCluster(iCluster.node);
        }
        else {
            this.ExpandCluster(geomGraph);
        }
        // LayoutAlgorithmSettings.ShowGraph(viewer.Graph.GeometryGraph);
        for (const o of this.geomGraphEditor.entitiesToBeChangedByUndo()) {
            this.invalidate(o);
        }
    }
    relayout(cluster) {
        let parent = cluster;
        while (parent.parent != null) {
            parent = parent.parent;
        }
        layoutGeomGraph(parent); // TODO: this call relayouts everything. Try to optimize.
        this.MakeExpandedNodesVisible(cluster.entity);
    }
    ExpandCluster(cluster) {
        if (cluster == null)
            return;
        this.relayout(cluster);
    }
    MakeExpandedNodesVisible(cluster) {
        for (const node of cluster.shallowNodes) {
            const iviewerNode = viewerObj(node);
            LayoutEditor.UnhideNodeEdges(node);
            iviewerNode.isVisible = true;
            if (node instanceof Graph) {
                const geomGraph = node.getAttr(AttributeRegistry.GeomObjectIndex);
                if (geomGraph.isCollapsed == false)
                    this.MakeExpandedNodesVisible(node);
            }
        }
    }
    static UnhideNodeEdges(drn) {
        for (const e of drn.selfEdges) {
            const viewerObject = viewerObj(e);
            viewerObject.isVisible = true;
        }
        for (const e of drn.outEdges) {
            if (viewerObj(e.target).isVisible)
                viewerObj(e).isVisible = true;
        }
        for (const e of drn.inEdges) {
            if (viewerObj(e.source).isVisible)
                viewerObj(e).isVisible = true;
        }
    }
    CollapseCluster(graph) {
        LayoutEditor.HideCollapsed(graph);
        const geomCluster = GeomGraph.getGeom(graph);
        const center = geomCluster.center;
        geomCluster.boundingBox = Rectangle.mkSizeCenter(geomCluster.labelSize, center);
        this.relayout(geomCluster);
    }
    static HideCollapsed(cluster) {
        for (const n of cluster.shallowNodes) {
            viewerObj(n).isVisible = false;
            if (n instanceof Graph) {
                if (GeomGraph.getGeom(n).isCollapsed == false)
                    LayoutEditor.HideCollapsed(n);
            }
        }
    }
    defaultObjectDecorator(obj) {
        if (obj.entity instanceof Label) {
            this.decorateEdgeLabelForDragging(obj);
            return;
        }
        const drawingObj = DrawingNode.getDrawingObj(obj.entity);
        const w = drawingObj.penwidth;
        if (!obj.unmarkedForDraggingCallback) {
            obj.unmarkedForDraggingCallback = () => (DrawingObject.getDrawingObj(obj.entity).penwidth = w);
        }
        drawingObj.penwidth = Math.max(this.viewer.LineThicknessForEditing, w * 2);
        this.invalidate(obj.entity);
    }
    defaultObjectDecoratorRemover(obj) {
        const decoratorRemover = obj.unmarkedForDraggingCallback;
        if (decoratorRemover) {
            decoratorRemover();
            obj.unmarkedForDraggingCallback = null;
            this.invalidate(obj.entity);
        }
        const ent = obj.entity;
        if (ent instanceof Node) {
            for (const edge of ent.edges) {
                this.removeObjDraggingDecorations(viewerObj(edge));
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    static TheDefaultEdgeDecoratorStub(edge) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    defaultEdgeLabelDecorator(label) {
        const geomLabel = label.entity.getAttr(AttributeRegistry.GeomObjectIndex);
        if (label.markedForDragging) {
            GeometryGraphEditor.calculateAttachmentSegment(geomLabel);
            label.unmarkedForDraggingCallback = () => {
                this.invalidate(label.entity);
            };
        }
        this.invalidate(label.entity);
    }
    static LeftButtonIsPressed(e) {
        return (e.buttons & 1) == 1;
    }
    static MiddleButtonIsPressed(e) {
        return (e.buttons & 4) == 4;
    }
    static RightButtonIsPressed(e) {
        return (e.buttons & 2) == 2;
    }
    MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e) {
        if (this.mouseDownScreenPoint == null)
            return false;
        const x = e.clientX;
        const y = e.clientY;
        const dx = (this.mouseDownScreenPoint.x - x) / this.viewer.DpiX;
        const dy = (this.mouseDownScreenPoint.y - y) / this.viewer.DpiY;
        return Math.sqrt(dx * dx + dy * dy) > this.MouseMoveThreshold / 3;
    }
    analyzeLeftMouseButtonClick(e) {
        if (this.edgeWithSmoothedPolylineExposed) {
            this.toggleCornerForSelectedEdge();
        }
        else if (this.viewer.objectUnderMouseCursor) {
            this.analyzeLeftMouseButtonClickOnObjectUnderCursor(e);
        }
    }
    analyzeLeftMouseButtonClickOnObjectUnderCursor(e) {
        const obj = this.viewer.objectUnderMouseCursor;
        const modifierKeyIsPressed = e.ctrlKey || e.shiftKey;
        const editableObj = obj.entity;
        if (editableObj instanceof Edge) {
            const geomEdge = editableObj.getAttr(AttributeRegistry.GeomObjectIndex);
            if (geomEdge != null && this.viewer.layoutEditingEnabled) {
                if (geomEdge.smoothedPolyline == null) {
                    geomEdge.smoothedPolyline = LayoutEditor.CreateUnderlyingPolyline(geomEdge);
                }
                if (this.edgeWithSmoothedPolylineExposed !== obj)
                    this.switchToEdgeEditing(obj);
            }
        }
        else {
            if (obj.markedForDragging) {
                this.unselectForDragging(obj);
            }
            else {
                if (!modifierKeyIsPressed) {
                    this.unselectEverything();
                }
                this.selectObjectForDragging(obj);
            }
            this.unselectEdge();
        }
    }
    toggleCornerForSelectedEdge() {
        const corner = GeometryGraphEditor.findClosestCornerForEdit(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, this.mouseDownGraphPoint, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner);
        if (corner == null) {
            this.tryInsertCorner();
        }
        else {
            if (corner.prev == null || corner.next == null) {
                return; // ignore the source and the target corners
            }
            this.geomGraphEditor.createUndoPoint();
            this.geomGraphEditor.registerForUndo(this.edgeWithSmoothedPolylineExposed.edge);
            this.geomGraphEditor.deleteSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), corner);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.entity);
        }
    }
    tryInsertCorner() {
        // we have to be close enough to the curve
        if (!this.closeEnoughToSelectedEdge()) {
            this.unselectEdge();
        }
        else {
            const a = GeometryGraphEditor.getPreviousCornerSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint);
            if (a == null)
                return;
            const b = a.next;
            if (b == null)
                return;
            this.geomGraphEditor.insertSite(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge), this.mouseDownGraphPoint, a);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);
        }
    }
    closeEnoughToSelectedEdge() {
        const curve = GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).curve;
        const t = curve.closestParameter(this.mouseDownGraphPoint);
        return curve.value(t).sub(this.mouseDownGraphPoint).length < this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner;
    }
    static CreateUnderlyingPolyline(geomEdge) {
        const ret = SmoothedPolyline.mkFromPoints(LayoutEditor.CurvePoints(geomEdge));
        return ret;
    }
    static *CurvePoints(geomEdge) {
        yield geomEdge.source.center;
        const isCurve = geomEdge.curve instanceof Curve;
        if (isCurve) {
            const curve = geomEdge.curve;
            if (curve.segs.length > 0)
                yield curve.start;
            for (let i = 0; i < curve.segs.length; i++)
                yield curve.segs[i].end;
        }
        yield geomEdge.target.center;
    }
    //         static void SetCoefficientsCorrecty(SmoothedPolyline ret, ICurve curve) {
    //            //  throw new NotImplementedException();
    //         }
    ModifierKeyIsPressed() {
        const modifierKeyWasUsed = (this.viewer.modifierKeys & ModifierKeysEnum.Control) == ModifierKeysEnum.Control ||
            (this.viewer.modifierKeys & ModifierKeysEnum.Shift) == ModifierKeysEnum.Shift;
        return modifierKeyWasUsed;
    }
    switchToEdgeEditing(edge) {
        this.unselectEverything();
        this.edgeWithSmoothedPolylineExposed = edge;
        edge.radiusOfPolylineCorner = this.viewer.smoothedPolylineCircleRadius;
        this.DecorateEdgeForDragging(edge);
        this.invalidate(edge.entity);
    }
    *ViewerNodes() {
        for (const o of this.viewer.entities) {
            if (o.entity instanceof Node)
                yield o.entity.getAttr(AttributeRegistry.ViewerIndex);
        }
    }
    selectObjectForDragging(obj) {
        if (obj.markedForDragging == false) {
            obj.markedForDragging = true;
            this.dragGroup.add(obj);
            this.decorateObjectForDragging(obj);
        }
    }
    prepareToRemoveFromDragGroup(obj) {
        obj.markedForDragging = false;
        this.removeObjDraggingDecorations(obj);
    }
    unselectForDragging(obj) {
        this.prepareToRemoveFromDragGroup(obj);
        this.dragGroup.delete(obj);
    }
    unselectEverything() {
        for (const obj of this.dragGroup) {
            this.prepareToRemoveFromDragGroup(obj);
        }
        this.dragGroup.clear();
        this.unselectEdge();
    }
    unselectEdge() {
        if (this.edgeWithSmoothedPolylineExposed != null) {
            this.edgeWithSmoothedPolylineExposed.selectedForEditing = false;
            this.removeEdgeDraggingDecorations(this.edgeWithSmoothedPolylineExposed);
            this.invalidate(this.edgeWithSmoothedPolylineExposed.edge);
            this.edgeWithSmoothedPolylineExposed = null;
        }
    }
    static *Edges(node) {
        for (const edge of node.entity.edges) {
            yield viewerObj(edge);
        }
    }
    // returns true if the editor needs own the events
    viewerMouseDown(sender, e) {
        if (!this.viewer.layoutEditingEnabled || this.viewer.graph == null) {
            return false;
        }
        this.viewer.setObjectUnderCursorFromEvent(e);
        this.mouseDownGraphPoint = this.viewer.screenToSource(e);
        this.mouseDownScreenPoint = new Point(e.clientX, e.clientY);
        if (!LayoutEditor.LeftButtonIsPressed(e))
            return false;
        this.leftMouseButtonWasPressed = true;
        if (this.insertingEdge) {
            // if (this.SourceOfInsertedEdge != null && this.SourcePort != null && this.DraggingStraightLine()) {
            //   this.viewer.StartDrawingRubberLine(this.sourcePort.port.Location)
            // }
            return true;
        }
        if (this.insertionMode == InsertionMode.Node) {
            this.insertNode();
            return true;
        }
        if (this.edgeWithSmoothedPolylineExposed != null) {
            if (this.mouseIsInsideOfCornerSite(e)) {
                e.preventDefault();
            }
            return true;
        }
        const obj = this.viewer.objectUnderMouseCursor;
        if (obj && !this.viewer.objectUnderMouseCursor.hasOwnProperty('edge')) {
            this.ActiveDraggedObject = obj;
            return true;
        }
        if (this.ActiveDraggedObject != null) {
            e.preventDefault();
            return true;
        }
        return false;
    }
    insertNode() {
        const id = this.findNodeID();
        const node = new Node(id);
        this._graph.addNode(node);
        new DrawingNode(node); // it would create the default drawing attribute: TODO: keep a customizable attribute here
        const vn = this.viewer.createIViewerNodeN(node, this.mouseDownGraphPoint);
        this.viewer.addNode(vn, true);
    }
    findNodeID() {
        let i = 0;
        let id = 'node' + i.toString();
        while (this._graph.findNode(id)) {
            id = 'node' + ++i;
        }
        return id;
    }
    viewerMouseMove(sender, e) {
        if (!this.viewer.layoutEditingEnabled) {
            return;
        }
        if (LayoutEditor.LeftButtonIsPressed(e)) {
            if (this.ActiveDraggedObject != null || this.activeCornerSite != null) {
                this.drag(e);
            }
            else if (this.insertingEdge) {
                //e.preventDefault()
                //e.stopImmediatePropagation()
                this.mouseMoveInsertEdgeLeftButtonOn(e);
            }
            else {
                this.MouseMoveLiveSelectObjectsForDragging(e);
            }
        }
        else if (this.insertingEdge) {
            this.mouseMoveInsertEdgeNoButtons(e);
        }
    }
    setDraggingFlag(e) {
        if (!this.dragging && this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {
            this.dragging = true;
        }
    }
    TrySetNodePort(e, nodeWrapper, portWr, loosePolylineWrapper) {
        if (this.graph == null)
            return;
        Assert.assert(this.insertingEdge);
        const mousePos = this.viewer.screenToSource(e);
        loosePolylineWrapper.loosePolyline = null;
        if (this.DraggingStraightLine()) {
            nodeWrapper.node = this.setPortWhenDraggingStraightLine(portWr, mousePos);
        }
        else {
            if (this.interactiveEdgeRouter == null) {
                this.PrepareForEdgeDragging();
            }
            loosePolylineWrapper.loosePolyline = this.interactiveEdgeRouter.GetHitLoosePolyline(mousePos);
            if (loosePolylineWrapper.loosePolyline != null) {
                this.SetPortUnderLoosePolyline(mousePos, loosePolylineWrapper.loosePolyline, nodeWrapper, portWr);
            }
            else {
                nodeWrapper.node = null;
                portWr.port = null;
            }
        }
        return portWr.port != null;
    }
    setPortWhenDraggingStraightLine(portWr, mousePos) {
        if (isIViewerNode(this.viewer.objectUnderMouseCursor)) {
            const viewerNode = this.viewer.objectUnderMouseCursor;
            const t = { portParameter: 0 };
            const geomNode = geomObjFromIViewerObj(viewerNode);
            if (this.NeedToCreateBoundaryPort(mousePos, viewerNode, t)) {
                portWr.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, portWr.port);
            }
            else if (LayoutEditor.PointIsInside(mousePos, geomNode.boundaryCurve)) {
                portWr.port = this.CreateFloatingPort(geomNode, mousePos);
            }
            else {
                portWr.port = null;
            }
            return viewerNode;
        }
        portWr.port = null;
        return null;
    }
    CreateOrUpdateCurvePort(t, geomNode, port) {
        const isCp = port instanceof CurvePort;
        if (!isCp) {
            return CurvePort.mk(geomNode.boundaryCurve, t);
        }
        const cp = port;
        cp.parameter = t;
        cp.curve = geomNode.boundaryCurve;
        return port;
    }
    CreateFloatingPort(geomNode, location) {
        return new FloatingPort(geomNode.boundaryCurve, location);
    }
    SetPortUnderLoosePolyline(mousePos, loosePoly, nodeWr, portWrap) {
        let dist = Number.POSITIVE_INFINITY;
        let par = 0;
        for (const viewerNode of this.GetViewerNodesInsideOfLooseObstacle(loosePoly)) {
            const curve = viewerNode.entity.getAttr(AttributeRegistry.GeomObjectIndex).boundaryCurve;
            if (LayoutEditor.PointIsInside(mousePos, curve)) {
                nodeWr.node = viewerNode;
                this.SetPortForMousePositionInsideOfNode(mousePos, nodeWr.node, portWrap);
                return;
            }
            const p = curve.closestParameter(mousePos);
            const d = curve.value(p).sub(mousePos).length;
            if (d < dist) {
                par = p;
                dist = d;
                nodeWr.node = viewerNode;
            }
        }
        portWrap.port = this.CreateOrUpdateCurvePort(par, geomObjFromIViewerObj(nodeWr.node), portWrap.port);
    }
    GetViewerNodesInsideOfLooseObstacle(loosePoly) {
        if (this.looseObstaclesToTheirViewerNodes == null) {
            this.InitLooseObstaclesToViewerNodeMap();
        }
        const ret = this.looseObstaclesToTheirViewerNodes.get(loosePoly);
        return ret;
    }
    InitLooseObstaclesToViewerNodeMap() {
        this.looseObstaclesToTheirViewerNodes = new Map();
        for (const viewerNode of this.ViewerNodes()) {
            const loosePoly = this.interactiveEdgeRouter.GetHitLoosePolyline(geomObjFromIViewerObj(viewerNode).center);
            let loosePolyNodes = this.looseObstaclesToTheirViewerNodes.get(loosePoly);
            if (loosePolyNodes == undefined) {
                this.looseObstaclesToTheirViewerNodes.set(loosePoly, (loosePolyNodes = new Array()));
            }
            loosePolyNodes.push(viewerNode);
        }
    }
    SetPortForMousePositionInsideOfNode(mousePosition, node, port) {
        const geomNode = geomObjFromIViewerObj(node);
        const t = { portParameter: 0 };
        if (this.NeedToCreateBoundaryPort(mousePosition, node, t)) {
            port.port = this.CreateOrUpdateCurvePort(t.portParameter, geomNode, port.port);
        }
        else {
            port.port = this.CreateFloatingPort(geomNode, mousePosition);
        }
    }
    static PointIsInside(point, iCurve) {
        return Curve.PointRelativeToCurveLocation(point, iCurve) == PointLocation.Inside;
    }
    NeedToCreateBoundaryPort(mousePoint, node, t) {
        const drawingNode = node.entity.getAttr(AttributeRegistry.DrawingObjectIndex);
        const curve = geomObjFromIViewerObj(node).boundaryCurve;
        t.portParameter = curve.closestParameter(mousePoint);
        const pointOnCurve = curve.value(t.portParameter);
        const length = mousePoint.sub(pointOnCurve).length;
        if (length <= this.viewer.smoothedPolylineCircleRadius * 2 + drawingNode.penwidth / 2) {
            this.TryToSnapToTheSegmentEnd(t, curve, pointOnCurve);
            return true;
        }
        return false;
    }
    TryToSnapToTheSegmentEnd(t, c, pointOnCurve) {
        if (c instanceof Curve) {
            const sipar = c.getSegIndexParam(t.portParameter);
            const segPar = sipar.par;
            const seg = c.segs[sipar.segIndex];
            if (segPar - seg.parStart < seg.parEnd - segPar) {
                if (seg.start.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {
                    t.portParameter -= segPar - seg.parStart;
                }
                else if (seg.end.sub(pointOnCurve).length < this.viewer.smoothedPolylineCircleRadius * 2) {
                    t.portParameter += +(seg.parEnd - segPar);
                }
            }
        }
    }
    drag(e) {
        if (!this.dragging) {
            if (this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(e)) {
                this.prepareFirstTimeDragging();
            }
            else {
                // the mouse has not moved enough
                return;
            }
        }
        const currentDragPoint = this.viewer.screenToSource(e);
        this.handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint);
        this.geomGraphEditor.drag(currentDragPoint.sub(this._lastDragPoint), this.GetDraggingMode(), this._lastDragPoint);
        for (const affectedObject of this.geomGraphEditor.entitiesToBeChangedByUndo()) {
            this.invalidate(affectedObject);
        }
        e.stopPropagation();
        this._lastDragPoint = currentDragPoint;
    }
    prepareFirstTimeDragging() {
        this.dragging = true;
        // first time we are in dragging
        if (this.activeCornerSite != null) {
            this.geomGraphEditor.prepareForGeomEdgeChange(this.edgeWithSmoothedPolylineExposed.edge.getAttr(AttributeRegistry.GeomObjectIndex));
        }
        else if (this.ActiveDraggedObject != null) {
            this.unselectEdge();
            if (!this.ActiveDraggedObject.markedForDragging) {
                this.unselectEverything();
            }
            this.prepareForDragging();
        }
        this._lastDragPoint = this.mouseDownGraphPoint;
    }
    handleTheMouseCursorOutOfTheBoundingBox(currentDragPoint) {
        const w = this.viewer.smoothedPolylineCircleRadius; // some rather small but still visible distance on the screen
        const mousePointerBox = Rectangle.mkSizeCenter(new Size(w, w), currentDragPoint);
        const g = GeomGraph.getGeom(this._graph);
        if (!g.boundingBox.containsRect(mousePointerBox)) {
            this.geomGraphEditor.registerForUndo(this._graph);
            g.boundingBox = g.boundingBox.addRec(mousePointerBox);
            this.invalidate(this._graph);
        }
    }
    prepareForDragging() {
        this.selectObjectForDragging(this.ActiveDraggedObject);
        this.geomGraphEditor.prepareForObjectDragging(this.DraggedGeomObjects(), this.GetDraggingMode());
        //  const currentUndoRedo = this.undoAction
        // for (const g of this.geomGraphEditor.objectsToDrag) {
        //   currentUndoRedo.AddAffectedObject(g.entity.getAttr(AttributeRegistry.ViewerIndex))
        //   currentUndoRedo.AddRestoreData(g.entity, getRestoreData(g.entity))
        // }
    }
    GetDraggingMode() {
        const incremental = (this.viewer.modifierKeys & ModifierKeysEnum.Shift) == ModifierKeysEnum.Shift || this.viewer.IncrementalDraggingModeAlways;
        return incremental ? DraggingMode.Incremental : DraggingMode.Default;
    }
    static RouteEdgesRectilinearly(viewer) {
        const geomGraph = viewer.graph.getAttr(AttributeRegistry.GeomObjectIndex);
        const settings = geomGraph.layoutSettings;
        RectilinearInteractiveEditor.CreatePortsAndRouteEdges(settings.commonSettings.NodeSeparation / 3, 1, geomGraph.nodesBreadthFirst, geomGraph.deepEdges, settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode);
        const labelPlacer = EdgeLabelPlacement.constructorG(geomGraph);
        labelPlacer.run();
    }
    *DraggedGeomObjects() {
        // restrict the dragged elements to be under the same cluster
        const activeObjCluster = LayoutEditor.GetActiveObjectCluster(this.ActiveDraggedObject);
        for (const draggObj of this.dragGroup) {
            if (LayoutEditor.GetActiveObjectCluster(draggObj) == activeObjCluster) {
                yield GeomObject.getGeom(draggObj.entity);
            }
        }
    }
    static GetActiveObjectCluster(viewerObject) {
        return viewerObject.entity.parent;
    }
    viewerMouseUp(sender, args) {
        if (args.defaultPrevented) {
            return;
        }
        if (!this.viewer.layoutEditingEnabled) {
            return;
        }
        this.handleMouseUpOnLayoutEnabled(args);
    }
    handleMouseUpOnLayoutEnabled(args) {
        const click = !this.MouseDownPointAndMouseUpPointsAreFarEnoughOnScreen(args);
        if (click && this.leftMouseButtonWasPressed) {
            if (this.viewer.objectUnderMouseCursor != null || this.edgeWithSmoothedPolylineExposed != null) {
                this.analyzeLeftMouseButtonClick(args);
                args.preventDefault();
            }
            else {
                this.unselectEverything();
            }
        }
        else if (this.dragging) {
            if (!this.insertingEdge) {
                this.geomGraphEditor.updateDeltaForDragUndo(this.mouseDownGraphPoint.sub(this._lastDragPoint));
                this.interactiveEdgeRouter = null;
                this.looseObstaclesToTheirViewerNodes = null;
            }
            else {
                this.InsertEdgeOnMouseUp();
            }
            const gg = GeomGraph.getGeom(this._graph);
            const newBox = gg.getPumpedGraphWithMarginsBox();
            if (!newBox.equal(gg.boundingBox)) {
                this.geomGraphEditor.registerForUndo(this._graph);
                gg.boundingBox = newBox;
                this.invalidate(this._graph);
                args.preventDefault();
            }
        }
        this.dragging = false;
        this.geomGraphEditor.ForgetDragging();
        this.activeCornerSite = null;
        this.ActiveDraggedObject = null;
        this.leftMouseButtonWasPressed = false;
        if (this.TargetPort != null) {
            this.viewer.RemoveTargetPortEdgeRouting();
        }
        if (this.SourcePort != null) {
            this.viewer.RemoveSourcePortEdgeRouting();
        }
        this.TargetOfInsertedEdge = null;
        this.SourceOfInsertedEdge = null;
        this.TargetPort = null;
        this.SourcePort = null;
    }
    InsertEdgeOnMouseUp() {
        this.viewer.stopDrawingRubberEdge();
        if (this.TargetPort != null) {
            const e = this.FinishRoutingEdge();
            this.addEdgeToTheViewer(e);
        }
        this.interactiveEdgeRouter.Clean();
    }
    addEdgeToTheViewer(e) {
        const vEdge = this.viewer.createEdgeWithGivenGeometry(e);
        this.viewer.addEdge(vEdge, true);
    }
    mkArrowhead() {
        const arr = new Arrowhead();
        arr.length = this.arrowheadLength;
        return arr;
    }
    FinishRoutingEdge() {
        const e = new Edge(this.sourceOfInsertedEdgeWrap.node.entity, this.targetOfInsertedEdgeWrap.node.entity);
        e.add();
        const edgeAttr = this.EdgeAttr.clone();
        edgeAttr.rebind(e);
        this.geomEdge.rebind(e);
        this.geomEdge.sourceArrowhead = edgeAttr.arrowtail == ArrowTypeEnum.none ? null : this.mkArrowhead();
        this.geomEdge.targetArrowhead = edgeAttr.arrowhead == ArrowTypeEnum.none ? null : this.mkArrowhead();
        if (this.TargetOfInsertedEdge != this.SourceOfInsertedEdge) {
            if (!(this.geomEdge.curve instanceof LineSegment)) {
                this.interactiveEdgeRouter.TryToRemoveInflectionsAndCollinearSegments(this.geomEdge.smoothedPolyline);
                this.interactiveEdgeRouter.SmoothenCorners(this.geomEdge.smoothedPolyline);
                this.geomEdge.curve = this.geomEdge.smoothedPolyline.createCurve();
            }
            Arrowhead.trimSplineAndCalculateArrowheads(this.geomEdge, this.geomEdge.curve, true);
        }
        else {
            this.geomEdge = LayoutEditor.CreateEdgeGeometryForSelfEdge(this.SourceOfInsertedEdge.entity);
        }
        this.viewer.RemoveSourcePortEdgeRouting();
        this.viewer.RemoveTargetPortEdgeRouting();
        return e;
    }
    static CreateEdgeGeometryForSelfEdge(node) {
        const edge = new Edge(node, node);
        const geomEdge = new GeomEdge(edge);
        StraightLineEdges.CreateSimpleEdgeCurveWithUnderlyingPolyline(geomEdge);
        return geomEdge;
    }
    SelectEntitiesForDraggingWithRectangle(args) {
        /*
        const rect = Rectangle.mkPP(this.mouseDownGraphPoint, this.viewer.ScreenToSource(args))
        for (const node of this.ViewerNodes()) {
          if (rect.intersects(geomNodeOfIViewerNode(node).boundingBox)) {
            this.selectObjectForDragging(node)
          }
        }
        if (rect.width > 0) {
          args.stopImmediatePropagation()
        }*/
    }
    /** it also sets this.activeCornerSite */
    mouseIsInsideOfCornerSite(e) {
        const p = this.viewer.screenToSource(e);
        const lw = this.edgeWithSmoothedPolylineExposed.edge.getAttr(AttributeRegistry.DrawingObjectIndex).penwidth;
        this.activeCornerSite = GeometryGraphEditor.findClosestCornerForEdit(GeomEdge.getGeom(this.edgeWithSmoothedPolylineExposed.edge).smoothedPolyline, p, this.edgeWithSmoothedPolylineExposed.radiusOfPolylineCorner + lw);
        return this.activeCornerSite !== null;
    }
    MouseScreenPointIsCloseEnoughToVertex(point, radius) {
        return point.sub(this.mouseDownGraphPoint).length < radius;
    }
    invalidate(ent) {
        const vo = viewerObj(ent);
        if (!vo)
            return;
        if (vo.entity instanceof Label) {
            if (vo.markedForDragging) {
                const geomLabel = GeomObject.getGeom(vo.entity);
                GeometryGraphEditor.calculateAttachmentSegment(geomLabel);
            }
        }
        else {
            if (vo.entity instanceof Edge) {
                if (vo.entity.label) {
                    this.viewer.invalidate(viewerObj(vo.entity.label));
                }
            }
        }
        this.viewer.invalidate(vo);
        if (ent instanceof Graph) {
            for (const n of ent.nodesBreadthFirst) {
                this.viewer.invalidate(viewerObj(n));
            }
            for (const e of ent.deepEdges) {
                this.viewer.invalidate(viewerObj(e));
                if (e.label)
                    this.viewer.invalidate(viewerObj(e.label));
            }
        }
    }
    /**   Undoes the editing*/
    undo() {
        if (this.geomGraphEditor.canUndo) {
            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByUndo());
            this.geomGraphEditor.undo();
            for (const o of objectsToInvalidate) {
                const vo = viewerObj(o);
                if (vo.markedForDragging) {
                    this.dragGroup.add(vo);
                }
                else {
                    this.dragGroup.delete(vo);
                }
                this.invalidate(o);
            }
        }
    }
    /**   Redo the editing*/
    redo() {
        if (this.geomGraphEditor.canRedo) {
            const objectsToInvalidate = new Set(this.geomGraphEditor.entitiesToBeChangedByRedo());
            this.geomGraphEditor.redo();
            for (const o of objectsToInvalidate) {
                const vo = viewerObj(o);
                if (vo.markedForDragging) {
                    this.dragGroup.add(vo);
                }
                else {
                    this.dragGroup.delete(vo);
                }
                this.invalidate(o);
            }
        }
    }
    // //  Clear the editor
    //  Clear() {
    //     this.UnselectEverything();
    // }
    // //  Finds a corner to delete or insert
    // //  <returns>null if a corner is not found</returns>
    // // //  create a tight bounding box for the graph
    // //  FitGraphBoundingBox(graphToFit: IViewerObject) {
    // //     if ((graphToFit != null)) {
    // //         this.geomGraphEditor.FitGraphBoundingBox(graphToFit, (<GeometryGraph>(graphToFit.DrawingObject.GeomObject)));
    // //         this.invalidate();
    // //     }
    // // }
    // // //
    // //  RegisterNodeAdditionForUndo(node: IViewerNode) {
    // //     let undoAction = new AddNodeUndoAction(this.graph, this.viewer, node);
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(undoAction);
    // // }
    // // //  registers the edge addition for undo
    // //  RegisterEdgeAdditionForUndo(edge: IViewerEdge) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new AddEdgeUndoAction(this.viewer, edge));
    // // }
    // // //
    // //  RegisterEdgeRemovalForUndo(edge: IViewerEdge) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveEdgeUndoAction(this.graph, this.viewer, edge));
    // // }
    // // //
    // //  RegisterNodeForRemoval(node: IViewerNode) {
    // //     this.geomGraphEditor.InsertToListAndSetTheBoxBefore(new RemoveNodeUndoAction(this.viewer, node));
    // // }
    static RectRouting(mode) {
        return mode == EdgeRoutingMode.Rectilinear || mode == EdgeRoutingMode.RectilinearToCenter;
    }
    // // EnumerateNodeBoundaryCurves(): IterableIterator<ICurve> {
    // //     return from;
    // //     vn;
    // //     this.ViewerNodes();
    // //     let GeomNode: select;
    // //     vn.BoundaryCurve;
    // // }
    // //  ForgetEdgeDragging() {
    // //     if ((this.viewer.Graph == null)) {
    // //         return;
    // //     }
    // //     if (this.DraggingStraightLine()) {
    // //         return;
    // //     }
    // //     if (!LayoutEditor.RectRouting(this.viewer.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.EdgeRoutingMode)) {
    // //         InteractiveEdgeRouter = null;
    // //         this.looseObstaclesToTheirViewerNodes = null;
    // //     }
    // // }
    //  prepares for edge dragging
    PrepareForEdgeDragging() {
        if (this.viewer.graph == null) {
            return;
        }
        if (this.DraggingStraightLine()) {
            return;
        }
        const settings = GeomGraph.getGeom(this.viewer.graph).layoutSettings;
        if (!LayoutEditor.RectRouting(settings.commonSettings.edgeRoutingSettings.EdgeRoutingMode)) {
            if (this.interactiveEdgeRouter == null) {
                const padding = settings.commonSettings.NodeSeparation / 3;
                const loosePadding = 0.65 * padding;
                this.interactiveEdgeRouter = InteractiveEdgeRouter.constructorANNN(Array.from(this._graph.nodesBreadthFirst).map((n) => GeomNode.getGeom(n).boundaryCurve), padding, loosePadding, 0);
            }
        }
    }
    // // //  insert a polyline corner at the point befor the prevCorner
    // //  InsertPolylineCorner(point: Point, previousCorner: CornerSite) {
    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, point, previousCorner, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // // }
    // // InsertPolylineCorner() {
    // //     this.geomGraphEditor.InsertSite(this.SelectedEdge.edge.GeometryEdge, this.mouseRightButtonDownPoint, this.cornerInfo.Item1, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // // }
    // // //  delete the polyline corner, shortcut it.
    // //  DeleteCorner(corner: CornerSite) {
    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, corner, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // //     this.viewer.OnDragEnd([
    // //                 this.SelectedEdge]);
    // // }
    // // DeleteCorner() {
    // //     this.geomGraphEditor.DeleteSite(this.SelectedEdge.edge.GeometryEdge, this.cornerInfo.Item1, this.SelectedEdge);
    // //     this.invalidate(this.SelectedEdge);
    // //     this.viewer.OnDragEnd([
    // //                 this.SelectedEdge]);
    // // }
    mouseMoveInsertEdgeNoButtons(e) {
        const oldNode = this.SourceOfInsertedEdge;
        if (this.TrySetNodePort(e, this.sourceOfInsertedEdgeWrap, this.sourcePortWrap, this.sourceLoosePolylineWrap)) {
            this.viewer.SetSourcePortForEdgeRouting(this.sourcePortWrap.port.Location);
        }
        else if (oldNode != null) {
            this.viewer.RemoveSourcePortEdgeRouting();
        }
    }
    mouseMoveInsertEdgeLeftButtonOn(e) {
        if (this.SourcePort != null) {
            this.setDraggingFlag(e);
            if (this.dragging) {
                const loosePolylineWr = { loosePolyline: null };
                if (this.TrySetNodePort(e, this.targetOfInsertedEdgeWrap, this.targetPortWrap, loosePolylineWr)) {
                    this.viewer.setTargetPortForEdgeRouting(this.targetPortWrap.port.Location);
                    this.drawEdgeInteractivelyToPort(loosePolylineWr.loosePolyline, this.DraggingStraightLine());
                }
                else {
                    this.viewer.RemoveTargetPortEdgeRouting();
                    this.DrawEdgeInteractivelyToLocation(e, this.DraggingStraightLine());
                }
            }
            e.preventDefault();
        }
    }
    MouseMoveLiveSelectObjectsForDragging(e) {
        this.unselectEverything();
        if (LeftMouseIsPressed(e) && (this.viewer.modifierKeys & ModifierKeysEnum.Shift) != ModifierKeysEnum.Shift) {
            this.SelectEntitiesForDraggingWithRectangle(e);
        }
    }
    DrawEdgeInteractivelyToLocation(e, straightLine) {
        this.DrawEdgeInteractivelyToLocationP(this.viewer.screenToSource(e), straightLine);
    }
    DrawEdgeInteractivelyToLocationP(point, straightLine) {
        this.geomEdge = straightLine ? this.getStraightLineEdge(point) : this.CalculateEdgeInteractivelyToLocation(point);
        this.viewer.drawRubberEdge(this.geomEdge);
    }
    getStraightLineEdge(point) {
        const g = new GeomEdge(null);
        g.curve = LineSegment.mkPP(this.SourcePort.Location, point);
        return g;
    }
    CalculateEdgeInteractivelyToLocation(location) {
        if (this.interactiveEdgeRouter.SourcePort == null) {
            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);
        }
        return this.interactiveEdgeRouter.RouteEdgeToLocation(location);
    }
    drawEdgeInteractivelyToPort(portLoosePolyline, straightLine) {
        this.geomEdge = straightLine
            ? this.getStraightLineEdge(this.TargetPort.Location)
            : this.CalculateEdgeInteractively(this.TargetPort, portLoosePolyline);
        this.viewer.drawRubberEdge(this.geomEdge);
    }
    DraggingStraightLine() {
        if (this.viewer.graph == null) {
            return true;
        }
        return this.interactiveEdgeRouter != null && this.interactiveEdgeRouter.OverlapsDetected;
    }
    CalculateEdgeInteractively(targetPortParameter, portLoosePolyline) {
        if (this.interactiveEdgeRouter.SourcePort == null) {
            this.interactiveEdgeRouter.SetSourcePortAndSourceLoosePolyline(this.SourcePort, this.sourceLoosePolylineWrap.loosePolyline);
        }
        let curve;
        let smoothedPolyline = null;
        if (this.SourceOfInsertedEdge == this.TargetOfInsertedEdge) {
            curve = LineSegment.mkPP(this.SourcePort.Location, this.TargetPort.Location);
        }
        else {
            const boxedPolyline = { smoothedPolyline: null };
            curve = this.interactiveEdgeRouter.RouteEdgeToPort(targetPortParameter, portLoosePolyline, false, boxedPolyline);
            smoothedPolyline = boxedPolyline.smoothedPolyline;
        }
        const ret = new GeomEdge(null);
        ret.curve = curve;
        ret.smoothedPolyline = smoothedPolyline;
        return ret;
    }
}
// //  ScaleNodeAroundCenter(viewerNode: IViewerNode, scale: number) {
// //     let nodePosition = viewerNode.node.BoundingBox.Center;
// //     let scaleMatrix = new PlaneTransformation(scale, 0, 0, 0, scale, 0);
// //     let translateToOrigin = new PlaneTransformation(1, 0, (nodePosition.X * -1), 0, 1, (nodePosition.Y * -1));
// //     let translateToNode = new PlaneTransformation(1, 0, nodePosition.X, 0, 1, nodePosition.Y);
// //     let matrix = (translateToNode
// //                 * (scaleMatrix * translateToOrigin));
// //     viewerNode.node.GeomNode.BoundaryCurve = viewerNode.node.GeomNode.BoundaryCurve.Transform(matrix);
// //     this.invalidate(viewerNode);
// //     for (let edge of viewerNode.OutEdges.Concat(viewerNode.InEdges).Concat(viewerNode.SelfEdges)) {
// //         this.RecoverEdge(edge);
// //     }
// // }
// // RecoverEdge(edge: IViewerEdge) {
// //     let curve = edge.edge.GeometryEdge.UnderlyingPolyline.CreateCurve();
// //     Arrowheads.TrimSplineAndCalculateArrowheads(edge.edge.GeometryEdge, curve, true, this.Graph.LayoutAlgorithmSettings.EdgeRoutingSettings.KeepOriginalSpline);
// //     this.invalidate(edge);
// // }
// // //
// //  DetachNode(node: IViewerNode) {
// //     if ((node == null)) {
// //         return;
// //     }
// //     this.decoratorRemovalsDict.Remove(node);
// //     for (let edge of LayoutEditor.Edges(node)) {
// //         this.RemoveObjDraggingDecorations(edge);
// //     }
// // }
// }
function LeftMouseIsPressed(e) {
    return (e.buttons & 1) == 1;
}
//# sourceMappingURL=layoutEditor.js.map