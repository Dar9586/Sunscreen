import { Edge } from './edge';
import { Entity } from './entity';
import { Node } from './node';
/** This class keeps the connection between the nodes and the edges of the graph. The nodes of a Graph can also be Graphs.  */
export declare class Graph extends Node {
    remove(node: Node): void;
    /** Removes itself from under the parent.
     *  Also removes all the edges leading out of the graph.
     */
    removeSubgraph(): void;
    /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
    outGoingEdges(): IterableIterator<{
        edge: Edge;
        node: Node;
        attachedAtSource: boolean;
    }>;
    isAncestor(entity: Entity): boolean;
    /**  Iterates over all connected components of the graph and for each component
     * returns all its nodes with "this" as the parent
     */
    getClusteredConnectedComponents(): IterableIterator<Array<Node>>;
    private reachableFrom;
    hasSomeAttrOnIndex(index: number): boolean;
    graphs(): IterableIterator<Graph>;
    noEmptySubgraphs(): boolean;
    hasSubgraphs(): boolean;
    /** iterates breadth first  */
    subgraphsBreadthFirst(): IterableIterator<Graph>;
    isEmpty(): boolean;
    setEdge(sourceId: string, targetId: string): Edge;
    /** Iterates over the nodes of the current graph but not entering the subgraphs.
     *  Yields the top subgraphs among the nodes as well
     */
    get shallowNodes(): IterableIterator<Node>;
    /** Iterates over all the nodes of including the subgraphs.
     * The iteration happens in the breadth first pattern.
     */
    get nodesBreadthFirst(): IterableIterator<Node>;
    /** iterates breadth first  */
    private nodesBreadthFirst_;
    constructor(id?: string);
    /**
     * Finds the node with the givin id belonging to a graph or one of its subgraphs.
     */
    findNodeRecursive(id: string): Node;
    /** Returns a node belonging to this graph having the same id.
     * If a node with the given id belongs to a subgraph than it would no be returned.
     * To find such a deeper nested node use findNodeRecursive
     */
    findNode(id: string): Node;
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    get shallowEdges(): IterableIterator<Edge>;
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges(): IterableIterator<Edge>;
    private deepEdgesIt;
    isConsistent(): boolean;
    nodeIsConsistent(n: Node): boolean;
    /** Detouches all the node's edges and removes the node from the graph.
     * This method does not change the parent of the node.
     */
    removeNode(node: Node): void;
    /** adds a node to the graph */
    addNode(n: Node): Node;
    private nodeCollection;
    get shallowNodeCount(): number;
    get nodeCountDeep(): number;
    get edgeCount(): number;
    liftNode(n: Node): Node;
    /** return the number of all edges in the graph, including the subgraphs */
    get deepEdgesCount(): number;
    eachNodeIdIsUnique(): boolean;
    /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
    allElements(): IterableIterator<Entity>;
    allSuccessorsWidthFirst(): IterableIterator<Node>;
    allSuccessorsDepthFirst(): IterableIterator<Node>;
}
export declare function shallowConnectedComponents(graph: Graph): IterableIterator<Node[]>;
/** sets a new Graph as the parent of the node */
export declare function setNewParent(newParent: Graph, node: Node): void;
/** implements the google PageRank.
 * omega is the probability of following a link
 * */
export declare function pagerank(graph: Graph, omega: number): Map<Node, number>;
export declare function edgeNodesBelongToSet(e: Edge, s: Set<Node>): boolean;
