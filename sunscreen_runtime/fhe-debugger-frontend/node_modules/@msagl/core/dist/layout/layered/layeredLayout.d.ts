import { BasicGraph } from '../../structs/BasicGraph';
import { Algorithm } from '../../utils/algorithm';
import { PolyIntEdge } from './polyIntEdge';
import { SugiyamaLayoutSettings } from './sugiyamaLayoutSettings';
import { GeomNode } from '../core/geomNode';
import { Database } from './Database';
import { LayerArrays } from './LayerArrays';
import { GeomGraph } from '../core/geomGraph';
import { CancelToken } from '../../utils/cancelToken';
import { LayerCalculator } from './layering/layerCalculator';
import { ConstrainedOrdering } from './ordering/constrainedOrdering';
import { ProperLayeredGraph } from './ProperLayeredGraph';
import { Anchor } from './anchor';
import { XLayoutGraph } from './xLayoutGraph';
/** Executes the layered layout following the Sugiyama Scheme.
 * Cancel token allows to cancel the layout run(is ignored by now).
 * If "transformToScreen" is true then the y-coordinate of the graph will be reversed:
 * and the graph will be positioned in the first quadrand with left-bottom = (0,0)
 */
export declare function layoutGraphWithSugiayma(geomGraph: GeomGraph, cancelToken: CancelToken, transformToScreen: boolean): void;
export declare class LayeredLayout extends Algorithm {
    originalGraph: GeomGraph;
    sugiyamaSettings: SugiyamaLayoutSettings;
    nodeIdToIndex: Map<string, number>;
    IntGraph: BasicGraph<GeomNode, PolyIntEdge>;
    database: Database;
    engineLayerArrays: LayerArrays;
    gluedDagSkeletonForLayering: BasicGraph<GeomNode, PolyIntEdge>;
    constrainedOrdering: ConstrainedOrdering;
    properLayeredGraph: ProperLayeredGraph;
    LayersAreDoubled: boolean;
    anchors: Anchor[];
    xLayoutGraph: XLayoutGraph;
    /** return true if the ratio is less than 1/50 or greater than 50 */
    get extremeAspectRatio(): boolean;
    get verticalConstraints(): import("./verticalConstraintsForSugiyama").VerticalConstraintsForSugiyama;
    get HorizontalConstraints(): import("./HorizontalConstraintsForSugiyama").HorizontalConstraintsForSugiyama;
    constructor(originalGraph: GeomGraph, settings: SugiyamaLayoutSettings, cancelToken: CancelToken);
    run(): void;
    runPostLayering(): void;
    SetLabels(): void;
    cycleRemoval(): void;
    calculateLayers(): LayerArrays;
    UpdateNodePositionData(): void;
    SnapLeftSidesOfTheNodeToGrid(i: number, gridSize: number): void;
    GetCurrentHeight(): number;
    NodeAnchors(): IterableIterator<Anchor>;
    GetCurrentWidth(): number;
    ExtendLayeringToUngluedSameLayerVertices(p: number[]): number[];
    calculateEdgeSplines(): void;
    YLayeringAndOrdering(layering: LayerCalculator): LayerArrays;
    CreateProperLayeredGraph(layering: number[]): LayerArrays;
    YLayeringAndOrderingWithoutHorizontalConstraints(layerArraysIn: LayerArrays): LayerArrays;
    CalculateYLayers(): LayerArrays;
    InsertLayersIfNeeded(layerArrays: LayerArrays): LayerArrays;
    RecreateIntGraphFromDataBase(): void;
    InsertVirtualEdgesIfNeeded(layerArrays: LayerArrays): void;
    AnalyzeNeedToInsertLayersAndHasMultiedges(layerArrays: LayerArrays): {
        needToInsertLayers: boolean;
        multipleEdges: boolean;
    };
    UseBrandesXCalculations(layerArrays: LayerArrays): boolean;
    CalculateAnchorsAndYPositions(layerArrays: LayerArrays): void;
    OptimizeEdgeLabelsLocations(): void;
    GetSuccessorAndPredecessor(i: number): {
        predecessor: Anchor;
        successor: Anchor;
    };
    CalculateLayerArrays(): LayerArrays;
    StretchToDesiredAspectRatio(aspectRatio: number, desiredAR: number): void;
    StretchInYDirection(scaleFactor: number): void;
    StretchInXDirection(scaleFactor: number): void;
    CalculateOriginalGraphBox(): void;
    StraightensShortEdges(): void;
    StraightenEdgePaths(): boolean;
    ShiftVertexWithNeighbors(u: number, i: number, v: number): boolean;
    TryShiftToTheLeft(x: number, v: number): boolean;
    TryShiftToTheRight(x: number, v: number): boolean;
    CalculateXLayersByGansnerNorth(layerArrays: LayerArrays): void;
    CalculateXLayersByGansnerNorthOnProperLayeredGraph(): void;
    CreateXLayoutGraph(layerArrays: LayerArrays): XLayoutGraph;
    CalculateXPositionsByBrandes(layerArrays: LayerArrays): void;
    GluedDagSkeletonEdges(): PolyIntEdge[];
    static CalcAnchorsForOriginalNode(i: number, intGraph: BasicGraph<GeomNode, PolyIntEdge>, anchors: Anchor[], database: Database, settings: SugiyamaLayoutSettings): void;
    CreateGluedDagSkeletonForLayering(): void;
    SetGluedEdgesWeights(): void;
    GetNodeCountsOfGluedDag(): number[];
}
