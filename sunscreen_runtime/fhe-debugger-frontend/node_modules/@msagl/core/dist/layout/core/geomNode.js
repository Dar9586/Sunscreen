// A node of a GeomGraph
import { CurveFactory } from './../../math/geometry/curveFactory';
import { GeomObject } from './geomObject';
import { AttributeRegistry } from '../../structs/attributeRegistry';
export class GeomNode extends GeomObject {
    constructor() {
        super(...arguments);
        this.padding = 1;
    }
    /** clones but does not bind to the entity */
    clone() {
        const ret = new GeomNode(null);
        if (this.boundaryCurve)
            ret.boundaryCurve = this.boundaryCurve.clone();
        return ret;
    }
    translate(delta) {
        if (delta.x === 0 && delta.y === 0)
            return;
        this.boundaryCurve.translate(delta);
    }
    toJSON() {
        return { boundaryCurve: this.boundaryCurve, padding: this.padding };
    }
    get node() {
        return this.entity;
    }
    get boundaryCurve() {
        return this._boundaryCurve;
    }
    set boundaryCurve(value) {
        if (value != null &&
            value.boundingBox &&
            (value.boundingBox.height < GeomNode.minHeight || value.boundingBox.width < GeomNode.minWidth)) {
            value = CurveFactory.mkCircle(GeomNode.minWidth, value.boundingBox.center);
        }
        this._boundaryCurve = value;
    }
    get id() {
        return this.node.id;
    }
    toString() {
        return this.id;
    }
    // Creates a Node instance
    static mkNode(curve, node) {
        const n = new GeomNode(node);
        n.boundaryCurve = curve;
        return n;
    }
    // Fields which are set by Msagl
    // return the center of the curve bounding box
    get center() {
        return this.boundaryCurve.boundingBox.center;
    }
    set center(value) {
        const del = value.sub(this.center);
        this.boundaryCurve.translate(del);
    }
    // sets the bounding curve scaled to fit the targetBounds
    fitBoundaryCurveToTarget(targetBounds) {
        if (this.boundaryCurve != null) {
            // RoundedRect is special, rather then simply scaling the geometry we want to keep the corner radii constant
            const radii = CurveFactory.isRoundedRect(this.boundaryCurve);
            if (radii == null) {
                /*Assert.assert(this.boundaryCurve.boundingBox.width > 0)*/
                /*Assert.assert(this.boundaryCurve.boundingBox.height > 0)*/
                const scaleX = targetBounds.width / this.boundaryCurve.boundingBox.width;
                const scaleY = targetBounds.height / this.boundaryCurve.boundingBox.height;
                this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(scaleX, scaleY);
                this.boundaryCurve.translate(targetBounds.center.sub(this.boundaryCurve.boundingBox.center));
            }
            else {
                this.boundaryCurve = CurveFactory.mkRectangleWithRoundedCorners(targetBounds.width, targetBounds.height, radii.radX, radii.radY, targetBounds.center);
            }
        }
    }
    static getGeom(attrCont) {
        return attrCont.getAttr(AttributeRegistry.GeomObjectIndex);
    }
    *inEdges() {
        for (const e of this.node.inEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    *outEdges() {
        for (const e of this.node.outEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    *selfEdges() {
        for (const e of this.node.selfEdges) {
            yield GeomObject.getGeom(e);
        }
    }
    /** creates a new rectangle equal to the padded  */
    get boundingBoxWithPadding() {
        const ret = this.boundingBox.clone();
        ret.pad(this.padding);
        return ret;
    }
    // the bounding box of the node
    get boundingBox() {
        return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;
    }
    set boundingBox(value) {
        if (!this.boundaryCurve) {
            return;
        }
        if (Math.abs(value.width - this.width) < 0.0001 && Math.abs(value.height - this.height) < 0.0001) {
            this.center = value.center;
        }
        else {
            this.fitBoundaryCurveToTarget(value);
        }
    }
    // width of the node does not include the padding
    get width() {
        return this.boundaryCurve.boundingBox.width;
    }
    // height of the node does not including the padding
    get height() {
        return this.boundaryCurve.boundingBox.height;
    }
    transform(t) {
        if (this.boundaryCurve != null) {
            this.boundaryCurve = this.boundaryCurve.transform(t);
        }
    }
    underCollapsedGraph() {
        const graph = this.node.parent;
        if (graph == null)
            return false;
        const gGraph = GeomObject.getGeom(graph);
        if (gGraph == null)
            return false;
        if (gGraph.isCollapsed) {
            return true;
        }
        return gGraph.underCollapsedGraph();
    }
    *getAncestors() {
        for (const g of this.node.getAncestors()) {
            yield GeomObject.getGeom(g);
        }
    }
}
GeomNode.minHeight = 2;
GeomNode.minWidth = 3;
//# sourceMappingURL=geomNode.js.map