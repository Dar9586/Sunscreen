import { Rectangle, Size } from '../../math/geometry/rectangle';
import { Edge } from '../../structs/edge';
import { Point } from '../../math/geometry/point';
import { GeomGraph } from './geomGraph';
import { ICurve, LineSegment } from '../../math/geometry';
import { Tile } from './tile';
import { Node } from '../../structs/node';
/** Represents a part of the curve containing in a tile.
 * One tile can have several parts of clips corresponding to the same curve.
 */
export declare type CurveClip = {
    curve: ICurve;
    edge?: Edge;
};
export declare type ArrowHeadData = {
    tip: Point;
    edge: Edge;
    base: Point;
};
export declare function tileIsEmpty(sd: Tile): boolean;
/** keeps the data needed to render the tile hierarchy */
export declare class TileMap {
    /** stop generating new tiles when the tiles on the level has size that is less than minTileSize :
     * t.width <= this.minTileSize.width && t.height <= this.minTileSize.height
     */
    private minTileSize;
    /** the maximal number visual elements vizible in a tile */
    private tileCapacity;
    /** the tiles of level z is represented by levels[z] */
    private levels;
    private pageRank;
    /** the more rank is the more important the entity is */
    nodeRank: Map<Node, number>;
    nodeIndexInSortedNodes: Map<Node, number>;
    tileSizes: Size[];
    /** retrieves the data for a single tile(x-y-z) */
    getTileData(x: number, y: number, z: number): Tile;
    /** retrieves all the tiles of z-th level */
    getTilesOfLevel(z: number): IterableIterator<{
        x: number;
        y: number;
        data: Tile;
    }>;
    private geomGraph;
    private topLevelTileRect;
    /** geomGraph  - the graph to work with.
     * The topLevelTileRect serves as the only tile of the top level.
     */
    constructor(geomGraph: GeomGraph, topLevelTileRect: Rectangle);
    private getMinTileSize;
    private fillTheLowestLayer;
    /**
     * Creates tilings for levels from 0 to z, including the level z.
     * The method does not necesserely creates all levels until z, but can exit earlier
     *  if all tiles either has size smaller or equal than this.minTileSize or have at most this.tileCapacityMin elements.
     * Returns the number of created levels.
     */
    buildUpToLevel(z: number): number;
    private needToSubdivide;
    setOfNodesOnTheLevel(i: number): Set<Node>;
    regenerateCurveClipsUpToLayer(levelIndex: number, activeNodes: Set<Node>): void;
    private clearCurveClipsInLevelsUpTo;
    regenerateCurveClipsUnderTileUpToLevel(t: Tile, levelIndex: number, activeNodes: Set<Node>): void;
    private removeEmptyTiles;
    regenerateCurveClipsWhenPreviosLayerIsDone(z: number): void;
    private calculateNodeRank;
    private compareByPagerank;
    /** Fills the tiles up to the capacity.
     * Returns the number of inserted node.
     * An edge and its attributes is inserted just after its source and the target are inserted.
     * The nodes are sorted by rank here.  */
    private filterOutEntities;
    /** Goes over all tiles where 'node' had presence and tries to add.
     *  If the above succeeds then all edges leading to the higher ranking nodes added without consulting with tileCapacity. The edge attributes added as well
     */
    private addNodeToLevel;
    private transferDataOfLevelToMap;
    /** It is assumed that the previous level z-1 have been calculated.
     * Returns true if every edge is appears in some tile as the first edge
     */
    private subdivideLevel;
    countClips(z: number): number;
    countCacheClips(z: number): any;
    private getWHOnLevel;
    private subdivideTilesOnLevel;
    private subdivideTile;
    /** returns the updated value of allTilesAreSmall */
    private addSubtilesToLevel;
    private generateSubtilesWithoutTileClips;
    innerClips(curve: ICurve, verticalMiddleLine: LineSegment, horizontalMiddleLine: LineSegment): Array<ICurve>;
    private generateSubTileExceptEdgeClips;
}
