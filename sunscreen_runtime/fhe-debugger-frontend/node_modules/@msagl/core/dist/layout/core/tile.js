import { GeomNode } from './geomNode';
import { GeomLabel } from './geomLabel';
import { Curve } from '../../math/geometry';
import { PointPairMap } from '../../utils/pointPairMap';
import { PointPair } from '../../math/geometry/pointPair';
import { Assert } from '../../utils/assert';
/** keeps the data needed to render a tile, and some fields for optimizations */
export class Tile {
    constructor(rect) {
        this._curveClips = [];
        this.arrowheads = [];
        this.nodes = [];
        this.labels = [];
        this.rect = rect;
        this.bundleTable = new PointPairMap();
    }
    get curveClips() {
        if (this._curveClips.length > 0)
            return this._curveClips;
        return Array.from(this.getBundles())
            .map((b) => b.edges.map((e) => {
            return { curve: b.clip, edge: e };
        }))
            .flat();
    }
    set curveClips(value) {
        this._curveClips = value;
    }
    get cachedClipsLength() {
        return this.bundleTable ? this.bundleTable.size : 0;
    }
    /**
     *
     * returns the array of edges passing through the curve */
    addToBundlesOrFetchFromBundles(s, e, curveToClip) {
        Assert.assert(!(curveToClip instanceof Curve), 'CurveClip.curve is not a Curve');
        const pp = new PointPair(curveToClip.value(s), curveToClip.value(e));
        const bundle = this.bundleTable.get(pp);
        if (bundle) {
            return bundle.edges;
        }
        const ret = [];
        this.bundleTable.set(pp, { clip: curveToClip.trim(s, e), edges: ret });
        return ret;
    }
    findCreateBundle(seg) {
        const pp = new PointPair(seg.start, seg.end);
        const ret = this.bundleTable.get(pp);
        if (ret)
            return ret;
        const b = { clip: seg, edges: new Array() };
        this.bundleTable.set(pp, b);
        return b;
    }
    addCurveClip(cc) {
        Assert.assert(!(cc.curve instanceof Curve), 'CurveClip.curve should not be a Curve!');
        this.findCreateBundle(cc.curve).edges.push(cc.edge);
    }
    *getBundles() {
        yield* this.bundleTable.values();
    }
    get curveBundlesLength() {
        return this.bundleTable.size;
    }
    isEmpty() {
        return this.bundleTable.size == 0 && this.arrowheads.length == 0 && this.nodes.length == 0 && this.labels.length == 0;
    }
    initCurveClips() {
        if (this.bundleTable) {
            this.bundleTable.clear();
        }
        else {
            this.bundleTable = new PointPairMap();
        }
    }
    /** clears all arrays but does not touch this.rect */
    clear() {
        this.arrowheads = [];
        this.nodes = [];
        this.labels = [];
        if (this.bundleTable)
            this.bundleTable.clear();
        else
            this.bundleTable = new PointPairMap();
    }
    /** returns the number of entities that will be rendered for a tile: each bundle is counted as one entity */
    get entityCount() {
        return this.bundleTable.size + this.arrowheads.length + this.labels.length + this.nodes.length;
    }
    addElement(data) {
        if (data instanceof GeomNode) {
            this.nodes.push(data);
        }
        else if (data instanceof GeomLabel) {
            this.labels.push(data);
        }
        else if ('curve' in data) {
            Assert.assert(this.rect.containsRect(data.curve.boundingBox), 'CurveClip.curve is not in tile');
            if (data.curve instanceof Curve) {
                for (const seg of data.curve.segs) {
                    this.addCurveClip({ edge: data.edge, curve: seg });
                }
            }
            else {
                this.addCurveClip(data);
            }
        }
        else {
            this.arrowheads.push(data);
        }
    }
}
//# sourceMappingURL=tile.js.map