import { Graph } from '../../structs/graph';
import { Rectangle, Size } from '../../math/geometry/rectangle';
import { GeomObject } from './geomObject';
import { GeomNode } from './geomNode';
import { GeomEdge } from './geomEdge';
import { PlaneTransformation } from '../../math/geometry/planeTransformation';
import { Point } from '../../math/geometry/point';
import { RTree } from '../../math/geometry/RTree/rTree';
import { ICurve } from '../../math/geometry';
import { IGeomGraph } from '../initialLayout/iGeomGraph';
import { ILayoutSettings } from '../iLayoutSettings';
import { Entity } from '../../structs/entity';
import { Edge } from '../../structs/edge';
import { Node } from '../../structs/node';
import { PointPair } from '../../math/geometry/pointPair';
export declare function optimalPackingRunner(geomGraph: GeomGraph, subGraphs: GeomGraph[]): void;
/** GeomGraph is an attribute on a Graph. The underlying Graph keeps all structural information but GeomGraph holds the geometry data, and the layout settings */
export declare class GeomGraph extends GeomNode {
    beautifyEdges: (activeNodes: Set<Node>) => void;
    isAncestor(source: GeomNode): boolean;
    deepTranslate(delta: Point): void;
    /** The empty space between the graph inner entities and its boundary */
    margins: {
        left: number;
        top: number;
        bottom: number;
        right: number;
    };
    private rrect;
    private _layoutSettings;
    private _labelSize;
    /** The X radius of the rounded rectangle border */
    radX: number;
    /** The Y radius of the rounded rectangle border */
    radY: number;
    /** it is a rather shallow clone */
    clone(): GeomGraph;
    /** Calculate bounding box from children, not updating the bounding boxes recursively. */
    calculateBoundsFromChildren(): Rectangle;
    allSuccessorsWidthFirst(): IterableIterator<GeomNode>;
    static getGeom(attrCont: Graph): GeomGraph;
    edgeCurveOrArrowheadsIntersectRect(geomEdge: GeomEdge, rect: Rectangle): boolean;
    isEmpty(): boolean;
    setSettingsRecursively(ls: ILayoutSettings): void;
    get layoutSettings(): ILayoutSettings;
    set layoutSettings(value: ILayoutSettings);
    get labelSize(): Size;
    set labelSize(value: Size);
    get boundingBox(): Rectangle;
    set boundingBox(value: Rectangle);
    transform(matrix: PlaneTransformation): void;
    /** Contrary to the deepTranslate() it also translates edges leading out of the graph */
    translate(delta: Point): void;
    get nodesBreadthFirst(): IterableIterator<GeomNode>;
    private nodesBreadthFirstIter;
    setEdge(s: string, t: string): GeomEdge;
    /** this does not change the graph bounding box */
    getPumpedGraphWithMarginsBox(): Rectangle;
    /** sets the bounding box and the boundary curve as well */
    pumpTheBoxToTheGraphWithMargins(): Rectangle;
    get center(): Point;
    set center(value: Point);
    get left(): number;
    get right(): number;
    get top(): number;
    get bottom(): number;
    CheckClusterConsistency(): boolean;
    get edgeCount(): number;
    get boundaryCurve(): ICurve;
    set boundaryCurve(value: ICurve);
    get shallowNodes(): IterableIterator<GeomNode>;
    shallowNodes_(): IterableIterator<GeomNode>;
    /** iterates over the edges of the graph which adjacent to the nodes of the graph:
     * not iterating over the subgraphs
     */
    /** iterates over the edges of the graph including subgraphs */
    get deepEdges(): IterableIterator<GeomEdge>;
    private deepEdgesIt;
    get shallowEdges(): IterableIterator<GeomEdge>;
    private shallowEdgesIt;
    static mk(id: string, labelSize?: Size): GeomGraph;
    get Clusters(): IterableIterator<IGeomGraph>;
    /** iterates over all subgraphs  */
    subgraphs(): IterableIterator<GeomGraph>;
    static mkWithGraphAndLabel(graph: Graph, labelSize: Size): GeomGraph;
    constructor(graph: Graph);
    get deepNodeCount(): number;
    get subgraphsDepthFirst(): IterableIterator<IGeomGraph>;
    getSubgraphsDepthFirst(): IterableIterator<IGeomGraph>;
    get uniformMargins(): number;
    set uniformMargins(value: number);
    get height(): number;
    get width(): number;
    get shallowNodeCount(): number;
    get graph(): Graph;
    liftNode(n: GeomNode): GeomNode;
    findNode(id: string): GeomNode;
    addNode(gn: GeomNode): GeomNode;
    addLabelToGraphBB(rect: Rectangle): void;
}
export declare function pumpTheBoxToTheGraph(igraph: IGeomGraph, t: {
    b: Rectangle;
}): void;
/** iterate over the graph objects intersected by a rectangle: by default, return only the intersected nodes */
export declare function intersectedObjects(rtree: RTree<Entity, Point>, rect: Rectangle, onlyNodes?: boolean): IterableIterator<Entity>;
export declare function buildRTree(graph: Graph): RTree<Entity, Point>;
declare type PpEdge = {
    edge: Edge;
    pp: PointPair;
};
export declare type HitTreeNodeType = Entity | PpEdge;
export declare function getGeomIntersectedObjects(tree: RTree<HitTreeNodeType, Point>, slack: number, point: Point): IterableIterator<GeomObject>;
export declare function buildRTreeWithInterpolatedEdges(graph: Graph, slack: number): RTree<HitTreeNodeType, Point>;
export {};
