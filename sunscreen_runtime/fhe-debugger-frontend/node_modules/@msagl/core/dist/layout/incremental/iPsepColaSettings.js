import { CommonLayoutSettings } from '../commonLayoutSettings';
import { IPsepCola } from './iPsepCola';
export class IPsepColaSetting {
    constructor() {
        this.commonSettings = new CommonLayoutSettings();
        //  Stop after maxIterations completed
        this.maxIterations = 100;
        this.clusterMargin = 10;
        this.minorIterations = 3;
        this.projectionIterations = 5;
        this.approximateRepulsion = true;
        //  RungaKutta integration potentially gives smoother increments, but is more expensive
        this.RungeKuttaIntegration = false;
        this.initialStepSize = 1.4;
        this.decay = 0.9;
        this.friction = 0.8;
        this.repulsiveForceConstant = 1;
        this.attractiveForceConstant = 1;
        this.gravity = 1;
        this.interComponentForces = true;
        this.applyForces = true;
        //  Avoid overlaps between nodes boundaries, and if there are any
        //  clusters, then between each cluster boundary and nodes that are not
        //  part of that cluster.
        this.AvoidOverlaps = true;
        this.approximateRouting = true;
        this.logScaleEdgeForces = true;
        this.displacementThreshold = 0.1;
        this.maxConstraintLevel = 2;
        this.minConstraintLevel = 0;
        this.attractiveInterClusterForceConstant = 1;
        this.clusterGravity = 1;
        this.commonSettings.NodeSeparation *= 2;
    }
    get edgeRoutingSettings() {
        return this.commonSettings.edgeRoutingSettings;
    }
    set edgeRoutingSettings(value) {
        this.commonSettings.edgeRoutingSettings = value;
    }
    get PackingAspectRatio() {
        return this.commonSettings.PackingAspectRatio;
    }
    set PackingAspectRatio(value) {
        this.commonSettings.PackingAspectRatio = value;
    }
    get NodeSeparation() {
        return this.commonSettings.NodeSeparation;
    }
    set NodeSeparation(value) {
        this.commonSettings.NodeSeparation = value;
    }
    //  Stop after maxIterations completed
    get MaxIterations() {
        return this.maxIterations;
    }
    set MaxIterations(value) {
        this.maxIterations = value;
    }
    //  Number of iterations in inner loop.
    get MinorIterations() {
        return this.minorIterations;
    }
    set MinorIterations(value) {
        this.minorIterations = value;
    }
    //  Number of iterations completed
    get Iterations() {
        return this.iterations;
    }
    set Iterations(value) {
        this.iterations = value;
    }
    //  number of times to project over all constraints at each layout iteration
    get ProjectionIterations() {
        return this.projectionIterations;
    }
    set ProjectionIterations(value) {
        this.projectionIterations = value;
    }
    //  Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)
    //  use a fast inexact technique (that takes O(n log n) time)
    get ApproximateRepulsion() {
        return this.approximateRepulsion;
    }
    set ApproximateRepulsion(value) {
        this.approximateRepulsion = value;
    }
    //  StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in
    //  potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect
    //  because if it is too large or too small it will be quickly updated by the algorithm anyway.
    get InitialStepSize() {
        return this.initialStepSize;
    }
    set InitialStepSize(value) {
        if (value <= 0 || value > 2) {
            throw new Error('ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)');
        }
        this.initialStepSize = value;
    }
    //  FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
    get Decay() {
        return this.decay;
    }
    set Decay(value) {
        if (value < 0.1 || value > 1) {
            throw new Error('Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value');
        }
        this.decay = value;
    }
    //  Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
    get Friction() {
        return this.friction;
    }
    set Friction(value) {
        if (value < 0 || value > 1) {
            throw new Error('Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity');
        }
        this.friction = value;
    }
    //  strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.
    get RepulsiveForceConstant() {
        return this.repulsiveForceConstant;
    }
    set RepulsiveForceConstant(value) {
        this.repulsiveForceConstant = value;
    }
    //  strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.
    get AttractiveForceConstant() {
        return this.attractiveForceConstant;
    }
    set AttractiveForceConstant(value) {
        this.attractiveForceConstant = value;
    }
    //  gravity is a constant force applied to all nodes attracting them to the Origin
    //  and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.
    get GravityConstant() {
        return this.gravity;
    }
    set GravityConstant(value) {
        this.gravity = value;
    }
    //  If the following is false forces will not be considered between each component and each component will have its own gravity origin.
    get InterComponentForces() {
        return this.interComponentForces;
    }
    set InterComponentForces(value) {
        this.interComponentForces = value;
    }
    //  If the following is false forces will not be applied, but constraints will still be satisfied.
    get ApplyForces() {
        return this.applyForces;
    }
    set ApplyForces(value) {
        this.applyForces = value;
    }
    //  restart layout, use e.g. after a mouse drag or non-structural change to the graph
    ResetLayout() {
        this.Unconverge();
        if (this.algorithm != null) {
            this.algorithm.ResetNodePositions();
        }
    }
    /**   reset iterations and convergence status*/
    Unconverge() {
        this.iterations = 0;
        this.converged = false;
    }
    InitializeLayoutGN(graph, initialConstraintLevel) {
        this.InitializeLayout(graph, initialConstraintLevel);
    }
    //  Initialize the layout algorithm
    InitializeLayout(graph, initialConstraintLevel) {
        this.algorithm = new IPsepCola(graph, this, initialConstraintLevel);
        this.ResetLayout();
    }
    //
    Uninitialize() {
        this.algorithm = null;
    }
    //
    get IsInitialized() {
        return this.algorithm != null;
    }
    //
    IncrementalRunG(graph) {
        this.IncrementalRunGF(graph);
    }
    SetupIncrementalRun(graph) {
        if (!this.IsInitialized) {
            this.InitializeLayout(graph, this.MaxConstraintLevel);
        }
        else if (this.IsDone) {
            //  If we were already done from last time but we are doing more work then something has changed.
            this.ResetLayout();
        }
    }
    //  Run the FastIncrementalLayout instance incrementally
    IncrementalRunGF(graph) {
        this.SetupIncrementalRun(graph);
        this.algorithm.run();
        // graph.UpdateBoundingBox()
    }
    //
    IncrementalRun(cancelToken, graph) {
        if (cancelToken != null) {
            cancelToken.throwIfCanceled();
        }
        this.SetupIncrementalRun(graph);
        this.algorithm.cancelToken = cancelToken;
        this.algorithm.run();
        // graph.UpdateBoundingBox()
    }
    Clone() {
        return IPsepColaSetting.ctorClone(this);
    }
    //  If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing
    //  or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing
    get ApproximateRouting() {
        return this.approximateRouting;
    }
    set ApproximateRouting(value) {
        this.approximateRouting = value;
    }
    //  If true then attractive forces across edges are computed as:
    //  AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))
    //  where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.
    //  Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.
    //  If false then a the edge force is based on (actualLength - idealLength)^2, which works better with
    //  lots of constraints.
    get LogScaleEdgeForces() {
        return this.logScaleEdgeForces;
    }
    set LogScaleEdgeForces(value) {
        this.logScaleEdgeForces = value;
    }
    //  If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.
    //  Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.
    get DisplacementThreshold() {
        return this.displacementThreshold;
    }
    set DisplacementThreshold(value) {
        this.displacementThreshold = value;
    }
    //  Set to true if displacement from the last iteration was less than DisplacementThreshold.
    //  The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:
    //
    //   while(!settings.Converged)
    //   {
    //     layout.CalculateLayout();
    //     redrawGraphOrHandleInteractionOrWhatever();
    //   }
    //
    //  RemainingIterations affects damping.
    get Converged() {
        return this.converged;
    }
    set Converged(value) {
        this.converged = value;
    }
    //  Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.
    get PercentDone() {
        if (this.Converged) {
            return 100;
        }
        else {
            return ((100 * this.iterations) / this.MaxIterations);
        }
    }
    //  Not quite the same as Converged:
    get IsDone() {
        return this.Converged || this.iterations >= this.MaxIterations;
    }
    //  Returns an estimate of the cost function calculated in the most recent iteration.
    //  It's a float because FastIncrementalLayout.Energy is a volatile float so it
    //  can be safely read from other threads
    get Energy() {
        if (this.algorithm != null) {
            return this.algorithm.energy;
        }
        return 0;
    }
    //
    get MaxConstraintLevel() {
        return this.maxConstraintLevel;
    }
    set MaxConstraintLevel(value) {
        if (this.maxConstraintLevel != value) {
            this.maxConstraintLevel = value;
            if (this.IsInitialized) {
                this.Uninitialize();
            }
        }
    }
    //
    get MinConstraintLevel() {
        return this.minConstraintLevel;
    }
    set MinConstraintLevel(value) {
        this.minConstraintLevel = value;
    }
    //  Constraint level ranges from Min to MaxConstraintLevel.
    //  0 = no constraints
    //  1 = only structural constraints
    //  2 = all constraints including non-overlap constraints
    //
    //  A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to
    //  obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.
    //  Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.
    getCurrentConstraintLevel() {
        if (this.algorithm == null) {
            return 0;
        }
        return this.algorithm.getCurrentConstraintLevel();
    }
    setCurrentConstraintLevel(value) {
        this.algorithm.setCurrentConstraintLevel(value);
    }
    //  Attractive strength of edges connected to clusters
    get AttractiveInterClusterForceConstant() {
        return this.attractiveInterClusterForceConstant;
    }
    set AttractiveInterClusterForceConstant(value) {
        this.attractiveInterClusterForceConstant = value;
    }
    //  Shallow copy the settings
    static ctorClone(previousSettings) {
        const ret = new IPsepColaSetting();
        ret.maxIterations = previousSettings.maxIterations;
        ret.minorIterations = previousSettings.minorIterations;
        ret.projectionIterations = previousSettings.projectionIterations;
        ret.approximateRepulsion = previousSettings.approximateRepulsion;
        ret.initialStepSize = previousSettings.initialStepSize;
        ret.RungeKuttaIntegration = previousSettings.RungeKuttaIntegration;
        ret.decay = previousSettings.decay;
        ret.friction = previousSettings.friction;
        ret.repulsiveForceConstant = previousSettings.repulsiveForceConstant;
        ret.attractiveForceConstant = previousSettings.attractiveForceConstant;
        ret.gravity = previousSettings.gravity;
        ret.interComponentForces = previousSettings.interComponentForces;
        ret.applyForces = previousSettings.applyForces;
        ret.AvoidOverlaps = previousSettings.AvoidOverlaps;
        ret.RespectEdgePorts = previousSettings.RespectEdgePorts;
        ret.RouteEdges = previousSettings.RouteEdges;
        ret.approximateRouting = previousSettings.approximateRouting;
        ret.logScaleEdgeForces = previousSettings.logScaleEdgeForces;
        ret.displacementThreshold = previousSettings.displacementThreshold;
        ret.minConstraintLevel = previousSettings.minConstraintLevel;
        ret.maxConstraintLevel = previousSettings.maxConstraintLevel;
        ret.attractiveInterClusterForceConstant = previousSettings.attractiveInterClusterForceConstant;
        ret.clusterGravity = previousSettings.clusterGravity;
        ret.PackingAspectRatio = previousSettings.PackingAspectRatio;
        ret.NodeSeparation = previousSettings.NodeSeparation;
        ret.clusterMargin = previousSettings.clusterMargin;
        return ret;
    }
    //  Controls how tightly members of clusters are pulled together
    get ClusterGravity() {
        return this.clusterGravity;
    }
    set ClusterGravity(value) {
        this.clusterGravity = value;
    }
    //      creates the settings that seems working
    //  <returns></returns>
    static CreateFastIncrementalLayoutSettings() {
        const f = new IPsepColaSetting();
        f.ApplyForces = false;
        f.ApproximateRepulsion = true;
        f.ApproximateRouting = true;
        f.AttractiveForceConstant = 1.0;
        f.AttractiveInterClusterForceConstant = 1.0;
        f.AvoidOverlaps = true;
        f.ClusterGravity = 1.0;
        f.Decay = 0.9;
        f.DisplacementThreshold = 0.00000005;
        f.Friction = 0.8;
        f.GravityConstant = 1.0;
        f.InitialStepSize = 2.0;
        f.InterComponentForces = false;
        f.Iterations = 0;
        f.LogScaleEdgeForces = false;
        f.MaxConstraintLevel = 2;
        f.MaxIterations = 20;
        f.MinConstraintLevel = 0;
        f.MinorIterations = 1;
        f.ProjectionIterations = 5;
        f.RepulsiveForceConstant = 2.0;
        f.RespectEdgePorts = false;
        f.RouteEdges = false;
        f.RungeKuttaIntegration = true;
        f.NodeSeparation = 20;
        return f;
    }
}
//# sourceMappingURL=iPsepColaSettings.js.map