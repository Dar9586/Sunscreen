import { Point } from '../../../math/geometry';
import { Disc } from './disc';
import { MultipoleCoefficients } from './multipoleCoefficients';
declare enum Dim {
    Horizontal = 0,
    Vertical = 1
}
declare abstract class KdNode {
    parent: InternalKdNode;
    med: Disc;
    multipoleCoefficients: MultipoleCoefficients;
    intersects(v: KdNode): boolean;
    abstract computeMultipoleCoefficients(precision: number): void;
}
declare class InternalKdNode extends KdNode {
    leftChild: KdNode;
    rightChild: KdNode;
    constructor(med: Disc, left: KdNode, right: KdNode);
    computeMultipoleCoefficients(precision: number): void;
}
declare class LeafKdNode extends KdNode {
    particles: Array<Array<Particle>>;
    ps: Point[];
    constructor(particles: Array<Array<Particle>>);
    computeMultipoleCoefficients(precision: number): void;
    ComputeMinimumEnclosingDisc(): Disc;
    private Min;
    Size(): number;
    private Max;
    private Dimension;
    Split(t: {
        rightSibling: LeafKdNode;
    }): InternalKdNode;
    ComputeForces(): void;
}
export declare class Particle {
    force: Point;
    point: Point;
    splitLeft: boolean;
    pos(d: Dim): number;
    constructor(point: Point);
}
export declare class KDTree {
    particles: Particle[];
    root: InternalKdNode;
    leaves: Array<LeafKdNode>;
    private particlesBy;
    constructor(particles: Particle[], bucketSize: number);
    ComputeForces(precision: number): void;
}
export {};
