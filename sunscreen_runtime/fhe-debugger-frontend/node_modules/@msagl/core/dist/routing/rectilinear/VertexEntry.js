import { CompassVector } from '../../math/geometry/compassVector';
import { Direction } from '../../math/geometry/direction';
export class VertexEntry {
    // A class that records an entry from a specific direction for a vertex.
    // Vertex that this VertexEntry enters
    // The previous VertexEntry along this path; null for a path source
    // Length of the path up to this vertex
    // Number of bends in the path up to this vertex
    // Cost of the path up to this vertex
    constructor(vertex, prevEntry, length, numberOfBends, cost) {
        // Indicates whether we are allowing further entries into this vertex from this direction.
        this.IsClosed = false;
        this.Vertex = vertex;
        this.Direction = prevEntry != null ? CompassVector.DirectionFromPointToPoint(prevEntry.Vertex.point, vertex.point) : Direction.None;
        this.ResetEntry(prevEntry, length, numberOfBends, cost);
    }
    ResetEntry(prevEntry, length, numberOfBends, cost) {
        // A new prevEntry using the same previous vertex but a different entry to that vertex is valid here;
        // e.g. we could have prevEntry from S, which in turn had a prevEntry from E, replaced by prevEntry from
        // S which has a prevEntry from S.
        // #if (TEST_MSAGL)
        // if ((this.PreviousEntry != null)) {
        //    Assert.assert((this.PreviousEntry.Vertex === prevEntry.Vertex), "Inconsistent prevEntry vertex");
        //    Assert.assert((this.PreviousEntry.Direction !== prevEntry.Direction), "Duplicate prevEntry direction");
        //    Assert.assert((this.Direction === CompassVector.PureDirectionFromPointToPoint(this.PreviousEntry.Vertex.point, this.Vertex.point)), "Inconsistent entryDir");
        // }
        // #endif
        // // TEST_MSAGL
        this.PreviousEntry = prevEntry;
        this.Length = length;
        this.NumberOfBends = numberOfBends;
        this.Cost = cost;
    }
    // The vertex that this VertexEntry is entered from
    get PreviousVertex() {
        return this.PreviousEntry == null ? null : this.PreviousEntry.Vertex;
    }
    toString() {
        return this.Vertex.point + (' ' + (this.Direction + (' ' + (this.IsClosed + (' ' + this.Cost)))));
    }
}
//# sourceMappingURL=VertexEntry.js.map