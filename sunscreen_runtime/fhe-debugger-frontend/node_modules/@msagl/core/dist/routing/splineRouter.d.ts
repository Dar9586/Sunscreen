import { Shape } from './shape';
import { GeomEdge } from '../layout/core/geomEdge';
import { Point } from '../math/geometry/point';
import { Algorithm } from '../utils/algorithm';
import { ICurve, Polyline } from '../math/geometry';
import { PolylinePoint } from '../math/geometry/polylinePoint';
import { PointSet } from '../utils/PointSet';
import { RTree } from '../math/geometry/RTree/rTree';
import { VisibilityGraph } from './visibility/VisibilityGraph';
import { TightLooseCouple } from './TightLooseCouple';
import { VisibilityEdge } from './visibility/VisibilityEdge';
import { RectangleNode } from '../math/geometry/RTree/rectangleNode';
import { BundlingSettings } from './BundlingSettings';
import { CancelToken, GeomGraph } from '..';
import { EdgeRoutingSettings } from './EdgeRoutingSettings';
import { Port } from '../layout/core/port';
import { ShapeObstacleCalculator } from './ShapeObstacleCalculator';
import { InteractiveEdgeRouter } from './interactiveEdgeRouter';
import { PointPairMap } from '../utils/pointPairMap';
import { Cdt } from './ConstrainedDelaunayTriangulation/Cdt';
import { CdtEdge } from './ConstrainedDelaunayTriangulation/CdtEdge';
import { DebugCurve } from '../math/geometry/debugCurve';
import { Node } from '..';
/**  routing edges around shapes */
export declare class SplineRouter extends Algorithm {
    continueOnOverlaps: boolean;
    obstacleCalculator: ShapeObstacleCalculator;
    /** each polyline points to the nodes within it, maximal with this property */
    loosePolylinesToNodes: Map<Polyline, Set<Node>>;
    get ContinueOnOverlaps(): boolean;
    set ContinueOnOverlaps(value: boolean);
    rootShapes: Shape[];
    coneAngle: number;
    tightPadding: number;
    loosePadding: number;
    get LoosePadding(): number;
    set LoosePadding(value: number);
    rootWasCreated: boolean;
    root: Shape;
    visGraph: VisibilityGraph;
    ancestorSets: Map<Shape, Set<Shape>>;
    shapesToTightLooseCouples: Map<Shape, TightLooseCouple>;
    portsToShapes: Map<Port, Shape>;
    portsToEnterableShapes: Map<Port, Set<Shape>>;
    portRTree: RTree<Point, Point>;
    looseRoot: Shape;
    BundlingSettings: BundlingSettings;
    enterableLoose: Map<GeomEdge, Set<Polyline>>;
    enterableTight: Map<GeomEdge, Set<Polyline>>;
    geomGraph: GeomGraph;
    multiEdgesSeparation: number;
    private routeMultiEdgesAsBundles;
    UseEdgeLengthMultiplier: boolean;
    UsePolylineEndShortcutting: boolean;
    UseInnerPolylingShortcutting: boolean;
    AllowedShootingStraightLines: boolean;
    get MultiEdgesSeparation(): number;
    set MultiEdgesSeparation(value: number);
    static mk2(graph: GeomGraph, edgeRoutingSettings: EdgeRoutingSettings): SplineRouter;
    static mk4(graph: GeomGraph, tightTightPadding: number, loosePadding: number, coneAngle: number): SplineRouter;
    static mk5(graph: GeomGraph, tightTightPadding: number, loosePadding: number, coneAngle: number, bundlingSettings: BundlingSettings): SplineRouter;
    constructor(graph: GeomGraph, edges: Array<GeomEdge>, tightPadding?: number, loosePadding?: number, coneAngle?: number, bundlingSettings?: BundlingSettings, cancelToken?: CancelToken);
    private edges;
    static mk6(graph: GeomGraph, tightPadding: number, loosePadding: number, coneAngle: number, inParentEdges: Array<GeomEdge>, outParentEdges: Array<GeomEdge>): SplineRouter;
    Initialize(obstacles: Array<Shape>, coneAngleValue: number): void;
    run(): void;
    /** Uses the existing routes and optimizing them only to avoid 'activeNodes'.   */
    rerouteOnSubsetOfNodes(activeNodes: Set<Node>): void;
    calcLooseShapesToNodes(): void;
    RouteOnRoot(): void;
    CalculatePortsToEnterableShapes(): void;
    static EdgesAttachedToPortAvoidTheNode(port: Port): boolean;
    SetLoosePolylinesForAnywherePorts(): void;
    BindLooseShapes(): void;
    BindLooseShapesUnderShape(shape: Shape): void;
    CalculateShapeToBoundaries(shape: Shape): void;
    private _overlapsDetected;
    get OverlapsDetected(): boolean;
    set OverlapsDetected(value: boolean);
    get AdjustedLoosePadding(): number;
    GroupEdgesByPassport(): Array<{
        passport: Set<Shape>;
        edges: Array<GeomEdge>;
    }>;
    RouteOnVisGraph(): void;
    private rerouteOnActiveNodes;
    getDebugCurvesFromEdgesAndCdt(cdt: Cdt): DebugCurve[];
    private RouteEdgesWithTheSamePassport;
    /** edgeToPolys maps edges to their original polyline routes */
    private rerouteEdgesWithTheSamePassportActiveNodes;
    /** poly gives the polyline to reroute */
    private rerouteEdge;
    private getCdtFromPassport;
    get RouteMultiEdgesAsBundles(): boolean;
    set RouteMultiEdgesAsBundles(value: boolean);
    private routeEdge;
    ScaleDownLooseHierarchy(interactiveEdgeRouter: InteractiveEdgeRouter, obstacleShapes: Set<Shape>): void;
    RouteMultiEdges(multiEdges: Array<GeomEdge[]>, interactiveEdgeRouter: InteractiveEdgeRouter, parents: Set<Shape>): void;
    SplitOnRegularAndMultiedges(edges: Iterable<GeomEdge>, t: {
        regularEdges: Array<GeomEdge>;
        multiEdges: Array<GeomEdge[]>;
    }): void;
    static RegisterInPortLocationsToEdges(eg: GeomEdge, portLocationPairsToEdges: PointPairMap<Array<GeomEdge>>): void;
    static IsEdgeToParent(e: GeomEdge): boolean;
    CreateInteractiveEdgeRouter(obstacleShapes: Array<Shape>): InteractiveEdgeRouter;
    GetObstaclesFromPassport(passport: Set<Shape>): Set<Shape>;
    GetAllAncestors(passport: Set<Shape>): Set<Shape>;
    GetCommonAncestorsAbovePassport(passport: Set<Shape>): Set<Shape>;
    RouteBundles(): void;
    CreateTheMapToParentLooseShapes(shape: Shape, loosePolylinesToLooseParentShapeMap: Map<ICurve, Shape>): void;
    FindCdtGates(cdt: Cdt): Set<CdtEdge>;
    CalculateEdgeEnterablePolylines(): void;
    GetEdgeEnterablePolylines(edge: GeomEdge, looseEnterable: Set<Polyline>, tightEnterable: Set<Polyline>): void;
    GetEnterablesForShape(shape: Shape, looseEnterable: Set<Polyline>, tightEnterable: Set<Polyline>): void;
    GetTightHierarchy(): RectangleNode<Polyline, Point>;
    GetLooseHierarchy(): RectangleNode<Polyline, Point>;
    ScaleLooseShapesDown(): void;
    /**
     * The set of shapes where the edge source and target ports shapes are citizens: the shapes who's interior the edge can cross
     *   In the simple case it is the union of the target port shape parents and the sourceport shape parents.
     *   When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.
     */
    EdgePassport(edge: GeomEdge): Set<Shape>;
    AllPorts(): IterableIterator<Port>;
    CalculatePortsToShapes(): void;
    RouteEdgeInternal(edge: GeomEdge, iRouter: InteractiveEdgeRouter): void;
    /** returns ToAncestorEnum.None if the source and the target are just siblings
     *          ToAncestorEnum. if the source is a descendant of the target
     *         -1 if the target is a descendant of the source
     */
    LineSweeperPorts: Point[];
    AddVisibilityEdgesFromPort(port: Port): IterableIterator<VisibilityEdge>;
    makeTransparentShapesOfEdgeAndGetTheShapes(edge: GeomEdge): Array<Shape>;
    LooseShapeOfOriginalShape(s: Shape): Shape;
    LoosePolyOfOriginalShape(s: Shape): Polyline;
    TightPolyOfOriginalShape(s: Shape): Polyline;
    GetTransparentShapes(sourcePort: Port, targetPort: Port, sourceShape: Shape, targetShape: Shape): IterableIterator<Shape>;
    static SetTransparency(shapes: Iterable<Shape>, v: boolean): void;
    IsAncestor(possibleAncestor: Shape, possiblePredecessor: Shape): boolean;
    static CreateLooseObstacleHierarachy(loosePolys: Array<Polyline>): RectangleNode<Polyline, Point>;
    CreateTightObstacleHierarachy(obstacles: Array<Shape>): RectangleNode<Polyline, Point>;
    CalculateVisibilityGraph(): void;
    static ShowVisGraph(fileName: string, tmpVisGraph: VisibilityGraph, obstacles: Array<Polyline>, greenCurves?: Array<ICurve>, redCurves?: Array<ICurve>): void;
    private ProcessHookAnyWherePorts;
    FillVisibilityGraphUnderShape(shape: Shape): void;
    TryToCreateNewEdgeAndSetIsPassable(edge: VisibilityEdge, looseShape: Shape): void;
    AddBoundaryEdgesToVisGraph(boundary: Polyline): void;
    /** this run will split the polyline enough to route later from the inner ports */
    RemoveInsidePortsAndSplitBoundaryIfNeeded(boundary: Polyline): PointSet;
    static FindPointOnPolylineToInsertAfter(boundary: Polyline, point: Point): PolylinePoint;
    GetOrCreateRoot(): void;
    RemoveRoot(): void;
    static GetAncestorSetsMap(shapes: Array<Shape>): Map<Shape, Set<Shape>>;
    static GetAncestorSet(child: Shape, ancSets: Map<Shape, Set<Shape>>): Set<Shape>;
    static CreatePortsIfNeeded(edges: GeomEdge[]): void;
}
export declare function routeSplines(gg: GeomGraph, edgesToRoute: GeomEdge[], cancelToken: CancelToken): void;
