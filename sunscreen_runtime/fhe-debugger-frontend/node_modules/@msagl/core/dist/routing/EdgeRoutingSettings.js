import { BundlingSettings } from './BundlingSettings';
import { EdgeRoutingMode } from './EdgeRoutingMode';
export class EdgeRoutingSettings {
    constructor() {
        this.coneAngle = 30 * (Math.PI / 180);
        // Amount of space to leave around nodes
        this.padding = 2;
        this.polylinePadding = 1;
        this.routingToParentConeAngle = Math.PI / 6;
        this.simpleSelfLoopsForParentEdgesThreshold = 200;
        this.incrementalRoutingThreshold = 5000000;
        // debugging
        this.routeMultiEdgesAsBundles = true;
        // if set to true the original spline is kept under the corresponding GeomEdge
        this.KeepOriginalSpline = false;
        this.EdgeRoutingMode = EdgeRoutingMode.Spline;
    }
    toJSON() {
        const ret = {};
        if (this.EdgeRoutingMode != EdgeRoutingMode.Spline)
            ret.edgeRoutingMode = EdgeRoutingMode.Spline;
        if (this.ConeAngle != 30 * (Math.PI / 180))
            ret.coneAngle = this.ConeAngle;
        if (this.padding != 3)
            ret.padding = this.padding;
        if (this.polylinePadding != 1.5)
            ret.polylinePadding = this.polylinePadding;
        if (this.bundlingSettings)
            ret.bundlingSettingsJSON = this.bundlingSettings.toJSON();
        return ret;
    }
    static fromJSON(source) {
        const ret = new EdgeRoutingSettings();
        if (source.edgeRoutingMode)
            source.edgeRoutingMode = ret.edgeRoutingMode;
        if (source.coneAngle)
            ret.coneAngle = source.coneAngle;
        // Amount of space to leave around nodes
        if (source.padding)
            ret.padding = source.padding;
        if (source.polylinePadding)
            ret.polylinePadding = source.polylinePadding;
        // the settings for general edge bundling
        if (source.bundlingSettingsJSON)
            ret.bundlingSettings = BundlingSettings.createFromJSON(source.bundlingSettingsJSON);
        if (source.routingToParentConeAngle)
            ret.routingToParentConeAngle = source.routingToParentConeAngle;
        if (source.simpleSelfLoopsForParentEdgesThreshold)
            ret.simpleSelfLoopsForParentEdgesThreshold = source.simpleSelfLoopsForParentEdgesThreshold;
        if (source.incrementalRoutingThreshold)
            ret.incrementalRoutingThreshold = source.incrementalRoutingThreshold;
        if (source.routeMultiEdgesAsBundles)
            ret.routeMultiEdgesAsBundles = source.routeMultiEdgesAsBundles;
        // if set to true the original spline is kept under the corresponding GeomEdge
        if (source.KeepOriginalSpline)
            ret.KeepOriginalSpline = source.KeepOriginalSpline;
        return ret;
    }
    // defines the way edges are routed
    get EdgeRoutingMode() {
        return this.edgeRoutingMode;
    }
    set EdgeRoutingMode(value) {
        if (value === EdgeRoutingMode.SplineBundling && this.bundlingSettings == null) {
            if (this.bundlingSettings == null) {
                this.bundlingSettings = new BundlingSettings();
            }
        }
        this.edgeRoutingMode = value;
    }
    // the angle in degrees of the cones in the routing with the spanner
    get ConeAngle() {
        return this.coneAngle;
    }
    set ConeAngle(value) {
        this.coneAngle = value;
    }
    // Amount of space to leave around nodes
    get Padding() {
        return this.padding;
    }
    set Padding(value) {
        this.padding = value;
    }
    // Additional amount of padding to leave around nodes when routing with polylines
    get PolylinePadding() {
        return this.polylinePadding;
    }
    set PolylinePadding(value) {
        this.polylinePadding = value;
    }
    // this is a cone angle to find a relatively close point on the parent boundary
    get RoutingToParentConeAngle() {
        return this.routingToParentConeAngle;
    }
    set RoutingToParentConeAngle(value) {
        this.routingToParentConeAngle = value;
    }
    // if the number of the nodes participating in the routing of the parent edges is less than the threshold
    // then the parent edges are routed avoiding the nodes
    get SimpleSelfLoopsForParentEdgesThreshold() {
        return this.simpleSelfLoopsForParentEdgesThreshold;
    }
    set SimpleSelfLoopsForParentEdgesThreshold(value) {
        this.simpleSelfLoopsForParentEdgesThreshold = value;
    }
    // defines the size of the changed graph that could be routed fast with the standard spline routing when dragging
    get IncrementalRoutingThreshold() {
        return this.incrementalRoutingThreshold;
    }
    set IncrementalRoutingThreshold(value) {
        this.incrementalRoutingThreshold = value;
    }
    // if set to true routes multi edges as ordered bundles, when routing in a spline mode
    // <exception cref="NotImplementedException"></exception>
    get RouteMultiEdgesAsBundles() {
        return this.routeMultiEdgesAsBundles;
    }
    set RouteMultiEdgesAsBundles(value) {
        this.routeMultiEdgesAsBundles = value;
    }
}
//# sourceMappingURL=EdgeRoutingSettings.js.map