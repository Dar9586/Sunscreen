import { Rectangle } from '..';
import { ICurve } from '../math/geometry/icurve';
import { Point } from '../math/geometry/point';
import { Polyline } from '../math/geometry/polyline';
import { PolylinePoint } from '../math/geometry/polylinePoint';
import { RectangleNode } from '../math/geometry/RTree/rectangleNode';
export declare class InteractiveObstacleCalculator {
    IgnoreTightPadding: boolean;
    /** if set to true the vertices of the loose polylines would be randomly shifted by a small amont */
    randomizationShift: number;
    ObstaclesIntersectLine(a: Point, b: Point): boolean;
    LoosePadding: number;
    tightPolylinesToLooseDistances: Map<Polyline, number>;
    LooseObstacles: Polyline[];
    TightObstacles: Set<Polyline>;
    OverlapsDetected: boolean;
    private static PadCorner;
    static CurveIsClockwise(iCurve: ICurve, pointInside: Point): boolean;
    static PaddedPolylineBoundaryOfNode(curve: ICurve, padding: number, randomizePoints?: boolean): Polyline;
    /** surrounds the given polyline with the given offset, optionally randomizes the output */
    static LoosePolylineWithFewCorners(tightPolyline: Polyline, p: number, randomizationShift: number): Polyline;
    static CreateLoosePolylineOnBisectors(tightPolyline: Polyline, offset: number, randomizationShift: number): Polyline;
    static CreateRectNodeOfPolyline(polyline: Polyline): RectangleNode<Polyline, Point>;
    CreateLooseObstacles(): void;
    Obstacles: Array<ICurve>;
    TightPadding: number;
    CreateTightObstacles(): void;
    Calculate(): void;
    IsEmpty(): boolean;
    constructor(obstacles: Array<ICurve>, tightPadding: number, loosePadding: number, ignoreTightPadding: boolean);
    ObstaclesIntersectICurve(curve: ICurve): boolean;
    static CurveIntersectsRectangleNode(curve: ICurve, curveBox: Rectangle, rectNode: RectangleNode<Polyline, Point>): boolean;
    static PointIsInside(point: Point, curve: ICurve): boolean;
    CreateTightObstaclesIgnoringTightPadding(): void;
    CreateTightObstacles_(): RectangleNode<Polyline, Point>;
    static CalculateTightPolyline(tightObstacles: Set<Polyline>, tightPadding: number, curve: ICurve): void;
    static CalculateHierarchy(polylines: Array<Polyline>): RectangleNode<Polyline, Point>;
    static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(tightObstacleSet: Set<Polyline>): RectangleNode<Polyline, Point>;
    static MapToInt<T>(objects: T[]): Map<T, number>;
    static ReplaceTightObstaclesWithConvexHulls(tightObsts: Set<Polyline>, overlappingPairSet: Array<[Polyline, Polyline]>): RectangleNode<Polyline, Point>;
    RootOfTightHierarchy: RectangleNode<Polyline, Point>;
    RootOfLooseHierarchy: RectangleNode<Polyline, Point>;
    static OneCurveLiesInsideOfOther(polyA: ICurve, polyB: ICurve): boolean;
    static PolylinesIntersect(a: Polyline, b: Polyline): boolean;
    static GetOverlappedPairSet(rootOfObstacleHierarchy: RectangleNode<Polyline, Point>): Set<[Polyline, Polyline]>;
    static BisectorPoints(tightPolyline: Polyline, offset: number): IterableIterator<Point>;
    static GetStickingVertexOnBisector(pp: PolylinePoint, p: number, t: {
        skip: boolean;
    }): Point;
    static LooseDistCoefficient: number;
    static FindMaxPaddingForTightPolyline(hierarchy: RectangleNode<Polyline, Point>, polyline: Polyline, desiredPadding: number): number;
    static GetPaddedCorner(first: PolylinePoint, second: PolylinePoint, third: PolylinePoint, padding: number): {
        a: Point;
        b: Point;
        numberOfPoints: number;
    };
    static CornerIsNotTooSharp(u: Point, v: Point, w: Point): boolean;
    static CreatePaddedPolyline(poly: Polyline, padding: number, randomizePoints?: boolean): Polyline;
}
