import { Point } from '../../math/geometry/point';
import { Polyline } from '../../math/geometry/polyline';
import { PointMap } from '../../utils/PointMap';
import { Algorithm } from './../../utils/algorithm';
import { CdtEdge } from './CdtEdge';
import { CdtSite } from './CdtSite';
import { CdtTriangle } from './CdtTriangle';
import { CdtSweeper } from './CdtSweeper';
import { RectangleNode } from '../../math/geometry/RTree/rectangleNode';
export declare type SymmetricSegment = {
    A: Point;
    B: Point;
};
export declare class Cdt extends Algorithm {
    isolatedSitesWithObject: Array<[Point, unknown]>;
    isolatedSites: Point[];
    obstacles: Polyline[];
    isolatedSegments: Array<SymmetricSegment>;
    P1: CdtSite;
    P2: CdtSite;
    sweeper: CdtSweeper;
    PointsToSites: PointMap<CdtSite>;
    allInputSites: Array<CdtSite>;
    simplifyObstacles: boolean;
    constructor(isolatedSites: Point[], obstacles: Array<Polyline>, isolatedSegments: Array<SymmetricSegment>);
    static constructor_(isolatedSitesWithObj: Array<[Point, unknown]>): Cdt;
    FillAllInputSites(): void;
    AddSite(point: Point, relatedObject: unknown): CdtSite;
    private AddP1AndP2;
    private AddPolylineToAllInputSites;
    private AddConstrainedEdge;
    static GetOrCreateEdge(a: CdtSite, b: CdtSite): CdtEdge;
    private static CreateEdgeOnOrderedCouple;
    GetTriangles(): Set<CdtTriangle>;
    run(): void;
    SweepAndFinalize(): void;
    cleanRemovedEdges(): void;
    private Initialization;
    private static OnComparison;
    static AbovePP(a: Point, b: Point): number;
    private static AboveCC;
    RestoreEdgeCapacities(): void;
    SetInEdges(): void;
    FindSite(point: Point): CdtSite;
    static PointIsInsideOfTriangle(point: Point, t: CdtTriangle): boolean;
    rectangleNodeOnTriangles: RectangleNode<CdtTriangle, Point>;
    getRectangleNodeOnTriangles(): RectangleNode<CdtTriangle, Point>;
}
export declare function createCDTOnPolylineRectNode(polylineHierarchy: RectangleNode<Polyline, Point>): Cdt;
