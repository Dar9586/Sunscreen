import { PointLocation } from '../../math/geometry';
import { Point } from '../../math/geometry/point';
import { Rectangle } from '../../math/geometry/rectangle';
import { CdtEdge } from './CdtEdge';
import { CdtSite } from './CdtSite';
import { ThreeArray } from './ThreeArray';
export declare class CdtTriangle {
    containsPoint(p: Point): boolean;
    static PointLocationForTriangle(p: Point, triangle: CdtTriangle): PointLocation;
    /** extend by eps the triangles edges before the test */
    intersectsLine(a: Point, b: Point, eps: number): boolean;
    Edges: ThreeArray<CdtEdge>;
    Sites: ThreeArray<CdtSite>;
    private abIntersectsTrianglSide;
    static mkSSSD(a: CdtSite, b: CdtSite, c: CdtSite, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): CdtTriangle;
    static mkSED(pi: CdtSite, edge: CdtEdge, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): CdtTriangle;
    static mkSSSEE(aLeft: CdtSite, aRight: CdtSite, bRight: CdtSite, a: CdtEdge, b: CdtEdge, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): CdtTriangle;
    BindEdgeToTriangle(site: CdtSite, edge: CdtEdge): void;
    FillCcwTriangle(a: CdtSite, b: CdtSite, c: CdtSite, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): void;
    CreateEdge(i: number, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): void;
    Contains(cdtSite: CdtSite): boolean;
    OppositeEdge(pi: CdtSite): CdtEdge;
    OppositeSite(cdtEdge: CdtEdge): CdtSite;
    BoundingBox(): Rectangle;
    static mkSSSEED(aLeft: CdtSite, aRight: CdtSite, bRight: CdtSite, a: CdtEdge, b: CdtEdge, createEdgeDelegate: (a: CdtSite, b: CdtSite) => CdtEdge): CdtTriangle;
    toString(): string;
}
