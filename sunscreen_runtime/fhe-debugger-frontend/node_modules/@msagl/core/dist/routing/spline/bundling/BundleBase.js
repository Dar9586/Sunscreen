import { Point, parameterSpan } from '../../..';
import { TriangleOrientation } from '../../../math/geometry/point';
export class BundleBase {
    constructor(count, boundaryCurve, position, belongsToRealNode) {
        this.BelongsToRealNode = belongsToRealNode;
        this.Curve = boundaryCurve;
        this.Position = position;
        this.points = new Array(count);
        this.tangents = new Array(count);
        this.OrientedHubSegments = new Array(count);
    }
    isCorrectlyOrienected() {
        const orientation = Point.getTriangleOrientation(this.Curve.boundingBox.center, this.Curve.value(this.parEnd), this.Curve.value(this.parStart));
        return orientation !== TriangleOrientation.Counterclockwise;
    }
    get Count() {
        return this.points.length;
    }
    get CurveCenter() {
        return this.Curve.boundingBox.center;
    }
    get OppositeBase() {
        return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;
    }
    get length() {
        return this.points.length;
    }
    get Points() {
        return this.points;
    }
    get Tangents() {
        return this.tangents;
    }
    get InitialMidParameter() {
        return this.initialMidParameter;
    }
    set InitialMidParameter(value) {
        this.initialMidParameter = value;
        this.InitialMidPoint = this.Curve.value(value);
    }
    /**
     * corresponds to the left point of the base: if looking from the center of
     * this.Curve.boundingBox.center
     */
    get ParStart() {
        return this.parStart;
    }
    set ParStart(value) {
        this.parStart = value;
        this.StartPoint = this.Curve.value(this.parStart);
    }
    /**
     * corresponds to the right point of the base: if looking from the center of
     * this.Curve.boundingBox.center */
    get ParEnd() {
        return this.parEnd;
    }
    set ParEnd(value) {
        this.parEnd = value;
        this.EndPoint = this.Curve.value(this.parEnd);
    }
    get ParMid() {
        return (this.parStart + this.parEnd) / 2;
    }
    get MidPoint() {
        return Point.middle(this.StartPoint, this.EndPoint);
    }
    get Span() {
        return this.SpanBetweenTwoParameters(this.parStart, this.parEnd);
    }
    SpanBetweenTwoParameters(start, end) {
        return start <= end ? end - start : end - start + parameterSpan(this.Curve);
    }
    RotateLeftPoint(rotationOfSourceLeftPoint, parameterChange) {
        if (rotationOfSourceLeftPoint === 0) {
            return this.EndPoint;
        }
        return this.RotatePoint(rotationOfSourceLeftPoint, this.parEnd, parameterChange);
    }
    RotateRigthPoint(rotationOfSourceRightPoint, parameterChange) {
        if (rotationOfSourceRightPoint === 0) {
            return this.StartPoint;
        }
        return this.RotatePoint(rotationOfSourceRightPoint, this.parStart, parameterChange);
    }
    RotatePoint(rotation, t, parameterChange) {
        const change = parameterSpan(this.Curve) * parameterChange;
        t += rotation * change;
        t = this.AdjustParam(t);
        return this.Curve.value(t);
    }
    AdjustParam(t) {
        if (t > this.Curve.parEnd)
            t = this.Curve.parStart + (t - this.Curve.parEnd);
        else if (t < this.Curve.parStart)
            t = this.Curve.parEnd - (this.Curve.parStart - t);
        return t;
    }
    RotateBy(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {
        const change = parameterSpan(this.Curve) * parameterChange;
        if (rotationOfRightPoint !== 0) {
            this.ParStart = this.AdjustParam(this.ParStart + rotationOfRightPoint * change);
        }
        if (rotationOfLeftPoint !== 0) {
            this.ParEnd = this.AdjustParam(this.ParEnd + rotationOfLeftPoint * change);
        }
    }
    RelativeOrderOfBasesIsPreserved(rotationOfRightPoint, rotationOfLeftPoint, parameterChange) {
        const change = parameterSpan(this.Curve) * parameterChange;
        //we do not swap parRight and parLeft
        const rnew = this.parStart + rotationOfRightPoint * change;
        const lnew = this.parStart < this.parEnd
            ? this.parEnd + rotationOfLeftPoint * change
            : this.parEnd + parameterSpan(this.Curve) + rotationOfLeftPoint * change;
        if (rnew > lnew)
            return false;
        //span could not be greater than pi
        if (this.SpanBetweenTwoParameters(rnew, lnew) > parameterSpan(this.Curve) / 2.0)
            return false;
        //the base is the only base in the hub
        if (this.Prev == null)
            return true;
        //distance between mid points is larger than parameterChange => we can't change the order
        if (this.SpanBetweenTwoParameters(this.Prev.ParMid, this.ParMid) > change &&
            this.SpanBetweenTwoParameters(this.ParMid, this.Next.ParMid) > change)
            return true;
        const rSoP = this.RotateLeftPoint(rotationOfLeftPoint, parameterChange);
        const lSoP = this.RotateRigthPoint(rotationOfRightPoint, parameterChange);
        const newMidPoint = Point.middle(rSoP, lSoP);
        const curMidPoint = this.MidPoint;
        //check Prev
        if (Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, curMidPoint) !=
            Point.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, newMidPoint))
            return false;
        //Next
        if (Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, curMidPoint) !=
            Point.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, newMidPoint))
            return false;
        return true;
    }
}
//# sourceMappingURL=BundleBase.js.map