import { Point } from './point';
import { Polyline } from './polyline';
import { IRectangle } from './IRectangle';
import { PlaneTransformation } from './planeTransformation';
export declare class Size {
    pad(padW: number): any;
    width: number;
    height: number;
    /** creates a square if called with width only */
    constructor(width: number, height?: number);
}
export declare type RectJSON = {
    left: number;
    right: number;
    top: number;
    bottom: number;
};
export declare class Rectangle implements IRectangle<Point> {
    /** this function will not work correctly for transformations that are not translations, or rotations by n*90, or a combination of those */
    transform(m: PlaneTransformation): Rectangle;
    translate(m: Point): Rectangle;
    /** Returns true iff the rectangles are geometrically identical */
    equal(bbox: Rectangle): boolean;
    /** Returns true iff the rectangles are distEpsilon close */
    equalEps(bbox: Rectangle): boolean;
    /** make a rectangle with the given size and center */
    static mkSizeCenter(size: Size, center: Point): Rectangle;
    left_: number;
    bottom_: number;
    right_: number;
    top_: number;
    constructor(t: RectJSON);
    add_rect(rectangle: IRectangle<Point>): IRectangle<Point>;
    contains_point(point: Point): boolean;
    contains_rect(rect: IRectangle<Point>): boolean;
    intersection_rect(rectangle: IRectangle<Point>): IRectangle<Point>;
    intersects_rect(rectangle: IRectangle<Point>): boolean;
    unite(b: IRectangle<Point>): IRectangle<Point>;
    contains_point_radius(p: Point, radius: number): boolean;
    intersects(rectangle: Rectangle): boolean;
    intersection(rectangle: Rectangle): Rectangle;
    get center(): Point;
    set center(value: Point);
    intersectsOnY(r: Rectangle): boolean;
    intersectsOnX(r: Rectangle): boolean;
    static mkEmpty(): Rectangle;
    get left(): number;
    set left(value: number);
    get right(): number;
    set right(value: number);
    get top(): number;
    set top(value: number);
    get bottom(): number;
    set bottom(value: number);
    get leftBottom(): Point;
    set leftBottom(value: Point);
    get rightTop(): Point;
    set rightTop(value: Point);
    get leftTop(): Point;
    set leftTop(value: Point);
    get rightBottom(): Point;
    set rightBottom(value: Point);
    protected onUpdated(): void;
    static mkPP(point0: Point, point1: Point): Rectangle;
    static rectangleOnPoint(p: Point): Rectangle;
    static mkLeftBottomSize(left: number, bottom: number, sizeF: Size): Rectangle;
    static getRectangleOnCoords(x0: number, y0: number, x1: number, y1: number): Rectangle;
    static mkOnPoints(points: Iterable<Point>): Rectangle;
    static mkOnRectangles(rectangles: Iterable<Rectangle>): Rectangle;
    get width(): number;
    set width(value: number);
    isEmpty(): boolean;
    setToEmpty(): void;
    get height(): number;
    set height(value: number);
    static rectangleOfTwo(a: Rectangle, b: Rectangle): Rectangle;
    containsWithPadding(point: Point, padding: number): boolean;
    get area(): number;
    add(point: Point): void;
    addRecSelf(rectangle: Rectangle): void;
    addRec(rectangle: Rectangle): Rectangle;
    /**  Returns the translated clone of the specified rectangle */
    static translate(rectangle: Rectangle, delta: Point): Rectangle;
    /**  Returns a new Rectangle which is the transform the input rectangle */
    static transform(rectangle: Rectangle, m: PlaneTransformation): Rectangle;
    contains(point: Point): boolean;
    containsRect(rect: Rectangle): boolean;
    containsRectWithPadding(rect: Rectangle, padding: number): boolean;
    get diagonal(): number;
    padWidth(padding: number): void;
    padHeight(padding: number): void;
    pad(padding: number): void;
    padEverywhere(margins: {
        left: number;
        bottom: number;
        right: number;
        top: number;
    }): void;
    static intersect(rect1: Rectangle, rect2: Rectangle): Rectangle;
    perimeter(): Polyline;
    scaleAroundCenter(scale: number): void;
    clone(): Rectangle;
    get size(): Size;
    set size(value: Size);
    static creatRectangleWithSize(size: Size, center: Point): Rectangle;
    addPointWithSize(size: Size, point: Point): void;
}
