import { ICurve } from './icurve';
import { Rectangle } from './rectangle';
import { PN } from './parallelogramNode';
import { Point, PointJSON } from './point';
import { PlaneTransformation } from './planeTransformation';
export declare type BezierJSON = {
    b: PointJSON[];
};
/** the standard implementation of a cubic bezier curve */
export declare class BezierSeg implements ICurve {
    bbox: Rectangle;
    toJSON(): BezierJSON;
    static fromJSON(bData: BezierJSON): BezierSeg;
    leftDerivative(t: number): Point;
    rightDerivative(t: number): Point;
    /** control points */
    b: Point[];
    /** coefficients */
    l: Point;
    e: Point;
    c: Point;
    /** get a control point */
    B(controlPointIndex: number): Point;
    pBoxNode: PN;
    /** A tree of ParallelogramNodes covering the curve.
     This tree is used in curve intersections routines. */
    pNodeOverICurve(): PN;
    /** Returns the point on the curve corresponding to parameter t */
    value(t: number): Point;
    static adjustParamTo01(u: number): number;
    /**throw away the segments [0,u] and [v,1] of the segment,
    Returns the trimmed curve */
    trim(u: number, v: number): ICurve;
    trimWithWrap(start: number, end: number): ICurve;
    private casteljau;
    derivative(t: number): Point;
    secondDerivative(t: number): Point;
    thirdDerivative(t: number): Point;
    constructor(b0: Point, b1: Point, b2: Point, b3: Point);
    get start(): Point;
    get end(): Point;
    reverse(): BezierSeg;
    translate(delta: Point): void;
    scaleFromOrigin(xScale: number, yScale: number): BezierSeg;
    offsetCurve(offset: number, dir: Point): ICurve;
    lengthPartial(start: number, end: number): number;
    get length(): number;
    static lengthOnControlPolygon(b0: Point, b1: Point, b2: Point, b3: Point): number;
    get boundingBox(): Rectangle;
    transform(transformation: PlaneTransformation): ICurve;
    closestParameterWithinBounds(targetPoint: Point, low: number, high: number): number;
    clone(): BezierSeg;
    static mkBezier(b: Point[]): BezierSeg;
    parStart: number;
    parEnd: number;
    curvature(t: number): number;
    F(t: number): number;
    G(t: number): number;
    Xp(t: number): number;
    Ypp(t: number): number;
    Yp(t: number): number;
    Xpp(t: number): number;
    Xppp(t: number): number;
    Yppp(t: number): number;
    curvatureDerivative(t: number): number;
    Fp(t: number): number;
    Fpp(t: number): number;
    closestParameter(targetPoint: Point): number;
    curvatureSecondDerivative(t: number): number;
    Q(t: number): number;
    Qp(t: number): number;
    Gpp(t: number): number;
    Gp(t: number): number;
    getParameterAtLength(length: number): number;
    evaluateError(length: number, t: number): 0 | 1 | -1;
}
