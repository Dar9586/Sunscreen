import { IconLayer, TextLayer } from '@deck.gl/layers/typed';
import { BezierSeg, Ellipse } from '@msagl/core';
import { DrawingObject } from '@msagl/drawing';
import { iconMapping } from './arrows';
import CurveLayer from './curve-layer';
import { CURVE } from './curve-layer';
import GraphStyleExtension from './graph-style-extension';
export function getEdgeLayer(props, style) {
    // @ts-ignore
    if (!props.data._curves) {
        // @ts-ignore
        props.data._curves = Array.from(getCurves(props.data, (segment, datum, index) => {
            // @ts-expect-error
            segment.__source = {
                parent: this,
                object: datum,
                index: index,
            };
            return segment;
        }));
    }
    return new CurveLayer(props, {
        id: `${props.id}-edge`,
        // @ts-ignore
        data: props.data._curves,
        getCurveType,
        getControlPoints,
        getRange: (d) => {
            // @ts-ignore
            return [d.parStart, d.parEnd];
        },
        widthUnits: 'pixels',
        // one vertex per 4 pixels
        getResolution: (d) => {
            // @ts-ignore
            return d.length * props.resolution;
        },
        // @ts-ignore
        clipByInstance: false,
        extensions: [
            new GraphStyleExtension({
                overrideProps: {
                    opacity: style.opacity,
                    getWidth: style.strokeWidth,
                    getColor: style.strokeColor,
                },
            }),
        ],
    });
}
export function getArrowHeadLayer(props, style) {
    return new IconLayer(props, {
        id: `${props.id}-arrowhead`,
        iconAtlas: 'deck://arrowAtlas',
        iconMapping,
        getPosition: (d) => [d.tip.x, d.tip.y],
        getColor: (d) => getEdgeColor(d.edge),
        getIcon: (d) => getEdgeType(d.edge),
        getSize: (d) => getArrowSize(d.tip, d.base),
        getAngle: (d) => getArrowAngle(d.tip, d.base),
        billboard: false,
        sizeUnits: 'common',
        extensions: [
            new GraphStyleExtension({
                overrideProps: {
                    opacity: style.opacity,
                    sizeScale: style.arrowSize,
                    getColor: style.arrowColor,
                },
            }),
        ],
    });
}
export function getEdgeLabelLayer(props, style) {
    return new TextLayer(props, {
        id: `${props.id}-edge-label`,
        getText: getLabelText,
        getSize: getLabelSize,
        getColor: getLabelColor,
        getPosition: (d) => [d.center.x, d.center.y],
        sizeUnits: 'common',
        extensions: [
            new GraphStyleExtension({
                overrideProps: {
                    opacity: style.opacity,
                    sizeScale: style.labelSize,
                    getColor: style.labelColor,
                },
            }),
        ],
    });
}
function getCurveType(c) {
    if (c instanceof Ellipse) {
        return CURVE.Arc;
    }
    if (c instanceof BezierSeg) {
        return CURVE.Bezier;
    }
    return CURVE.Line;
}
function getControlPoints(c) {
    if (c instanceof Ellipse) {
        return [c.center, c.aAxis, c.bAxis].flatMap(pointToArray);
    }
    if (c instanceof BezierSeg) {
        return c.b.flatMap(pointToArray);
    }
    return [c.start, c.end].flatMap(pointToArray);
}
function* getCurves(data, transform) {
    let j = 0;
    for (const cc of data) {
        const { curve } = cc;
        // @ts-ignore
        transform(curve, cc, j);
        yield curve;
        j++;
    }
}
function pointToArray(p) {
    return [p.x, p.y];
}
function getEdgeColor(e) {
    const drawinEdge = getDrawingObj(e);
    if (drawinEdge) {
        const color = drawinEdge.color;
        if (color)
            return [color.R, color.G, color.B];
    }
    return [0, 0, 0];
}
function getEdgeType(e) {
    return 'triangle-n';
}
function getArrowSize(tip, end) {
    const dx = tip.x - end.x;
    const dy = tip.y - end.y;
    return Math.sqrt(dx * dx + dy * dy);
}
function getArrowAngle(tip, end) {
    const dx = tip.x - end.x;
    const dy = tip.y - end.y;
    return (Math.atan2(dy, dx) / Math.PI) * 180;
}
function getLabelText(l) {
    return getDrawingObj(l.parent.entity).labelText;
}
function getLabelSize(l) {
    return getDrawingObj(l.parent.entity).fontsize;
}
function getLabelColor(l) {
    const color = getDrawingObj(l.parent.entity).labelfontcolor;
    if (color) {
        return [color.R, color.G, color.B];
    }
    return [0, 0, 0];
}
function getDrawingObj(e) {
    return DrawingObject.getDrawingObj(e);
}
//# sourceMappingURL=get-edge-layers.js.map