import { CompositeLayer } from '@deck.gl/core/typed';
import { TextLayer } from '@deck.gl/layers/typed';
import { TileData } from '@msagl/core';
import { Matrix4 } from '@math.gl/core';
import { getNodeLayers } from './get-node-layers';
import { getEdgeLayer, getArrowHeadLayer, getEdgeLabelLayer } from './get-edge-layers';
export default class GraphLayer extends CompositeLayer {
    updateState({ props, oldProps, changeFlags }) {
        const { graphStyle } = props;
        if (changeFlags.dataChanged || graphStyle !== oldProps.graphStyle) {
            // @ts-ignore
            const data = props.data;
            const filterContext = {
                tileMap: props.tileMap,
            };
            const layerMap = {};
            for (const layer of graphStyle.layers) {
                const layerData = new TileData(null);
                layerMap[layer.id] = layerData;
                if (layer.type === 'node') {
                    layerData.nodes = layer.filter ? data.nodes.filter((n) => layer.filter(n.node, filterContext)) : data.nodes;
                }
                if (layer.type === 'edge') {
                    layerData.curveClips = layer.filter ? data.curveClips.filter((c) => layer.filter(c.edge, filterContext)) : data.curveClips;
                    layerData.arrowheads = layer.filter ? data.arrowheads.filter((a) => layer.filter(a.edge, filterContext)) : data.arrowheads;
                    layerData.labels = layer.filter ? data.labels.filter((l) => layer.filter(l.parent.entity, filterContext)) : data.labels;
                }
            }
            this.setState({ layerMap });
        }
    }
    getPickingInfo({ sourceLayer, info }) {
        if (sourceLayer.id.endsWith('node-boundary') && info.picked) {
            info.object = this.props.highlighter.getNode(info.index);
        }
        return info;
    }
    filterSubLayer({ layer, viewport }) {
        const layerStyle = layer.props.layerStyle;
        const { zoom } = viewport;
        return layerStyle.minZoom <= zoom && layerStyle.maxZoom >= zoom;
    }
    renderLayers() {
        const { layerMap } = this.state;
        const { graphStyle, highlighter, resolution, fontFamily, fontWeight, lineHeight, tile, modelMatrix } = this.props;
        const layerCount = graphStyle.layers.length;
        const tileSize = tile.bbox.right - tile.bbox.left;
        return graphStyle.layers.map((layer, layerIndex) => {
            var _a, _b, _c, _d;
            const data = layerMap[layer.id];
            const subLayers = [];
            const subLayerProps = this.getSubLayerProps({ id: layer.id });
            Object.assign(subLayerProps, {
                layerStyle: layer,
                modelMatrix: new Matrix4(modelMatrix).scale([1, 1, -tileSize / 4]),
                parameters: {
                    depthRange: [1 - (layerIndex + 1) / layerCount, 1 - layerIndex / layerCount],
                },
            });
            if (((_a = data.nodes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                subLayers.push(getNodeLayers({
                    ...subLayerProps,
                    data: data.nodes,
                    getPickingColor: (n, { target }) => highlighter.encodeNodeIndex(n, target),
                    nodeDepth: highlighter.nodeDepth,
                    // From renderer layout options
                    fontFamily,
                    fontWeight,
                    lineHeight,
                }, layer));
            }
            if (((_b = data.curveClips) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                subLayers.push(getEdgeLayer({
                    ...subLayerProps,
                    data: data.curveClips,
                    getDepth: highlighter.edgeDepth,
                    resolution,
                }, layer));
            }
            if (((_c = data.arrowheads) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                subLayers.push(getArrowHeadLayer({
                    ...subLayerProps,
                    data: data.arrowheads,
                }, layer));
            }
            if (((_d = data.labels) === null || _d === void 0 ? void 0 : _d.length) > 0) {
                subLayers.push(getEdgeLabelLayer({
                    ...subLayerProps,
                    data: data.labels,
                    fontFamily,
                    fontWeight,
                    lineHeight,
                }, layer));
            }
            return subLayers;
        });
    }
}
GraphLayer.defaultProps = {
    ...TextLayer.defaultProps,
    resolution: { type: 'number', value: 1 },
    highlighter: { type: 'object' },
    fontSize: { type: 'number', value: 16 },
};
GraphLayer.layerName = 'Graphayer';
//# sourceMappingURL=graph-layer.js.map